<fragment uiName="mayaStandardSurfaceFinal" name="mayaStandardSurfaceFinal" type="plumbing" class="ShadeFragment" version="1.0" feature_level="0">
    <description><![CDATA[Finalize standard surface fragments.]]></description>
    <properties>
        <float3 name="lightLoopResult" />
        <float3 name="IrradianceEnv" />
        <float3 name="SpecularEnv" />
        <struct name="lightData" struct_name="mayaStandardSurfaceLightData" />
        <struct name="params" struct_name="mayaStandardSurfaceParams" />        
        <float3 name="ambientColor" />
        <float3 name="ambientIn" />
        <undefined name="GPUStage" semantic="GPUStage" />
    </properties>
    <values>
        <float3 name="lightLoopResult" value="0.0 0.0 0.0" />
        <float3 name="IrradianceEnv" value="0.0 0.0 0.0" />
        <float3 name="SpecularEnv" value="0.0 0.0 0.0" />
        <float3 name="ambientColor" value="0.0 0.0 0.0"/>
        <float3 name="ambientIn" value="0.0 0.0 0.0"/>
    </values>
    <outputs>
        <struct name="mayaStandardSurfaceFinal" struct_name="mayaSurfaceShaderOutput" />
    </outputs>
    <implementation>
        <implementation render="OGSRenderer" language="Cg" lang_version="2.1">
            <function_name val="mayaStandardSurfaceFinal" />
            <source>
                <![CDATA[
mayaSurfaceShaderOutput mayaStandardSurfaceFinal(
                float3 lightLoopResult,
                float3 IrradianceEnv,
                float3 SpecularEnv,
                mayaStandardSurfaceLightData lightData,
                mayaStandardSurfaceParams params,
                float3 ambientColor,
                float3 ambientIn)
{
    mayaSurfaceShaderOutput result;
    result.outColor = (ambientColor + ambientIn) * params.base * params.baseColor;
    result.outGlowColor = float3(0.0f, 0.0f, 0.0f);
    result.outMatteOpacity = float3(-1.0e+06f, -1.0e+06f, -1.0e+06f);

    if (nonZero(params.opacity))
    {
        // Add direct lighting and emission.
        result.outColor += lightLoopResult;
        result.outColor += params.emission;

        // Add indirect/environment lighting.
        float3 throughput = float3(1.0f, 1.0f, 1.0f);
        float3 brdf;
        float layerThroughput;
        float cosNV = dot(params.N, lightData.V);

        // Coat layer.
        if (params.coat > 0.0f)
        {
            // Note: For the coat layer we use a white tint and
            // instead scale layers below with the coat color.
            brdf = dielectricEnvBrdf(cosNV, params.coat, float3(1.0f, 1.0f, 1.0f),
                                     params.coatIOR, params.coatRoughness,
                                     layerThroughput);
            result.outColor += SpecularEnv * brdf * throughput;
            throughput *= layerThroughput * params.coatColor;
        }

        // Metal layer.
        if (params.metalness > 0.0f && nonZero(throughput))
        {
            brdf = conductorEnvBrdf(cosNV, params.base,
                                    params.metalIOR, params.metalExtinction,
                                    params.specularRoughness);
            result.outColor += SpecularEnv * brdf * throughput * params.metalness;
            throughput *= 1.0f - params.metalness;
        }

        // Specular reflection layer.
        if (params.specular > 0.0f && nonZero(throughput))
        {
            brdf = dielectricEnvBrdf(cosNV, params.specular, params.specularColor, 
                                     params.specularIOR, params.specularRoughness,
                                     layerThroughput);
            result.outColor += SpecularEnv * brdf * throughput;
            throughput *= layerThroughput;
        }

        // Transmission layer.
        throughput *= 1.0 - params.transmission;

        // Sheen layer.
        if (params.sheen > 0.0f && nonZero(throughput))
        {
            brdf = sheenEnvBrdf(cosNV, params.sheen, params.sheenColor,
                                params.sheenRoughness,
                                layerThroughput);
            result.outColor += IrradianceEnv * brdf * throughput;
            throughput *= layerThroughput;
        }

        // Base diffuse layer.
        result.outColor += IrradianceEnv * params.diffuseColor * throughput;

        // Opacity affects all layers.
        result.outColor *= params.opacity;
    }

    float trans = params.transmission * (1.0 - params.metalness);
    result.outTransparency = lerp(float3(1.0f, 1.0f, 1.0f), float3(trans, trans, trans), params.opacity);

    return result;
}
                ]]>
            </source>
        </implementation>
        <implementation render="OGSRenderer" language="HLSL" lang_version="11.0">
            <function_name val="mayaStandardSurfaceFinal" />
            <source>
                <![CDATA[
mayaSurfaceShaderOutput mayaStandardSurfaceFinal(
                float3 lightLoopResult,
                float3 IrradianceEnv,
                float3 SpecularEnv,
                mayaStandardSurfaceLightData lightData,
                mayaStandardSurfaceParams params,
                float3 ambientColor,
                float3 ambientIn)
{
    mayaSurfaceShaderOutput result;
    result.outColor = (ambientColor + ambientIn) * params.base * params.baseColor;
    result.outGlowColor = float3(0.0f, 0.0f, 0.0f);
    result.outMatteOpacity = float3(-1.0e+06f, -1.0e+06f, -1.0e+06f);

    if (nonZero(params.opacity))
    {
        // Add direct lighting and emission.
        result.outColor += lightLoopResult;
        result.outColor += params.emission;

        // Add indirect/environment lighting.
        float3 throughput = float3(1.0f, 1.0f, 1.0f);
        float3 brdf;
        float layerThroughput;
        float cosNV = dot(params.N, lightData.V);

        // Coat layer.
        if (params.coat > 0.0f)
        {
            // Note: For the coat layer we use a white tint and
            // instead scale layers below with the coat color.
            brdf = dielectricEnvBrdf(cosNV, params.coat, float3(1.0f, 1.0f, 1.0f),
                                     params.coatIOR, params.coatRoughness,
                                     layerThroughput);
            result.outColor += SpecularEnv * brdf * throughput;
            throughput *= layerThroughput * params.coatColor;
        }

        // Metal layer.
        if (params.metalness > 0.0f && nonZero(throughput))
        {
            brdf = conductorEnvBrdf(cosNV, params.base,
                                    params.metalIOR, params.metalExtinction,
                                    params.specularRoughness);
            result.outColor += SpecularEnv * brdf * throughput * params.metalness;
            throughput *= 1.0f - params.metalness;
        }

        // Specular reflection layer.
        if (params.specular > 0.0f && nonZero(throughput))
        {
            brdf = dielectricEnvBrdf(cosNV, params.specular, params.specularColor, 
                                     params.specularIOR, params.specularRoughness,
                                     layerThroughput);
            result.outColor += SpecularEnv * brdf * throughput;
            throughput *= layerThroughput;
        }

        // Transmission layer.
        throughput *= 1.0 - params.transmission;

        // Sheen layer.
        if (params.sheen > 0.0f && nonZero(throughput))
        {
            brdf = sheenEnvBrdf(cosNV, params.sheen, params.sheenColor,
                                params.sheenRoughness,
                                layerThroughput);
            result.outColor += IrradianceEnv * brdf * throughput;
            throughput *= layerThroughput;
        }

        // Base diffuse layer.
        result.outColor += IrradianceEnv * params.diffuseColor * throughput;

        // Opacity affects all layers.
        result.outColor *= params.opacity;
    }

    float trans = params.transmission * (1.0 - params.metalness);
    result.outTransparency = lerp(float3(1.0f, 1.0f, 1.0f), float3(trans, trans, trans), params.opacity);

    return result;
}
                ]]>
            </source>
        </implementation>
        <implementation render="OGSRenderer" language="GLSL" lang_version="3.0">
            <function_name val="mayaStandardSurfaceFinal" />
            <source>
                <![CDATA[
mayaSurfaceShaderOutput mayaStandardSurfaceFinal(
                vec3 lightLoopResult,
                vec3 IrradianceEnv,
                vec3 SpecularEnv,
                mayaStandardSurfaceLightData lightData,
                mayaStandardSurfaceParams params,
                vec3 ambientColor,
                vec3 ambientIn)
{
    mayaSurfaceShaderOutput result;
    result.outColor = (ambientColor + ambientIn) * params.base * params.baseColor;
    result.outGlowColor = vec3(0.0f, 0.0f, 0.0f);
    result.outMatteOpacity = vec3(-1.0e+06f, -1.0e+06f, -1.0e+06f);

    if (nonZero(params.opacity))
    {
        // Add direct lighting and emission.
        result.outColor += lightLoopResult;
        result.outColor += params.emission;

        // Add indirect/environment lighting.
        vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
        vec3 brdf;
        float layerThroughput;
        float cosNV = dot(params.N, lightData.V);

        // Coat layer.
        if (params.coat > 0.0f)
        {
            // Note: For the coat layer we use a white tint and
            // instead scale layers below with the coat color.
            brdf = dielectricEnvBrdf(cosNV, params.coat, vec3(1.0f, 1.0f, 1.0f),
                                     params.coatIOR, params.coatRoughness,
                                     layerThroughput);
            result.outColor += SpecularEnv * brdf * throughput;
            throughput *= layerThroughput * params.coatColor;
        }

        // Metal layer.
        if (params.metalness > 0.0f && nonZero(throughput))
        {
            brdf = conductorEnvBrdf(cosNV, params.base,
                                    params.metalIOR, params.metalExtinction,
                                    params.specularRoughness);
            result.outColor += SpecularEnv * brdf * throughput * params.metalness;
            throughput *= 1.0f - params.metalness;
        }

        // Specular reflection layer.
        if (params.specular > 0.0f && nonZero(throughput))
        {
            brdf = dielectricEnvBrdf(cosNV, params.specular, params.specularColor, 
                                     params.specularIOR, params.specularRoughness,
                                     layerThroughput);
            result.outColor += SpecularEnv * brdf * throughput;
            throughput *= layerThroughput;
        }

        // Transmission layer.
        throughput *= 1.0 - params.transmission;

        // Sheen layer.
        if (params.sheen > 0.0f && nonZero(throughput))
        {
            brdf = sheenEnvBrdf(cosNV, params.sheen, params.sheenColor,
                                params.sheenRoughness,
                                layerThroughput);
            result.outColor += IrradianceEnv * brdf * throughput;
            throughput *= layerThroughput;
        }

        // Base diffuse layer.
        result.outColor += IrradianceEnv * params.diffuseColor * throughput;

        // Opacity affects all layers.
        result.outColor *= params.opacity;
    }

    float trans = params.transmission * (1.0 - params.metalness);
    result.outTransparency = lerp(vec3(1.0f, 1.0f, 1.0f), vec3(trans, trans, trans), params.opacity);

    return result;
}
                ]]>
            </source>
        </implementation>
    </implementation>
</fragment>
