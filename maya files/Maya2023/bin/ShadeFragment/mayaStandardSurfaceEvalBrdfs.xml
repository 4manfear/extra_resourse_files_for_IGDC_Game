<fragment uiName="mayaStandardSurfaceEvalBrdfs" name="mayaStandardSurfaceEvalBrdfs" type="plumbing" class="ShadeFragment" version="1.0" feature_level="0">
    <description><![CDATA[Fragment for the Maya standard shader.]]></description>
    <properties>
        <struct name="lightData" struct_name="mayaStandardSurfaceLightData" />
        <struct name="params" struct_name="mayaStandardSurfaceParams" />
    </properties>
    <values>
    </values>
    <outputs>
        <float3 name="outColor" />
    </outputs>
    <implementation>
        <implementation render="OGSRenderer" language="Cg" lang_version="2.1">
            <function_name val="mayaStandardSurfaceEvalBrdfs" />
            <source>
                <![CDATA[
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
float ggxDistribution(float cosNH, float alpha)
{
    float alpha2 = square(alpha);
    float denom = M_PI * square( square(cosNH) * (alpha2 - 1.0) + 1.0 );
    return alpha2 / denom;
}

// https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf
// Appendix B.2 Equation 13
float ggxAnisoDistribution(float3 X, float3 Y, float3 H, float cosNH, float alphaX, float alphaY)
{
    float cosXH = dot(X, H);
    float cosYH = dot(Y, H);
    float denom = square(cosXH / alphaX) + square(cosYH / alphaY) + square(cosNH);
    return 1.0 / (M_PI * alphaX * alphaY * square(denom));
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf (Equation 34)
float ggxShadowingSmith1(float cosTheta, float alpha)
{
    float cosTheta2 = cosTheta * cosTheta;
    float tanTheta2 = (1.0f - cosTheta2) / cosTheta2;
    return 2.0f / (1.0f + sqrt(1.0f + alpha * alpha * tanTheta2));
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf (Equation 23)
float ggxShadowingSmith(float cosNL, float cosNV, float alpha)
{
    return ggxShadowingSmith1(cosNL, alpha) * ggxShadowingSmith1(cosNV, alpha);
}

float fresnelSchlick(float cosTheta, float ior)
{
    if (cosTheta < 0.0f)
        return 1.0f;
    float F0 = square((ior - 1.0f) / (ior + 1.0f));
    float x = 1.0 - cosTheta;
    float x2 = x * x;
    float x5 = x2 * x2*x;
    return F0 + (1.0f - F0) * x5;
}

float fresnelSchlickRoughness(float cosTheta, float ior, float roughness)
{
    cosTheta = abs(cosTheta);
    float F0 = (ior - 1.0f) / (ior + 1.0f);
    F0 *= F0;
    float x = 1.0 - cosTheta;
    float x2 = x*x;
    float x5 = x2*x2*x;
    return F0 + (max(1.0f - roughness, F0) - F0) * x5;
}

float3 fresnelConductor(float cosTheta, float3 n, float3 k)
{
   float c2 = cosTheta*cosTheta;
   float3 n2_k2 = n*n + k*k;
   float3 nc2 = 2.0f * n * cosTheta;

   float3 rs_a = n2_k2 + c2;
   float3 rp_a = n2_k2 * c2 + 1.0;
   float3 rs = (rs_a - nc2) / (rs_a + nc2);
   float3 rp = (rp_a - nc2) / (rp_a + nc2);

   return 0.5f * (rs + rp);
}

// LUT for sheen directional albedo.
// A 2D table parameterized with 'cosTheta' (cosine of angle to normal) on x-axis and 'roughness' on y-axis.
#define SHEEN_ALBEDO_TABLE_SIZE 16
uniform float sheenAlbedoLUT[SHEEN_ALBEDO_TABLE_SIZE*SHEEN_ALBEDO_TABLE_SIZE] = {
    1.6177, 0.978927, 0.618938, 0.391714, 0.245177, 0.150234, 0.0893475, 0.0511377, 0.0280191, 0.0144204, 0.00687674, 0.00295935, 0.00111049, 0.000336768, 7.07119e-05, 6.22646e-06,
    1.1084, 0.813928, 0.621389, 0.479304, 0.370299, 0.284835, 0.21724, 0.163558, 0.121254, 0.0878921, 0.0619052, 0.0419894, 0.0270556, 0.0161443, 0.00848212, 0.00342323,
    0.930468, 0.725652, 0.586532, 0.479542, 0.393596, 0.322736, 0.26353, 0.213565, 0.171456, 0.135718, 0.105481, 0.0800472, 0.0588117, 0.0412172, 0.0268329, 0.0152799,
    0.833791, 0.671201, 0.558957, 0.471006, 0.398823, 0.337883, 0.285615, 0.240206, 0.200696, 0.16597, 0.135422, 0.10859, 0.0850611, 0.0644477, 0.0464763, 0.0308878,
    0.771692, 0.633819, 0.537877, 0.461939, 0.398865, 0.344892, 0.297895, 0.256371, 0.219562, 0.186548, 0.156842, 0.130095, 0.10598, 0.0841919, 0.0645311, 0.04679,
    0.727979, 0.606373, 0.52141, 0.453769, 0.397174, 0.348337, 0.305403, 0.267056, 0.232655, 0.201398, 0.17286, 0.146756, 0.122808, 0.100751, 0.0804254, 0.0616485,
    0.695353, 0.585281, 0.508227, 0.44667, 0.394925, 0.350027, 0.310302, 0.274561, 0.242236, 0.212604, 0.185281, 0.16002, 0.13657, 0.114693, 0.0942543, 0.0750799,
    0.669981, 0.568519, 0.497442, 0.440542, 0.392567, 0.350786, 0.313656, 0.280075, 0.249533, 0.221359, 0.195196, 0.170824, 0.148012, 0.126537, 0.106279, 0.0870713,
    0.649644, 0.554855, 0.488453, 0.435237, 0.390279, 0.351028, 0.316036, 0.284274, 0.255266, 0.228387, 0.203297, 0.179796, 0.157665, 0.136695, 0.116774, 0.0977403,
    0.632951, 0.543489, 0.480849, 0.430619, 0.388132, 0.350974, 0.317777, 0.287562, 0.259885, 0.234153, 0.210041, 0.187365, 0.165914, 0.145488, 0.125983, 0.10724,
    0.61899, 0.533877, 0.47433, 0.426573, 0.386145, 0.35075, 0.319078, 0.290197, 0.263681, 0.238971, 0.215746, 0.193838, 0.173043, 0.153167, 0.134113, 0.115722,
    0.607131, 0.52564, 0.468678, 0.423001, 0.38432, 0.35043, 0.320072, 0.292349, 0.266856, 0.243055, 0.220636, 0.199438, 0.179264, 0.159926, 0.141332, 0.123323,
    0.596927, 0.518497, 0.463731, 0.419829, 0.382647, 0.350056, 0.320842, 0.294137, 0.269549, 0.246564, 0.224875, 0.204331, 0.18474, 0.165919, 0.147778, 0.130162,
    0.588052, 0.512241, 0.459365, 0.416996, 0.381114, 0.349657, 0.321448, 0.295641, 0.271862, 0.24961, 0.228584, 0.208643, 0.189596, 0.171266, 0.153566, 0.136341,
    0.580257, 0.506717, 0.455481, 0.41445, 0.379708, 0.34925, 0.321929, 0.296923, 0.273869, 0.252279, 0.231859, 0.212472, 0.193933, 0.176066, 0.158788, 0.141945,
    0.573355, 0.5018, 0.452005, 0.412151, 0.378416, 0.348844, 0.322316, 0.298028, 0.275627, 0.254638, 0.234772, 0.215896, 0.197828, 0.180398, 0.163522, 0.147049
};

// http://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_sheen.pdf (Equation 2)
float sheenDistribution(float cosTheta, float roughness)
{
    // Given roughness is assumed to be clamped to [M_FLOAT_EPS, 1.0]
    float invRoughness = 1.0f / roughness;
    float cos2 = cosTheta * cosTheta;
    float sin2 = 1.0f - cos2;
    return (2.0f + invRoughness) * pow(sin2, invRoughness * 0.5f) / (2.0f * M_PI);
}

float sheenDirectionalAlbedo(float cosTheta, float roughness)
{
    float x = cosTheta  * (SHEEN_ALBEDO_TABLE_SIZE - 1);
    float y = roughness * (SHEEN_ALBEDO_TABLE_SIZE - 1);
    int ix = int(x);
    int iy = int(y);
    int ix2 = (ix + 1) < 0 ? 0 : ((ix + 1) > (SHEEN_ALBEDO_TABLE_SIZE - 1) ? (SHEEN_ALBEDO_TABLE_SIZE - 1) : (ix + 1));
    int iy2 = (iy + 1) < 0 ? 0 : ((iy + 1) > (SHEEN_ALBEDO_TABLE_SIZE - 1) ? (SHEEN_ALBEDO_TABLE_SIZE - 1) : (iy + 1));
    float fx = x - ix;
    float fy = y - iy;

    // Bi-linear interpolation of the LUT values
    float v1 = lerp(sheenAlbedoLUT[iy  * SHEEN_ALBEDO_TABLE_SIZE + ix], sheenAlbedoLUT[iy  * SHEEN_ALBEDO_TABLE_SIZE + ix2], fx);
    float v2 = lerp(sheenAlbedoLUT[iy2 * SHEEN_ALBEDO_TABLE_SIZE + ix], sheenAlbedoLUT[iy2 * SHEEN_ALBEDO_TABLE_SIZE + ix2], fx);
    float albedo = lerp(v1, v2, fy);

    return clamp(albedo, 0.0f, 1.0f);
}

float3 sheenBrdf(float3 L, float3 V, float3 N, float cosNL,
               float weight, float3 color, float roughness,
               out float throughput)
{
    float3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = sheenDistribution(cosNH, roughness);
    float3 F = color * weight;

    float albedo = weight * sheenDirectionalAlbedo(cosNV, roughness);
    throughput = 1.0f - albedo;

    // Geometry term is skipped and we use a smoother denominator, as in:
    // https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf
    return F * D / (4.0f * (cosNL + cosNV - cosNL * cosNV));
}

float3 sheenEnvBrdf(float cosNV, float weight, float3 color, float roughness,
                  out float throughput)
{
    float albedo = weight * sheenDirectionalAlbedo(cosNV, roughness);
    throughput = 1.0f - albedo;
    return color * albedo;
}

float3 dielectricBrdf(float3 L, float3 V, float3 N, float3 T, float3 B, float cosNL,
                    float weight, float3 tint, float ior, float2 roughness,
                    out float throughput)
{
    float3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = roughness.x != roughness.y ? 
        ggxAnisoDistribution(T, B, H, cosNH, roughness.x, roughness.y) :
        ggxDistribution(cosNH, roughness.x);

    float G = ggxShadowingSmith(cosNL, cosNV, max(roughness.x, roughness.y));

    float cosVH = dot(V, H);
    float F = fresnelSchlick(cosVH, ior) * weight;

    throughput = 1.0f - F;
    return tint * D * G * F / (4.0f * cosNL * cosNV);
}

float3 dielectricEnvBrdf(float cosNV, float weight, float3 tint, float ior, float2 roughness,
                       out float throughput)
{
    float F = fresnelSchlickRoughness(cosNV, ior, max(roughness.x, roughness.y));
    F *= weight;
    throughput = 1.0f - F;
    return tint * F;
}

float3 conductorBrdf(float3 L, float3 V, float3 N, float3 T, float3 B, float cosNL,
                    float weight, float3 ior_n, float3 ior_k, float2 roughness)
{
    float3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = roughness.x != roughness.y ? 
        ggxAnisoDistribution(T, B, H, cosNH, roughness.x, roughness.y) :
        ggxDistribution(cosNH, roughness.x);

    float G = ggxShadowingSmith(cosNL, cosNV, max(roughness.x, roughness.y));

    float cosVH = dot(V, H);
    float3 F = fresnelConductor(cosVH, ior_n, ior_k) * weight;

    return F * D * G / (4.0f * cosNL * cosNV);
}

float3 conductorEnvBrdf(float cosNV, float weight, float3 ior_n, float3 ior_k, float2 roughness)
{
    float3 F = fresnelConductor(cosNV, ior_n, ior_k);
    return F * weight;
}

float3 diffuseBrdf(float3 L, float3 V, float3 N, float cosNL, 
                 float3 color, float roughness)
{
    // Lambertian reflectance.
    float3 result = color / M_PI;

    // Evaluate Oren-Nayar BRDF if we have a roughness.
    if (roughness > 0.0f)
    {
        float cosLV = dot(L, V);
        float cosNV = abs(dot(N, V));

        float t = cosLV - cosNL * cosNV;
        t = t > 0.0f ? t / max(cosNL, cosNV) : 0.0f;

        float sigma2 = roughness * 0.707107f;
        sigma2 *= sigma2;

        float A = 1.0f - 0.5f * (sigma2 / (sigma2 + 0.33f));
        float B = 0.45f * sigma2 / (sigma2 + 0.09f);
        result *= A + B * t;
    }

    return result;
}

float aiBrdf(mayaStandardSurfaceLightData lightData, 
             float3 H, float cosNL, float roughness)
{
    float rx = square(roughness);
    rx = max(rx, 0.002f);   
    float rx2 = square(rx);

    float NH = dot(lightData.N, H);
    float NH2 = square(NH) + M_FLOAT_EPS;  // Make sure these are
    float NH4 = square(NH2) + M_FLOAT_EPS; // numerically stable
    float tan2ThetaM = (1.0f - NH2 ) / NH2;
    float D = exp(-tan2ThetaM / rx2) / (1.0f + M_PI * rx2 * NH4);  

    float NV = dot(lightData.N, lightData.V);
    float k = square(roughness+1.0f)/8.0f;
    float G1 = NV / (NV * (1.0 - k) + k);
    float G2 = cosNL / (cosNL * (1.0 - k) + k);
    float G = (G1 * G2);

    float atten = (1.0 + M_PI * roughness);
    return D * G / ( 2.0 * NV * cosNL * atten );
}

float3 aiDielectricBrdf(mayaStandardSurfaceLightData lightData, 
                      float cosNL, float weight, float3 tint, 
                      float ior, float roughness, 
                      out float throughput)
{
    float3 H = normalize(lightData.SL + lightData.V);
    float cosVH = dot(H, lightData.V);
    float F = fresnelSchlick(cosVH, ior) * weight;
    throughput = 1.0f - F;
    return tint * F * aiBrdf(lightData, H, cosNL, roughness);
}

float3 aiConductorBrdf(mayaStandardSurfaceLightData lightData, 
                     float cosNL, float weight, float3 ior_n, float3 ior_k, 
                     float roughness)
{
    float3 H = normalize(lightData.SL + lightData.V);
    float cosVH = dot(H, lightData.V);
    float3 F = fresnelConductor(cosVH, ior_n, ior_k) * weight;
    return F * aiBrdf(lightData, H, cosNL, roughness);
}

// Special ad-hoc BRDF evaulation needed by Arnold's area lights.
// See MtoA implementation for aiStandardSurface and aiAreaLight.
float3 aiAreaLightEvalBrdfs(mayaStandardSurfaceLightData lightData,
                          mayaStandardSurfaceParams params)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);

    if (nonZero(params.opacity))
    {
        float3 throughput = float3(1.0f, 1.0f, 1.0f);
        float cosNL = dot(params.N, lightData.L);
        if (cosNL > 0.0f)
        {
            float3 brdf;
            float layerThroughput = 1.0;

            // Coat layer.
            if (params.coat > 0.0f)
            {
                float roughness = max(params.coatRoughness.x, params.coatRoughness.y);
                roughness = sqrt(roughness);
                brdf = aiDielectricBrdf(lightData, cosNL, 
                                        params.coat, float3(1.0f, 1.0f, 1.0f), 
                                        params.coatIOR, roughness,
                                        layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput * params.coatColor;
            }

            float roughness = max(params.specularRoughness.x, params.specularRoughness.y);
            roughness = sqrt(roughness);

            // Metal layer.
            if (params.metalness > 0.0f && nonZero(throughput))
            {
                brdf = aiConductorBrdf(lightData, cosNL,
                                    params.base, params.metalIOR, 
                                    params.metalExtinction, roughness);
                result += lightData.specular * brdf * cosNL * throughput * params.metalness;
                throughput *= 1.0f - params.metalness;
            }

            // Specular reflection layer.
            if (params.specular > 0.0f && nonZero(throughput))
            {
                brdf = aiDielectricBrdf(lightData, cosNL, params.specular, params.specularColor, 
                                        params.specularIOR, roughness,
                                        layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Transmission layer.
            throughput *= 1.0 - params.transmission;

            // Sheen layer.
            if (params.sheen > 0.0f && nonZero(throughput))
            {
                brdf = sheenBrdf(lightData.L, lightData.V,
                                params.N, cosNL,
                                params.sheen, params.sheenColor,
                                params.sheenRoughness,
                                layerThroughput);
                result += lightData.diffuse * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Base diffuse layer.
            if (params.base > 0.0f && nonZero(throughput))
            {
                brdf = diffuseBrdf(lightData.L, lightData.V,
                                params.N, cosNL,
                                params.diffuseColor,
                                params.diffuseRoughness);
                result += lightData.diffuse * brdf * cosNL * throughput;
            }
        }
    }

    return result;
}

#define LIGHT_TYPE_AI_AREA_LIGHT 0x00115C86

// Called by the light loop for each light source sample.
float3 mayaStandardSurfaceEvalBrdfs(mayaStandardSurfaceLightData lightData,
                                  mayaStandardSurfaceParams params)
{
    // Special case for handling Arnold area lights which
    // are non-physical and requires an ad-hoc BRDF.
    //
    // TODO: We should implement proper physically based
    // area lights and remove this hack.
    //
    if (lightData.lightType == LIGHT_TYPE_AI_AREA_LIGHT)
    {
        return aiAreaLightEvalBrdfs(lightData, params);
    }

    float3 result = float3(0.0f, 0.0f, 0.0f);

    if (nonZero(params.opacity))
    {
        float3 throughput = float3(1.0f, 1.0f, 1.0f);
        float cosNL = dot(params.N, lightData.L);
        if (cosNL > 0.0f)
        {
            float3 brdf;
            float layerThroughput = 1.0;

            // Coat layer.
            if (params.coat > 0.0f)
            {
                // Note: For the coat layer we use a white tint and
                // instead scale layers below with the coat color.
                brdf = dielectricBrdf(lightData.SL, lightData.V,
                                      params.N, params.coatT, params.coatB, cosNL,
                                      params.coat, float3(1.0f, 1.0f, 1.0f),
                                      params.coatIOR, params.coatRoughness,
                                      layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput * params.coatColor;
            }

            // Metal layer.
            if (params.metalness > 0.0f && nonZero(throughput))
            {
                brdf = conductorBrdf(lightData.SL, lightData.V,
                                     params.N, params.T, params.B, cosNL,
                                     params.base, params.metalIOR,
                                     params.metalExtinction, params.specularRoughness);
                result += lightData.specular * brdf * cosNL * throughput * params.metalness;
                throughput *= 1.0f - params.metalness;
            }

            // Specular reflection layer.
            if (params.specular > 0.0f && nonZero(throughput))
            {
                brdf = dielectricBrdf(lightData.SL, lightData.V,
                                      params.N, params.T, params.B, cosNL,
                                      params.specular, params.specularColor,
                                      params.specularIOR, params.specularRoughness,
                                      layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Transmission layer.
            throughput *= 1.0 - params.transmission;

            // Sheen layer.
            if (params.sheen > 0.0f && nonZero(throughput))
            {
                brdf = sheenBrdf(lightData.L, lightData.V,
                                 params.N, cosNL,
                                 params.sheen, params.sheenColor,
                                 params.sheenRoughness,
                                 layerThroughput);
                result += lightData.diffuse * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Base diffuse layer.
            if (params.base > 0.0f && nonZero(throughput))
            {
                brdf = diffuseBrdf(lightData.L, lightData.V,
                                   params.N, cosNL,
                                   params.diffuseColor,
                                   params.diffuseRoughness);
                result += lightData.diffuse * brdf * cosNL * throughput;
            }
        }
    }

    return result;
}
                ]]>
            </source>
        </implementation>
        <implementation render="OGSRenderer" language="HLSL" lang_version="11.0">
            <function_name val="mayaStandardSurfaceEvalBrdfs" />
            <source>
                <![CDATA[
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
float ggxDistribution(float cosNH, float alpha)
{
    float alpha2 = square(alpha);
    float denom = M_PI * square( square(cosNH) * (alpha2 - 1.0) + 1.0 );
    return alpha2 / denom;
}

// https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf
// Appendix B.2 Equation 13
float ggxAnisoDistribution(float3 X, float3 Y, float3 H, float cosNH, float alphaX, float alphaY)
{
    float cosXH = dot(X, H);
    float cosYH = dot(Y, H);
    float denom = square(cosXH / alphaX) + square(cosYH / alphaY) + square(cosNH);
    return 1.0 / (M_PI * alphaX * alphaY * square(denom));
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf (Equation 34)
float ggxShadowingSmith1(float cosTheta, float alpha)
{
    float cosTheta2 = cosTheta * cosTheta;
    float tanTheta2 = (1.0f - cosTheta2) / cosTheta2;
    return 2.0f / (1.0f + sqrt(1.0f + alpha * alpha * tanTheta2));
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf (Equation 23)
float ggxShadowingSmith(float cosNL, float cosNV, float alpha)
{
    return ggxShadowingSmith1(cosNL, alpha) * ggxShadowingSmith1(cosNV, alpha);
}

float fresnelSchlick(float cosTheta, float ior)
{
    if (cosTheta < 0.0f)
        return 1.0f;
    float F0 = square((ior - 1.0f) / (ior + 1.0f));
    float x = 1.0 - cosTheta;
    float x2 = x * x;
    float x5 = x2 * x2*x;
    return F0 + (1.0f - F0) * x5;
}

float fresnelSchlickRoughness(float cosTheta, float ior, float roughness)
{
    cosTheta = abs(cosTheta);
    float F0 = (ior - 1.0f) / (ior + 1.0f);
    F0 *= F0;
    float x = 1.0 - cosTheta;
    float x2 = x*x;
    float x5 = x2*x2*x;
    return F0 + (max(1.0f - roughness, F0) - F0) * x5;
}

float3 fresnelConductor(float cosTheta, float3 n, float3 k)
{
   float c2 = cosTheta*cosTheta;
   float3 n2_k2 = n*n + k*k;
   float3 nc2 = 2.0f * n * cosTheta;

   float3 rs_a = n2_k2 + c2;
   float3 rp_a = n2_k2 * c2 + 1.0;
   float3 rs = (rs_a - nc2) / (rs_a + nc2);
   float3 rp = (rp_a - nc2) / (rp_a + nc2);

   return 0.5f * (rs + rp);
}

// LUT for sheen directional albedo.
// A 2D table parameterized with 'cosTheta' (cosine of angle to normal) on x-axis and 'roughness' on y-axis.
#define SHEEN_ALBEDO_TABLE_SIZE 16
uniform float sheenAlbedoLUT[SHEEN_ALBEDO_TABLE_SIZE*SHEEN_ALBEDO_TABLE_SIZE] = {
    1.6177, 0.978927, 0.618938, 0.391714, 0.245177, 0.150234, 0.0893475, 0.0511377, 0.0280191, 0.0144204, 0.00687674, 0.00295935, 0.00111049, 0.000336768, 7.07119e-05, 6.22646e-06,
    1.1084, 0.813928, 0.621389, 0.479304, 0.370299, 0.284835, 0.21724, 0.163558, 0.121254, 0.0878921, 0.0619052, 0.0419894, 0.0270556, 0.0161443, 0.00848212, 0.00342323,
    0.930468, 0.725652, 0.586532, 0.479542, 0.393596, 0.322736, 0.26353, 0.213565, 0.171456, 0.135718, 0.105481, 0.0800472, 0.0588117, 0.0412172, 0.0268329, 0.0152799,
    0.833791, 0.671201, 0.558957, 0.471006, 0.398823, 0.337883, 0.285615, 0.240206, 0.200696, 0.16597, 0.135422, 0.10859, 0.0850611, 0.0644477, 0.0464763, 0.0308878,
    0.771692, 0.633819, 0.537877, 0.461939, 0.398865, 0.344892, 0.297895, 0.256371, 0.219562, 0.186548, 0.156842, 0.130095, 0.10598, 0.0841919, 0.0645311, 0.04679,
    0.727979, 0.606373, 0.52141, 0.453769, 0.397174, 0.348337, 0.305403, 0.267056, 0.232655, 0.201398, 0.17286, 0.146756, 0.122808, 0.100751, 0.0804254, 0.0616485,
    0.695353, 0.585281, 0.508227, 0.44667, 0.394925, 0.350027, 0.310302, 0.274561, 0.242236, 0.212604, 0.185281, 0.16002, 0.13657, 0.114693, 0.0942543, 0.0750799,
    0.669981, 0.568519, 0.497442, 0.440542, 0.392567, 0.350786, 0.313656, 0.280075, 0.249533, 0.221359, 0.195196, 0.170824, 0.148012, 0.126537, 0.106279, 0.0870713,
    0.649644, 0.554855, 0.488453, 0.435237, 0.390279, 0.351028, 0.316036, 0.284274, 0.255266, 0.228387, 0.203297, 0.179796, 0.157665, 0.136695, 0.116774, 0.0977403,
    0.632951, 0.543489, 0.480849, 0.430619, 0.388132, 0.350974, 0.317777, 0.287562, 0.259885, 0.234153, 0.210041, 0.187365, 0.165914, 0.145488, 0.125983, 0.10724,
    0.61899, 0.533877, 0.47433, 0.426573, 0.386145, 0.35075, 0.319078, 0.290197, 0.263681, 0.238971, 0.215746, 0.193838, 0.173043, 0.153167, 0.134113, 0.115722,
    0.607131, 0.52564, 0.468678, 0.423001, 0.38432, 0.35043, 0.320072, 0.292349, 0.266856, 0.243055, 0.220636, 0.199438, 0.179264, 0.159926, 0.141332, 0.123323,
    0.596927, 0.518497, 0.463731, 0.419829, 0.382647, 0.350056, 0.320842, 0.294137, 0.269549, 0.246564, 0.224875, 0.204331, 0.18474, 0.165919, 0.147778, 0.130162,
    0.588052, 0.512241, 0.459365, 0.416996, 0.381114, 0.349657, 0.321448, 0.295641, 0.271862, 0.24961, 0.228584, 0.208643, 0.189596, 0.171266, 0.153566, 0.136341,
    0.580257, 0.506717, 0.455481, 0.41445, 0.379708, 0.34925, 0.321929, 0.296923, 0.273869, 0.252279, 0.231859, 0.212472, 0.193933, 0.176066, 0.158788, 0.141945,
    0.573355, 0.5018, 0.452005, 0.412151, 0.378416, 0.348844, 0.322316, 0.298028, 0.275627, 0.254638, 0.234772, 0.215896, 0.197828, 0.180398, 0.163522, 0.147049
};

// http://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_sheen.pdf (Equation 2)
float sheenDistribution(float cosTheta, float roughness)
{
    // Given roughness is assumed to be clamped to [M_FLOAT_EPS, 1.0]
    float invRoughness = 1.0f / roughness;
    float cos2 = cosTheta * cosTheta;
    float sin2 = 1.0f - cos2;
    return (2.0f + invRoughness) * pow(sin2, invRoughness * 0.5f) / (2.0f * M_PI);
}

float sheenDirectionalAlbedo(float cosTheta, float roughness)
{
    float x = cosTheta  * (SHEEN_ALBEDO_TABLE_SIZE - 1);
    float y = roughness * (SHEEN_ALBEDO_TABLE_SIZE - 1);
    int ix = int(x);
    int iy = int(y);
    int ix2 = clamp(ix + 1, 0, SHEEN_ALBEDO_TABLE_SIZE - 1);
    int iy2 = clamp(iy + 1, 0, SHEEN_ALBEDO_TABLE_SIZE - 1);
    float fx = x - ix;
    float fy = y - iy;

    // Bi-linear interpolation of the LUT values
    float v1 = lerp(sheenAlbedoLUT[iy  * SHEEN_ALBEDO_TABLE_SIZE + ix], sheenAlbedoLUT[iy  * SHEEN_ALBEDO_TABLE_SIZE + ix2], fx);
    float v2 = lerp(sheenAlbedoLUT[iy2 * SHEEN_ALBEDO_TABLE_SIZE + ix], sheenAlbedoLUT[iy2 * SHEEN_ALBEDO_TABLE_SIZE + ix2], fx);
    float albedo = lerp(v1, v2, fy);

    return clamp(albedo, 0.0f, 1.0f);
}

float3 sheenBrdf(float3 L, float3 V, float3 N, float cosNL,
               float weight, float3 color, float roughness,
               out float throughput)
{
    float3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = sheenDistribution(cosNH, roughness);
    float3 F = color * weight;

    float albedo = weight * sheenDirectionalAlbedo(cosNV, roughness);
    throughput = 1.0f - albedo;

    // Geometry term is skipped and we use a smoother denominator, as in:
    // https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf
    return F * D / (4.0f * (cosNL + cosNV - cosNL * cosNV));
}

float3 sheenEnvBrdf(float cosNV, float weight, float3 color, float roughness,
                  out float throughput)
{
    float albedo = weight * sheenDirectionalAlbedo(cosNV, roughness);
    throughput = 1.0f - albedo;
    return color * albedo;
}

float3 dielectricBrdf(float3 L, float3 V, float3 N, float3 T, float3 B, float cosNL,
                    float weight, float3 tint, float ior, float2 roughness,
                    out float throughput)
{
    float3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = roughness.x != roughness.y ? 
        ggxAnisoDistribution(T, B, H, cosNH, roughness.x, roughness.y) :
        ggxDistribution(cosNH, roughness.x);

    float G = ggxShadowingSmith(cosNL, cosNV, max(roughness.x, roughness.y));

    float cosVH = dot(V, H);
    float F = fresnelSchlick(cosVH, ior) * weight;

    throughput = 1.0f - F;
    return tint * D * G * F / (4.0f * cosNL * cosNV);
}

float3 dielectricEnvBrdf(float cosNV, float weight, float3 tint, float ior, float2 roughness,
                       out float throughput)
{
    float F = fresnelSchlickRoughness(cosNV, ior, max(roughness.x, roughness.y));
    F *= weight;
    throughput = 1.0f - F;
    return tint * F;
}

float3 conductorBrdf(float3 L, float3 V, float3 N, float3 T, float3 B, float cosNL,
                    float weight, float3 ior_n, float3 ior_k, float2 roughness)
{
    float3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = roughness.x != roughness.y ? 
        ggxAnisoDistribution(T, B, H, cosNH, roughness.x, roughness.y) :
        ggxDistribution(cosNH, roughness.x);

    float G = ggxShadowingSmith(cosNL, cosNV, max(roughness.x, roughness.y));

    float cosVH = dot(V, H);
    float3 F = fresnelConductor(cosVH, ior_n, ior_k) * weight;

    return F * D * G / (4.0f * cosNL * cosNV);
}

float3 conductorEnvBrdf(float cosNV, float weight, float3 ior_n, float3 ior_k, float2 roughness)
{
    float3 F = fresnelConductor(cosNV, ior_n, ior_k);
    return F * weight;
}

float3 diffuseBrdf(float3 L, float3 V, float3 N, float cosNL, 
                 float3 color, float roughness)
{
    // Lambertian reflectance.
    float3 result = color / M_PI;

    // Evaluate Oren-Nayar BRDF if we have a roughness.
    if (roughness > 0.0f)
    {
        float cosLV = dot(L, V);
        float cosNV = abs(dot(N, V));

        float t = cosLV - cosNL * cosNV;
        t = t > 0.0f ? t / max(cosNL, cosNV) : 0.0f;

        float sigma2 = roughness * 0.707107f;
        sigma2 *= sigma2;

        float A = 1.0f - 0.5f * (sigma2 / (sigma2 + 0.33f));
        float B = 0.45f * sigma2 / (sigma2 + 0.09f);
        result *= A + B * t;
    }

    return result;
}

float aiBrdf(mayaStandardSurfaceLightData lightData, 
             float3 H, float cosNL, float roughness)
{
    float rx = square(roughness);
    rx = max(rx, 0.002f);   
    float rx2 = square(rx);

    float NH = dot(lightData.N, H);
    float NH2 = square(NH) + M_FLOAT_EPS;  // Make sure these are
    float NH4 = square(NH2) + M_FLOAT_EPS; // numerically stable
    float tan2ThetaM = (1.0f - NH2 ) / NH2;
    float D = exp(-tan2ThetaM / rx2) / (1.0f + M_PI * rx2 * NH4);  

    float NV = dot(lightData.N, lightData.V);
    float k = square(roughness+1.0f)/8.0f;
    float G1 = NV / (NV * (1.0 - k) + k);
    float G2 = cosNL / (cosNL * (1.0 - k) + k);
    float G = (G1 * G2);

    float atten = (1.0 + M_PI * roughness);
    return D * G / ( 2.0 * NV * cosNL * atten );
}

float3 aiDielectricBrdf(mayaStandardSurfaceLightData lightData, 
                      float cosNL, float weight, float3 tint, 
                      float ior, float roughness, 
                      out float throughput)
{
    float3 H = normalize(lightData.SL + lightData.V);
    float cosVH = dot(H, lightData.V);
    float F = fresnelSchlick(cosVH, ior) * weight;
    throughput = 1.0f - F;
    return tint * F * aiBrdf(lightData, H, cosNL, roughness);
}

float3 aiConductorBrdf(mayaStandardSurfaceLightData lightData, 
                     float cosNL, float weight, float3 ior_n, float3 ior_k, 
                     float roughness)
{
    float3 H = normalize(lightData.SL + lightData.V);
    float cosVH = dot(H, lightData.V);
    float3 F = fresnelConductor(cosVH, ior_n, ior_k) * weight;
    return F * aiBrdf(lightData, H, cosNL, roughness);
}

// Special ad-hoc BRDF evaulation needed by Arnold's area lights.
// See MtoA implementation for aiStandardSurface and aiAreaLight.
float3 aiAreaLightEvalBrdfs(mayaStandardSurfaceLightData lightData,
                          mayaStandardSurfaceParams params)
{
    float3 result = float3(0.0f, 0.0f, 0.0f);

    if (nonZero(params.opacity))
    {
        float3 throughput = float3(1.0f, 1.0f, 1.0f);
        float cosNL = dot(params.N, lightData.L);
        if (cosNL > 0.0f)
        {
            float3 brdf;
            float layerThroughput = 1.0;

            // Coat layer.
            if (params.coat > 0.0f)
            {
                float roughness = max(params.coatRoughness.x, params.coatRoughness.y);
                roughness = sqrt(roughness);
                brdf = aiDielectricBrdf(lightData, cosNL, 
                                        params.coat, float3(1.0f, 1.0f, 1.0f), 
                                        params.coatIOR, roughness,
                                        layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput * params.coatColor;
            }

            float roughness = max(params.specularRoughness.x, params.specularRoughness.y);
            roughness = sqrt(roughness);

            // Metal layer.
            if (params.metalness > 0.0f && nonZero(throughput))
            {
                brdf = aiConductorBrdf(lightData, cosNL,
                                    params.base, params.metalIOR, 
                                    params.metalExtinction, roughness);
                result += lightData.specular * brdf * cosNL * throughput * params.metalness;
                throughput *= 1.0f - params.metalness;
            }

            // Specular reflection layer.
            if (params.specular > 0.0f && nonZero(throughput))
            {
                brdf = aiDielectricBrdf(lightData, cosNL, params.specular, params.specularColor, 
                                        params.specularIOR, roughness,
                                        layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Transmission layer.
            throughput *= 1.0 - params.transmission;

            // Sheen layer.
            if (params.sheen > 0.0f && nonZero(throughput))
            {
                brdf = sheenBrdf(lightData.L, lightData.V,
                                params.N, cosNL,
                                params.sheen, params.sheenColor,
                                params.sheenRoughness,
                                layerThroughput);
                result += lightData.diffuse * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Base diffuse layer.
            if (params.base > 0.0f && nonZero(throughput))
            {
                brdf = diffuseBrdf(lightData.L, lightData.V,
                                params.N, cosNL,
                                params.diffuseColor,
                                params.diffuseRoughness);
                result += lightData.diffuse * brdf * cosNL * throughput;
            }
        }
    }

    return result;
}

#define LIGHT_TYPE_AI_AREA_LIGHT 0x00115C86

// Called by the light loop for each light source sample.
float3 mayaStandardSurfaceEvalBrdfs(mayaStandardSurfaceLightData lightData,
                                  mayaStandardSurfaceParams params)
{
    // Special case for handling Arnold area lights which
    // are non-physical and requires an ad-hoc BRDF.
    //
    // TODO: We should implement proper physically based
    // area lights and remove this hack.
    //
    if (lightData.lightType == LIGHT_TYPE_AI_AREA_LIGHT)
    {
        return aiAreaLightEvalBrdfs(lightData, params);
    }

    float3 result = float3(0.0f, 0.0f, 0.0f);

    if (nonZero(params.opacity))
    {
        float3 throughput = float3(1.0f, 1.0f, 1.0f);
        float cosNL = dot(params.N, lightData.L);
        if (cosNL > 0.0f)
        {
            float3 brdf;
            float layerThroughput = 1.0;

            // Coat layer.
            if (params.coat > 0.0f)
            {
                // Note: For the coat layer we use a white tint and
                // instead scale layers below with the coat color.
                brdf = dielectricBrdf(lightData.SL, lightData.V,
                                      params.N, params.coatT, params.coatB, cosNL,
                                      params.coat, float3(1.0f, 1.0f, 1.0f),
                                      params.coatIOR, params.coatRoughness,
                                      layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput * params.coatColor;
            }

            // Metal layer.
            if (params.metalness > 0.0f && nonZero(throughput))
            {
                brdf = conductorBrdf(lightData.SL, lightData.V,
                                     params.N, params.T, params.B, cosNL,
                                     params.base, params.metalIOR,
                                     params.metalExtinction, params.specularRoughness);
                result += lightData.specular * brdf * cosNL * throughput * params.metalness;
                throughput *= 1.0f - params.metalness;
            }

            // Specular reflection layer.
            if (params.specular > 0.0f && nonZero(throughput))
            {
                brdf = dielectricBrdf(lightData.SL, lightData.V,
                                      params.N, params.T, params.B, cosNL,
                                      params.specular, params.specularColor,
                                      params.specularIOR, params.specularRoughness,
                                      layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Transmission layer.
            throughput *= 1.0 - params.transmission;

            // Sheen layer.
            if (params.sheen > 0.0f && nonZero(throughput))
            {
                brdf = sheenBrdf(lightData.L, lightData.V,
                                 params.N, cosNL,
                                 params.sheen, params.sheenColor,
                                 params.sheenRoughness,
                                 layerThroughput);
                result += lightData.diffuse * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Base diffuse layer.
            if (params.base > 0.0f && nonZero(throughput))
            {
                brdf = diffuseBrdf(lightData.L, lightData.V,
                                   params.N, cosNL,
                                   params.diffuseColor,
                                   params.diffuseRoughness);
                result += lightData.diffuse * brdf * cosNL * throughput;
            }
        }
    }

    return result;
}
                ]]>
            </source>
        </implementation>
        <implementation render="OGSRenderer" language="GLSL" lang_version="3.0">
            <function_name val="mayaStandardSurfaceEvalBrdfs" />
            <source>
                <![CDATA[
// http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
float ggxDistribution(float cosNH, float alpha)
{
    float alpha2 = square(alpha);
    float denom = M_PI * square( square(cosNH) * (alpha2 - 1.0) + 1.0 );
    return alpha2 / denom;
}

// https://disney-animation.s3.amazonaws.com/library/s2012_pbs_disney_brdf_notes_v2.pdf
// Appendix B.2 Equation 13
float ggxAnisoDistribution(vec3 X, vec3 Y, vec3 H, float cosNH, float alphaX, float alphaY)
{
    float cosXH = dot(X, H);
    float cosYH = dot(Y, H);
    float denom = square(cosXH / alphaX) + square(cosYH / alphaY) + square(cosNH);
    return 1.0 / (M_PI * alphaX * alphaY * square(denom));
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf (Equation 34)
float ggxShadowingSmith1(float cosTheta, float alpha)
{
    float cosTheta2 = cosTheta * cosTheta;
    float tanTheta2 = (1.0f - cosTheta2) / cosTheta2;
    return 2.0f / (1.0f + sqrt(1.0f + alpha * alpha * tanTheta2));
}

// https://www.cs.cornell.edu/~srm/publications/EGSR07-btdf.pdf (Equation 23)
float ggxShadowingSmith(float cosNL, float cosNV, float alpha)
{
    return ggxShadowingSmith1(cosNL, alpha) * ggxShadowingSmith1(cosNV, alpha);
}

float fresnelSchlick(float cosTheta, float ior)
{
    if (cosTheta < 0.0f)
        return 1.0f;
    float F0 = square((ior - 1.0f) / (ior + 1.0f));
    float x = 1.0 - cosTheta;
    float x2 = x * x;
    float x5 = x2 * x2*x;
    return F0 + (1.0f - F0) * x5;
}

float fresnelSchlickRoughness(float cosTheta, float ior, float roughness)
{
    cosTheta = abs(cosTheta);
    float F0 = (ior - 1.0f) / (ior + 1.0f);
    F0 *= F0;
    float x = 1.0 - cosTheta;
    float x2 = x*x;
    float x5 = x2*x2*x;
    return F0 + (max(1.0f - roughness, F0) - F0) * x5;
}

vec3 fresnelConductor(float cosTheta, vec3 n, vec3 k)
{
   float c2 = cosTheta*cosTheta;
   vec3 n2_k2 = n*n + k*k;
   vec3 nc2 = 2.0f * n * cosTheta;

   vec3 rs_a = n2_k2 + c2;
   vec3 rp_a = n2_k2 * c2 + 1.0;
   vec3 rs = (rs_a - nc2) / (rs_a + nc2);
   vec3 rp = (rp_a - nc2) / (rp_a + nc2);

   return 0.5f * (rs + rp);
}

// LUT for sheen directional albedo.
// A 2D table parameterized with 'cosTheta' (cosine of angle to normal) on x-axis and 'roughness' on y-axis.
#define SHEEN_ALBEDO_TABLE_SIZE 16
const float sheenAlbedoLUT[SHEEN_ALBEDO_TABLE_SIZE*SHEEN_ALBEDO_TABLE_SIZE] = float[](
    1.6177, 0.978927, 0.618938, 0.391714, 0.245177, 0.150234, 0.0893475, 0.0511377, 0.0280191, 0.0144204, 0.00687674, 0.00295935, 0.00111049, 0.000336768, 7.07119e-05, 6.22646e-06,
    1.1084, 0.813928, 0.621389, 0.479304, 0.370299, 0.284835, 0.21724, 0.163558, 0.121254, 0.0878921, 0.0619052, 0.0419894, 0.0270556, 0.0161443, 0.00848212, 0.00342323,
    0.930468, 0.725652, 0.586532, 0.479542, 0.393596, 0.322736, 0.26353, 0.213565, 0.171456, 0.135718, 0.105481, 0.0800472, 0.0588117, 0.0412172, 0.0268329, 0.0152799,
    0.833791, 0.671201, 0.558957, 0.471006, 0.398823, 0.337883, 0.285615, 0.240206, 0.200696, 0.16597, 0.135422, 0.10859, 0.0850611, 0.0644477, 0.0464763, 0.0308878,
    0.771692, 0.633819, 0.537877, 0.461939, 0.398865, 0.344892, 0.297895, 0.256371, 0.219562, 0.186548, 0.156842, 0.130095, 0.10598, 0.0841919, 0.0645311, 0.04679,
    0.727979, 0.606373, 0.52141, 0.453769, 0.397174, 0.348337, 0.305403, 0.267056, 0.232655, 0.201398, 0.17286, 0.146756, 0.122808, 0.100751, 0.0804254, 0.0616485,
    0.695353, 0.585281, 0.508227, 0.44667, 0.394925, 0.350027, 0.310302, 0.274561, 0.242236, 0.212604, 0.185281, 0.16002, 0.13657, 0.114693, 0.0942543, 0.0750799,
    0.669981, 0.568519, 0.497442, 0.440542, 0.392567, 0.350786, 0.313656, 0.280075, 0.249533, 0.221359, 0.195196, 0.170824, 0.148012, 0.126537, 0.106279, 0.0870713,
    0.649644, 0.554855, 0.488453, 0.435237, 0.390279, 0.351028, 0.316036, 0.284274, 0.255266, 0.228387, 0.203297, 0.179796, 0.157665, 0.136695, 0.116774, 0.0977403,
    0.632951, 0.543489, 0.480849, 0.430619, 0.388132, 0.350974, 0.317777, 0.287562, 0.259885, 0.234153, 0.210041, 0.187365, 0.165914, 0.145488, 0.125983, 0.10724,
    0.61899, 0.533877, 0.47433, 0.426573, 0.386145, 0.35075, 0.319078, 0.290197, 0.263681, 0.238971, 0.215746, 0.193838, 0.173043, 0.153167, 0.134113, 0.115722,
    0.607131, 0.52564, 0.468678, 0.423001, 0.38432, 0.35043, 0.320072, 0.292349, 0.266856, 0.243055, 0.220636, 0.199438, 0.179264, 0.159926, 0.141332, 0.123323,
    0.596927, 0.518497, 0.463731, 0.419829, 0.382647, 0.350056, 0.320842, 0.294137, 0.269549, 0.246564, 0.224875, 0.204331, 0.18474, 0.165919, 0.147778, 0.130162,
    0.588052, 0.512241, 0.459365, 0.416996, 0.381114, 0.349657, 0.321448, 0.295641, 0.271862, 0.24961, 0.228584, 0.208643, 0.189596, 0.171266, 0.153566, 0.136341,
    0.580257, 0.506717, 0.455481, 0.41445, 0.379708, 0.34925, 0.321929, 0.296923, 0.273869, 0.252279, 0.231859, 0.212472, 0.193933, 0.176066, 0.158788, 0.141945,
    0.573355, 0.5018, 0.452005, 0.412151, 0.378416, 0.348844, 0.322316, 0.298028, 0.275627, 0.254638, 0.234772, 0.215896, 0.197828, 0.180398, 0.163522, 0.147049
);

// http://blog.selfshadow.com/publications/s2017-shading-course/imageworks/s2017_pbs_imageworks_sheen.pdf (Equation 2)
float sheenDistribution(float cosTheta, float roughness)
{
    // Given roughness is assumed to be clamped to [M_FLOAT_EPS, 1.0]
    float invRoughness = 1.0f / roughness;
    float cos2 = cosTheta * cosTheta;
    float sin2 = 1.0f - cos2;
    return (2.0f + invRoughness) * pow(sin2, invRoughness * 0.5f) / (2.0f * M_PI);
}

float sheenDirectionalAlbedo(float cosTheta, float roughness)
{
    float x = cosTheta  * (SHEEN_ALBEDO_TABLE_SIZE - 1);
    float y = roughness * (SHEEN_ALBEDO_TABLE_SIZE - 1);
    int ix = int(x);
    int iy = int(y);
    int ix2 = clamp(ix + 1, 0, SHEEN_ALBEDO_TABLE_SIZE - 1);
    int iy2 = clamp(iy + 1, 0, SHEEN_ALBEDO_TABLE_SIZE - 1);
    float fx = x - ix;
    float fy = y - iy;

    // Bi-linear interpolation of the LUT values
    float v1 = lerp(sheenAlbedoLUT[iy  * SHEEN_ALBEDO_TABLE_SIZE + ix], sheenAlbedoLUT[iy  * SHEEN_ALBEDO_TABLE_SIZE + ix2], fx);
    float v2 = lerp(sheenAlbedoLUT[iy2 * SHEEN_ALBEDO_TABLE_SIZE + ix], sheenAlbedoLUT[iy2 * SHEEN_ALBEDO_TABLE_SIZE + ix2], fx);
    float albedo = lerp(v1, v2, fy);

    return clamp(albedo, 0.0f, 1.0f);
}

vec3 sheenBrdf(vec3 L, vec3 V, vec3 N, float cosNL,
               float weight, vec3 color, float roughness,
               out float throughput)
{
    vec3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = sheenDistribution(cosNH, roughness);
    vec3 F = color * weight;

    float albedo = weight * sheenDirectionalAlbedo(cosNV, roughness);
    throughput = 1.0f - albedo;

    // Geometry term is skipped and we use a smoother denominator, as in:
    // https://blog.selfshadow.com/publications/s2013-shading-course/rad/s2013_pbs_rad_notes.pdf
    return F * D / (4.0f * (cosNL + cosNV - cosNL * cosNV));
}

vec3 sheenEnvBrdf(float cosNV, float weight, vec3 color, float roughness,
                  out float throughput)
{
    float albedo = weight * sheenDirectionalAlbedo(cosNV, roughness);
    throughput = 1.0f - albedo;
    return color * albedo;
}

vec3 dielectricBrdf(vec3 L, vec3 V, vec3 N, vec3 T, vec3 B, float cosNL,
                    float weight, vec3 tint, float ior, vec2 roughness,
                    out float throughput)
{
    vec3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = roughness.x != roughness.y ? 
        ggxAnisoDistribution(T, B, H, cosNH, roughness.x, roughness.y) :
        ggxDistribution(cosNH, roughness.x);

    float G = ggxShadowingSmith(cosNL, cosNV, max(roughness.x, roughness.y));

    float cosVH = dot(V, H);
    float F = fresnelSchlick(cosVH, ior) * weight;

    throughput = 1.0f - F;
    return tint * D * G * F / (4.0f * cosNL * cosNV);
}

vec3 dielectricEnvBrdf(float cosNV, float weight, vec3 tint, float ior, vec2 roughness,
                       out float throughput)
{
    float F = fresnelSchlickRoughness(cosNV, ior, max(roughness.x, roughness.y));
    F *= weight;
    throughput = 1.0f - F;
    return tint * F;
}

vec3 conductorBrdf(vec3 L, vec3 V, vec3 N, vec3 T, vec3 B, float cosNL,
                    float weight, vec3 ior_n, vec3 ior_k, vec2 roughness)
{
    vec3 H = normalize(L + V);
    float cosNH = dot(N, H);
    float cosNV = dot(N, V);

    float D = roughness.x != roughness.y ? 
        ggxAnisoDistribution(T, B, H, cosNH, roughness.x, roughness.y) :
        ggxDistribution(cosNH, roughness.x);

    float G = ggxShadowingSmith(cosNL, cosNV, max(roughness.x, roughness.y));

    float cosVH = dot(V, H);
    vec3 F = fresnelConductor(cosVH, ior_n, ior_k) * weight;

    return F * D * G / (4.0f * cosNL * cosNV);
}

vec3 conductorEnvBrdf(float cosNV, float weight, vec3 ior_n, vec3 ior_k, vec2 roughness)
{
    vec3 F = fresnelConductor(cosNV, ior_n, ior_k);
    return F * weight;
}

vec3 diffuseBrdf(vec3 L, vec3 V, vec3 N, float cosNL, 
                 vec3 color, float roughness)
{
    // Lambertian reflectance.
    vec3 result = color / M_PI;

    // Evaluate Oren-Nayar BRDF if we have a roughness.
    if (roughness > 0.0f)
    {
        float cosLV = dot(L, V);
        float cosNV = abs(dot(N, V));

        float t = cosLV - cosNL * cosNV;
        t = t > 0.0f ? t / max(cosNL, cosNV) : 0.0f;

        float sigma2 = roughness * 0.707107f;
        sigma2 *= sigma2;

        float A = 1.0f - 0.5f * (sigma2 / (sigma2 + 0.33f));
        float B = 0.45f * sigma2 / (sigma2 + 0.09f);
        result *= A + B * t;
    }

    return result;
}

float aiBrdf(mayaStandardSurfaceLightData lightData, 
             vec3 H, float cosNL, float roughness)
{
    float rx = square(roughness);
    rx = max(rx, 0.002f);   
    float rx2 = square(rx);

    float NH = dot(lightData.N, H);
    float NH2 = square(NH) + M_FLOAT_EPS;  // Make sure these are
    float NH4 = square(NH2) + M_FLOAT_EPS; // numerically stable
    float tan2ThetaM = (1.0f - NH2 ) / NH2;
    float D = exp(-tan2ThetaM / rx2) / (1.0f + M_PI * rx2 * NH4);  

    float NV = dot(lightData.N, lightData.V);
    float k = square(roughness+1.0f)/8.0f;
    float G1 = NV / (NV * (1.0 - k) + k);
    float G2 = cosNL / (cosNL * (1.0 - k) + k);
    float G = (G1 * G2);

    float atten = (1.0 + M_PI * roughness);
    return D * G / ( 2.0 * NV * cosNL * atten );
}

vec3 aiDielectricBrdf(mayaStandardSurfaceLightData lightData, 
                      float cosNL, float weight, vec3 tint, 
                      float ior, float roughness, 
                      out float throughput)
{
    vec3 H = normalize(lightData.SL + lightData.V);
    float cosVH = dot(H, lightData.V);
    float F = fresnelSchlick(cosVH, ior) * weight;
    throughput = 1.0f - F;
    return tint * F * aiBrdf(lightData, H, cosNL, roughness);
}

vec3 aiConductorBrdf(mayaStandardSurfaceLightData lightData, 
                     float cosNL, float weight, vec3 ior_n, vec3 ior_k, 
                     float roughness)
{
    vec3 H = normalize(lightData.SL + lightData.V);
    float cosVH = dot(H, lightData.V);
    vec3 F = fresnelConductor(cosVH, ior_n, ior_k) * weight;
    return F * aiBrdf(lightData, H, cosNL, roughness);
}

// Special ad-hoc BRDF evaulation needed by Arnold's area lights.
// See MtoA implementation for aiStandardSurface and aiAreaLight.
vec3 aiAreaLightEvalBrdfs(mayaStandardSurfaceLightData lightData,
                          mayaStandardSurfaceParams params)
{
    vec3 result = vec3(0.0f, 0.0f, 0.0f);

    if (nonZero(params.opacity))
    {
        vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
        float cosNL = dot(params.N, lightData.L);
        if (cosNL > 0.0f)
        {
            vec3 brdf;
            float layerThroughput = 1.0;

            // Coat layer.
            if (params.coat > 0.0f)
            {
                float roughness = max(params.coatRoughness.x, params.coatRoughness.y);
                roughness = sqrt(roughness);
                brdf = aiDielectricBrdf(lightData, cosNL, 
                                        params.coat, vec3(1.0f, 1.0f, 1.0f), 
                                        params.coatIOR, roughness,
                                        layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput * params.coatColor;
            }

            float roughness = max(params.specularRoughness.x, params.specularRoughness.y);
            roughness = sqrt(roughness);

            // Metal layer.
            if (params.metalness > 0.0f && nonZero(throughput))
            {
                brdf = aiConductorBrdf(lightData, cosNL,
                                    params.base, params.metalIOR, 
                                    params.metalExtinction, roughness);
                result += lightData.specular * brdf * cosNL * throughput * params.metalness;
                throughput *= 1.0f - params.metalness;
            }

            // Specular reflection layer.
            if (params.specular > 0.0f && nonZero(throughput))
            {
                brdf = aiDielectricBrdf(lightData, cosNL, params.specular, params.specularColor, 
                                        params.specularIOR, roughness,
                                        layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Transmission layer.
            throughput *= 1.0 - params.transmission;

            // Sheen layer.
            if (params.sheen > 0.0f && nonZero(throughput))
            {
                brdf = sheenBrdf(lightData.L, lightData.V,
                                params.N, cosNL,
                                params.sheen, params.sheenColor,
                                params.sheenRoughness,
                                layerThroughput);
                result += lightData.diffuse * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Base diffuse layer.
            if (params.base > 0.0f && nonZero(throughput))
            {
                brdf = diffuseBrdf(lightData.L, lightData.V,
                                params.N, cosNL,
                                params.diffuseColor,
                                params.diffuseRoughness);
                result += lightData.diffuse * brdf * cosNL * throughput;
            }
        }
    }

    return result;
}

#define LIGHT_TYPE_AI_AREA_LIGHT 0x00115C86

// Called by the light loop for each light source sample.
vec3 mayaStandardSurfaceEvalBrdfs(mayaStandardSurfaceLightData lightData,
                                  mayaStandardSurfaceParams params)
{
    // Special case for handling Arnold area lights which
    // are non-physical and requires an ad-hoc BRDF.
    //
    // TODO: We should implement proper physically based
    // area lights and remove this hack.
    //
    if (lightData.lightType == LIGHT_TYPE_AI_AREA_LIGHT)
    {
        return aiAreaLightEvalBrdfs(lightData, params);
    }

    vec3 result = vec3(0.0f, 0.0f, 0.0f);

    if (nonZero(params.opacity))
    {
        vec3 throughput = vec3(1.0f, 1.0f, 1.0f);
        float cosNL = dot(params.N, lightData.L);
        if (cosNL > 0.0f)
        {
            vec3 brdf;
            float layerThroughput = 1.0;

            // Coat layer.
            if (params.coat > 0.0f)
            {
                // Note: For the coat layer we use a white tint and
                // instead scale layers below with the coat color.
                brdf = dielectricBrdf(lightData.SL, lightData.V,
                                      params.N, params.coatT, params.coatB, cosNL,
                                      params.coat, vec3(1.0f, 1.0f, 1.0f),
                                      params.coatIOR, params.coatRoughness,
                                      layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput * params.coatColor;
            }

            // Metal layer.
            if (params.metalness > 0.0f && nonZero(throughput))
            {
                brdf = conductorBrdf(lightData.SL, lightData.V,
                                     params.N, params.T, params.B, cosNL,
                                     params.base, params.metalIOR,
                                     params.metalExtinction, params.specularRoughness);
                result += lightData.specular * brdf * cosNL * throughput * params.metalness;
                throughput *= 1.0f - params.metalness;
            }

            // Specular reflection layer.
            if (params.specular > 0.0f && nonZero(throughput))
            {
                brdf = dielectricBrdf(lightData.SL, lightData.V,
                                      params.N, params.T, params.B, cosNL,
                                      params.specular, params.specularColor,
                                      params.specularIOR, params.specularRoughness,
                                      layerThroughput);
                result += lightData.specular * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Transmission layer.
            throughput *= 1.0 - params.transmission;

            // Sheen layer.
            if (params.sheen > 0.0f && nonZero(throughput))
            {
                brdf = sheenBrdf(lightData.L, lightData.V,
                                 params.N, cosNL,
                                 params.sheen, params.sheenColor,
                                 params.sheenRoughness,
                                 layerThroughput);
                result += lightData.diffuse * brdf * cosNL * throughput;
                throughput *= layerThroughput;
            }

            // Base diffuse layer.
            if (params.base > 0.0f && nonZero(throughput))
            {
                brdf = diffuseBrdf(lightData.L, lightData.V,
                                   params.N, cosNL,
                                   params.diffuseColor,
                                   params.diffuseRoughness);
                result += lightData.diffuse * brdf * cosNL * throughput;
            }
        }
    }

    return result;
} 
                ]]>
            </source>
        </implementation>
    </implementation>
</fragment>
