uniform mat4 gWVPXf : WorldViewProjection ;
uniform texture2D gDirectionTex : InputTexture;
uniform sampler2D DirectionSamp = sampler_state
{
Texture   = <gDirectionTex>;
};
uniform texture2D gHDRLatLongTex : InputTexture;
uniform sampler2D gHDRLatLongSamp = sampler_state
{
Texture   = <gHDRLatLongTex>;
};
uniform float gShininess[4];
uniform vec2 gTiling;
uniform vec2 gPixelSize;
uniform vec2 gBlockTexCoord0;
attribute VS_INPUT
{
vec3 Pos : POSITION;
vec2 UV : TEXCOORD0;
}
attribute VS_TO_PS
{
vec2 VSUV : TEXCOORD0;
vec4 SSamples : TEXCOORD1;
vec2 TSamples : TEXCOORD2;
}
attribute pixelOut {
vec4 colorOut:COLOR0;
}
GLSLShader VS_IBLConvolution
{
void main()
{
gl_Position = gWVPXf*vec4(Pos,1.0);
vec2 tc = UV * gTiling;
VSUV = tc;
vec2 offset = gPixelSize * 0.5;
SSamples.x = tc.x - (offset.x + gPixelSize.x);
SSamples.y = tc.x - offset.x;
SSamples.z = tc.x + offset.x;
SSamples.w = tc.x + (offset.x + gPixelSize.x);
TSamples.x = tc.y - offset.y;
TSamples.y = tc.y + offset.y;
}
}
attribute pixelOutput {
#ifndef RENDER_TARGET_COUNT
#define RENDER_TARGET_COUNT 1
#endif
#if RENDER_TARGET_COUNT == 1
vec4 oColor[1] : COLORV;
#endif
#if RENDER_TARGET_COUNT == 2
vec4 oColor[2] : COLORV;
#endif
#if RENDER_TARGET_COUNT == 3
vec4 oColor[3] : COLORV;
#endif
#if RENDER_TARGET_COUNT == 4
vec4 oColor[4] : COLORV;
#endif
}
GLSLShader PS_IBLConvolution
{
void main()
{
vec3 N = texture2D(DirectionSamp, gBlockTexCoord0.xy + floor(VSUV) * gPixelSize.xy).xyz;
vec4 SS = fract(SSamples);
vec2 TS = fract(TSamples);
for( int i = 0; i < RENDER_TARGET_COUNT; ++i)
{
oColor[i] = vec4(0.0,0.0,0.0,0.0);
}
for( int t = 0; t < 2; ++t)
{
vec4 rowSums[RENDER_TARGET_COUNT];
for( int i = 0; i < RENDER_TARGET_COUNT; ++i)
{
rowSums[i] = vec4(0.0,0.0,0.0,0.0);
}
vec4 L;
for( int s = 0; s < 4; ++s)
{
vec2 p1 = vec2(SS[s], TS[t]);
L = texture2D(DirectionSamp, p1);
vec3 color = texture2D(gHDRLatLongSamp, p1).rgb;
float NdotL = max(0.0, dot( N, L.xyz));
for( int i = 0; i < RENDER_TARGET_COUNT; ++i)
{
float pf = pow( NdotL, gShininess[i]);
rowSums[i] += vec4( color * pf, pf);
}
}
for( int j = 0; j < RENDER_TARGET_COUNT; ++j)
{
oColor[j] += L.w * rowSums[j];
}
}
}
}
technique Main
{
pass p0
{
VertexShader (in VS_INPUT, out VS_TO_PS) = VS_IBLConvolution;
PixelShader (in VS_TO_PS, out pixelOutput) = PS_IBLConvolution;
}
}
