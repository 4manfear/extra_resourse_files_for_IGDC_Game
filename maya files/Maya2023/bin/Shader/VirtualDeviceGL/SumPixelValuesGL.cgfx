float4x4 gWVPXf : WorldViewProjection < string UIWidget = "None"; >;
texture gSumTexture : InputTexture
<
string UIName = "Input Texture";
> = NULL;
sampler2D gSumSamp = sampler_state
{
Texture   = <gSumTexture>;
};
float2 gPixelSize;
struct VS_INPUT
{
float3 Pos : POSITION;
float2 UV : TEXCOORD0;
};
struct VS_TO_PS
{
float4 HPos : POSITION;
float2 UV : TEXCOORD0;
float2 OffsetCoords0 : TEXCOORD1;
float2 OffsetCoords1 : TEXCOORD2;
float2 OffsetCoords2 : TEXCOORD3;
float2 OffsetCoords3 : TEXCOORD4;
};
VS_TO_PS VS_SumPixelValues(VS_INPUT In)
{
VS_TO_PS Out;
Out.HPos = mul(float4(In.Pos, 1.0f), gWVPXf);
Out.UV = In.UV;
float2 offset = gPixelSize * 0.25;
Out.OffsetCoords0 = In.UV + float2(offset.x, offset.y);
Out.OffsetCoords1 = In.UV + float2(offset.x, -offset.y);
Out.OffsetCoords2 = In.UV + float2(-offset.x, -offset.y);
Out.OffsetCoords3 = In.UV + float2(-offset.x, offset.y);
return Out;
}
float4 PS_SumPixelValues(VS_TO_PS In) : COLOR
{
float4 result = 0.0f;
result += tex2D(gSumSamp, In.OffsetCoords0);
result += tex2D(gSumSamp, In.OffsetCoords1);
result += tex2D(gSumSamp, In.OffsetCoords2);
result += tex2D(gSumSamp, In.OffsetCoords3);
return result;
}
technique Main
{
pass p0
{
VertexProgram = compile glslv VS_SumPixelValues();
FragmentProgram = compile glslf PS_SumPixelValues();
}
}
