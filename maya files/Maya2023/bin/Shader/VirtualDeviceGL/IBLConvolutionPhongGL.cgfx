float4x4 gWVPXf : WorldViewProjection < string UIWidget = "None"; >;
texture gDirectionTex : InputTexture
<
string UIName = "Input Texture";
> = NULL;
sampler2D DirectionSamp = sampler_state
{
Texture   = <gDirectionTex>;
};
texture gHDRLatLongTex : InputTexture
<
string UIName = "Input Texture";
> = NULL;
sampler2D gHDRLatLongSamp = sampler_state
{
Texture   = <gHDRLatLongTex>;
};
float gShininess[4];
float2 gTiling;
float2 gPixelSize;
float2 gBlockTexCoord0;
struct VS_INPUT
{
float3 Pos : POSITION;
float2 UV : TEXCOORD0;
};
struct VS_TO_PS
{
float4 HPos : POSITION;
float2 UV : TEXCOORD0;
float4 SSamples : TEXCOORD1;
float2 TSamples : TEXCOORD2;
};
VS_TO_PS VS_IBLConvolution(VS_INPUT In)
{
VS_TO_PS Out;
Out.HPos = mul(float4(In.Pos, 1.0f), gWVPXf);
float2 tc = In.UV * gTiling;
Out.UV = tc;
float2 offset = gPixelSize * 0.5f;
Out.SSamples.x = tc.x - (offset.x + gPixelSize.x);
Out.SSamples.y = tc.x - offset.x;
Out.SSamples.z = tc.x + offset.x;
Out.SSamples.w = tc.x + (offset.x + gPixelSize.x);
Out.TSamples.x = tc.y - offset.y;
Out.TSamples.y = tc.y + offset.y;
return Out;
}
struct pixelOutput {
float4 oColor0 : COLOR0;
#if RENDER_TARGET_COUNT > 1
float4 oColor1 : COLOR1;
#endif
#if RENDER_TARGET_COUNT > 2
float4 oColor2 : COLOR2;
#endif
#if RENDER_TARGET_COUNT > 3
float4 oColor3 : COLOR3;
#endif
};
pixelOutput PS_IBLConvolution(VS_TO_PS In)
{
float3 N = tex2D(DirectionSamp, gBlockTexCoord0.xy + floor(In.UV) * gPixelSize.xy).xyz;
float4 SS = frac(In.SSamples);
float2 TS = frac(In.TSamples);
float4 results[RENDER_TARGET_COUNT];
for( int i = 0; i < RENDER_TARGET_COUNT; ++i)
{
results[i] = 0.0;
}
for( int t = 0; t < 2; ++t)
{
float4 rowSums[RENDER_TARGET_COUNT];
for( int i = 0; i < RENDER_TARGET_COUNT; ++i)
{
rowSums[i] = 0.0;
}
float4 L;
for( int s = 0; s < 4; ++s)
{
float2 p1 = float2(SS[s], TS[t]);
L = tex2D(DirectionSamp, p1);
float3 color = tex2D(gHDRLatLongSamp, p1).rgb;
float NdotL = max(0.0, dot( N, L.xyz));
for( int i = 0; i < RENDER_TARGET_COUNT; ++i)
{
float pf = pow( NdotL, gShininess[i]);
rowSums[i] += float4( color * pf, pf);
}
}
for( int j = 0; j < RENDER_TARGET_COUNT; ++j)
{
results[j] += L.w * rowSums[j];
}
}
pixelOutput psOutput;
psOutput.oColor0 = results[0];
#if RENDER_TARGET_COUNT > 1
psOutput.oColor1 = results[1];
#endif
#if RENDER_TARGET_COUNT > 2
psOutput.oColor2 = results[2];
#endif
#if RENDER_TARGET_COUNT > 3
psOutput.oColor3 = results[3];
#endif
return psOutput;
}
technique Main
{
pass p0
{
VertexProgram = compile glslv VS_IBLConvolution();
FragmentProgram = compile glslf PS_IBLConvolution();
}
}
