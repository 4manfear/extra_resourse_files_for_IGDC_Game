
//**************************************************************************/
// Copyright 2015 Autodesk, Inc.
// All rights reserved.
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
//**************************************************************************/

// World-view-projection transformation.
float4x4 gWVPXf : WorldViewProjection < string UIWidget = "None"; >;

// Target size.
float2 gTargetSize : ViewportPixelSize < string UIWidget = "None"; >;

// The single filter input, i.e. the image to be filtered.
texture gInputTex : InputTexture
<
    string UIName = "Input Texture";
>;

// Filter input sampler.
sampler2D gInputSamp = sampler_state
{
    Texture = <gInputTex>;
    MinFilter = Point;
    MagFilter = Point;
    MipFilter = Point;
};

// Swirl options
uniform float radius = 300.0;
uniform float angle = 0.8;
uniform float2 centerPercent = { 0.5, 0.5 };

// Vertex shader input structure.
struct VS_INPUT
{
    float4 Pos : POSITION;
    float3 UV : TEXCOORD0;
};

// Vertex shader output structure.
struct VS_TO_PS
{
    float4 HPos : POSITION;
    float3 UV : TEXCOORD0;
};

// Vertex shader.
VS_TO_PS VS_FilterSwirl(VS_INPUT In)
{
    VS_TO_PS Out;
    
    // Transform the position from object space to clip space for output.
    Out.HPos = mul(gWVPXf, In.Pos);
    
    // Pass the texture coordinates unchanged.
    Out.UV = In.UV;
    
    return Out;
}

// Pixel shader.
float4 PS_FilterSwirl(VS_TO_PS In) : COLOR0
{
	float2 uv = In.UV.xy;

	float2 center = gTargetSize * centerPercent;
	float2 tc = uv * gTargetSize;
	tc -= center;
	float dist = length(tc);
	if (dist < radius) 
	{
		float percent = (radius - dist) / radius;
		float theta = percent * percent * angle * 8.0;
		float s = sin(theta);
		float c = cos(theta);
		tc = float2(dot(tc, float2(c, -s)), dot(tc, float2(s, c)));
	}
	tc += center;
	float3 color = tex2D(gInputSamp, tc / gTargetSize).rgb;
	return float4(color, 1.0);	
}

// The main technique.
technique Main
{
    pass p0
    {
        VertexShader = compile glslv VS_FilterSwirl();
        PixelShader = compile glslf PS_FilterSwirl();
    }
}
