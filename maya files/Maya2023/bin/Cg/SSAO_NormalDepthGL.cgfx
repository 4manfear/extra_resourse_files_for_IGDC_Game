//**************************************************************************/
// Copyright (c) 2008 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
// DESCRIPTION: Screen space ambient occlusion - normal-depth buffer pass.
// AUTHOR: Mauricio Vives
// CREATED: October 2008
//**************************************************************************/

#include "SSAO_Common.cgh"
#ifdef CLIPPING
#include "ClippingGL.cgh"
#endif

// Check if the back-facing normal need to be flipped.
bool isSingleSided = false;
float mayaNormalMultiplier = 1.0f;

// Whether the projection matrix flips Z: -1.0 if so, otherwise 1.0.
#ifdef FX_COMPOSER
	float gProjZSense < string UIWidget = "None"; > = -1.0f;
#else
	float gProjZSense : ProjectionZSense < string UIWidget = "None"; >;
#endif

// Vertex shader input structure.
struct VS_INPUT_NormalDepth
{
    float3 Pos : POSITION;
    float3 Normal: NORMAL;
};

// Vertex shader output structure.
struct VS_TO_PS_NormalDepth
{
    float4 HPos : POSITION;
    float4 NormalDepth : TEXCOORD0;

#ifdef CLIPPING
    // Clip distances, for six clipping planes. 
    float Clip0 : CLP0;
    float Clip1 : CLP1;
    float Clip2 : CLP2;
    float Clip3 : CLP3;
    float Clip4 : CLP4;
    float Clip5 : CLP5;
#endif
};

// Vertex shader.
VS_TO_PS_NormalDepth VS_NormalDepth(VS_INPUT_NormalDepth In)
{
    VS_TO_PS_NormalDepth Out;
    
    // Transform the vertex from object space to clip space.
    Out.HPos = mul(float4(In.Pos, 1.0f), gWVPXf); // * float4( 1, -1, 1, 1);
    //Out.HPos = mul(gWVPXf, float4(In.Pos, 1.0f));
    
    // Record the normal and depth components for the pixel shader.
    // NOTE: This depends on whether the view direction is along +Z or -Z.  The projection matrix
    // "Z sense" determines this.
    Out.NormalDepth.xyz = mul(In.Normal, float3x3(gWVITXf[0].xyz,
												  gWVITXf[1].xyz,
												  gWVITXf[2].xyz));
	//Out.NormalDepth.xyz = mul( float3x3(gWVITXf[0].xyz,
	//								    gWVITXf[1].xyz,
	//									gWVITXf[2].xyz), In.Normal );

    Out.NormalDepth.z = gProjZSense * Out.NormalDepth.z;
    Out.NormalDepth.w = gProjZSense * mul(float4(In.Pos, 1.0f), gWVXf).z;
    //Out.NormalDepth.w = gProjZSense * mul( gWVXf, float4(In.Pos, 1.0f)).z;

#ifdef CLIPPING
    // Compute the six clip distances.
    float4 HPw = mul(float4(In.Pos, 1.0f), gWXf);
    //float4 HPw = mul(gWXf, float4(In.Pos, 1.0f));
    ComputeClipDistances(HPw, Out.Clip0, Out.Clip1, Out.Clip2, Out.Clip3,
        Out.Clip4, Out.Clip5);
#endif

    return Out;
}

// Pixel shader output structure.
struct PS_OUT
{
    float4 Normal : COLOR0;
    float4 Depth : COLOR1;
};

// Pixel shader.
PS_OUT PS_NormalDepth(VS_TO_PS_NormalDepth In, float frontFace : FACE)
{
    PS_OUT Out;

    // Set the normal for an unsigned normalized integer target, and depth for a floating-point
    // target.
	float3 normal = normalize(In.NormalDepth.xyz);

	if ( !isSingleSided )
	{
		float normalMul = ( frontFace < 1e-5 ) ? -mayaNormalMultiplier : mayaNormalMultiplier;
		normal *= normalMul;
	}

    Out.Normal = float4( (normal+1.0f) * 0.5f, 0.0f);
    Out.Depth  = In.NormalDepth.wwww;

    return Out;
}

#ifndef FX_COMPOSER

// Technique.
technique NormalDepth
{
    pass p0
    {
        VertexShader = compile glslv VS_NormalDepth();
        PixelShader = compile glslf PS_NormalDepth();
    }
}

#endif