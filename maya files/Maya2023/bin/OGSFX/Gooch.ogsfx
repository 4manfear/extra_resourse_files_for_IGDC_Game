// The warm and cool colors are coming from the application.
//#define WARM_COOL_COLOR_SOURCE_LITERAL

// We use a uniform color from the application as the vertex color.
#define VERTEX_COLOR_SOURCE_LITERAL

//When LIGHT_DIR_FROM_SYSTEM is defined, use the LightDirection system semantic. 
//Otherwise use the LightDirectionParameter semantic. 
#define LIGHT_DIR_FROM_SYSTEM

// World-view-projection transformation.
uniform mat4 gWVPXf : WorldViewProjection 
< 
string UIWidget = "None"; 
bool rowMajor = true;
>;

// World-view transformation
uniform mat4 gWV : WorldView 
< 
string UIWidget = "None"; 
bool rowMajor = true;
>;

#ifdef LIGHT_DIR_FROM_SYSTEM
// Light direction from graphic scheme
uniform vec3 gDir : LightDirection < string UIWidget = "None"; >;
#else
// Light direction specified by the application
uniform vec3 gLightDirection : LightDirectionParameter
<
string UIName = "Light Direction";
> = {1.0f, 0.0f, 0.0f};
#endif

// View direction. 1 for left-handed, and -1 for right-handed.
uniform int gHandedness : Handedness< string UIWidget = "None"; > = 1;

// The specular color.
uniform vec3  gHighlightColor : HighlightColor
<
string UIName = "Highlight Color";
> = {1.0f, 1.0f, 1.0f};

// The warm and cool colors are from the application, 
// if WARM_COOL_COLOR_SOURCE_LITERAL is defined.
#ifdef WARM_COOL_COLOR_SOURCE_LITERAL
// The warm color is displayed on the faces that is lit.
// Commonly we use red, orange or yellow as the warm color.
uniform vec3  gWarmColor : WarmColor
<
string UIName = "Warm Color";
> = {0.50f, 0.50f, 0.20f};

// The cool color is displayed on the faces that is in the shadow.
// Commonly we use blue, violet or green as the cool color.
uniform vec3  gCoolColor : CoolColor
<
string UIName = "Cool Color";
> = {0.35f, 0.40f, 0.10f};
#endif

// We use a uniform color from the application as the vertex color,
// if VERTEX_COLOR_SOURCE_LITERAL is defined.
#ifdef VERTEX_COLOR_SOURCE_LITERAL
// The base color is for surface diffuse reflection, when the vertex color is not valid.
uniform vec4  gBaseColor : BaseColor
<
string UIName = "Base Color";
> = {0.0f, 0.0f, 0.0f, 1.0f};
#endif

// The factor that the warm color combining with the base color.
uniform float  gDiffuseWarm : DiffuseWarm
<
string UIName = "Diffuse Warm";
string UIWidget = "Slider";
> = 0.65f;                  

// The factor that the cool color combining with the base color.
uniform float gDiffuseCool : DiffuseCool
<
string UIName = "Diffuse Cool";
string UIWidget = "Slider";
> = 0.10f;       

// The specular power factor.
uniform float gShininess : Shininess
<
string UIName = "Shininess";
string UIWidget = "Slider";
> = 8.0f;       


attribute VS_INPUT
{
    vec3 Pos  : POSITION;
    vec3 Normal  : NORMAL;
    
    // if VERTEX_COLOR_SOURCE_LITERAL is defined,
    // the vertex format doesn't need the color field.
    #ifndef VERTEX_COLOR_SOURCE_LITERAL
        vec4 Cs : COLOR;
    #endif
};

attribute VS_TO_PS
{
    // if WARM_COOL_COLOR_SOURCE_LITERAL is not defined, the warm and cool colors 
    // are generated from vertex color, and passed to the pixel shader.
    #ifndef WARM_COOL_COLOR_SOURCE_LITERAL
        vec3 WarmColor  : COLOR0;
        vec3 CoolColor  : COLOR1;
    #endif
    
    vec3 ReflectVec : TEXCOORD0;
    vec3 ViewVec    : TEXCOORD1;
    float NdotL     : TEXCOORD2;
    
    // if VERTEX_COLOR_SOURCE_LITERAL is defined,
    // the vertex color need not passed to the pixel shader.
    #ifndef VERTEX_COLOR_SOURCE_LITERAL
        vec4 Cs         : TEXCOORD3;
    #endif
};

attribute pixelOut
{
    vec4 colorOut: COLOR0;
}

GLSLShader GoochVS
{
	void main()
	{
		vec3 eyeNormal  = normalize(gWVPXf*vec4(Normal, 1.0)).xyz;
		
		#ifdef LIGHT_DIR_FROM_SYSTEM
			vec3 posToLight = normalize(gDir);
		#else
			vec3 posToLight = normalize(gLightDirection);
		#endif

		vsOut.ReflectVec  = normalize(reflect(-posToLight, eyeNormal));
		vsOut.ViewVec     = normalize(vec3(0, 0, gHandedness));
		vsOut.NdotL       = ((dot(posToLight, eyeNormal) + 1.0) * 0.5);
		gl_Position 	  = gWVPXf*vec4(Pos, 1.0);
		
		// if VERTEX_COLOR_SOURCE_LITERAL is defined,
		// the vertex color need not passed to the pixel shader.
		#ifndef VERTEX_COLOR_SOURCE_LITERAL
			vsOut.Cs        = Cs;
		#endif
		
		// if WARM_COOL_COLOR_SOURCE_LITERAL is not defined, the warm and cool colors 
		// are generated from vertex color.
		#ifndef WARM_COOL_COLOR_SOURCE_LITERAL
			const vec3 warmMap[] = vec3[](
				vec3( 0.55F, 0.55F, 0.55F ),  // 0:  0 0 0 = black
				vec3( 0.35F, 0.40F, 0.10F ),  // 1:  0 0 1 = blue
				vec3( 0.45F, 0.45F, 0.20F ),  // 2:  0 1 0 = green
				vec3( 0.50F, 0.50F, 0.00F ),  // 3:  0 1 1 = cyan
				vec3( 0.45F, 0.45F, 0.25F ),  // 4:  1 0 0 = red
				vec3( 0.35F, 0.30F, 0.10F ),  // 5:  1 0 1 = magenta
				vec3( 0.50F, 0.50F, 0.20F ),  // 6:  1 1 0 = yellow
				vec3( 0.60F, 0.60F, 0.20F )   // 7:  1 1 1 = white
			);

			const vec3 coolMap[] = vec3[](
				vec3( 0.20F, 0.20F, 0.30F ),  // 0:  0 0 0 = black
				vec3( 0.10F, 0.50F, 0.15F ),  // 1:  0 0 1 = blue
				vec3( 0.10F, 0.10F, 0.70F ),  // 2:  0 1 0 = green
				vec3( 0.10F, 0.10F, 0.75F ),  // 3:  0 1 1 = cyan
				vec3( 0.00F, 0.00F, 0.70F ),  // 4:  0 1 0 = red
				vec3( 0.10F, 0.15F, 0.70F ),  // 5:  1 0 1 = magenta
				vec3( 0.10F, 0.10F, 0.75F ),  // 6:  1 1 0 = yellow
				vec3( 0.00F, 0.00F, 0.60F )   // 7:  1 1 1 = white
			);

			//
			// Create the warm and cool colors to use as a tri-linear interpolation
			// of the color map above, based on the surface color.
			//
			#ifdef VERTEX_COLOR_SOURCE_LITERAL
				// The warm and cool colors are calculated from the literal vertex color.
				vsOut.WarmColor = lerp(
					lerp(lerp(warmMap[0], warmMap[4], gBaseColor.r), lerp(warmMap[1], warmMap[5], gBaseColor.r), gBaseColor.b),
					lerp(lerp(warmMap[2], warmMap[6], gBaseColor.r), lerp(warmMap[3], warmMap[7], gBaseColor.r), gBaseColor.b),
					gBaseColor.g);
					
				vsOut.CoolColor = lerp(
					lerp(lerp(coolMap[0], coolMap[4], gBaseColor.r), lerp(coolMap[1], coolMap[5], gBaseColor.r), gBaseColor.b),
					lerp(lerp(coolMap[2], coolMap[6], gBaseColor.r), lerp(coolMap[3], coolMap[7], gBaseColor.r), gBaseColor.b),
					gBaseColor.g);
			 #else
				// The warm and cool colors are calculated from the original vertex color.
				vsOut.WarmColor = lerp(
					lerp(lerp(warmMap[0], warmMap[4], Cs.r), lerp(warmMap[1], warmMap[5], OUT.Cs.r), Cs.b),
					lerp(lerp(warmMap[2], warmMap[6], Cs.r), lerp(warmMap[3], warmMap[7], OUT.Cs.r), Cs.b),
					Cs.g);
					
				vsOut.CoolColor = lerp(
					lerp(lerp(coolMap[0], coolMap[4], Cs.r), lerp(coolMap[1], coolMap[5], OUT.Cs.r), Cs.b),
					lerp(lerp(coolMap[2], coolMap[6], Cs.r), lerp(coolMap[3], coolMap[7], OUT.Cs.r), Cs.b),
					Cs.g);
			 #endif
		#endif        
	}
}

GLSLShader GoochPS
{
	void main()
	{
		#ifdef WARM_COOL_COLOR_SOURCE_LITERAL
			vec3 warmColor = gWarmColor;
			vec3 coolColor = gCoolColor;
		#else
			vec3 warmColor = psIn.WarmColor;
			vec3 coolColor = psIn.CoolColor;
		#endif
		
		#ifdef VERTEX_COLOR_SOURCE_LITERAL
			vec3 kwarm = min((warmColor + (gDiffuseWarm * gBaseColor.rgb)), 1.0);
			vec3 kcool = min((coolColor + (gDiffuseCool * gBaseColor.rgb)), 1.0);
		#else
			vec3 kwarm = min((warmColor + (gDiffuseWarm * psIn.Cs.rgb)), 1.0);
			vec3 kcool = min((coolColor + (gDiffuseCool * psIn.Cs.rgb)), 1.0);
		#endif        
			
		vec3 kfinal = lerp(kcool, kwarm, psIn.NdotL);

		vec3 nrefl  = normalize(psIn.ReflectVec);
		vec3 nview  = normalize(psIn.ViewVec);

		float spec    = max(-dot(nrefl, nview), 1.0E-7);
		vec3 spec2  = (gHighlightColor * pow(spec, gShininess));

		//If gBaseColor is set as the vertex color, we use the fourth channel as the opacity.
		//If not, we use the fourth channel of the vertex color as the opacity.
		#ifdef VERTEX_COLOR_SOURCE_LITERAL
			colorOut = vec4(min((kfinal + spec2), 1.0), gBaseColor.a);
		#else
			colorOut = vec4(min((kfinal + spec2), 1.0), psIn.Cs.a);
		#endif
	}
}

// The main technique.
technique Gooch
{
    pass P0
    {
        VertexShader (in VS_INPUT, out VS_TO_PS vsOut) = GoochVS;
        PixelShader (in VS_TO_PS psIn, out pixelOut) = GoochPS;
    }
}
