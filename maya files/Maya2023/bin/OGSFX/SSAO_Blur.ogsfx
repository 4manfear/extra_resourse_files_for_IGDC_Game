//**************************************************************************/
// Copyright (c) 2008 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
// DESCRIPTION: Screen space ambient occlusion - blur pass.
// AUTHOR: Mauricio Vives, converted to OGSFX by Eric Haines, July 2013
// CREATED: October 2008
//**************************************************************************/

// TODO: This define is necessary to make shader changes specific to the Cg (OpenGL) blur pass.
// DrawScreenQuad() will set the UV origin to the bottom left instead of the top right for *certain*
// OpenGL effects.  The test it uses is actually too specific: only if all input textures are
// targets! (which OpenGL samples from the bottom)  This leads to kludges like this one.  Instead,
// DrawScreenQuad() should consistently specify the UV coordinates of the screen quad, and the
// device-specific shader should handle any differences.
#define UV_ORIGIN_BOTTOM

#include "SSAO_Common.ogsfh"

// Specify a default blur amount (number of samples in each direction, or the "radius" of the box
// filter) if none is specified.  Use to determine the number of samples per pixel, including the
// center sample.
#ifndef BLUR_AMOUNT
#define BLUR_AMOUNT 3
#endif

// The direction of the blur, e.g. (0.0, 1.0) for vertical.
uniform vec2 gBlurDirection = { 1.0, 0.0 };

// The source buffer and sampler.
uniform texture2D gSourceTex ;
uniform sampler2D gSourceSamp = sampler_state
{
    Texture = <gSourceTex>;
};

// The depth buffer and sampler.
uniform texture2D gDepthTex ;
uniform sampler2D gDepthSamp = sampler_state
{
    Texture = <gDepthTex>;
};

// The scene buffer and sampler.
uniform texture2D gNormalTex ;
uniform sampler2D gNormalSamp = sampler_state
{
    Texture = <gNormalTex>;
};


// Pixel shader.
// (VS_TO_PS_ScreenQuad In, uniform sampler2D source, uniform vec2 direction) : COLOR0
GLSLShader PS_SSAO_Blur
{
    void main()
    {
        // Sample the depth at the current pixel, and skip any background pixels, indicated by a depth
        // of zero.
        float depth = texture2D(gDepthSamp, VSUV).x;
        if (depth < 1e-10)
        {
#if GL_ES
            gl_FragColor = texture2D(gSourceSamp, VSUVTile);
#else
            colorOut = texture2D(gSourceSamp, VSUVTile);
#endif
            return;
        }
		
		// Sample the normal.
        vec3 normal = texture2D(gNormalSamp, VSUV).xyz * 2.0f - vec3(1.0f, 1.0f, 1.0f);

        // Compute the sampling radius used at this depth in the SSAO pass.
        vec2 gViewScale = 1.0 / abs(vec2(gProjection[0][0], gProjection[1][1]));
        vec2 depthScale = (gPerspectiveFlag ? depth : 1.0) * gViewScale;
        float radius = gSampleRadius * (depthScale.x + depthScale.y); // * 0.5 * 2.0 = 1.0

        // Compute the texel offset for each sample, and the location of the starting sample.  Separate
        // texture coordinates and offsets are needed when tiling is used: the depth buffer is the full
        // image size (UV) and the SSAO source buffer is tile size (UVTile).
        vec2 gFullScreenSize = gScreenSize / gTileScale;
        vec2 gBlurRadius = BLUR_AMOUNT / gFullScreenSize;
        vec2 gBlurRadiusTile = BLUR_AMOUNT / gScreenSize;

        vec2 offset = (gBlurDirection * gBlurRadius) / BLUR_AMOUNT;
        vec2 UV = VSUV - gBlurDirection * gBlurRadius;
        vec2 offsetTile = (gBlurDirection * gBlurRadiusTile) / BLUR_AMOUNT;
        vec2 UVTile = VSUVTile - gBlurDirection * gBlurRadiusTile;

        // Perform a box blur that does not span large differences between depths and normals.
        // NOTE: This is a technically a non-separable filter, but it provides reasonable results.
        float sum = 0.0;
        float sumWeight = 0.0;
        int gNumSamples = BLUR_AMOUNT * 2 + 1;
        float gCenterTap = BLUR_AMOUNT;
        for (int i = 0; i < gNumSamples; i++)
        {
            // Sample the SSAO buffer and the depth buffer for the current sample.
            // NOTE: The SSAO buffer may only contain the content for a tile, so use the tile texture
            // coordinates.
            float value = texture2D(gSourceSamp, UVTile).x;
            float valueDepth = texture2D(gDepthSamp, UV).x;
            vec3 valueNormal = texture2D(gNormalSamp, UV).xyz * 2.0f - vec3(1.0f, 1.0f, 1.0f);

			// Compute the difference in depth and the dot product between the normals.
			float depthDiff = abs(valueDepth - depth);
			float normalDot = dot(valueNormal, normal);
		
		
		    // Add the sample to the sum if the depth difference is small or the dot product is near one.
			if (depthDiff < radius * 0.25f && ( /*normalDot < 1e-4f || */ normalDot > 0.9f))
			{
				// Apply a Bartlett triangular filter kernel from 0.2 at the outer samples to 1.0 in the
				// center.
				// NOTE: This differs from the original OGS version, which just performs a box blur.
				float wMin = 0.2;
				float w = (1.0f - wMin) * (1.0 - abs(1.0f - i / gCenterTap)) + wMin;
				sum += value * w;
				sumWeight += w;
			}
            
            // Increment the texture coordinates by the offset.
            UV += offset;
            UVTile += offsetTile;
        }

        // Take a weighted average of the values.
        sum /= sumWeight;

        // Return the weighted average as the grayscale color output of the shader.
#if GL_ES
        gl_FragColor = vec4(sum, sum, sum, 1.0);
#else
        colorOut = vec4(sum, sum, sum, 1.0);
#endif
    }
}

// Technique.
technique SSAO_Blur
{
    pass p0
    {
        VertexShader (in VS_INPUT_ScreenQuad, out VS_TO_PS_ScreenQuad) = VS_ScreenQuad;
        PixelShader (in VS_TO_PS_ScreenQuad, out pixelOut) = PS_SSAO_Blur;
    }
}

