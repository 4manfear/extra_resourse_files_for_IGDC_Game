//**************************************************************************/
// Copyright (c) 2008 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
// DESCRIPTION: Screen space ambient occlusion - composite pass.
// AUTHOR: Mauricio Vives, converted to OGSFX by Eric Haines, July 2013
// CREATED: October 2008
//**************************************************************************/

#include "SSAO_Common.ogsfh"

// Whether to composite with a scene buffer.  When this is not enabled, blending state should be
// enabled as desired to composite with an existing target, rather than using a previously
// rendered target (i.e. the scene buffer).
// #define USE_SCENE_BUFFER

// The SSAO composite factor.
uniform float gCompositeFactor = 1.0;

// The SSAO composite color (tint).
uniform vec3 gCompositeColor = {0.0, 0.0, 0.0};


// The source buffer and sampler.
uniform texture2D gSourceTex ;
uniform sampler2D gSourceSamp = sampler_state
{
    texture = <gSourceTex>;
};

#ifdef USE_SCENE_BUFFER
    // The scene buffer and sampler.
    uniform texture2D gSceneTex;
    uniform sampler2D gSceneSamp = sampler_state
    {
        texture = <gSceneTex>;
    };
#endif


// Pixel shader.
// NOTE: This expects screen quad vertex shader output.
// uniform vec4 PS_SSAO_Composite(VS_TO_PS_ScreenQuad In, uniform sampler2D source) : COLOR0
GLSLShader PS_SSAO_Composite
{
    void main()
    {
        // Compute the SSAO "intensity" as a linear interpolation between 1.0 (no SSAO) and the pixel
        // from the SSAO buffer, based on the composite factor.  The composite factor can exceed 1.0
        // to increase the SSAO effect.
        vec4 result;
        float intensity = saturate(lerp(1.0, texture2D(gSourceSamp, VSUVTile).r, 2.0f * gCompositeFactor));
        
        // Compute a tint color from the composite color and the intensity.
        vec3 tint = lerp(gCompositeColor, vec3(1.0,1.0,1.0), intensity);
    
        #ifdef USE_SCENE_BUFFER
            // Return the tint color multiplied by the scene buffer color, and the scene buffer alpha.
            vec4 scene = texture2D(gSceneSamp, VSUVTile);
            result = vec4(tint * scene.rgb, scene.a);
        #else
            // Return the tint color, to be used in a subsequent blend operation.
			result = vec4(gCompositeColor, intensity);
        #endif
#if GL_ES
        gl_FragColor = result;
#else
        colorOut = result;
#endif
    }
}

// Technique.
technique SSAO_Composite
{
    pass p0
    {
        VertexShader (in VS_INPUT_ScreenQuad, out VS_TO_PS_ScreenQuad) = VS_ScreenQuad;
        PixelShader (in VS_TO_PS_ScreenQuad, out pixelOut) = PS_SSAO_Composite;
    }
}
