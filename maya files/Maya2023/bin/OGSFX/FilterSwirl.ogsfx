//**************************************************************************/
// Copyright 2015 Autodesk, Inc.
// All rights reserved.
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
//**************************************************************************/

// World-view-projection transformation.
uniform mat4 gWVPXf : WorldViewProjection;

// Target size.
uniform vec2 gTargetSize : ViewportPixelSize;

// The single filter input, i.e. the image to be filtered.
uniform texture2D gInputTex : InputTexture;

// Filter input sampler.
uniform sampler2D gInputSamp = sampler_state
{
    Texture = <gInputTex>;
};

// Swirl parameters
uniform float radius = 300.0;
uniform float angle = 0.8;
uniform vec2 centerPercent = { 0.5, 0.5 };

// Vertex shader input structure.
attribute VS_INPUT
{
    vec4 Pos : POSITION;
    vec2 UV : TEXCOORD0;
};

// Vertex shader output structure.
attribute VS_TO_PS
{
    vec2 VSUV : TEXCOORD0;
};

// Vertex shader.
GLSLShader VS_FilterSwirl
{
	void main()
	{
        gl_Position = gWVPXf*Pos;
		
		// Pass the texture coordinates unchanged.
		VSUV = UV;
	}
}

// Pixel shader output structure.
attribute pixelOut
{
    vec4 colorOut: COLOR0;
}

GLSLShader PS_FilterSwirl
{
	void main() 
	{ 
	  vec2 uv = VSUV;
  
	  vec2 center = gTargetSize * centerPercent;
	  vec2 tc = uv * gTargetSize;
	  tc -= center;
	  float dist = length(tc);
	  if (dist < radius) 
	  {
		float percent = (radius - dist) / radius;
		float theta = percent * percent * angle * 8.0;
		float s = sin(theta);
		float c = cos(theta);
		tc = vec2(dot(tc, vec2(c, -s)), dot(tc, vec2(s, c)));
	  }
	  tc += center;
	  vec3 color = texture2D(gInputSamp, tc / gTargetSize).rgb;
	  colorOut = vec4(color, 1.0);  	 
	}
}

// The main technique.
technique Main
{
    pass p0
    {
        VertexShader (in VS_INPUT, out VS_TO_PS) = VS_FilterSwirl;
        PixelShader (in VS_TO_PS, out pixelOut) = PS_FilterSwirl;
    }
}

