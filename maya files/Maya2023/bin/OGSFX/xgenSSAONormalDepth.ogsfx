//**************************************************************************/
// Copyright (c) 2014 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
// DESCRIPTION: Screen space ambient occlusion - normal-depth buffer pass.
// AUTHOR: Mauricio Vives converted by Firas Hawi (July 2014)
// CREATED: October 2008
//**************************************************************************/

#include "SSAO_Common.ogsfh"
#ifdef CLIPPING
#include "ClippingGL.ogsfh"
#endif
// Whether the projection matrix flips Z: -1.0 if so, otherwise 1.0.
uniform float gProjZSense : ProjectionZSense ;

// Vertex shader input structure.
attribute VS_INPUT_NormalDepth
{
    vec3 Pos : POSITION;
    float width : TEXCOORD0; 
    vec3 curveVec : TEXCOORD1; 
    float offsetFlag : TEXCOORD2; 
}

// Vertex shader output structure.
attribute VS_TO_PS_NormalDepth
{
    vec4 NormalDepth : TEXCOORD0;

#ifdef CLIPPING
    // World position, for CLIPPING
    // World position
    vec4 oHPw       : TEXCOORD6;
#endif
}

//  Globals 
uniform mat4 World : world; 
uniform vec3 cameraDirection : viewdirection; 
uniform vec3 cameraPosition : worldcameraposition; 
uniform bool camIsOrtho : isorthographic; 


//Vertex shader
GLSLShader VS_NormalDepth
{
vec3 xgenVSWidthVec(vec3 Pm, float width, vec3 curveVec, mat4 world, vec3 viewDirection, vec3 worldCameraPosition, bool camIsOrtho)
{
    vec3 viewVec = viewDirection;
    if (!camIsOrtho) {
    vec3 pw = (world * vec4(Pm, 1.0f)).xyz;
        viewVec = pw - worldCameraPosition;
    }

    return normalize(cross(viewVec, curveVec)) * width;
}

vec3 xgenVSOffset(vec3 Pm, float offsetFlag, vec3 widthVecFinal)
{
    return Pm + offsetFlag * (widthVecFinal);
}

vec3 xgenVSNw(vec3 widthVecFinal, vec3 curveVec)
{
    return normalize(cross(widthVecFinal, curveVec));
}

// Vertex shader.
//VS_TO_PS_NormalDepth VS_NormalDepth(VS_INPUT_NormalDepth In)
void main()
{
    vec3 widthVecFinal = xgenVSWidthVec( Pos, width, curveVec, World, cameraDirection, cameraPosition, camIsOrtho ); 
    vec4 pm4 = vec4(xgenVSOffset( Pos, offsetFlag, widthVecFinal ), 1.0f); 
    vec3 nw3 = xgenVSNw(widthVecFinal, curveVec);
    vec3 nn = nw3;
    
    // Transform the vertex from object space to clip space.
    gl_Position = gWVPXf * pm4; 
    
    // Record the normal and depth components for the pixel shader.
    // NOTE: This depends on whether the view direction is along +Z or -Z.  The projection matrix
    // "Z sense" determines this.
    NormalDepth.xyz = (mat3(gWVITXf[0].xyz,
								gWVITXf[1].xyz,
								gWVITXf[2].xyz) *  nn);


    NormalDepth.z = gProjZSense * NormalDepth.z;
    NormalDepth.w = gProjZSense * (gWVXf * pm4).z;

    #ifdef CLIPPING
        // Compute the six clip distances.
        oHPw = gWXf*vec4(Pos, 1.0);
    #endif
}
}


// Pixel shader output structure.
attribute PS_OUT
{
    //vec4 Normal : COLOR0;
    //vec4 Depth : COLOR1;
    vec4 oMRT[2] : COLOR0;	
}

// Pixel shader.
//PS_OUT PS_NormalDepth(VS_TO_PS_NormalDepth In)
GLSLShader PS_NormalDepth
{
void main()
{
    #ifdef CLIPPING
    
        // Compute whether the pixel need to be discard by the clipping planes.
        // This is slow, for NV4x(GeForce 6xxx) or higher card, we can use the semantic CLP(n) 
        // in vertex shader to make it faster.
        int i;
        for ( i = 0; i < gNumClipPlanes; i++ ) {
            if (dot(oHPw, gClipPlanes[i]) < 0.0) discard;
        }
    
    #endif
    
        // Set the normal for an unsigned normalized integer target, and depth for a floating-point
        // target.
        oMRT[0] = vec4((normalize(NormalDepth.xyz) + vec3(1.0,1.0,1.0)) * 0.5, 0.0);
        oMRT[1]  = vec4(NormalDepth.w,NormalDepth.w,NormalDepth.w,NormalDepth.w);
}
}


// Technique.
technique NormalDepth
{
    pass p0
    {
        VertexShader (in VS_INPUT_NormalDepth, out VS_TO_PS_NormalDepth) = VS_NormalDepth;
        PixelShader (in VS_TO_PS_NormalDepth, out PS_OUT) = PS_NormalDepth;
    }
}
