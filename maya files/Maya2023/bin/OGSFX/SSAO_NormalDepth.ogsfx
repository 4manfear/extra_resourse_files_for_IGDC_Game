//**************************************************************************/
// Copyright (c) 2008 Autodesk, Inc.
// All rights reserved.
// 
// These coded instructions, statements, and computer programs contain
// unpublished proprietary information written by Autodesk, Inc., and are
// protected by Federal copyright law. They may not be disclosed to third
// parties or copied or duplicated in any form, in whole or in part, without
// the prior written consent of Autodesk, Inc.
//**************************************************************************/
// DESCRIPTION: Screen space ambient occlusion - normal-depth buffer pass.
// AUTHOR: Mauricio Vives, converted to OGSFX by Eric Haines, July 2013
// CREATED: October 2008
//**************************************************************************/

#include "SSAO_Common.ogsfh"

#ifdef CLIPPING
#include "Clipping.ogsfh"
#endif

// Check if the back-facing normal need to be flipped.
uniform bool isSingleSided = false;
uniform float mayaNormalMultiplier = 1.0f;

// Whether the projection matrix flips Z: -1.0 if so, otherwise 1.0.
uniform float gProjZSense : ProjectionZSense ;

// Depth priority, which shifts the model a bit forward in the z-buffer
uniform float gDepthPriority : DepthPriority = 0.0;

// Vertex shader input structure.
attribute VS_INPUT_NormalDepth
{
    vec3 Pos : POSITION;
    vec3 Normal: NORMAL;
}

// Vertex shader output structure.
attribute VS_TO_PS_NormalDepth
{
    vec4 NormalDepth : TEXCOORD0;

#ifdef CLIPPING
    // World position, for CLIPPING
    // World position
    vec4 oHPw       : TEXCOORD6;
#endif
}

// Vertex shader.
// VS_TO_PS_NormalDepth VS_NormalDepth(VS_INPUT_NormalDepth In)
GLSLShader VS_NormalDepth
{
    void main()
    {
    #ifdef CLIPPING
        // Compute the six clip distances.
        oHPw = gWXf*vec4(Pos, 1.0);
    #endif
        
        // Transform the vertex from object space to clip space.
        gl_Position = gWVPXf*vec4(Pos, 1.0);
        
        // modify the gl_Position a bit by biasing the Z a bit forward, based on depth priority
        gl_Position.z -= gl_Position.w*2.0*gDepthPriority;
        
        // Record the normal and depth components for the pixel shader.
        // NOTE: This depends on whether the view direction is along +Z or -Z.  The projection matrix
        // "Z sense" determines this.
        NormalDepth.xyz = mat3(gWVITXf[0].xyz,
        gWVITXf[1].xyz,
        gWVITXf[2].xyz)*Normal;
        NormalDepth.z = gProjZSense * NormalDepth.z;
        NormalDepth.w = gProjZSense * (gWVXf*vec4(Pos, 1.0)).z;
    }
}

// Pixel shader output structure.
attribute PS_OUT
{
    // vec4 Normal : COLOR0;
    // vec4 Depth : COLOR1;
    vec4 oMRT[2] : COLOR0;
}

// Pixel shader.
// PS_OUT PS_NormalDepth(VS_TO_PS_NormalDepth In)
GLSLShader PS_NormalDepth
{
    void main()
    {
    
    #ifdef CLIPPING
    
        // Compute whether the pixel need to be discard by the clipping planes.
        // This is slow, for NV4x(GeForce 6xxx) or higher card, we can use the semantic CLP(n) 
        // in vertex shader to make it faster.
        int i;
        for ( i = 0; i < gNumClipPlanes; i++ ) {
            if (dot(oHPw, gClipPlanes[i]) < 0.0) discard;
        }
    
    #endif
		
		vec3 normal = normalize(NormalDepth.xyz);
	
		if ( !isSingleSided ) 
		{
			float normalMul = gl_FrontFacing ? mayaNormalMultiplier : -mayaNormalMultiplier;
			normal *= normalMul;
		}

        // Set the normal for an unsigned normalized integer target, and depth for a floating-point
        // target.
        oMRT[0] = vec4( (normal+1.0) * 0.5, 0.0);
        oMRT[1]  = NormalDepth.wwww;
    }
}

// Technique.
technique NormalDepth
{
    pass p0
    {
        VertexShader (in VS_INPUT_NormalDepth, out VS_TO_PS_NormalDepth) = VS_NormalDepth;
        PixelShader (in VS_TO_PS_NormalDepth, out PS_OUT) = PS_NormalDepth;
    }
}

