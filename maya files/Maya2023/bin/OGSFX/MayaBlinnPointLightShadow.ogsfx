//**************************************************************************/
// Copyright 2016 Autodesk, Inc.
// All rights reserved.
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
//**************************************************************************/
//
// Maya Blinn (ogsfx)
//

// Vertex input structure
attribute APP_DATA 
{ 
    vec3 Pm : POSITION; 
    vec3 Nm : NORMAL; 
}; 

// Vertex output structure
attribute VS_TO_PS 
{ 
    vec3 Nw : TEXCOORD0; 
    vec3 Pw : TEXCOORD1; 
    vec3 Vw : TEXCOORD2; 
}; 

// Vertex shader output structure.
attribute pixelOut 
{
    vec4 colorOut: COLOR0;
}

//  Globals 
uniform mat4 WorldIT : worldinversetranspose; 
uniform mat4 World : world; 
uniform vec3 cameraPosition : worldcameraposition; 
uniform float DepthPriority : depthpriority; 
uniform mat4 WorldViewProj : worldviewprojection; 

uniform float mayaNormalMultiplier = 1.000000; 
uniform float mayaPointLight_lightOn = 1.000000; 
uniform float mayaPointLight_intensity = 1.000000; 
uniform vec3 mayaPointLight_color = { 1.000000, 1.000000, 1.000000 }; 
uniform float mayaPointLight_emitsDiffuse = 1.000000; 
uniform float mayaPointLight_emitsSpecular = 1.000000;
// Light position semantic:lightposition0, lightposition1, ...,  lightposition15
//  
uniform vec3 mayaPointLight_position : lightposition0;  
uniform textureCube mayaShadowPointLight_shadowMap; 
uniform samplerCube mayaShadowPointLight_shadowSamp =  sampler_state
{ 
    Texture = <mayaShadowPointLight_shadowMap>; 
}; 
uniform float mayaShadowPointLight_shadowBias = 0.02200;
uniform float mayaShadowPointLight_filterRadius = 1.000000; 
uniform int mayaShadowPointLight_shadowMapSize = 512; 
uniform vec3 mayaShadowPointLight_shadowColor = { 0.000000, 0.000000, 0.000000 }; 
uniform bool mayaShadowPointLight_mayaGlobalShadowOn = 0; 
uniform bool mayaShadowPointLight_mayaShadowOn = 0; 
uniform vec2 mayaShadowPointLight_depthRange = { 0.000000, 0.000000 }; 

uniform float blinn1eccentricity = 0.300000; 
uniform float blinn1specularRollOff = 0.700000; 
uniform float blinn1translucence = 0.000000; 
uniform float blinn1translucenceDepth = 0.500000; 
uniform float blinn1translucenceFocus = 0.500000; 
uniform vec3 blinn1color = { 0.200000, 0.600000, 1.000000 }; 
uniform vec3 blinn1transparency = { 0.000000, 0.000000, 0.000000 }; 
uniform vec3 blinn1ambientColor = { 0.000000, 0.000000, 0.000000 }; 
uniform vec3 blinn1incandescence = { 0.000000, 0.000000, 0.000000 }; 
uniform float blinn1diffuse = 0.800000; 
uniform vec3 blinn1specularColor = { 1.000000, 1.000000, 1.000000 }; 
uniform float blinn1reflectivity = 0.500000; 
uniform vec3 blinn1reflectedColor = { 0.000000, 0.000000, 0.000000 }; 
uniform float blinn1glowIntensity = 0.000000; 
uniform bool blinn1hideSource = 0; 
uniform float blinn1matteOpacity = 1.000000; 
uniform int blinn1matteOpacityMode = 2; 
uniform float blinn1outAlphaPassThrough = 1.000000; 

uniform vec3 ambientShader_ambientIllum = { 0.000000, 0.000000, 0.000000 }; 
uniform float specularRollOff = 0.700000; 

uniform float extraOpacity = 1.000000; 


// Vertex Shader 
GLSLShader MainVertexShader
{
	//  Vertex shader fragments 
	//
	vec3 iNw( vec3 nm, mat4 worldITC )
	{ 
		 return mul( worldITC, vec4(nm,0) ).xyz; 
	} 

	vec3 iPw( vec3 pm, mat4 world ) 
	{ 
		return mul( world, vec4(pm, 1.0f) ).xyz; 
	} 

	vec3 iVw( vec3 Pm, vec3 Ew, mat4 world  )
	{ 
		vec4 Pw = mul( world, vec4(Pm,1) ); 
		return Ew - Pw.xyz; 
	} 

	vec4 iPcPriority( vec3 pm, float depthPriority, mat4 worldViewProjectionC )
	{ 
		vec4 P = mul( worldViewProjectionC, vec4(pm,1) ); 
		P.z -= P.w * 2.0f * depthPriority; 
		return P; 
	} 

	void main()
	{ 
		Nw = iNw( Nm, WorldIT ); 
		Pw = iPw( Pm, World ); 
		Vw = iVw( Pm, cameraPosition, World ); 
		gl_Position = iPcPriority ( Pm, DepthPriority, WorldViewProj ); 
	} 
}

// Pixel Shader
GLSLShader MainPixelShader
{
	//  Declarations 
	struct irradiance { 
		vec3 diffuseI; 
		vec3 specularI; 
		vec3 Ld; 
		vec3 Ls; 
	}; 

	struct mayaSurfaceShaderOutput {
		vec3 outColor;
		vec3 outTransparency;
		vec3 outGlowColor;
		vec3 outMatteOpacity;
		float outAlphaPassThrough;
	};

	//  Pixel Shader Fragments 
	vec3 iNw( vec3 iNw )
	{ 
		return normalize( iNw ); 
	} 

	float FacingFactor( float facing )
	{ 
		return facing; 
	} 


	vec3 mayaNormalFlip(vec3 Nw, bool backFacing, float normalMultiplier) 
	{ 
		return normalMultiplier * (backFacing ? -Nw : Nw); 
	} 


	vec3 mayaNwPassThrough(vec3 Nw) 
	{ 
		return Nw; 
	} 


	irradiance mayaPointLight( float lightOn, float intensity, vec3 color, float emitDiff, float emitSpec, 
							   vec3 lightPosition, vec3 Pw)
	{ 
		const float epsilon = 0.00001f; 
		vec3 L = lightPosition - Pw; 
		float d = length( L ) + epsilon; 
		float atten = 1.0f / pow( d + 1.0f, 0.0 + epsilon); 
		vec3 c = lightOn * atten * intensity * color; 
		irradiance irrad; 
		irrad.diffuseI =  emitDiff * c; 
		irrad.specularI = emitSpec * c; 
		irrad.Ld = irrad.Ls = L / d; 
		return irrad; 
	} 

	
	
	vec3 iPw( vec3 ipw )
	{ 
		return ipw; 
	} 


	irradiance mayaShadowPointLight(	irradiance irradIn,					
								 vec3 lightPosition,				
								 vec3 Pw,							
								 samplerCube samp,					
								 float bias,
								 vec2 range,						
								 float filterRadius,
								 vec3 shadowColor,
								 bool globalShadowOn,
								 bool shadowOn)					
	{		
		if ( !( globalShadowOn && shadowOn ) ) return irradIn;
		
		const vec3 avgXYZ = vec3(0.3333,0.3334,0.3333); // dot with this for average 
		float lightGain = 0.0f;										
		vec3 lookup = Pw - lightPosition;							
		float Distance = length(lookup);																				
		float depthRange = range.y-range.x;	
		vec3 normalizeLookup = normalize(lookup);
																								
		float SampledDistance = (textureCube(samp, normalizeLookup ).r)*depthRange + range.x;				
		if (Distance > depthRange) {
            lightGain = 1.0f;
		} else {
			if (Distance <= SampledDistance + bias*Distance)																
				lightGain = 1.0;																				
			else																								
				lightGain = 0.0;
		}											

		float dIntens = saturate(dot(irradIn.diffuseI, avgXYZ)); 
		irradIn.diffuseI = lerp( dIntens * shadowColor, irradIn.diffuseI, lightGain ); 
		irradIn.specularI = irradIn.specularI * lightGain; 

		return irradIn; 													
	}	
		

	vec3 iVw( vec3 iVw )
	{ 
		return normalize( iVw ); 
	} 

	vec3 mayaHVector(vec3 L, vec3 V) 
	{ 
		return normalize(L + V); 
	} 

	vec4 mayaShaderGeom(vec3 N, vec3 L, vec3 V, vec3 H) 
	{ 
		float NL = saturate(dot(N, L)); 
		float NV = saturate(dot(N, V)); 
		float NH = saturate(dot(N, H)); 
		float VH = saturate(dot(V, H)); 
		return vec4(NL, NV, NH, VH); 
	} 


	vec3 mayaLambertDiffuse(vec4 NL_NV_NH_VH, vec3 diffuseI) 
	{ 
		return NL_NV_NH_VH.x * diffuseI; 
	} 

	vec3 mayaBlinnSpecular(
		vec3 specularI, 
		vec4 NL_NV_NH_VH, 
		float ecc, 
		float rolloff) 
	{ 
		float ecc2 = ecc * ecc - 1.0f; 
		float NH = NL_NV_NH_VH.z; 
		float d = (ecc2 + 1.0f) / (1.0f + ecc2 * NH * NH); 
		d *= d; 
		float NL = NL_NV_NH_VH.x; 
		float NV = NL_NV_NH_VH.y; 
		float VH = NL_NV_NH_VH.w; 
		NH *= 2.0f; 
		float g = 1.0f; 
		if (NV < NL) 
			g = (NV * NH < VH) ? NH / VH : 1.0f / NV; 
		else 
			g = (NL * NH < VH) ? (NL * NH) / (VH * NV) : 1.0f / NV; 
		float k = 1.0f - VH; 
		k = k * k * k; 
		float f = k + (1.0f - k) * rolloff; 
		return specularI * saturate(d * g * f); 
	} 

	float mayaTranslucence(
		vec4 NL_NV_NH_VH, 
		float translucence, 
		float depth, 
		float focus) 
	{ 
		float TRANSL_FADE = 0.15f; 
		float TRANSL_ANGLE_FAC = -11.5f; 
		float bright = 0.0f; 
		float cosMinAngle = TRANSL_ANGLE_FAC * depth; 

		if (translucence != 0.0f && NL_NV_NH_VH.x > cosMinAngle) {  
			if (focus == 0.0f) { 
				bright = translucence; 
			} else { 
				float VL = saturate(NL_NV_NH_VH.w * NL_NV_NH_VH.w);  
				bright =  translucence * pow(VL,  focus /(1.00001f - focus));  
			} 
			float fade = saturate(TRANSL_FADE - cosMinAngle); 
			if (NL_NV_NH_VH.x < (fade + cosMinAngle)) { 
				bright *= (NL_NV_NH_VH.x - cosMinAngle) / fade; 
			} 
		}  
		return bright;  
	} 


	vec3 ambientShader( vec3 color )
	{ 
		return color; 
	} 


	float mayaBlinnReflectionRolloff(
		vec4 NL_NV_NH_VH, 
		float reflectance, 
		float rolloff) 
	{ 
		float nv3 = 1.0f - NL_NV_NH_VH.y; 
		nv3 = nv3 * nv3 * nv3; 
		float r = saturate(reflectance); 
		r *= nv3 + (1.0f - nv3) * rolloff; 
		return r; 
	} 

	mayaSurfaceShaderOutput mayaADSRCombiner(
		vec3 diffuseIrradIn, 
		vec3 specularIrradIn, 
		float translucenceIn, 
		vec3 color, 
		vec3 transparency, 
		vec3 ambientColor, 
		vec3 ambientIn, 
		vec3 incandescence, 
		float diffuse, 
		vec3 specularColor, 
		float reflectivity, 
		vec3 reflectedColor, 
		float glowIntensity, 
		bool hideSource, 
		float matteOpacity, 
		int matteOpacityMode, 
		float outAlphaPassThrough) 
	{ 
		mayaSurfaceShaderOutput result; 
		result.outColor = (ambientColor+ambientIn) * color; 
		result.outColor += (diffuse + translucenceIn) * diffuseIrradIn * color; 
		result.outColor *= saturate(1.0f - transparency); 
		result.outColor += specularIrradIn * specularColor; 
		result.outColor += incandescence; 
		result.outColor += reflectivity * reflectedColor; 
		result.outTransparency = transparency; 
		result.outGlowColor = glowIntensity * result.outColor; 

		if (hideSource) { 
			result.outColor = vec3(0.0f, 0.0f, 0.0f); 
			result.outTransparency = vec3(1.0f, 1.0f, 1.0f); 
		} 

		if (matteOpacityMode == 0) { 
			result.outMatteOpacity = vec3(-1.0e+06f, -1.0e+06f, -1.0e+06f); 
		} else if (matteOpacityMode == 1) { 
			result.outMatteOpacity = vec3(matteOpacity, matteOpacity, matteOpacity); 
		} else { 
			result.outMatteOpacity = (1.0f - result.outTransparency) * matteOpacity; 
		} 
		result.outAlphaPassThrough = outAlphaPassThrough; 
		return result; 
	} 

	vec4 mayaSurfaceToFloat4(
		mayaSurfaceShaderOutput surface, 
		float extraOpacity) 
	{ 
		vec3 intenseVec = vec3(0.3333, 0.3333, 0.3333); 
		vec3 opacity = saturate(1.0f - surface.outTransparency); 
		float cutoutA = surface.outAlphaPassThrough * extraOpacity; 
		return vec4(cutoutA*surface.outColor, cutoutA*dot(opacity, intenseVec)); 
	} 

    void main()
	{ 
		mayaSurfaceShaderOutput PixelOutput; 

		vec3 v_Nw = iNw( Nw ); 
		bool v_mayaIsBackFacing = ! gl_FrontFacing; 
		vec3 v_mayaNormalFlip = mayaNormalFlip( v_Nw, v_mayaIsBackFacing, mayaNormalMultiplier ); 
		vec3 v_mayaNwPassThrough = mayaNwPassThrough( v_mayaNormalFlip ); 

		irradiance s_mayaIrradiance; 
		irradiance v_mayaPointLight = mayaPointLight( mayaPointLight_lightOn, mayaPointLight_intensity, mayaPointLight_color, mayaPointLight_emitsDiffuse, mayaPointLight_emitsSpecular, mayaPointLight_position, Pw );

		vec3 v_Pw = iPw( Pw ); 

		s_mayaIrradiance = mayaShadowPointLight( v_mayaPointLight, mayaPointLight_position, v_Pw, mayaShadowPointLight_shadowSamp, mayaShadowPointLight_shadowBias, mayaShadowPointLight_depthRange, mayaShadowPointLight_filterRadius, mayaShadowPointLight_shadowColor, mayaShadowPointLight_mayaGlobalShadowOn, mayaShadowPointLight_mayaShadowOn ); 

		vec3 v_Vw = iVw( Vw ); 

		vec3 v_mayaHVector = mayaHVector( s_mayaIrradiance.Ls, v_Vw ); 

		vec4 v_mayaShaderGeom = mayaShaderGeom( v_mayaNwPassThrough, s_mayaIrradiance.Ld, v_Vw, v_mayaHVector ); 

		vec3 v_mayaLambertDiffuse = mayaLambertDiffuse( v_mayaShaderGeom, s_mayaIrradiance.diffuseI ); 
		vec3 v_mayaBlinnSpecular = mayaBlinnSpecular( s_mayaIrradiance.specularI, v_mayaShaderGeom, blinn1eccentricity, blinn1specularRollOff ); 
		float v_mayaTranslucence = mayaTranslucence( v_mayaShaderGeom, blinn1translucence, blinn1translucenceDepth, blinn1translucenceFocus ); 

		vec3 v_ambientShader = ambientShader( ambientShader_ambientIllum ); 

		float v_mayaBlinnReflectionRolloff = mayaBlinnReflectionRolloff( v_mayaShaderGeom, blinn1reflectivity, specularRollOff ); 

		PixelOutput = mayaADSRCombiner( v_mayaLambertDiffuse, v_mayaBlinnSpecular, v_mayaTranslucence, blinn1color, blinn1transparency, blinn1ambientColor, v_ambientShader, blinn1incandescence, blinn1diffuse, blinn1specularColor, v_mayaBlinnReflectionRolloff, blinn1reflectedColor, blinn1glowIntensity, blinn1hideSource, blinn1matteOpacity, blinn1matteOpacityMode, blinn1outAlphaPassThrough ); 
		vec4 v_mayaSurfaceToFloat = mayaSurfaceToFloat4( PixelOutput, extraOpacity ); 

		colorOut = v_mayaSurfaceToFloat; 
	} 
}


technique main
{ 
    pass P0 
    { 
        VertexShader (in APP_DATA, out VS_TO_PS) = MainVertexShader;
        PixelShader (in VS_TO_PS, out pixelOut) = MainPixelShader;
    } 
 } 
