// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//  MASHmapHelperButton
//
//  Description;
//  This creates the single connection drag and drop layout and widget for the Strength Map attributes.
//  @param: The node name.
//

global proc MASHmapHelperButton ( string $attr )
{
    string $nodeName[];
    tokenize($attr, ".", $nodeName);

    MASHmapHelperSingleInputBuildQt($attr);
 }

 global proc MASHmapHelperButtonEdit ( string $attr )
 {
    string $nodeName[];
    tokenize($attr, ".", $nodeName);

    MASHmapHelperSingleInputUpdateQt($attr);
}

global proc MASHmapHelperSingleInputBuildQt(string $nodeName)
{
    string $buffer[];
    tokenize($nodeName, ".", $buffer);
    $nodeName = $buffer[0];
    string $nodeType = `nodeType($nodeName)`;
    string $layout = ($nodeType+"FalloffObjectLayout");

    python("import MASHsingleInputQtWidget");
    rowLayout -numberOfColumns 2 -columnWidth2 139 250 $layout;
    text -w 105 -h 20 -vis 1
    -label (getPluginResource("MASH", "kMapHelper"))
    -align "right" -font "plainLabelFont" ;
    //get python to create the widget, include the desired nodeType as an arguement
    python("MASHsingleInputQtWidget.build_qt_widget('" + $layout + "', '" + $nodeName + "', 'transform', 'inMapMatrix', 'worldMatrix[0]', 'MapSwitchToUVMode')");
    setParent..;

}

global proc MASHmapHelperSingleInputUpdateQt(string $nodeName )
{
    string $buffer[];
    tokenize($nodeName, ".", $buffer);
    $nodeName = $buffer[0];
    string $nodeType = `nodeType($nodeName)`;
    string $layout = ($nodeType+"FalloffObjectLayout");

    python("import MASHsingleInputQtWidget");
    python("MASHsingleInputQtWidget.update_qt_widget('" + $layout + "', '" + $nodeName + "', 'transform', 'inMapMatrix', 'worldMatrix[0]', 'MapSwitchToUVMode')");
}


global proc string getSurfaceShader (string $objName) {

    string $myShapeNode[] = `listRelatives -children -shapes $objName`;
    string $mySGs[] = `listConnections -type shadingEngine $myShapeNode[0]`;
    string $surfaceShader[] = `listConnections ($mySGs[0] + ".surfaceShader")`;
    return $surfaceShader[0];

}

//
//  Procedure Name:
//  mapHelperButtonCMDS
//
//  Description;
//  Called from Python, this proc creates the Map Helper plane.
//

global proc mapHelperButtonCMDS (string $nodeName, int $whichCMD) {
    string $name[];
    tokenize($nodeName, ".", $name);

    string $matrixAttribute = ".inMapMatrix";

    if ($whichCMD == 10) {
        $whichCMD = 1;
        $matrixAttribute = ".positionMapMatrix";
    }

    if ($whichCMD == 20) {
        $whichCMD = 1;
        $matrixAttribute = ".rotationMapMatrix";
    }

    if ($whichCMD == 30) {
        $whichCMD = 1;
        $matrixAttribute = ".scaleMapMatrix";
    }

    if ($whichCMD == 1)
    {

        string $texture[] = `listConnections -d off -s on ($nodeName + ".mColour")`;

        float $x, $y, $z;
        float $centreX, $centreY, $centreZ;
        int $helperSizeFound = 0;

        if (`objExists ($nodeName+".positionOutPP")` || `objExists ($nodeName+".fallPosArray")`){
            vector $positions[];
            if (`objExists ($nodeName+".positionOutPP")`) {
                $positions = `getAttr ($nodeName+".positionOutPP")`;
            } else if (`objExists ($nodeName+".fallPosArray")`) {
                string $list[] = `listConnections ($nodeName+".fallPosArray")`;
                if (size($list) > 0) {
                    $positions = `getAttr ($nodeName+".fallPosArray")`;
                } else if (`objExists ($nodeName+".inputArray")`) {
                    $positions = `getAttr ($nodeName+".inputArray")`;
                    print (size($positions)+"\n");
                }
            }

            $helperSizeFound = 1;

            float $minX, $maxX;
            float $minY, $maxY;
            float $minZ, $maxZ;
            float $totalX, $totalY, $totalZ;

            int $idx = 0;
            for ($pos in $positions) {
                if ($idx==0) {
                    $minX = ($pos.x);
                    $minY = ($pos.y);
                    $minZ = ($pos.z);

                    $maxX = ($pos.x);
                    $maxY = ($pos.y);
                    $maxZ = ($pos.z);
                }

                if (($pos.x) < $minX) $minX = ($pos.x);
                if (($pos.y) < $minY) $minY = ($pos.y);
                if (($pos.z) < $minZ) $minZ = ($pos.z);

                if (($pos.x) > $maxX) $maxX = ($pos.x);
                if (($pos.y) > $maxY) $maxY = ($pos.y);
                if (($pos.z) > $maxZ) $maxZ = ($pos.z);

                $totalX += $pos.x;
                $totalY += $pos.y;
                $totalZ += $pos.z;

                $idx++;
            }

            if (size($positions) > 0) { //if the node isn't connected this will avoid a/zero.
                $centreX = $totalX/size($positions);
                $centreY = $totalY/size($positions);
                $centreZ = $totalZ/size($positions);
            }

            $x = $maxX - $minX;
            $y = $maxY - $minY;
            $z = $maxZ - $minZ;

            //in case the network is 2d (like linear distribution)
            if ($x < 1.0) $x = 1.0;
            if ($y < 1.0) $y = 1.0;
            if ($z < 1.0) $z = 1.0;
        }

        if (size($texture) > 0) {

            float $sizeX = 1.0;
            float $sizeY = 1.0;

            string $plane[];

            $plane = `polyPlane -ch on -o on -ax 0 1 0 -w $sizeX -h $sizeY -sw 10 -sh 10 -cuv 2 -name ($name[0]+" Map Helper#")` ;

            setAttr ($plane[1]+".createUVs") 1;

            select $plane[0];
            createAndAssignShader lambert "";

            string $shader = `getSurfaceShader($plane[0])`;
            //texture to shader
            connectAttr -force ($texture[0]+".outColor") ($shader + ".color");

            setKeyframe -attribute "frameOffset" -t 0sec $texture[0];
            setKeyframe -attribute "frameOffset" -v 0.4 -t 50sec $texture[0];

            //shader to MASH
            catchQuiet(`setAttr ($texture[0]+".defaultColor") -type double3 0 0 0 `);

            string $parents[] = `listRelatives -allParents $plane[0]`;

            connectAttr -f ($parents[0]+".worldMatrix[0]") ($nodeName+$matrixAttribute);

            if ($helperSizeFound){
                setAttr ($plane[0]+".scaleX") ($x*1.02);
                setAttr ($plane[0]+".scaleY") ($y*1.02);
                setAttr ($plane[0]+".scaleZ") ($z*1.02);

                setAttr ($plane[0]+".translateX") ($centreX);
                setAttr ($plane[0]+".translateY") ($centreY);
                setAttr ($plane[0]+".translateZ") ($centreZ);
            }

            select $nodeName;

            $shape = `listRelatives -shapes $plane[0]`;
            setAttr ($shape[0]+".primaryVisibility") 0;
            setAttr ($shape[0]+".visibleInReflections") 0;
            setAttr ($shape[0]+".visibleInRefractions") 0;
            setAttr ($shape[0]+".castsShadows") 0;

        }else{ //NO MAP

            float $sizeX = 1.0;
            float $sizeY = 1.0;

            string $plane[];

            //rudimentry automatic orientation
            $plane = `polyPlane -ch on -o on -ax 0 1 0 -w $sizeX -h $sizeY -sw 10 -sh 10 -cuv 2 -name ($name[0]+" Map Helper#")` ;

            setAttr ($plane[1]+".createUVs") 1;

            select $plane[0];
            createAndAssignShader lambert "";

            string $shader = `getSurfaceShader($plane[0])`;
            //texture to shader
            string $file = `createRenderNodeCB -as2DTexture "" "file" ""`;
            connectAttr -force ($file+".outColor") ($shader + ".color");

            connectAttr -force ($file+".outColor") ($nodeName + ".mColour");

            setKeyframe -attribute "frameOffset" -t 0sec $file;
            setKeyframe -attribute "frameOffset" -v 0.4 -t 50sec $file;

            //shader to MASH
            setAttr ($texture[0]+".defaultColor") -type double3 0 0 0 ;

            connectAttr -f ($plane[0]+".worldMatrix[0]") ($nodeName+$matrixAttribute);

            if ($helperSizeFound){
                setAttr ($plane[0]+".scaleX") ($x*1.02);
                setAttr ($plane[0]+".scaleY") ($y*1.02);
                setAttr ($plane[0]+".scaleZ") ($z*1.02);

                setAttr ($plane[0]+".translateX") ($centreX);
                setAttr ($plane[0]+".translateY") ($centreY);
                setAttr ($plane[0]+".translateZ") ($centreZ);
            }

            select $nodeName;

            $shape = `listRelatives -shapes $plane[0]`;
            setAttr ($shape[0]+".primaryVisibility") 0;
            setAttr ($shape[0]+".visibleInReflections") 0;
            setAttr ($shape[0]+".visibleInRefractions") 0;
            setAttr ($shape[0]+".castsShadows") 0;

            select $plane[0];

            int $randNum = `rand 10000`;
            string $random = ("mash3dPaintCTX"+$randNum);

            art3dPaintCtx $random;
            setToolTo $random;
            toolPropertyWindow;

            evalDeferred("MASHinViewMessage(\"Switching to 3d paint tool.\", \"Info\")");
        }

    } else if ($whichCMD == 2) {

        string $sel[] = `ls -sl`;
        if (size($sel) > 0) {
            string $locsToMove[] = `listRelatives -children $sel[0]`;
            string $nodeType;
            $nodeType = `nodeType $sel[0]`;
            if ($nodeType == "transform") {
                connectAttr -force ($sel[0]+".worldMatrix[0]") ($nodeName+".inMapMatrix") ;
                MASHinViewMessage((getPluginResource("MASH", "kConnectedMapHelper")), "Info");
            } else {
                MASHinViewMessage((getPluginResource("MASH", "kPleaseSelectMapHelperTransform")), "Warning");
            }

        } else {
            MASHinViewMessage((getPluginResource("MASH", "kPleaseSelectMapHelperTransform")), "Warning");
        }

    } else {
        MASHinViewMessage((getPluginResource("MASH", "kNoTextureAdded")), "Error");
    }


    evalDeferred("updateAE " + $nodeName);
    dgdirty -a;
}
