// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
global proc MASHfalloffButtons ( string $attr )
{
    MASHfalloffObjectListWidgetBuildQt($attr);
}

global proc MASHfalloffButtonsEdit ( string $attr )
{
    MASHfalloffObjectTransformListWidgetUpdateQt($attr);
}


global proc MASHfalloffObjectListWidgetBuildQt(string $nodeName)
{
    string $buffer[];
    tokenize($nodeName, ".", $buffer);
    $nodeName = $buffer[0];

    python("import MASHlistQtWidget");
    
    string $parent = `setParent -q`;
    //get python to create the widget, include the desired nodeType as an arguement
    python("MASHlistQtWidget.build_qt_widget('" + $parent + "', '" + $nodeName + "', 'MASH_Falloff', 'strengthPP', 'falloffOut', '', 'kDDFalloffObjets')");
    setParent..;

}

global proc MASHfalloffObjectTransformListWidgetUpdateQt(string $nodeName )
{
    string $buffer[];
    tokenize($nodeName, ".", $buffer);
    $nodeName = $buffer[0];
    string $parent = `setParent -q`;
    python("import MASHlistQtWidget");
    python("MASHlistQtWidget.update_qt_widget('" + $parent + "', '" + $nodeName + "', 'MASH_Falloff', 'strengthPP', 'falloffOut', '', 'kDDFalloffObjets')");
}

global proc string MASH_FalloffButtonCmds (string $nodeName, int $whichCMD) {
    string $nodeType = `nodeType $nodeName`;
    string $falloffNode;
    if ($nodeType == "MASH_BlendDeformer" || $nodeType == "MASH_Jiggle" || $nodeType == "MASH_Deformer" || $nodeType == "MASH_Explode" ) {
        //deformers are a special case, add the falloff in a different way (the positions come from the origShape rather then a previous MASH node).
        if ($whichCMD == 1) {
            int $nameLength = `size $nodeName`;
            $falloffNode = `createNode MASH_Falloff -n ("Falloff_"+$nodeName+"Shape")`;

            string $parents[] = `listRelatives -fullPath -parent $falloffNode`;
            string $transform = $parents[0];

            setAttr ($transform+".scaleX") 10;
            setAttr ($transform+".scaleY") 10;
            setAttr ($transform+".scaleZ") 10;

            string $incomingPosition[];
            //connect input geometry to the falloff node so it knows where the points are
            //we do this by grabbing the first input geometry from the deformer and then hooking it up to the falloff node
            //the falloff node will then automatically extract the vertex positions and use them as the basis for the falloff.
            string $geometry[];
            //explode node is another type of special case, the falloff points should come from the input mesh.
            if ($nodeType == "MASH_Explode") {
                $geometry = `listConnections -p true ($nodeName+".inputMesh")`;
                setAttr ($falloffNode+".componentReadType") 2;
            } else {
                $geometry = `listConnections -p true ($nodeName+".input[0].inputGeometry")`;
            }

            connectAttr -force $geometry[0] ($falloffNode+".falloffIn");
            int $index = getNextFreeMultiIndex( ($nodeName+".strengthPP"), 0 );
            connectAttr -force ($falloffNode+".falloffOut") ($nodeName+".strengthPP[" + $index + "]") ;
            }

            if ($whichCMD == 2) {
                int $failed = 0;
                string $sel[] = `ls -sl`;

                if (size($sel) > 0) {
                    string $locsToMove[] = `listRelatives -children $sel[0]`;
                    string $nodeType;
                    if (size($locsToMove) > 0) {
                        $nodeType = `nodeType $locsToMove[0]`;
                        if ($nodeType == "MASH_Falloff") {
                        //found falloff node, connect
                        int $index = getNextFreeMultiIndex( ($nodeName+".strengthPP"), 0 );
                        connectAttr -force ($locsToMove[0]+".falloffOut") ($nodeName+".strengthPP[" + $index + "]") ;
                        } else {
                            $failed = 1;
                        }
                    } else {
                        $failed = 1;
                    }
                } else {
                    $failed = 1;
                }
            if ($failed) {
                MASHinViewMessage((getPluginResource("MASH", "kDDPleaseSelectFalloffTransform")), "Warning");
            }
        }

    } else {
        if ($whichCMD == 1) {
            int $nameLength = `size $nodeName`;

            $falloffNode = `createNode MASH_Falloff -n ("Falloff_"+$nodeName+"Shape")`;

            string $parents[] = `listRelatives -fullPath -parent $falloffNode`;
            string $transform = $parents[0];

            setAttr ($transform+".scaleX") 10;
            setAttr ($transform+".scaleY") 10;
            setAttr ($transform+".scaleZ") 10;

        //connect input positions to the falloff node so it knows where the points are
        //first try for positionsInPP which is the compound attribute on the multi-channel nodes
        //next go for the fallPosArray which is for single channel nodes NOT in the position channels
        //finally grab the inputArray which will be used for single channel nodes in the position channel.
        if(`objExists ($nodeName +".inputPoints")`) { //Repro nodes
            $incomingPosition = `listConnections -d 0 -s 1 -p 1 ($nodeName+".inputPoints")`;
            if (size($incomingPosition) > 0) {
                connectAttr -force $incomingPosition ($falloffNode+".falloffIn");
            }
        }

        int $index = getNextFreeMultiIndex( ($nodeName+".strengthPP"), 0 );
        connectAttr -force ($falloffNode+".falloffOut") ($nodeName+".strengthPP[" + $index + "]") ;
    }

        //connect a falloff to a different node.
        if ($whichCMD == 2) {
            string $sel[] = `ls -sl`;
            int $foundFalloff = 0;
            for ($nodes in $sel) {
                print ("node found: "+$nodes+"\n");
                string $nodeToClone;
                string $locsToMove[] = `listRelatives -children $nodes`;
                if (size($locsToMove) > 0) {
                    $nodeToClone = $locsToMove[0];
                } else {
                    $nodeToClone = $nodes;
                }
                string $nodeType = `nodeType $nodeToClone`;
                if ($nodeType == "MASH_Falloff") {
                    $foundFalloff = 1;
                    $clonedFalloffName = "Falloff_" + $nodeName;
                    string $duplicateFalloff[] = `duplicate -name $clonedFalloffName $nodeToClone`;
                    string $falloffToConnect[] = `listRelatives -children $duplicateFalloff[0]`;

                    //connect positions to the new falloff object
                    if(`objExists ($nodeName +".inputPoints")`) { //Repro nodes
                        $incomingPosition = `listConnections -d 0 -s 1 -p 1 ($nodeName+".inputPoints")`;
                        if (size($incomingPosition) > 0) {
                            connectAttr -force $incomingPosition ($falloffToConnect[0]+".falloffIn");
                        }
                    }
                    //found falloff node, connect
                    int $index = getNextFreeMultiIndex( ($nodeName+".strengthPP"), 0 );
                    connectAttr -force ($falloffToConnect[0]+".falloffOut") ($nodeName+".strengthPP[" + $index + "]") ;
                }
            }
            if (!$foundFalloff) {
                MASHinViewMessage((getPluginResource("MASH", "kDDPleaseSelectFalloffTransform")), "Warning");
            } else {
                MASHinViewMessage((getPluginResource("MASH", "kDDFalloffCloned")), "Info");
            }
        }
    }

    evalDeferred("updateAE " + $nodeName);

    return $falloffNode;
}
