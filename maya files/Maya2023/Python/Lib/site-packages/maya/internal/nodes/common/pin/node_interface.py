"""
    Module containing functions to edit the pin constraint base class node
"""
# ------------------------------------------------------------------------------
import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
from builtins import range
import string

import maya.cmds

import maya.internal.common.utils.message as msg_utils
import maya.internal.common.utils.geometry as geo_utils
import maya.internal.common.utils.transform as xfm_utils
import maya.internal.common.utils.ui as ui_utils
import maya.internal.common.node_interface as nifc

# ------------------------------------------------------------------------------
#
# Shared labels
#
# ------------------------------------------------------------------------------

labelNormalAxis = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelNormalAxis']
labelTangentAxis = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelTangentAxis']
labelOutputConnect = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOutputConnect']
labelInputConnect = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelInputConnect']
labelUVSet = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelUVset']

annotNormalAxis = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kAnnotNormalAxis']
annotTangentAxis = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kAnnotTangentAxis']
annotOutputConnect = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kAnnotOutputConnect']
annotInputConnect = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kAnnotInputConnect']
annotUVSet = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kAnnotUVSetName']

wrnMsgNormalAxis = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kUVPinWrnMsgNormalAxis' ]
wrnMsgTangentAxis = maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kUVPinWrnMsgTangentAxis' ]

attrNameNormalAxis = 'normalAxis'
attrNameTangentAxis = 'tangentAxis'

# ------------------------------------------------------------------------------
#
# Enum types
#
# ------------------------------------------------------------------------------
class eAxisType(object):
    kXAxis	  = 0
    kYAxis	  = 1
    kZAxis	  = 2
    kNXAxis	  = 3
    kNYAxis	  = 4
    kNZAxis	  = 5
    kNoneAxis = 6

# ------------------------------------------------------------------------------
class eXformIO(object):
    kCurrent = 0
    kMatrix = 1
    kNull = 2
    kLocator = 3

# ------------------------------------------------------------------------------
def createCoordSysMenu(label, annotation='', changeCommand=None, noneAxis=False):

    opts = [ (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptXAxis'], eAxisType.kXAxis),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptYAxis'], eAxisType.kYAxis),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptZAxis'], eAxisType.kZAxis),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptNXAxis'], eAxisType.kNXAxis),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptNYAxis'], eAxisType.kNYAxis),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptNZAxis'], eAxisType.kNZAxis) ]
    if noneAxis:
        opts.append( (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptNoneAxis'], eAxisType.kNoneAxis) )
    return ui_utils.createOptionMenu(label=label, options=opts, annotation=annotation, changeCommand=changeCommand)

# ------------------------------------------------------------------------------
def createXformIOMenu(label, annotation='', changeCommand=None):

    opts = [ (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptCurrent'], eXformIO.kCurrent),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptNull'], eXformIO.kNull),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptLocator'], eXformIO.kLocator),
             (maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kLabelOptMatrix'], eXformIO.kMatrix) ]

    return ui_utils.createOptionMenu(label=label, options=opts, annotation=annotation, changeCommand=changeCommand)

# ------------------------------------------------------------------------------
def hasConflictingAxis(normalAxis, tangentAxis):
    if (normalAxis == eAxisType.kNoneAxis or tangentAxis == eAxisType.kNoneAxis):
        return False
    # check if we have the same axis (either + or - direction)
    return (normalAxis%3 == tangentAxis%3)

# ------------------------------------------------------------------------------
def findNonConflictingAxis(axis, candidateAxis=None):
    # Check if out first choice is not conflicting, if so return that
    if candidateAxis is not None and not hasConflictingAxis(axis, candidateAxis):
        return candidateAxis
    # Just create a non-conflicting axis
    return (axis + 1) % (eAxisType.kNZAxis+1)

# ------------------------------------------------------------------------------
def capturePrevAxis(pinOptionBox):
    pinOptionBox.prevNormalAxis = pinOptionBox.getWidgetValue(attrNameNormalAxis)
    pinOptionBox.prevTangentAxis = pinOptionBox.getWidgetValue(attrNameTangentAxis)

# ------------------------------------------------------------------------------
def resolveConflictingAxisOptionBox(pinOptionBox, checkNormalAxis=True):

    na = pinOptionBox.getWidgetValue(attrNameNormalAxis)
    ta = pinOptionBox.getWidgetValue(attrNameTangentAxis)
    if hasConflictingAxis(na, ta):
        if checkNormalAxis:
            msg_utils.showWarning(wrnMsgNormalAxis)
            pinOptionBox.setWidgetValue(attrNameNormalAxis, findNonConflictingAxis(ta, pinOptionBox.prevNormalAxis))
        else:
            msg_utils.showWarning(wrnMsgTangentAxis)
            pinOptionBox.setWidgetValue(attrNameTangentAxis, findNonConflictingAxis(na, pinOptionBox.prevTangentAxis))

    capturePrevAxis(pinOptionBox)

# ------------------------------------------------------------------------------
def resolveConflictingAxisAttributeEditor(nodeName, prevAxis, checkNormalAxis=True):
    attrNormal = "{0}.{1}".format(nodeName, attrNameNormalAxis)
    attrTangent = "{0}.{1}".format(nodeName, attrNameTangentAxis)
    na = maya.cmds.getAttr(attrNormal)
    ta = maya.cmds.getAttr(attrTangent)
    if hasConflictingAxis(na, ta):
        if checkNormalAxis:
            msg_utils.showWarning(wrnMsgNormalAxis)
            maya.cmds.setAttr(attrNormal, findNonConflictingAxis(ta, prevAxis))
        else:
            msg_utils.showWarning(wrnMsgTangentAxis)
            maya.cmds.setAttr(attrTangent, findNonConflictingAxis(na, prevAxis))

    if checkNormalAxis:
        return maya.cmds.getAttr(attrNormal)
    else:
        return maya.cmds.getAttr(attrTangent)

# ------------------------------------------------------------------------------
def createCoordSysWidgets(pinOptionBox, noneNormalAxis=False, noneTangentAxis=False):
    widget, lookup = createCoordSysMenu(label=labelNormalAxis,
                                        annotation=annotNormalAxis,
                                        changeCommand=pinOptionBox._onUpdateNormalAxis,
                                        noneAxis=noneNormalAxis)
    pinOptionBox.optionMenuGrp_labelToEnum[attrNameNormalAxis] = lookup
    pinOptionBox.normalMenu = widget

    widget, lookup = createCoordSysMenu(label=labelTangentAxis,
                                        annotation=annotTangentAxis,
                                        changeCommand=pinOptionBox._onUpdateTangentAxis,
                                        noneAxis=noneTangentAxis)
    pinOptionBox.optionMenuGrp_labelToEnum[attrNameTangentAxis] = lookup
    pinOptionBox.tangentMenu = widget

# ------------------------------------------------------------------------------
class NodeInterface(nifc.NodeInterface):
    def __init__(self, nodeName):
        super(NodeInterface, self).__init__(nodeName)

    def setGeometry(self, geomShape):
        origPlug = geo_utils.getOrCreateOriginalGeometry(geomShape)
        if not origPlug:
            return

        worldAttrName = '{0}[0]'.format(geo_utils.getWorldShapeOutAttr(geomShape))
        maya.cmds.connectAttr('{0}.{1}'.format(geomShape, worldAttrName), '{0}.deformedGeometry'.format(self.editNode), force=True)
        maya.cmds.connectAttr(origPlug, '{0}.originalGeometry'.format(self.editNode), force=True)

    def getGeometry(self, useCurrent=True):
        if not self.isValid():
            return None

        attr = 'deformedGeometry' if useCurrent else 'originalGeometry'
        plugName = '{0}.{1}'.format(self.editNode, attr)
        cons = maya.cmds.listConnections(plugName, plugs=False, shapes=True, destination=False)
        return cons[0] if cons and len(cons) > 0 else None

    def driverGeomTypeFilter(self):
        return geo_utils.GeomType.MeshNurbsCurve

    def getConnectedMatrixOutputs(self):
        if not self.isValid():
            return []
        plugName = '{0}.outputMatrix'.format(self.editNode)
        cmo = maya.cmds.listConnections(plugName, plugs=False, source=False)
        return cmo if cmo else []

    def hookupOutputs(self, outputConnect=eXformIO.kMatrix, indices=None, targets=None):
        createdNodes = list()

        if not self.isValid():
            return createdNodes

        if outputConnect == eXformIO.kMatrix or indices is None or len(indices) == 0:
            # Nothing to create...
            return createdNodes

        geom = self.getGeometry()
        if geom is None:
            return createdNodes

        numOutputs = len(indices)

        if outputConnect == eXformIO.kCurrent and (targets is None or len(targets) != numOutputs):
            return createdNodes

        shapeParent = xfm_utils.getParent(geom)
        wrnOutputXformList = list()

        for i in range(0, numOutputs):
            if outputConnect == eXformIO.kCurrent:
                xform = targets[i]

                inherit =  maya.cmds.getAttr('{0}.inheritsTransform'.format(xform))
                if inherit:
                    wrnOutputXformList.append(xform)

            elif outputConnect == eXformIO.kLocator:
                xform = maya.cmds.spaceLocator(n='pinOutput')[0]
                createdNodes.append(xform)
            else:
                xform = maya.cmds.createNode('transform', n='pinOutput')
                createdNodes.append(xform)

            if outputConnect == eXformIO.kCurrent:
                xfm_utils.clearTransformAttributes(xform)

            maya.cmds.connectAttr('{0}.outputMatrix[{1}]'.format(self.editNode, indices[i]), '{0}.offsetParentMatrix'.format(xform), force=True)
            maya.cmds.setAttr('{0}.inheritsTransform'.format(xform), 0)

        if len(wrnOutputXformList) > 0:
            msg_utils.showWarning(maya.stringTable['y_maya_internal_nodes_common_pin_node_interface.kWrnMsgOutputConnect' ].format(wrnOutputXformList))

        return createdNodes

    def getUvSetName(self):
        plugName = '{0}.uvSetName'.format(self.editNode)
        return maya.cmds.getAttr(plugName)

    def setUvSetName(self, uvSetName):
        plugName = '{0}.uvSetName'.format(self.editNode)
        return maya.cmds.setAttr(plugName, uvSetName, type='string')
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
