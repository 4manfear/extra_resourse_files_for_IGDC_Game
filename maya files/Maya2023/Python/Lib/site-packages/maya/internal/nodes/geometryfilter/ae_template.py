import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import int

import maya.internal.common.ae.template as aetemplate
import maya.internal.common.node_interface as nifc
import maya.internal.common.qt.buttons as qt_buttons
import maya.internal.common.qt.table as qt_table
import maya.internal.common.utils.ui as ui_utils
import maya.internal.common.utils.connections as con_utils
import maya.internal.common.utils.deform as dfm_utils
import maya.internal.common.utils.falloff as fo_utils
import maya.internal.common.utils.geometry as geo_utils
import maya.internal.nodes.blendfalloff.action as fo_action
from maya.internal.nodes.common.componenttag.component_tag_edit import ComponentTagExpressionEdit

from PySide2 import QtWidgets, QtCore, QtGui

from maya.internal.nodes.geometryfilter.node_interface import NodeInterface

createNewFalloffLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionCreateFalloff' ]
createNewFalloffLayerLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionCreateFalloffLayer' ]
unnamedFalloffLayerName = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionUnnamedFalloffLayer' ]

colIdxLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColIdx' ]
colTagLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColTag' ]
colGidLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColGid' ]
colFalLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColFal' ]
colGeoLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColGeo' ]

#-------------------------------------------------------------------------------
class eColumn(object):
    kIdx = 0
    kTag = 1
    kGid = 2
    kFal = 3
    kGeo = 4
    kLAST = 5

    optVarLookup = {
            kIdx : 'deformAEShowColumnIndex',
            kTag : 'deformAEShowColumnComponentTag',
            kGid : 'deformAEShowColumnGroupId',
            kFal : 'deformAEShowColumnFalloff',
            kGeo : 'deformAEShowColumnGeometry' }

    @staticmethod
    def getOptVarValue(colId):
        optVar = eColumn.optVarLookup.get(colId)
        if optVar and maya.cmds.optionVar(exists=optVar):
            return maya.cmds.optionVar(q=optVar)
        return True if colId != eColumn.kGid else False

    @staticmethod
    def setOptVarValue(colId, value):
        optVar = eColumn.optVarLookup.get(colId)
        if optVar:
            maya.cmds.optionVar(iv=(optVar, value))

#-------------------------------------------------------------------------------
def _setAlternateFont(wi):
    brs = wi.foreground()
    brs.setColor(QtGui.QColor(150, 150, 150))
    wi.setForeground(brs)

    fnt = wi.font()
    fnt.setItalic(True)
    wi.setFont(fnt)

#-------------------------------------------------------------------------------
class ColumnAction(QtWidgets.QAction):
    def __init__(self, name, parent, colId):
        checked = eColumn.getOptVarValue(colId)
        super(ColumnAction, self).__init__(name, parent, checkable=True, checked=checked)
        self.column = colId

COMPONENTTAG_ICON = ui_utils.createIcon(':/tag.png')
GROUPID_ICON = ui_utils.createIcon(':/selectComp.png')

#-------------------------------------------------------------------------------
class InputInfo(object):
    def __init__(self):
        self.tag = None
        self.gid = None
        self.geo = None
        self.src = None
        self.con = None
        self.index = -1
        self.row = -1

    def __eq__(self, other):
        if not isinstance(other, InputInfo):
            return False
        return self.tag == other.tag and \
               self.gid == other.gid and \
               self.geo == other.geo and \
               self.src == other.src and \
               self.con == other.con and \
               self.index == other.index and \
               self.row == other.row

    def __ne__(self, other):
        return not (self == other)

    def isActive(self):
        return self.geo is not None or self.gid or self.src or self.con or self.tag != '*'

#-------------------------------------------------------------------------------
class InputTableWidget(qt_table.TableWidget):

    def __init__(self, hiddenColumns=[]):
        super(InputTableWidget, self).__init__()
        self.prepareTable(eColumn.kLAST)

        self.makeHeader(eColumn.kIdx, colIdxLabel, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColIdxTip' ])
        self.makeHeader(eColumn.kTag, colTagLabel, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColTagTip' ])
        self.makeHeader(eColumn.kGid, colGidLabel, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColGidTip' ])
        self.makeHeader(eColumn.kFal, colFalLabel, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelColFalTip' ])
        self.makeHeader(eColumn.kGeo, colGeoLabel, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelGeoTip' ])

        # Hide columns based on optVars
        for col in [ eColumn.kIdx, eColumn.kTag, eColumn.kGid, eColumn.kFal, eColumn.kGeo]:
            if not eColumn.getOptVarValue(col) or col in hiddenColumns:
                self.hideColumn(col)
        self.hasFalloffSupport = eColumn.kFal not in hiddenColumns
        self.setColumnResizeMode(content=[eColumn.kIdx, eColumn.kGid, eColumn.kGeo], stretch=[eColumn.kTag, eColumn.kFal])

        self.interface = None
        self.cellDoubleClicked.connect( self.doubleClickedOnItem )

    def sizeHint(self):
        return QtCore.QSize(400, ui_utils.dpiScale(4*30+25))

    def makeTableItem(self, col, info):
        horizontalAlign=QtCore.Qt.AlignHCenter
        horizontalAlign=QtCore.Qt.AlignLeft
        altFont = False

        if col == eColumn.kIdx:
            text = str(info.index)
        elif col == eColumn.kGid:
            text = str(info.gid)
        elif col == eColumn.kTag:
            text = info.tag
            if info.gid != 0:
                text = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelNotApplicable' ]
            elif text == '*':
                text += maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelAll' ]
            elif text == '':
                text = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelNone' ]
        elif col == eColumn.kFal:
            text = fo_utils.getConnectionLabel(info.src)
            if text == '':
                text = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelRightClickAdd' ]
                altFont = True
        elif col == eColumn.kGeo:
            text = info.geo if info.geo is not None else ''

        flags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled

        wi = qt_table.InfoTableWidgetItem(text, info)
        wi.setTextAlignment(horizontalAlign | QtCore.Qt.AlignVCenter)

        if col == eColumn.kTag:
            if info.gid == 0:
                plugName = self.interface.componentTagExpressionPlugName(info.index)
                settable = maya.cmds.getAttr(plugName,settable=True)
                if settable:
                    flags = flags | QtCore.Qt.ItemIsEditable
                wi.setIcon(COMPONENTTAG_ICON)
            else:
                altFont = True
                wi.setIcon(GROUPID_ICON)

        elif col == eColumn.kGid:
            if info.gid == 0:
                altFont = True

        elif col == eColumn.kFal:
            ic = fo_action.iconForFalloffSource(info.src)
            if ic is not None:
                wi.setIcon(fo_action.iconForFalloffSource(info.src))

        if altFont:
            _setAlternateFont(wi)

        wi.setFlags(flags)
        return wi

    def updateItems(self, nodeName):
        self.interface = NodeInterface(nodeName)
        self.editExpressionRow = None
        if self.interface.isValid():
            inputData = self.interface.getInputData()

            self.setSortingEnabled(False)
            self.setRowCount(len(inputData))

            # Note: inserting multiple items in a QTableWidget will re-layout the
            #       widget at every insertion. This is very slow when inserting
            #       hundreds of items.
            #
            #       The correct work-around would be to:
            #
            #           1. Use a QTableView
            #           2. Create a custom QAbstractTableModel sub-class
            #           3. Create a new instance of this model
            #           4. Fill the model with data.
            #           5. Assign the new model instance to the table.
            #
            #       One could wrap all this in a Python 'with' clause
            #       and a special table-filling context object that would
            #       create the new model instance and swap it when the context
            #       ends.
            #
            #       As this would require more disrupting changes to the
            #       maya.internal.common.qt.table, including writing a model
            #       sub-class, a quick work-around is to disable signals on
            #       the model while inserting items.
            #
            #       Another option would be to make the QTableWidget model
            #       available through PySide2, It is a private class of Qt,
            #       but given how complex creating a new model from scratch,
            #       re-using the existing one would be simpler. Then the
            #       correct fix would again be to swap models, like this:
            #
            #            newModel = QtWidgets.QTableModel()
            #            newModel.setRowCount(len(inputData))
            #
            #            for row, d in enumerate(inputData):
            #                info = InputInfo()
            #                info.index = d[0]
            #                info.gid = d[1]
            #                info.tag = d[2]
            #                info.geo = d[3]
            #                info.src = d[4]
            #                info.row = row
            #
            #                for col in [ eColumn.kIdx, eColumn.kTag, eColumn.kGid, eColumn.kFal, eColumn.kGeo]:
            #                    newModel.setItem(row, col, self.makeTableItem(col, info))
            #
            #            self.setModel(newModel)
            #
            #       But there is another obstacle to this: QTableWidget redeclares setModel()
            #       to be private and PySide2 enforces this. Normally you could call it through
            #       a base class pointer, but this is impossible from Python. Thus a potential 
            #       solution of create a new table, taking its model and setting this other model
            #       on ourselves doesn't work because self.setModel() fails in PySide2!
            #
            #       The solution here is to try to avoid doing as much work as possible by comparing
            #       the new value and the existing value of each item and only update the items that
            #       have changed.
            #
            #       We also use setUpdatesEnabled() to avoid repaints during the updates.

            for row, d in enumerate(inputData):
                info = InputInfo()
                info.index = d[0]
                info.gid = d[1]
                info.tag = d[2]
                info.geo = d[3]
                info.src = d[4]
                info.con = d[5]
                info.row = row

                infoChanged = False
                for col in [ eColumn.kIdx, eColumn.kTag, eColumn.kGid, eColumn.kFal, eColumn.kGeo]:
                    existingItem = self.item(row, col)
                    if not existingItem or existingItem.info != info:
                        self.setItem(row, col, self.makeTableItem(col, info))
                        infoChanged = True
                if infoChanged:
                    self.setCellWidget(row, eColumn.kTag, None)
                    if not info.isActive():
                        self.hideRow(info.row)
                    else:
                        self.showRow(info.row)

        else:
            self.clearItems()

    def _updateItems(self):
        self.updateItems(self.interface.getEditNode())

    def clearItems(self):
        self.setRowCount(0)
        self.interface = None

    def contextMenuEvent(self, event):
        index = self.indexAt(event.pos())
        widgetItem = None
        if not index.isValid():
            info = InputInfo()
        else:
            widgetItem = self.item(index.row(), index.column())
            info = widgetItem.info

        curFalloff = None
        curFalloffSourcePlug = None
        if info.index >= 0:
            curFalloffSourcePlug = info.src
            curFalloff = con_utils.plugNode(curFalloffSourcePlug)
            actionLabel = None
        else:
            actionLabel = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kLabelAddItem' ]

        menu = QtWidgets.QMenu(self)

        selectAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionSelect' ])
        menu.addSeparator()

        focMenu = fo_action.FalloffContextMenuBuilder(actionLabel)
        focMenu.appendToMenu(menu, curFalloff, curFalloffSourcePlug)

        paintableAttrs = self.interface.paintablePlugs(info.index) if info.index >= 0 else []
        focMenu.appendPaintMenu(menu, paintableAttrs)

        if not self.hasFalloffSupport:
            focMenu.disableAllActions()

        menu.addSeparator()
        removeInputAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionRemove' ])

        menu.addSeparator()
        convertAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionConvert' ])

        # Which deformer is being visualized?
        visDef = maya.cmds.weightsColor(info.geo, q=True, dfm=True)[0] if info.geo is not None else None
        visOn = (visDef == self.interface.getEditNode())
        if visOn:
            visWeightAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionVisWeightsOff' ])
        else:
            visWeightAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionVisWeightsOn' ])

        columnAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kActionColumns' ])
        self.columnMenu = QtWidgets.QMenu(menu)
        columnAction.setMenu(self.columnMenu)

        self.columnMenu.addAction(ColumnAction(colTagLabel, self.columnMenu, eColumn.kTag))
        self.columnMenu.addAction(ColumnAction(colGidLabel, self.columnMenu, eColumn.kGid))
        self.columnMenu.addAction(ColumnAction(colFalLabel, self.columnMenu, eColumn.kFal))
        self.columnMenu.addAction(ColumnAction(colGeoLabel, self.columnMenu, eColumn.kGeo))
        self.columnMenu.triggered.connect(self.columnVisibilityChanged)

        selectAction.setEnabled(info.index >= 0 and info.geo is not None)
        convertAction.setEnabled(info.index >= 0 and info.gid != 0 and info.geo is not None)
        visWeightAction.setEnabled(info.index >= 0 and info.geo is not None)
        removeInputAction.setEnabled(info.index >= 0)

        action = menu.exec_(self.mapToGlobal(event.pos()))

        if action == selectAction:
            self._selectComponents(info)
        elif action == convertAction:
            self._convertToComponentTags(info)
        elif action == visWeightAction:
            if visOn:
                maya.cmds.weightsColor(info.geo, fc=False)
            else:
                maya.cmds.weightsColor(info.geo, dfm=self.interface.getEditNode(), fc=True)
        elif action == removeInputAction:
            self._removeInput(info)
        elif action == focMenu.selectAction:
            maya.cmds.select(curFalloff)
        elif isinstance(action, fo_action.Action):
            if action.actId == fo_action.eAction.kPaint:
                self._paintFalloff(info, action)
            else:
                self._assignFalloff(info, action)
        elif action == focMenu.disconnectAction:
            self._disconnectFalloff(info)
        elif action == focMenu.deleteAction:
            self._deleteFalloff(info)

        return

    @ui_utils.undoChunk('select deformer components')
    def _selectComponents(self, info):
        comp = self.interface.getComponents(info.index)
        if comp:
            args = []
            for c in comp:
                args.append('{0}.{1}'.format(info.geo, c))
            maya.cmds.select(*args, r=True)
        else: # We failed, so just select the total shape without components
             maya.cmds.select(info.geo, r=True)

    @ui_utils.undoChunk('convert deformer entry to component tags')
    def _convertToComponentTags(self, info):
        if info.index >= 0 and info.gid != 0:
            dfm_utils.replaceGroupParts(self.interface.getEditNode(), onlyIndices=[info.index])

    @ui_utils.undoChunk('remove input from deformer')
    def _removeInput(self, info):
        if info.index >= 0:
            if info.geo is not None:
                maya.cmds.deformer(self.interface.getEditNode(), edit=True, remove=True, geometry=info.geo)

            maya.cmds.removeMultiInstance('{}.input[{}]'.format(self.interface.getEditNode(), info.index), b=True)
            maya.cmds.removeMultiInstance('{}.weightFunction[{}]'.format(self.interface.getEditNode(), info.index), b=True)

    @ui_utils.undoChunk('assign falloff')
    def _assignFalloff(self, info, action):
        index = info.index
        if index < 0:
            index = self.interface.getFreeIndex()

        if action.actId == fo_action.eAction.kNew:
            saveSelection = maya.cmds.ls(selection=True)
            if self.interface.createAndAssignFalloff(index, action.falloffType, self.interface.getEditNode()):
                self._updateItems()
            maya.cmds.select(saveSelection, r=True)

        elif action.actId == fo_action.eAction.kExisting:
            if self.interface.assignFalloff(index, action.falloff, action.falloffOutputIndex, self.interface.getEditNode()):
                self._updateItems()
        return

    @ui_utils.undoChunk('disconnect falloff')
    def _disconnectFalloff(self, info):
        if self.interface.setFalloffSourcePlug(info.index, None):
            self._updateItems()

    @ui_utils.undoChunk('delete falloff')
    def _deleteFalloff(self, info):
        if self.interface.deleteFalloff(info.index):
            self._updateItems()

    @ui_utils.undoChunk('paint component falloff')
    def _paintFalloff(self, info, action):
        fo_utils.paintComponentFalloff(info.geo, action.paintPlug)

    @QtCore.Slot(int, int)
    def doubleClickedOnItem(self, row, col):
        widgetItem = self.item(row, col)
        if col == eColumn.kTag:
            if widgetItem.info.gid > 0: # we are not using component tags
                return

            editable = int(widgetItem.flags() & QtCore.Qt.ItemIsEditable) != 0
            if not editable:
                return

            tagWidget = self.cellWidget(row, eColumn.kTag)
            if tagWidget is None:
                geometryPlugName = self.interface.inputGeometryPlugName(widgetItem.info.index)
                plugName = self.interface.componentTagExpressionPlugName(widgetItem.info.index)
                tagWidget = ComponentTagExpressionEdit(plugName, geometryPlugName=geometryPlugName, onlyShowDuringEdit=True)
                self.setCellWidget(row, eColumn.kTag, tagWidget)
                tagWidget.outOfFocusSignal.connect(self.removeExpressionEditor)

            tagWidget.show()
            tagWidget.setFocus()
            self.editExpressionRow = row
        elif col == eColumn.kFal:
            info = widgetItem.info
            if info.index >= 0:
                curFalloff = con_utils.plugNode(info.src)
                if curFalloff:
                    maya.cmds.select(curFalloff)
        elif col == eColumn.kGeo:
            info = widgetItem.info
            if info.index >= 0:
                self._selectComponents(info)

    @QtCore.Slot()
    def columnVisibilityChanged(self, action):
        if isinstance(action, ColumnAction):
            if self.horizontalHeader().isSectionHidden(action.column):
                self.showColumn(action.column)
                eColumn.setOptVarValue(action.column, True)
            else:
                self.hideColumn(action.column)
                eColumn.setOptVarValue(action.column, False)

    def removeExpressionEditor(self):
        if self.editExpressionRow is not None:
            self.setCellWidget(self.editExpressionRow, eColumn.kTag, None)

#-------------------------------------------------------------------------------
class InputWidget(QtWidgets.QWidget):
    def __init__(self, uiParent=None, hiddenColumns=[]):
        super(InputWidget, self).__init__()
        self.mainLayout = QtWidgets.QVBoxLayout()
        # Table widget
        self.tableWidget = InputTableWidget(hiddenColumns=hiddenColumns)
        self.tableWidget.itemSelectionChanged.connect(self.tableSelectionChangedSlot)
        self.mainLayout.addWidget(self.tableWidget)

        # Finish up the layout
        self.setLayout(self.mainLayout)

    def changeNode(self, nodeName, plugName):
        self.nodeName = nodeName
        self.refresh()

    def refresh(self):
        self.tableWidget.updateItems(self.nodeName)

    def updateTopBar(self):
        pass

    @QtCore.Slot()
    def tableSelectionChangedSlot(self):
        self.updateTopBar()

#-------------------------------------------------------------------------------
class ManageGeometryWidget(qt_buttons.ManageMenuButtonWidget):
    def __init__(self, uiParent=None):
        super(ManageGeometryWidget, self).__init__(
            label = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kManageGeometry' ],
            annotation = maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kManageGeometryAnnot' ],
            uiParent=uiParent)

        self.addGeomAct = self.addMenuAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kAddDriverItem' ], ':/item_add.png')
        self.remGeomAct = self.addMenuAction(maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kRemDriverItem' ], ':/item_delete.png')

    @ui_utils.undoChunk('add geometry')
    def addGeoms(self, editor, shapes):
        editor.addShapesToDeformer(shapes)

    @ui_utils.undoChunk('remove geometry')
    def removeGeoms(self, editor, shapes):
        editor.removeShapesFromDeformer(shapes)

    def enableMenuItems(self):
        editor = nifc.NodeInterfaceFactory.createFromNode(self.nodeName, 'geometryFilter')
        if editor is not None and editor.isValid():
            if editor.addOrRemoveShapesAllowed():
                selected = set(geo_utils.getSelectedShapes(geomType=editor.deformableGeomTypeFilter()))
                bendies = set(editor.getDeformedShapes())

                selectedUnused = editor.filterAddShapesToDeformer(selected)
                selectedUsed = selected.intersection(bendies)  # the selected bendies that are used

                self.addGeomAct.setEnabled(len(selectedUnused)>0)
                self.remGeomAct.setEnabled(len(selectedUsed)>0)
            else:
                self.addGeomAct.setEnabled(False)
                self.remGeomAct.setEnabled(False) 
        else:
            self.addGeomAct.setEnabled(False)
            self.remGeomAct.setEnabled(False)

    def actionTriggered(self, action):
        editor = nifc.NodeInterfaceFactory.createFromNode(self.nodeName, 'geometryFilter')
        if editor is None or not editor.isValid():
            return

        if action == self.addGeomAct:
            self.addGeoms(editor, geo_utils.getSelectedShapes(geomType=editor.deformableGeomTypeFilter(), useComponents=True))
        elif action == self.remGeomAct:
            self.removeGeoms(editor, geo_utils.getSelectedShapes(geomType=editor.deformableGeomTypeFilter()))

#-------------------------------------------------------------------------------
class AETemplate(aetemplate.Template):

    def inputAttributesTableHiddenColumns(self):
        return []

    def buildUI(self, nodename):
        with aetemplate.Layout(self, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kDeformerAttributes' ], collapse=True):
            self.addControls(['envelope'])

            self.defineQtCustom(ManageGeometryWidget, 'input')
            hiddenColumns = self.inputAttributesTableHiddenColumns()
            self.defineQtCustom(lambda parent : InputWidget(parent, hiddenColumns), 'input')

            with aetemplate.Layout(self, maya.stringTable['y_maya_internal_nodes_geometryfilter_ae_template.kGPUAttributes' ], collapse=True):
                self.addControls(['blockGPU'])

        self.suppress('originalGeometry')
        self.suppress('outputGeometry')
        self.suppress('map64BitIndices')
        self.suppress('weightFunction')

        self.callTemplate('dependNode')




# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
