import maya
maya.utils.loadStringResourcesForModule(__name__)

import maya.cmds
from PySide2.QtWidgets import QLineEdit, QCompleter, QWidget, QHBoxLayout, QLabel
import PySide2.QtCore as QtCore
import maya.OpenMayaUI as mui

labelAll = maya.stringTable['y_maya_internal_nodes_common_componenttag_component_tag_edit.kLabelAll' ]

#-------------------------------------------------------------------------------
def getOptionVarValue(name, default_value):
    if maya.cmds.optionVar(ex=name):
        return maya.cmds.optionVar(q=name)
    return default_value

#-------------------------------------------------------------------------------
class ComponentTagExpressionEdit(QLineEdit):

    updatedExpressionSignal = QtCore.Signal()
    outOfFocusSignal = QtCore.Signal()

    def __init__(self, plugName=None, componentTagNames=None, geometryPlugName=None, onlyShowDuringEdit=False):
        """
        Create the widget to set the componentTagExpression on the specified plugName.
        The valid componentTags that can be used can be specified in 2 different ways.

        First is to specifiy them as a static list, using the componentTagNames parameter.
        This list can be altered later by using the setComponentTagNames method if needed.

        The second method is to provide a geometryPlug to query for its componentTags.
        This list will dynamically be updated any time the widget enters focus.
        """
        super(ComponentTagExpressionEdit, self).__init__()
        self.setFrame(False)
        self.setPlugName(plugName)
        self.refreshComponentTagExpression()

        self.geometryPlugName = geometryPlugName
        model = QtCore.QStringListModel(self)
        if componentTagNames:
            model.setStringList(componentTagNames)

        self._completer = QCompleter(model)
        self._completer.setWidget(self)
        self._completer.setCompletionMode(QCompleter.UnfilteredPopupCompletion)
        self.connect(self,
                    QtCore.SIGNAL('editingFinished()'),
                    self._updateAttribute)
        self.connect(self,
                    QtCore.SIGNAL('returnPressed()'),
                    self._updateAttribute)
        self.connect(
                self._completer,
                QtCore.SIGNAL('activated(QString)'),
                self._insertCompletion)
        self._keysToIgnore = [QtCore.Qt.Key_Enter,
                              QtCore.Qt.Key_Return,
                              QtCore.Qt.Key_Escape,
                              QtCore.Qt.Key_Tab]

        self.onlyShowDuringEdit = onlyShowDuringEdit
        if self.onlyShowDuringEdit:
            self.hide()

    def updatePlug(self, plugName, geometryPlug):
        self.plugName = plugName
        self.geometryPlugName = geometryPlug

    def focusInEvent(self, event):
        super(ComponentTagExpressionEdit, self).focusInEvent(event)
        if self.geometryPlugName is not None and maya.cmds.objExists(self.geometryPlugName):
            tagNames = [labelAll] + (maya.cmds.geometryAttrInfo(self.geometryPlugName, cnm=True) or [])
            self.setComponentTagNames(tagNames)

    def focusOutEvent(self, event):
        super(ComponentTagExpressionEdit, self).focusOutEvent(event)
        if self.onlyShowDuringEdit:
            self.hide()
            self.outOfFocusSignal.emit()

    def setPlugName(self, plugName):
        self.plugName = plugName

    def setComponentTagNames(self, componentTagNames):
        model = self._completer.model()
        model.setStringList(componentTagNames)

    def _updateAttribute(self):
        if self.plugName is not None:
            newVal = self.text().strip()
            if maya.cmds.getAttr(self.plugName) != newVal:
                maya.cmds.setAttr(self.plugName, newVal, type="string")
                self.updatedExpressionSignal.emit()

        if self.onlyShowDuringEdit:
            self.clearFocus()

    def refreshComponentTagExpression(self):
        if self.plugName is not None:
            self.setText(maya.cmds.getAttr(self.plugName))

    def setTags(self, tags):
        self._completer.setModel(QtCore.QStringListModel(tags))

    def _insertCompletion(self, completion):
        """
        This is the event handler for the QCompleter.activated(QString) signal,
        it is called when the user selects an item in the completer popup.
        """
        if completion.strip() == labelAll:
            extra_text ='*'
        else:
            extra_text = completion
        extra_text += ' '
        t = self.text()
        l = self.cursorPosition() - len(self._completer.completionPrefix())
        t = t[:l]  + extra_text + t[l + len(self._completer.completionPrefix()):]
        self.setText(t)
        self.setCursorPosition(l + len(extra_text))

    def textUnderCursor(self):
        text = self.text()
        textUnderCursor = ''
        i = self.cursorPosition() - 1
        while i >=0 and text[i] not in [" ", "+", "-"]:
            textUnderCursor = text[i] + textUnderCursor
            i -= 1
        return textUnderCursor

    def keyPressEvent(self, event):
        if self._completer.popup().isVisible():
            if event.key() in self._keysToIgnore:
                event.ignore()
                return
        else:
            if event.key() == QtCore.Qt.Key_Return:
                self.returnPressed.emit()
                event.accept()
                self.clearFocus()
                return

        super(ComponentTagExpressionEdit, self).keyPressEvent(event)
        completionPrefix = self.textUnderCursor()
        if completionPrefix != self._completer.completionPrefix():
            self._updateCompleterPopupItems(completionPrefix)
        if len(event.text()) > 0 and len(completionPrefix) > 0:
            self._completer.complete()
        if len(completionPrefix) == 0:
            self._completer.popup().hide()


    def _updateCompleterPopupItems(self, completionPrefix):
        """
        Filters the completer's popup items to only show items
        with the given prefix.
        """
        self._completer.setCompletionPrefix(completionPrefix)
        self._completer.popup().setCurrentIndex(
                self._completer.completionModel().index(0,0))

#-------------------------------------------------------------------------------
class ComponentTagExpressionFieldGrp(QWidget):
    def __init__(self, uiParent=None):
        super(ComponentTagExpressionFieldGrp, self).__init__()
        self.mainLayout = QHBoxLayout()
        self.mainLayout.setContentsMargins(1,0,5,0)
        self.mainLayout.setSpacing(2)

        self.labelWidget = QLabel()
        self.labelWidget.setMinimumWidth(mui.MQtUtil.dpiScale(98))
        self.labelWidget.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
        self.tagWidget = ComponentTagExpressionEdit(plugName=None)
        self.mainLayout.addWidget(self.labelWidget)
        self.mainLayout.addWidget(self.tagWidget)
        self.setLayout(self.mainLayout)

    def changeNode(self, nodeName, plugName):
        name = self.getAttributeLabel(plugName, getOptionVarValue('attrEditorIsLongName', 1))
        self.labelWidget.setText(name)
        self.tagWidget.setPlugName(plugName)
        self.tagWidget.geometryPlugName = self.getGeometryPlug(nodeName, plugName)
        self.refresh()

    def refresh(self):
        self.tagWidget.refreshComponentTagExpression()

    def getAttributeLabel(self, plugName, mode=1):
        if mode == 0:
            return maya.cmds.attributeName(plugName, s=True)
        elif mode == 2:
            return maya.cmds.attributeName(plugName, l=True)
        else:
            return maya.cmds.attributeName(plugName, n=True)

    # Method that is supposed to be overriden by a subclass to return the
    # plug that contains the geometry with all the tags to select from
    def getGeometryPlug(self, nodeName, plugName):
        return None
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
