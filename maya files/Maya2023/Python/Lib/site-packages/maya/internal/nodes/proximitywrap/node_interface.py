"""
proximityWrap -
    Module containing functions to edit the proximityWrap node
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


import maya.cmds

import maya.internal.common.utils.message as msg_utils
import maya.internal.common.utils.geometry as geo_utils
import maya.internal.common.utils.connections as con_utils
import maya.internal.nodes.geometryfilter.node_interface as gf_ifc

noneDriverLabel = maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kLabelSelectNone' ]

# ------------------------------------------------------------------------------
class NodeInterface(gf_ifc.NodeInterface):
    _mayaNodeType = 'proximityWrap'

    def __init__(self, nodeName):
        super(NodeInterface, self).__init__(nodeName)

    def getDriverIndices(self):
        indices = maya.cmds.getAttr(u'{0}.drivers'.format(self.editNode), multiIndices=True)
        return indices if indices else []

    def getNumDrivers(self):
        return len(self.getDriverIndices())

    def getValidDriverIndex(self, index=None):
        validIndices = self.getDriverIndices()
        if index is not None and index in validIndices:
            return index
        else:
            return validIndices[0] if len(validIndices) > 0 else None

    def getDriverPlug(self, index):
        return u'{0}.drivers[{1}]'.format(self.editNode, index)

    def getFreeDriverIndex(self):
        index = 0
        while index < 10000000:
            plugBase = self.getDriverPlug(index)
            if len( maya.cmds.connectionInfo(u'{0}.driverGeometry'.format(plugBase), sfd=True ) or [] ) == 0 and \
               len( maya.cmds.connectionInfo(u'{0}.driverBindGeometry'.format(plugBase), sfd=True ) or [] ) == 0 :
                return index
            index += 1
        return 0

    def deformableGeomTypeFilter(self):
        return geo_utils.GeomType.MeshNurbsCurve

    def driverGeomTypeFilter(self):
        return geo_utils.GeomType.MeshNurbs

    def addDriver(self, shapeNode, **kwargs):
        origPlug = geo_utils.getOrCreateOriginalGeometry(shapeNode)
        worldAttr = geo_utils.getWorldShapeOutAttr(shapeNode)

        index = self.getFreeDriverIndex()
        plugBase = self.getDriverPlug(index)

        if geo_utils.checkGeomType(shapeNode, geomType=self.driverGeomTypeFilter()):
            maya.cmds.connectAttr(origPlug, u'{0}.driverBindGeometry'.format(plugBase), force=True)
            maya.cmds.connectAttr(u'{0}.{1}[0]'.format(shapeNode,worldAttr), '{0}.driverGeometry'.format(plugBase), force=True)

            settableAttrs = [ 'driverWrapMode',
                              'driverStrength',
                              'driverFalloffStart',
                              'driverFalloffEnd',
                              'driverSmoothNormals',
                              'driverOverrideSmoothNormals',
                              'driverOverrideFalloffRamp' ]

            con_utils.setAttributes(plugBase, kwargs, settableAttrs)

            # Initialize the ramp if needed...
            rmpIndices = maya.cmds.getAttr(u'{0}.driverFalloffRamp'.format(plugBase), multiIndices=True)
            if rmpIndices is None or len(rmpIndices) == 0:
                maya.cmds.setAttr(u'{0}.driverFalloffRamp[0]'.format(plugBase), 0, 1.0, 2)
                maya.cmds.setAttr(u'{0}.driverFalloffRamp[1]'.format(plugBase), 1, 0.0, 2)

            return True
        else:
            msg_utils.showError(maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kErrMsgNoAddDriver' ].format(shapeNode))
            return False

    def removeDriver(self, shapeNode, connectedLookup):
            index = connectedLookup.get(shapeNode, None)
            if index is not None:
                maya.cmds.removeMultiInstance(self.getDriverPlug(index), b=True)
                return True
            else:
                return False

    def addDrivers(self, driverShapes, **kwargs):
        if len(driverShapes) == 0:
            msg_utils.showError(maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kErrMsgNoGeo' ])
            return False

        bendyShapes = self.getDeformedShapes()
        connectedLookup = self.getConnectedDrivers()

        added = list()
        skipped = list()

        for shape in driverShapes:
            if shape in list(connectedLookup.keys()) or shape in bendyShapes:
                skipped.append(shape)
            else:
                self.addDriver(shape, **kwargs)
                added.append(shape)

        if len(skipped) > 0:
            print (maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kInfoMsgDriverSkipped' ].format(str(skipped)))

        if len(added) == 0:
            msg_utils.showWarning(maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kWrnMsgNoAddedDriver' ])
        else:
            print (maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kInfoMsgDriverAdded' ].format(str(added)))

        return (len(added) > 0)

    def removeDrivers(self, driverShapes):

        connectedLookup = self.getConnectedDrivers()

        removed = list()
        for shape in driverShapes:
            if self.removeDriver(shape, connectedLookup):
                removed.append(shape)

        if len(removed) == 0:
            msg_utils.showWarning(maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kWrnMsgNoDeletedDriver' ])
        else:
            print (maya.stringTable['y_maya_internal_nodes_proximitywrap_node_interface.kInfoMsgDriverRemoved' ].format(str(removed)))

        return (len(removed) > 0)

    def filterAddShapesToDeformer(self, shapeNodes):
        '''
        Filter which shapes can be added
        '''
        # First get all shapes that are not being deformed as candidates
        toAddBase = super(NodeInterface, self).filterAddShapesToDeformer(shapeNodes)

        # Remove from that the ones being used as drivers or are of the wrong type
        toAdd = list()
        connectedLookup = self.getConnectedDrivers()
        for shape in toAddBase:
            if shape in list(connectedLookup.keys()):
                continue
            toAdd.append(shape)

        return toAdd

    def getConnectedDrivers(self):
        indices = self.getDriverIndices()
        lookup = dict()
        for index in indices:
            plugBase = self.getDriverPlug(index)
            for plugDriver in ['driverGeometry', 'driverBindGeometry']:
                plugName = u'{0}.{1}'.format(plugBase, plugDriver)
                cons = maya.cmds.listConnections(plugName, plugs=False, shapes=True, destination=False)
                if cons and len(cons) > 0:
                    lookup[cons[0]] = index
            for plugDriver in ['driverClusterMatrix', 'driverClusterRestMatrix']:
                plugName = u'{0}.{1}'.format(plugBase, plugDriver)
                cons = maya.cmds.listConnections(plugName, plugs=False, destination=False)
                if cons and len(cons) > 0:
                    lookup[cons[0]] = index
        return lookup

    def getWrapMode(self, index):
        plugName = u'{0}.driverWrapMode'.format(self.getDriverPlug(index))
        wm = maya.cmds.getAttr(plugName)
        if wm == 100: # global
            return maya.cmds.getAttr(u'{0}.wrapMode'.format(self.editNode))
        else:
            return wm

    def getMatrixDriverName(self, index, usePlugName=False, useCurrent=True):
        plugDriver = 'driverClusterMatrix' if useCurrent else 'driverClusterRestMatrix'
        plugName = u'{0}.{1}'.format(self.getDriverPlug(index), plugDriver)

        if usePlugName:
            cons = maya.cmds.listConnections(plugName, plugs=True, destination=False)
        else:
            cons = maya.cmds.listConnections(plugName, plugs=False, destination=False)
        return cons[0] if cons and len(cons) > 0 else None

    def getGeometryDriverName(self, index, usePlugName=False, useCurrent=True):
        plugDriver = 'driverGeometry' if useCurrent else 'driverBindGeometry'
        plugName = u'{0}.{1}'.format(self.getDriverPlug(index), plugDriver)

        if usePlugName:
            cons = maya.cmds.listConnections(plugName, plugs=True, destination=False)
        else:
            cons = maya.cmds.listConnections(plugName, plugs=False, shapes=True, destination=False)
        return cons[0] if cons and len(cons) > 0 else None

    def getDriverName(self, index, usePlugName=False, useCurrent=True):

        wm = self.getWrapMode(index)

        if wm != 4: # not matrix
            nm = self.getGeometryDriverName(index, usePlugName=usePlugName, useCurrent=useCurrent)
            if not nm:
                nm = self.getMatrixDriverName(index, usePlugName=usePlugName, useCurrent=useCurrent)
        else:
            nm = self.getMatrixDriverName(index, usePlugName=usePlugName, useCurrent=useCurrent)
            if not nm:
                nm = self.getGeometryDriverName(index, usePlugName=usePlugName, useCurrent=useCurrent)
            if not nm:
                nm = 'matrix'

        return nm if nm else ''

    def getCurrentDriverLookup(self, usePlugName=False):
        indices = self.getDriverIndices()
        lookup = {}
        for index in indices:
            curDriverName = self.getDriverName(index, usePlugName=usePlugName, useCurrent=True)
            if curDriverName:
                lookup[curDriverName] = index

        return lookup

# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
