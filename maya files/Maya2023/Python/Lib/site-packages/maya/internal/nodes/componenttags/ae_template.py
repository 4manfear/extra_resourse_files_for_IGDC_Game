import maya
maya.utils.loadStringResourcesForModule(__name__)

import maya.internal.common.ae.template as aetemplate

import maya.internal.common.utils.componenttag as ctag_utils
import maya.internal.common.utils.geometry as geo_utils
import maya.internal.common.qt.table as qt_table
import maya.internal.common.qt.buttons as qt_buttons
import maya.internal.common.utils.ui as ui_utils
import maya.cmds
import maya.api.OpenMaya as om
import fnmatch

from PySide2 import QtWidgets, QtCore, QtGui

compCtgLookup = { 'vtx' : om.MFnGeometryData.kVerts,
                  'cv' : om.MFnGeometryData.kVerts,
                  'pt' : om.MFnGeometryData.kVerts,
                  'f' : om.MFnGeometryData.kFaces,
                  'sf' : om.MFnGeometryData.kFaces,
                  'e' : om.MFnGeometryData.kEdges }

ctgDisplayNames = [ maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCtgAuto'],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCtgNull' ],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCtgVerts' ],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCtgEdges' ],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCtgFaces' ],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCtgUnsupported' ]]

CTG_ICON_VERTEX = ui_utils.createIcon(':/componentTag_vertex.png')
CTG_ICON_EDGE = ui_utils.createIcon(':/componentTag_edge.png')
CTG_ICON_FACE = ui_utils.createIcon(':/componentTag_face.png')

ctgIcon = [ None, None, CTG_ICON_VERTEX, CTG_ICON_EDGE, CTG_ICON_FACE, None ]

editModeNames = [ maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kEditNone'],
                  maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDirectWritable' ],
                  maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDirectReadOnly' ],
                  maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kProcedural' ]]

editModeToolTips = [ maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kToolTipNone'],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kToolTipDirectWritable' ],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kToolTipDirectReadOnly' ],
                    maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kToolTipProcedural' ]]

countSeparatorLabel = maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kCountSeparator' ]

class eModMode(object):
    kAdd = 0
    kRemove = 1
    kReplace = 2
    kClear = 3
    kAddFirst = 4

class eEditMode(object):
    kUnspecified = 0
    kDirectWritable = 1
    kDirectReadOnly = 2
    kProcedural = 3

class eFilterFlags(object):
    kVerts = 0
    kEdges = 1
    kFaces = 2
    kNull = 3
    kDirectWritable = 4
    kDirectReadOnly = 5
    kProcedural = 6
    kFinal = 7
    kLAST = 8

tagRenameFailMsg =maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kTagRenameFailedMsg' ]

FILTER_ICON = ui_utils.createIcon(':/filter.png')
FILTER_ACTIVE_ICON = ui_utils.createIcon(':/filter_active.png')

kOptVarFilterText = 'componentTagFilterText'
kOptVarFilterVerts = 'componentTagFilterVerts'
kOptVarFilterEdges = 'componentTagFilterEdges'
kOptVarFilterFaces = 'componentTagFilterFaces'
kOptVarFilterNull = 'componentTagFilterNull'
kOptVarFilterEditable = 'componentTagFilterEditable'
kOptVarFilterReadOnly = 'componentTagFilterReadOnly'
kOptVarFilterProcedural = 'componentTagFilterProcedural'
kOptVarFilterFinal = 'componentTagFilterFinal'

filterOptVarLookup = {
        eFilterFlags.kVerts : kOptVarFilterVerts,
        eFilterFlags.kEdges : kOptVarFilterEdges,
        eFilterFlags.kFaces : kOptVarFilterFaces,
        eFilterFlags.kNull : kOptVarFilterNull,
        eFilterFlags.kDirectWritable : kOptVarFilterEditable,
        eFilterFlags.kDirectReadOnly : kOptVarFilterReadOnly,
        eFilterFlags.kProcedural : kOptVarFilterProcedural,
        eFilterFlags.kFinal : kOptVarFilterFinal }

#-------------------------------------------------------------------------------
def _getOptVar(optVar, defaultValue):
    if maya.cmds.optionVar(exists=optVar):
        return maya.cmds.optionVar(q=optVar)
    return defaultValue

def _findInjectionPlug(plugChain, injectionNode):
     # find the plug in the plugChain that matches the injectionNode
    pfx = '{}.'.format(injectionNode)
    for p in plugChain:
        if p.startswith(pfx):
            return p
    return None

def _analyzeComponentCategories(compList):
    # Figure out which component categories exist in the specified componentList
    selCtg = set()
    if len(compList) == 0:
        selCtg.add(om.MFnGeometryData.kNull)
        return selCtg

    for cmp in compList:
        # cmp will look something like 'f[123:125]'
        ctg = compCtgLookup.get(cmp.split('[')[0], om.MFnGeometryData.kInvalid)
        selCtg.add(ctg)

    return selCtg

#-------------------------------------------------------------------------------
#
# ComponentTagsDlg is a simple class to disapy the dialogs for componentTag creation,
# deletion, editing etc...
#
#-------------------------------------------------------------------------------
labelOk = maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgOk']
labelCancel = maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgCancel']
labelEnterName = maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgEnterName' ]

class ComponentTagsDlg(object):

    @staticmethod
    def renameErrorDialog(currentTagName, newTagName):
        result = maya.cmds.confirmDialog(
                title=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgTitleRenameError' ],
                message=tagRenameFailMsg.format(currentTagName, newTagName),
                button=[labelOk],
                defaultButton=labelOk)

        if result == labelOk:
            return True
        return False

    @staticmethod
    def renameDialog(injectionNodeName, currentTagName):
        result = maya.cmds.promptDialog(
                title=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgTitleRename' ],
                text=currentTagName,
                message=labelEnterName,
                button=[labelOk, labelCancel],
                defaultButton=labelOk,
                cancelButton=labelCancel,
                dismissString=labelCancel)

        if result == labelOk:
            newTagName = maya.cmds.promptDialog(query=True, text=True).strip()
            if ctag_utils.renameTag(injectionNodeName, currentTagName, newTagName):
                return True, newTagName
            else:
                ComponentTagsDlg.renameErrorDialog(currentTagName, newTagName)

        return False, None

    @staticmethod
    def createErrorDialog(tagName):
        result = maya.cmds.confirmDialog(
            title=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgTitleCreateError' ],
            message=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgErrorCreate' ].format(tagName),
            button=[labelOk],
            defaultButton=labelOk)

        if result == labelOk:
            return True
        return False

    @staticmethod
    def createDialog(shapeNodeName):
        result = maya.cmds.promptDialog(
                title=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgTitleCreate' ],
                message=labelEnterName,
                button=[labelOk, labelCancel],
                defaultButton=labelOk,
                cancelButton=labelCancel,
                dismissString=labelCancel)

        if result == labelOk:
            tagName = maya.cmds.promptDialog(query=True, text=True)
            tagName = tagName.strip()
            injectionNode = ctag_utils.getInjectionNode(shapeNodeName)
            if ctag_utils.createTagWithSelection(shapeNodeName, injectionNode, tagName):
                return True
            else:
                ComponentTagsDlg.createErrorDialog(tagName)
        return False

    @staticmethod
    def deleteDialog(tagItemList):
        currentTagNames = [tagItem.key for tagItem in tagItemList]

        result = maya.cmds.confirmDialog(
                title=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgTitleDelete' ],
                message=maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kDlgConfirmDelete' ].format(' '.join(currentTagNames)),
                button=[labelOk, labelCancel],
                defaultButton=labelOk,
                cancelButton=labelCancel,
                dismissString=labelCancel)

        if result == labelOk:
            removedTag = False
            for tagItem in tagItemList:
                removedTag |= ctag_utils.deleteTag(tagItem.injectionNode, tagItem.key)
            return removedTag

        return False

#-------------------------------------------------------------------------------
#
# ComponentTagItemInfo holds all the information about a particular component tag and is
# stored with the widget item in the key column
#
# -------------------------------------------------------------------------------
class ComponentTagItemInfo(object):
    def __init__(self):
        self.key = None
        self.injectionNode = None
        self.injectionOrd = 0
        self.ctg = None
        self.affectCount = 0
        self.fullCount = 0
        self.modified = False
        self.final = True
        self.editMode = eEditMode.kUnspecified

    def decodeDict(self, componentTagDict):
        self.injectionNode = componentTagDict.get('node', None)
        self.key = componentTagDict.get('key', None)
        self.ctg = componentTagDict.get('category', 1)
        self.affectCount = componentTagDict.get('affectCount', 0)
        self.fullCount = componentTagDict.get('fullCount', 0)
        self.modified = componentTagDict.get('modified', False)
        self.final = componentTagDict.get('final', True)
        self.injectionOrd = componentTagDict.get('injectionOrder', 1)

        procedural = componentTagDict.get('procedural', False)
        editable = componentTagDict.get('editable', False)
        self.editMode = eEditMode.kDirectWritable
        if procedural:
            self.editMode = eEditMode.kProcedural
        elif not editable:
            self.editMode = eEditMode.kDirectReadOnly

    def filterMatch(self, filterFlags):
        if self.ctg == om.MFnGeometryData.kVerts and not filterFlags[eFilterFlags.kVerts]:
            return False
        if self.ctg == om.MFnGeometryData.kEdges and not filterFlags[eFilterFlags.kEdges]:
            return False
        if self.ctg == om.MFnGeometryData.kFaces and not filterFlags[eFilterFlags.kFaces]:
            return False
        if self.ctg == om.MFnGeometryData.kNull and not filterFlags[eFilterFlags.kNull]:
            return False
        if not self.final and filterFlags[eFilterFlags.kFinal]:
            return False

        if self.editMode == eEditMode.kDirectWritable and not filterFlags[eFilterFlags.kDirectWritable]:
            return False
        if self.editMode == eEditMode.kDirectReadOnly and not filterFlags[eFilterFlags.kDirectReadOnly]:
            return False
        if self.editMode == eEditMode.kProcedural and not filterFlags[eFilterFlags.kProcedural]:
            return False

        return True

    def isEditable(self):
        return self.editMode == eEditMode.kDirectWritable

#-------------------------------------------------------------------------------
#
# FilterAction is an action to trigger the filtering of a specific aspect of a
# component tag
#
# -------------------------------------------------------------------------------
class FilterAction(QtWidgets.QAction):
    def __init__(self, name, parent, filterType):
        checked = _getOptVar(filterOptVarLookup[filterType], True)
        super(FilterAction, self).__init__(name, parent, checkable=True, checked=checked)
        self.filterType = filterType

#-------------------------------------------------------------------------------
class ComponentTagStyledItemDelegate(QtWidgets.QStyledItemDelegate):
    def initStyleOption(self, option, index):
        super(ComponentTagStyledItemDelegate, self).initStyleOption(option, index)
        if index.column() == TagTableModel.kColCtg and option.features & QtWidgets.QStyleOptionViewItem.HasDecoration:
            # ensure that the icon is centered
            sz = option.decorationSize
            sz.setWidth(option.rect.width())
            option.decorationSize = sz

#-------------------------------------------------------------------------------
class TagTableModel(QtCore.QAbstractTableModel):
    """
    The TagTableModel class defines the interface of the tag history
    list for the UI components.
    """
    kColKey = 0
    kColCtg = 1
    kColInj = 2
    kColCnt = 3
    kColOrd = 4
    kColLAST = 5

    renamedTagSignal = QtCore.Signal(str,str)

    def __init__(self, parent, *args):
        QtCore.QAbstractTableModel.__init__(self, parent, *args)
        self.tagItems = []
        self.header = [maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColKey' ],
                       maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColCtg' ],
                       maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColInj' ],
                       maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColCnt' ],
                       maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColOrd' ]]
        self.headerTips = [maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColKeyTip' ],
                           maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColCtgTip' ],
                           maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColInjTip' ],
                           maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColAffTip' ],
                           maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kColOrdTip' ]]

        self.plugName = None
        self.shapeNodeName = None
        self.componentTagHistoryHash = None

    def rowCount(self, parent):
        return len(self.tagItems)

    def columnCount(self, parent):
        return len(self.header)

    def getTagItem(self, index):
        """Return the tagItem at the spcified index in the model"""
        if not index.isValid():
            return None
        if index.row() < len(self.tagItems):
            return self.tagItems[index.row()]
        else:
            return None

    def getIndexFromTagName(self, tagName):
        """Find the index for a tag with the specified name"""
        if tagName:
            for row,tagItem in enumerate(self.tagItems):
                if tagItem.key == tagName:
                    return self.createIndex(row, TagTableModel.kColKey)
        return QtCore.QModelIndex()

    def data(self, index, role):
        """Get data out of the model"""

        tagItem = self.getTagItem(index)
        if tagItem is None:
            return None
        col = index.column()

        # Display
        if role == QtCore.Qt.DisplayRole:
            if col == self.kColKey:
                return tagItem.key
            elif col == self.kColInj:
                if tagItem.modified:
                    return tagItem.injectionNode + '*'
                else:
                    return tagItem.injectionNode
            elif col == self.kColCnt:
                return '{}{}{}'.format(tagItem.affectCount, countSeparatorLabel, tagItem.fullCount)
            elif col == self.kColOrd:
                return str(tagItem.injectionOrd)
            else:
                return ''

        # Text Alignment
        elif role == QtCore.Qt.TextAlignmentRole:
            if col == self.kColKey or col == self.kColInj:
                return QtCore.Qt.AlignVCenter
            else:
                return QtCore.Qt.AlignCenter

        # Edit
        if role == QtCore.Qt.EditRole:
            if col == self.kColKey:
                return tagItem.key

        # Decoration
        elif role == QtCore.Qt.DecorationRole:
            if col == self.kColCtg:
                return ctgIcon[tagItem.ctg]

        # Foreground
        elif role == QtCore.Qt.ForegroundRole:
            if tagItem.editMode == eEditMode.kProcedural or tagItem.editMode == eEditMode.kDirectReadOnly:
                return QtGui.QColor(150, 150, 150)

        # Font
        elif role == QtCore.Qt.FontRole:
            if col == self.kColInj:
                if tagItem.editMode == eEditMode.kProcedural or tagItem.editMode == eEditMode.kDirectReadOnly:
                    fnt = QtWidgets.QApplication.font()
                    fnt.setItalic(True)
                    return fnt

        # Tooltip
        elif role == QtCore.Qt.ToolTipRole:
            if col == self.kColInj:
                return editModeToolTips[tagItem.editMode]

        return None

    def headerData(self, col, orientation, role):
        """Get data for the header"""
        if orientation == QtCore.Qt.Horizontal:
            if role == QtCore.Qt.DisplayRole:
                return self.header[col]
            elif role == QtCore.Qt.ToolTipRole:
                return self.headerTips[col]
        return None

    def setData(self, index, value, role):
        """Set new data in the model, like f.e. changing a tag name"""
        if not index.isValid() or index.column() != self.kColKey or role != QtCore.Qt.EditRole:
            return False

        tagItem = self.getTagItem(index)
        if tagItem is None:
            return False

        newTagName = value.strip()
        if not self._renameTag(tagItem, newTagName) and tagItem.key != newTagName:
            self.dataChanged.emit(index, index)
            return True

        return False

    def flags(self, index):
        """Return the flags that specify whether a certain index can be selected, edited, etc..."""
        flags = QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEnabled
        if index.column() == self.kColKey:
            tagItem = self.getTagItem(index)
            if tagItem and tagItem.editMode == eEditMode.kDirectWritable:
                flags |= QtCore.Qt.ItemIsEditable
        return flags

    def invalidateContents(self):
        """This ensures the list will be rebuild on the next update"""
        self.componentTagHistoryHash = None

    def modelPlug(self):
        """Returns the plug used to build up the model"""
        return self.plugName

    def shapeNode(self):
        """Returns the shape node used to build up the model"""
        return self.shapeNodeName

    def setModelPlug(self, plugName):
        """
        Sets the plug for building up the model. This will
        rebuild the contents if a change is detected
        """
        self.plugName = plugName
        self.shapeNodeName = self.plugName.split(".")[0]

        curHash = maya.cmds.geometryAttrInfo(plugName, chh=True)
        if curHash == self.componentTagHistoryHash:
            return

        self.componentTagHistoryHash = curHash
        self.layoutAboutToBeChanged.emit()

        # Start rebuilding the tagItems list
        self.tagItems = []

        cth = maya.cmds.geometryAttrInfo(self.plugName, cth=True)

        if cth is not None:
            # temporarily disable sorting before inserting new items
            row = 0

            for ctag in cth:
                tagItem = ComponentTagItemInfo()
                tagItem.decodeDict(ctag)
                self.tagItems.append(tagItem)
                row = (row+1)

        self.layoutChanged.emit()

    @ui_utils.undoChunk('rename component tag')
    def _renameTag(self, tagItem, newTagName):
        success = ctag_utils.renameTag(tagItem.injectionNode, tagItem.key, newTagName)
        if success:
            self.renamedTagSignal.emit(tagItem.key, newTagName)
        return success


#-------------------------------------------------------------------------------
class TagSortFilterProxyModel(QtCore.QSortFilterProxyModel):
    """
    Customized Sort/Filter proxy model for the component tags. This sits between
    the TagTableView and the TagTableModel to filter and sort the items.
    """

    filterFlagsChangedSignal = QtCore.Signal()

    def __init__(self, ui):
        super(TagSortFilterProxyModel,self).__init__()

        # Use case insentive filters and sorting order
        self.setFilterCaseSensitivity(QtCore.Qt.CaseInsensitive)
        self.setSortCaseSensitivity(QtCore.Qt.CaseInsensitive)

        self.filterText = _getOptVar(kOptVarFilterText, '')
        self.filterFlags = [ _getOptVar(filterOptVarLookup[i], True) for i in range(eFilterFlags.kLAST) ]

    def filterAcceptsRow(self, row, parent):
        """The basic filtering that decides whether a row will be shown"""
        model = self.sourceModel()
        index = model.index(row, 0, parent)

        tagItem = model.getTagItem(index)
        if tagItem is None:
            return False

        nameFilterActive = self.filterText != ''
        if nameFilterActive and not fnmatch.fnmatch(tagItem.key, self.filterText):
            return False

        if not tagItem.filterMatch(self.filterFlags):
            return False

        return True

    def getNameFilter(self):
        return self.filterText

    def setNameFilter(self, filterText):
        """Set the filter for the tag name"""
        txt = filterText.strip()
        if txt == '*':
            txt = ''

        if txt != self.filterText:
            self.filterText = txt
            maya.cmds.optionVar(sv=(kOptVarFilterText, self.filterText))
            self.invalidateFilter()

    def setFilterFlags(self, filterFlags):
        """Set filters for verts/edges/faces etc..."""
        if filterFlags != self.filterFlags:
            self.filterFlags = filterFlags
            # Save our settings
            for filterType in range(eFilterFlags.kLAST):
                maya.cmds.optionVar(iv=(filterOptVarLookup[filterType], self.filterFlags[filterType]))
            self.invalidateFilter()
            self.filterFlagsChangedSignal.emit()


    def lessThan(self, left, right):
        """Comparison of two items that is used for sorting the tagItem list"""
        col = left.column()

        model = self.sourceModel()
        li = self.sourceModel().getTagItem(left)
        ri = self.sourceModel().getTagItem(right)

        if col == TagTableModel.kColKey:
            return li.key < ri.key if li.key != ri.key else li.injectionOrd < ri.injectionOrd
        elif col == TagTableModel.kColInj:
            return li.injectionNode < ri.injectionNode if li.injectionNode != ri.injectionNode else li.key < ri.key
        elif col == TagTableModel.kColOrd:
            return li.injectionOrd < ri.injectionOrd if li.injectionOrd != ri.injectionOrd else li.key < ri.key
        elif col == TagTableModel.kColCtg:
            return li.ctg < ri.ctg
        elif col == TagTableModel.kColCnt:
            return li.affectCount < ri.affectCount if li.affectCount != ri.affectCount else li.fullCount < ri.fullCount

#-------------------------------------------------------------------------------
class TagTableView(qt_table.TableView):
    """
    The TableView widget that interacts with the TagTableModel to display
    the tag history list
    """
    def __init__(self):
        super(TagTableView, self).__init__()
        self.prepareTable()
        self.setSortingEnabled(True)

        self.clicked.connect( self.clickedOnComponentTag )
        self.filterText = _getOptVar(kOptVarFilterText, '')
        self.filterFlags = [ _getOptVar(filterOptVarLookup[i], True) for i in range(eFilterFlags.kLAST) ]

        delegate = ComponentTagStyledItemDelegate(self)
        self.setItemDelegate(delegate)
        self.setSelectionMode(QtWidgets.QAbstractItemView.ExtendedSelection)

        self.focusTagName = None

    def postInitialize(self):
        self.setColumnResizeMode(content=[TagTableModel.kColOrd, TagTableModel.kColCtg, TagTableModel.kColCnt],
                                 interactive=[TagTableModel.kColKey, TagTableModel.kColInj])

    def sizeHint(self):
        return QtCore.QSize(400, ui_utils.dpiScale(10*30+25))

    def tagSourceModel(self):
        """Return the original model containing the tagItems"""
        return self.model().sourceModel()

    def plugName(self):
        return self.tagSourceModel().modelPlug()

    def shapeNodeName(self):
        return self.tagSourceModel().shapeNodeName

    def getTagItem(self, index):
        """Get the tagItem at the specified index"""
        # The index is an index for the proxy model, so we need to
        # remap it to an index for the actual data model
        srcIndex = self.model().mapToSource(index)
        return self.tagSourceModel().getTagItem(srcIndex)

    def getSelectedTagItems(self):
        """Get all the tag items for each selected row"""
        srl = self.selectedIndexes()
        tagItemList = list()
        for index in srl:
            if (index.column() == TagTableModel.kColKey):
                tagItemList.append(self.getTagItem(index))
        return tagItemList

    def contextMenuEvent(self, event):
        """Create and execute the context menu for the selected item"""
        tagItemList = self.getSelectedTagItems()
        numSelectedTags = len(tagItemList)

        menu = QtWidgets.QMenu(self)
        selectAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionSelect' ])
        menu.addSection(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kModifyTagSection' ])
        renameAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionRename' ])
        deleteAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionDelete' ])
        duplicateAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionDuplicate' ])
        mergeAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionMerge' ])
        menu.addSection(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kModifyTagComponentsSection' ])
        addCompAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionCompAdd' ])
        remCompAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionCompRemove' ])
        repCompAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionCompReplace' ])
        clrCompAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionCompClear' ])
        menu.addSection(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kConvertSection' ])
        convertToFacesAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionConvertToFaces' ])
        convertToEdgesAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionConvertToEdges' ])
        convertToVertsAction = menu.addAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionConvertToVerts' ])

        # Is the node a shape node?
        isShape = geo_utils.checkGeomType(self.shapeNodeName())

        # Are all selected items editable?
        editable = numSelectedTags > 0 and all(tagItem.isEditable() for tagItem in tagItemList)

        # Are all selected items of the same category?
        tagCtg = om.MFnGeometryData.kNull if numSelectedTags == 0 else tagItemList[0].ctg
        ctgSame = all(tagItem.ctg == tagCtg for tagItem in tagItemList)

        if editable and isShape:
            # See what type of components we have selected in the viewport
            compSelection = ctag_utils.selectionToCompList(self.shapeNodeName())
            selCtg = _analyzeComponentCategories(compSelection)
            ctgMatch = len(selCtg) == 1 and all(tagItem.ctg in selCtg for tagItem in tagItemList)
            hasComp = not om.MFnGeometryData.kNull in selCtg
        else:
            compSelection = None
            ctgMatch = False
            hasComp = False

        # Enable and disable the menu items
        selectAction.setEnabled(numSelectedTags > 0 and isShape)
        deleteAction.setEnabled(editable)
        renameAction.setEnabled(editable and numSelectedTags==1)
        repCompAction.setEnabled(hasComp)
        addCompAction.setEnabled(hasComp and ctgMatch)
        remCompAction.setEnabled(hasComp and ctgMatch)
        clrCompAction.setEnabled(editable and any(tagItem.affectCount > 0 for tagItem in tagItemList))
        duplicateAction.setEnabled(numSelectedTags > 0)
        mergeAction.setEnabled(numSelectedTags > 1 and ctgSame)
        convertToFacesAction.setEnabled(editable and any(tagItem.ctg != om.MFnGeometryData.kFaces for tagItem in tagItemList))
        convertToEdgesAction.setEnabled(editable and any(tagItem.ctg != om.MFnGeometryData.kEdges for tagItem in tagItemList))
        convertToVertsAction.setEnabled(editable and any(tagItem.ctg != om.MFnGeometryData.kVerts for tagItem in tagItemList))

        # Start executing the menu
        updateNeeded = False
        action = menu.exec_(self.mapToGlobal(event.pos()))

        if action == selectAction:
            self._selectTags(tagItemList)
        elif action == renameAction:
            updateNeeded = self._renameTagWithDialog(tagItemList[0])
        elif action == deleteAction:
            updateNeeded = self._deleteTagWithDialog(tagItemList)
        elif action == duplicateAction:
            updateNeeded = self._duplicateTags(tagItemList)
        elif action == mergeAction:
            updateNeeded = self._mergeTags(tagItemList)
        elif action == repCompAction:
            updateNeeded = self._modifyComp(tagItemList, None, eModMode.kReplace)
        elif action == addCompAction:
            updateNeeded = self._modifyComp(tagItemList, compSelection, eModMode.kAdd)
        elif action == remCompAction:
            updateNeeded = self._modifyComp(tagItemList, compSelection, eModMode.kRemove)
        elif action == clrCompAction:
            updateNeeded = self._modifyComp(tagItemList, None, eModMode.kClear)
        elif action == convertToFacesAction:
            updateNeeded = self._convertComp(tagItemList, om.MFnGeometryData.kFaces)
        elif action == convertToEdgesAction:
            updateNeeded = self._convertComp(tagItemList, om.MFnGeometryData.kEdges)
        elif action == convertToVertsAction:
            updateNeeded = self._convertComp(tagItemList, om.MFnGeometryData.kVerts)

        if updateNeeded:
            # If needed immediate action can be taken here when something has changed
            pass

    def updateItems(self, plugName):
        # Check if we want to select the last created one
        if self.focusTagName is not None:
            srcIndex = self.tagSourceModel().getIndexFromTagName(self.focusTagName)
            if srcIndex.isValid():
                prxIndex = self.model().mapFromSource(srcIndex)
                self.selectionModel().select(prxIndex, QtCore.QItemSelectionModel.ClearAndSelect)

                if prxIndex.row() == 0:
                    self.scrollToTop()
                elif (prxIndex.row()+1) == self.model().rowCount():
                    self.scrollToBottom()
                else:
                    self.scrollTo(prxIndex)

        self.focusTagName = None

    def _getComponents(self, tagItem):
        # Find the component from the injection point
        plugChain = maya.cmds.geometryAttrInfo(self.plugName(), och=True)
        injectionPlug = _findInjectionPlug(plugChain, tagItem.injectionNode)
        if injectionPlug:
            return maya.cmds.geometryAttrInfo(injectionPlug, cex=tagItem.key, cmp=True)
        else:
            return None

    def _selectComponents(self, shapeNodeName, comp, mode=eModMode.kReplace):
        if comp and geo_utils.checkGeomType(shapeNodeName):
            args = []
            for c in comp:
                args.append('{0}.{1}'.format(shapeNodeName, c))

            if mode == eModMode.kReplace:
                maya.cmds.select(*args, r=True)
            elif mode == eModMode.kAdd:
                maya.cmds.select(*args, add=True)
            elif mode == eModMode.kAddFirst:
                maya.cmds.select(*args, af=True)
            elif mode == eModMode.kRemove:
                maya.cmds.select(*args, d=True)

    @ui_utils.undoChunk('select component tag')
    def _selectTags(self, tagItemList):
        first = True
        for tagItem in tagItemList:
            comp = self._getComponents(tagItem)
            if comp:
                self._selectComponents(self.shapeNodeName(), comp, mode=eModMode.kReplace if first else eModMode.kAdd)
                first = False

        if first: # We failed, so just select the total shape without components
            maya.cmds.select(self.shapeNodeName(), r=True)

    @ui_utils.undoChunk('create component tag')
    def _createTagWithDialog(self, tagItem):
        return ComponentTagsDlg.createDialog(self.shapeNodeName())

    @ui_utils.undoChunk('create component tag')
    def _createTag(self):
        tagName = ctag_utils.getFreeTagName(self.plugName())
        injectionNode = ctag_utils.getInjectionNode(self.shapeNodeName())
        if injectionNode is None:
            return False
        self.focusTagName = tagName
        return ctag_utils.createTagWithSelection(self.shapeNodeName(), injectionNode, tagName)

    @ui_utils.undoChunk('merge component tag')
    def _mergeTags(self, tagItemList):
        tagName, injectionNode = ctag_utils.createNewTag(self.shapeNodeName(), baseName='mergedTag')
        if tagName is None:
            return False

        saveSelection = maya.cmds.ls(selection=True)
        self._selectTags(tagItemList)
        ctag_utils.setTagToSelection(self.shapeNodeName(), injectionNode, tagName)
        maya.cmds.select(saveSelection, r=True)
        self.focusTagName = tagName
        return True

    @ui_utils.undoChunk('duplicate component tag')
    def _duplicateTags(self, tagItemList):
        for tagItem in tagItemList:
            tagName, injectionNode = ctag_utils.createNewTag(self.shapeNodeName(), baseName=tagItem.key)
            comp = self._getComponents(tagItem)
            if comp:
                ctag_utils.setTagToComponents(injectionNode, tagName, comp)
            self.focusTagName = tagName
        return True

    @ui_utils.undoChunk('rename component tag')
    def _renameTagWithDialog(self, tagItem):
        success, newName = ComponentTagsDlg.renameDialog(tagItem.injectionNode, tagItem.key)
        if success:
            self.renamedTag(tagItem.key, newName)
        return success

    @ui_utils.undoChunk('delete component tag')
    def _deleteTagWithDialog(self, tagItemList):
        return ComponentTagsDlg.deleteDialog(tagItemList)

    @ui_utils.undoChunk('delete component tag')
    def _deleteTags(self, tagItemList):
        removed = False
        for tagItem in tagItemList:
            if tagItem.isEditable() and ctag_utils.deleteTag(tagItem.injectionNode, tagItem.key):
                removed = True
        return removed

    @ui_utils.undoChunk('modify component tag components')
    def _modifyComp(self, tagItemList, compSelection, mode):
        modified = False
        if mode == eModMode.kReplace:
            for tagItem in tagItemList:
                modified |= ctag_utils.setTagToSelection(self.shapeNodeName(), tagItem.injectionNode, tagItem.key)
            return modified

        saveSelection = maya.cmds.ls(selection=True)

        for tagItem in tagItemList:
            if mode == eModMode.kClear:
                maya.cmds.select( clear=True )
            else:
                if tagItem.ctg == om.MFnGeometryData.kNull or tagItem.affectCount == 0:
                    maya.cmds.select( clear=True )
                else:
                    comp = self._getComponents(tagItem)
                    self._selectComponents(self.shapeNodeName(), comp, eModMode.kReplace)
                self._selectComponents(self.shapeNodeName(), compSelection, mode=mode)

            modified |= ctag_utils.setTagToSelection(self.shapeNodeName(), tagItem.injectionNode, tagItem.key)

        maya.cmds.select(saveSelection, r=True)
        return modified

    @ui_utils.undoChunk('convert component tag components')
    def _convertComp(self, tagItemList, ctg):
        for tagItem in tagItemList:
            if tagItem.ctg != ctg:
                ctag_utils.convertTagCategory(tagItem.injectionNode, tagItem.key, ctg)
        return True

    @QtCore.Slot(int, int)
    def clickedOnComponentTag(self, index):
        if index.isValid() and index.column() == TagTableModel.kColCtg:
            self._selectTags([self.getTagItem(index)])

    @QtCore.Slot()
    def createTag(self):
        self._createTag()

    @QtCore.Slot()
    def removeCurrentTag(self):
        self._deleteTags(self.getSelectedTagItems())

    @QtCore.Slot()
    def renamedTag(self, oldTagName, newTagName):
        self.focusTagName = newTagName

#-------------------------------------------------------------------------------
class ComponentTagWidget(QtWidgets.QWidget):
    """
    The total widget for the tag history list. This contains the filtering
    widgets, the add/remove buttons and the actual table view
    """
    def __init__(self, uiParent=None):
        super(ComponentTagWidget, self).__init__()
        self.plugName = None
        self.uuid = None
        self.mainLayout = QtWidgets.QVBoxLayout()

        # Filtering
        self.topBarLayout = QtWidgets.QHBoxLayout()
        self.topBarLayout.setSpacing(2)

        self.filterNameLineEdit = QtWidgets.QLineEdit()
        self.filterNameLineEdit.setPlaceholderText(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kSearch' ])
        self.filterNameLineEdit.setToolTip(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kAnnotSearch' ])

        self.filterNameLineEdit.editingFinished.connect(self.tagFilterTextChanged)
        self.filterButton = QtWidgets.QPushButton()
        self.filterButton.setToolTip(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kAnnotFilter' ])

        # Make filter menu
        self.filterMenu = QtWidgets.QMenu(self)
        self.clearFilterAction = QtWidgets.QAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltClear' ], self.filterMenu)
        self.fullFilterAction = QtWidgets.QAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltFull' ], self.filterMenu)
        self.filterMenu.addAction(self.clearFilterAction)
        self.filterMenu.addAction(self.fullFilterAction)

        self.filterMenu.addSection(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kFilterTypesSection' ])
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltVerts' ], self.filterMenu, eFilterFlags.kVerts))
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltEdges' ], self.filterMenu, eFilterFlags.kEdges))
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltFaces' ], self.filterMenu, eFilterFlags.kFaces))
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltNull' ], self.filterMenu, eFilterFlags.kNull))

        self.filterMenu.addSection(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kFilterEditSection' ])
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltEditables' ], self.filterMenu, eFilterFlags.kDirectWritable))
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltReadOnly' ], self.filterMenu, eFilterFlags.kDirectReadOnly))
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltProcedural' ], self.filterMenu, eFilterFlags.kProcedural))
        self.filterMenu.addSection(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kFilterDefinitionSection' ])
        self.filterMenu.addAction(FilterAction(maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kActionFltFinal' ], self.filterMenu, eFilterFlags.kFinal))

        self.filterMenu.aboutToShow.connect(self.setFilterFlagsOnMenu)
        self.filterMenu.triggered.connect(self.tagFilterMenuChanged)

        self.filterButton.setMenu(self.filterMenu)
        self.topBarLayout.addWidget(self.filterNameLineEdit)
        self.topBarLayout.addWidget(self.filterButton)

        self.addTagButton, self.remTagButton = qt_buttons.makeItemAddDelIconButtons(
                maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kTagAdd' ],
                maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kTagRemove' ])

        spacer = QtWidgets.QSpacerItem(20, 5, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Minimum)
        self.topBarLayout.addItem(spacer)
        self.topBarLayout.addWidget(self.addTagButton)
        self.topBarLayout.addWidget(self.remTagButton)

        # ComponentTags list
        self.tagProxyModel = TagSortFilterProxyModel(self)
        self.tagSourceModel = TagTableModel(self)
        self.tagTable = TagTableView()
        self.tagTable.setModel(self.tagProxyModel)
        self.tagProxyModel.setSourceModel(self.tagSourceModel)

        self.tagTable.selectionModel().selectionChanged.connect(self.tagListSelectionChangedSlot)
        self.tagSourceModel.renamedTagSignal.connect(self.tagTable.renamedTag)

        self.tagTable.postInitialize()

        self.mainLayout.addLayout(self.topBarLayout)
        self.mainLayout.addWidget(self.tagTable)

        # Finish up the layout
        self.tagProxyModel.filterFlagsChangedSignal.connect(self.updateFilterButton)
        self.addTagButton.clicked.connect(self.tagTable.createTag)
        self.remTagButton.clicked.connect(self.tagTable.removeCurrentTag)

        self.updateFilterButton()
        self.filterNameLineEdit.setText(self.tagProxyModel.getNameFilter())
        self.setLayout(self.mainLayout)

    def changeNode(self, nodeName, plugName):
        if self.plugName != plugName:
            self.plugName = plugName
            self.tagSourceModel.invalidateContents()

        uuid = maya.cmds.ls(nodeName, uuid=True)
        if uuid != self.uuid:
            self.uuid = uuid
            self.tagSourceModel.invalidateContents()

        self.refresh()

    def clear(self):
        if self.tagSourceModel is not None:
            self.tagSourceModel.invalidateContents()

    def refresh(self):
        self.tagSourceModel.setModelPlug(self.plugName)
        self.tagTable.updateItems(self.plugName)
        self.updateTopBar()

    def updateTopBar(self):
        tagItemList = self.tagTable.getSelectedTagItems()
        editable = len(tagItemList) and all(tagItem.isEditable() for tagItem in tagItemList)
        self.remTagButton.setEnabled(editable)

    @QtCore.Slot()
    def tagFilterTextChanged(self):
        #self.tagProxyModel.setFilterWildcard(filterText)
        self.tagProxyModel.setNameFilter(self.filterNameLineEdit.text())
        self.filterNameLineEdit.setText(self.tagProxyModel.getNameFilter())

    @QtCore.Slot()
    def tagListSelectionChangedSlot(self, selected, deselected):
        self.updateTopBar()

    @QtCore.Slot()
    def tagFilterMenuChanged(self, action):
        if action == self.clearFilterAction:
            self.tagProxyModel.setFilterFlags([ False for i in range(eFilterFlags.kLAST) ])
        elif action == self.fullFilterAction:
            self.tagProxyModel.setFilterFlags([ True for i in range(eFilterFlags.kLAST) ])
        else:
            filterFlags = [ True for i in range(eFilterFlags.kLAST) ]
            acts = self.filterMenu.actions()
            for a in acts:
                if isinstance(a, FilterAction):
                    filterFlags[a.filterType] = a.isChecked()
            self.tagProxyModel.setFilterFlags(filterFlags)

    @QtCore.Slot()
    def setFilterFlagsOnMenu(self):
        self.clearFilterAction.setEnabled(True in self.tagProxyModel.filterFlags)
        self.fullFilterAction.setEnabled(False in self.tagProxyModel.filterFlags)

        acts = self.filterMenu.actions()
        for a in acts:
            if isinstance(a, FilterAction):
                checked = _getOptVar(filterOptVarLookup[a.filterType], True)
                a.setChecked(checked)

    @QtCore.Slot()
    def updateFilterButton(self):
        if False in self.tagProxyModel.filterFlags:
            self.filterButton.setIcon(FILTER_ACTIVE_ICON)
        else:
            self.filterButton.setIcon(FILTER_ICON)

#-------------------------------------------------------------------------------
class AETemplate(aetemplate.Template):
    def __init__(self, nodeName):
        self.nodeName = nodeName
        self.buildUI(nodeName)

    def buildUI(self, nodeName):
        lsctb =  maya.cmds.ls(nodeName, type="componentTagBase")
        if lsctb and len(lsctb) > 0:
            with aetemplate.Layout(self, maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kAttrHeader2' ], collapse=True):
                self.defineQtCustom(ComponentTagWidget, "outputGeometry")
            return

        lso =  maya.cmds.deformableShape(nodeName, lso=True)
        if lso and len(lso) > 0:
            with aetemplate.Layout(self, maya.stringTable['y_maya_internal_nodes_componenttags_ae_template.kAttrHeader' ], collapse=True):
                self.defineQtCustom(ComponentTagWidget, lso[0])

        # Since we are handling the attribute in the custom widget, suppress the automatic one
        self.suppress("componentTags")

# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
