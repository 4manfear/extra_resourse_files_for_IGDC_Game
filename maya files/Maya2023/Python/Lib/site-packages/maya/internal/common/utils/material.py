import maya.cmds
import maya.internal.common.utils.connections as con_utils
import maya.internal.common.utils.componenttag as ctag_utils

#-----------------------------------------------------------------------------------------------------------------------
class Bind(object):

    def __init__(self, bindPlug, shadingEngine, mode=0, defaultBind=False):
        self.bindPlug = bindPlug
        self.shadingEngine = shadingEngine
        self.groupId = -1
        self.cmp = None
        self.groupPartsNode = None
        self.defaultBind = defaultBind
        self.mode = mode

        if not self.defaultBind:
            groupIdAttr = ['objectGroupId', 'compObjectGroupId']
            cmpAttr = ['objectGrpCompList', 'compObjectGrpCompList']
            attr = '{}.{}'.format(self.bindPlug, groupIdAttr[self.mode])
            self.groupId = maya.cmds.getAttr(attr)
            self.groupIdNode = con_utils.getSourceNode(attr)
            groupIdPlug = con_utils.getSourcePlug(attr)
            self.cmp = maya.cmds.getAttr('{}.{}'.format(self.bindPlug, cmpAttr[self.mode]))

            # Find the groupPart node we are connected to
            cons = maya.cmds.listConnections(groupIdPlug, source=False, destination=True, type='groupParts') or []
            self.groupPartsNode = cons[0] if len(cons) > 0 else None

#-----------------------------------------------------------------------------------------------------------------------
class InstanceBinds(object):
    def __init__(self, instanceNum):
        self.instanceNum = instanceNum
        self.shadBinds = list()

    def show(self):
        print ('Instance {}'.format(self.instanceNum))
        for b in self.shadBinds:
            # Find the groupPart node we are connected to
            print ('    {} : {} {}  {}'.format(b.groupId, b.shadingEngine, b.groupPartsNode, b.cmp))

#-----------------------------------------------------------------------------------------------------------------------
class MaterialBindClassic(object):
    def __init__(self):
        self.shape = None
        self.instanceBinds = []
        self.numInstances = 0

    def _collecInstanceBinds(self, instanceId, mode):

        instAttr = ['instObjGroups', 'compInstObjGroups']
        objectGroupsAttr = ['objectGroups', 'compObjectGroups']

        instObjGroupsPlug = '{}.{}'.format(self.shape, instAttr[mode])
        instObjGroupsIndexPlug = '{}[{}]'.format(instObjGroupsPlug, instanceId)
        objGroupsPlug = '{}.{}'.format(instObjGroupsIndexPlug, objectGroupsAttr[mode])

        shadBinds = []

        # See if anything is hooked up to the top level plug which means the default bind
        cons = maya.cmds.listConnections(instObjGroupsIndexPlug, source=False, destination=True) or []
        for node in cons:
            ot =  maya.cmds.objectType(node)
            if ot == 'shadingEngine':
                shadBinds.append(Bind(instObjGroupsIndexPlug, node, mode, defaultBind=True))

        # Check what is connected to the children of the plug
        indices = maya.cmds.getAttr(objGroupsPlug, multiIndices=True) or []
        for j in indices:
            objGroupsIndexPlug = '{}[{}]'.format(objGroupsPlug, j)

            cons = maya.cmds.listConnections(objGroupsIndexPlug, source=False, destination=True) or []
            for node in cons:
                ot =  maya.cmds.objectType(node)
                if ot == 'shadingEngine':
                    shadBinds.append(Bind(objGroupsIndexPlug, node, mode))

        return shadBinds


    def collect(self, shape):
        self.shape = shape
        instObjGroupsPlug = '{}.instObjGroups'.format(self.shape)

        self.instanceBinds = []
        self.numInstances = maya.cmds.getAttr(instObjGroupsPlug, size=True)

        for i in range(0, self.numInstances):
            shadBinds = self._collecInstanceBinds(i, mode=0)
            compShadBinds = self._collecInstanceBinds(i, mode=1)

            if len(compShadBinds) > 0:
                shadBinds.extend(compShadBinds)

            if len(shadBinds) > 0:
                instBind = InstanceBinds(i)
                instBind.shadBinds = shadBinds
                self.instanceBinds.append(instBind)

    def isEmpty(self):
        return len(self.instanceBinds) == 0

    def size(self):
        return len(self.instanceBinds)

    def show(self):
        print ('Classic binds on {}'.format(self.shape))
        for ib in self.instanceBinds:
            ib.show()

#-----------------------------------------------------------------------------------------------------------------------
class MaterialBindModern(object):
    def __init__(self):
        self.shape = None
        self.instanceBinds = []
        self.numInstances = 0

    def collect(self, shape):
        self.shape = shape
        self.instanceBinds = []

        plug = '{}.instMaterialAssign'.format(shape)
        self.numInstances = maya.cmds.getAttr(plug, size=True)

        for i in range(0, self.numInstances):
            instPlug = '{}[{}]'.format(plug, i)
            srcNode = con_utils.getSourceNode(instPlug)
            if srcNode:
                ot =  maya.cmds.objectType(srcNode)
                if ot == 'materialTemplate':
                    self.instanceBinds.append((i, srcNode))

    def isEmpty(self):
        return len(self.instanceBinds) == 0

    def size(self):
        return len(self.instanceBinds)

    def show(self):
        print ('Modern binds on {}'.format(self.shape))
        for ib in self.instanceBinds:
            print ('    {} : {}'.format(ib[0], ib[1]))

#-----------------------------------------------------------------------------------------------------------------------
#
#
#
#-----------------------------------------------------------------------------------------------------------------------
class MaterialBindConverter(object):
    def __init__(self):
        self.modern = MaterialBindModern()
        self.classic = MaterialBindClassic()

    def _baseName(self, shapeName):
        parts = shapeName.rsplit(':',1)
        ns = parts[0] if len(parts) > 1 else None
        leafName =shapeName.split('|')[-1]
        return leafName if ns is None else '{}:{}'.format(ns, leafName)

    def _generateTemplateNodeName(self, instanceNum):
        name = '{}_materialTemplate'.format(self._baseName(self.shape))
        if self.hasInstances:
            name = '{}_{}'.format(name, instanceNum)
        return name

    def parseBind(self, mtlInterface, classicShadBind):

        if classicShadBind.defaultBind:
            self.usedFullBindPlugs.append(classicShadBind.bindPlug)
            tagName = '*'
        else:
            if classicShadBind.cmp is None:
                return

            bindIndex = mtlInterface.getFreeIndex()
            base = mtlInterface.getEditNode().replace(':', '_')
            tagName = u'{}_idx{}_Mtl'.format(base, bindIndex).strip('_')

            ctag_utils.createTag(self.injectionNode, tagName, classicShadBind.cmp)
            self.usedBindPlugs.append(classicShadBind.bindPlug)

            if classicShadBind.groupPartsNode:
                self.usedGroupPartNodes.add(classicShadBind.groupPartsNode)
            elif classicShadBind.groupIdNode:
                self.usedGroupIdNodes.add(classicShadBind.groupIdNode)

        mtlInterface.appendAssignment(classicShadBind.shadingEngine, tagName)

    def parseInstance(self, classicInstance):
        instanceNum = classicInstance.instanceNum

        mtlAssignPlug = '{}.instMaterialAssign[{}]'.format(self.shape, instanceNum)

        if len(classicInstance.shadBinds) == 1:
            classicShadBind = classicInstance.shadBinds[0]
            if classicShadBind.defaultBind:
                # We have only one bind to the whole geometry
                self.usedFullBindPlugs.append(classicShadBind.bindPlug)
                maya.cmds.connectAttr('{}.message'.format(classicShadBind.shadingEngine), mtlAssignPlug, f=True)
                return

        # We need to make a material template to convert the classic material bindings
        bindNode = maya.cmds.createNode('materialTemplate', n=self._generateTemplateNodeName(instanceNum))
        maya.cmds.connectAttr('{}.message'.format(bindNode), mtlAssignPlug, f=True)

        from maya.internal.nodes.materialtemplate.node_interface import NodeInterface as MaterialTemplateNodeInterface
        mtlInterface = MaterialTemplateNodeInterface(bindNode)

        # Fill in the materials assignments for this instance
        for shadBind in classicInstance.shadBinds:
            self.parseBind(mtlInterface, shadBind)

    def cleanup(self):
        # Remove all the used instObjGroup plugs
        for bindPlug in self.usedBindPlugs:
            maya.cmds.removeMultiInstance(bindPlug, b=True )

        # Disconnect the used instObjGroup plugs for full geometries
        for bindPlug in self.usedFullBindPlugs:
                cons = maya.cmds.listConnections(bindPlug, c=False, p=True, s=False, d=True) or []
                for p in cons:
                    maya.cmds.disconnectAttr(bindPlug, p)

        # Remove all the used groupParts nodes
        for groupPartsNode in self.usedGroupPartNodes:
            # Delete the groupParts node. That should also delete the groupId node
            maya.cmds.delete(groupPartsNode)

        # Remove all the used groupId nodes not connected to a groupParts node
        for groupIdNode in self.usedGroupIdNodes:
            # Delete the groupId node.
            maya.cmds.delete(groupIdNode)

    def convert(self, shape):
        if not maya.cmds.objExists(shape) or maya.cmds.referenceQuery(shape, isNodeReferenced=True):
            return False

        self.modern.collect(shape)
        if not self.modern.isEmpty():
            # already converted
            return False

        self.classic.collect(shape)
        if self.classic.isEmpty():
            # nothing to convert
            return False

        self.shape = shape
        self.usedGroupPartNodes = set()
        self.usedGroupIdNodes = set()
        self.usedBindPlugs = list()
        self.usedFullBindPlugs = list()

        self.hasInstances = self.classic.size() > 1

        # Get the shape on which we want to generate the new componentTags (if needed)
        self.injectionNode = ctag_utils.getInjectionNode(shape)

        for ib in self.classic.instanceBinds:
            self.parseInstance(ib)

        # Cleanup
        self.cleanup()

        return True

#-------------------------------------------------------------------------------
def classificationsSuitableFor(shapeNodeName):
    #
    # Description:
    #	This procedure determines the classifications of shaders or shader
    #	types most appropriate to the shape.

    itemRenderType = -1;
    particleRenderType = -1;
    if shapeNodeName:
        #  An item has been specified to which the new shader should be
        #  assigned. We will attempt to determine its render type and/or
        #  particle render type.
        plugName = '{}.renderType'.format(shapeNodeName)
        lsResult = maya.cmds.ls(plugName)
        if lsResult:
            itemRenderType =  maya.cmds.getAttr(plugName)

        plugName = '{}.particleRenderType'.format(shapeNodeName)
        lsResult = maya.cmds.ls(plugName)
        if lsResult:
            particleRenderType =  maya.cmds.getAttr(plugName)

    classifications = list()

    if particleRenderType == 8 or particleRenderType == 9:
        # The object is a cloud or tube particle render type.
        # Only particle shaders are valid for this type.
        classifications.append('shader/volume/particle')
    elif itemRenderType == 0:
        # The object is a "surface" render type.
        classifications.append('shader/surface')
    elif itemRenderType == 1:
        # The object is a "volume" render type.
        classifications.append('shader/volume/fog')
    else:
        # The object is neither a "surface" nor "volume" render type.
        # Most likely we got to here because no shapeNodeName was specified.
        classifications.append('shader/surface')
        classifications.append('shader/volume')

    return classifications


#-------------------------------------------------------------------------------
def findMaterialCandidateTypesForShape(shapeNodeName):
    #
    # Description:
    #	This procedure is get all existing shaders which can
    #	be assigned to the specified shapeNodeName
    #
    shapeMaterialTypes = list()

    # Determine the classifications of shaders which would be most appropriate
    # to assign to the specified item. If the shape is unspecified, this will
    # return the most commonly appropriate classifications.
    classificationArray = classificationsSuitableFor(shapeNodeName)

    for cf in classificationArray:
        # Get a list of all node types which are classified according to the
        # current classification
        shadTypes = maya.cmds.listNodeTypes(cf)
        shapeMaterialTypes.extend(shadTypes)

    return shapeMaterialTypes

#-------------------------------------------------------------------------------
def findMaterialCandidatesForShape(shapeNodeName):
    #
    # Description:
    #	This procedure is get all existing shaders which can
    #	be assigned to the specified shapeNodeName.
    #
    shapeMaterialTypes = findMaterialCandidateTypesForShape(shapeNodeName)

    shapeMaterials = list()
    if len(shapeMaterialTypes) == 0:
        return shapeMaterials

    for shadType in shapeMaterialTypes:
        # Get a list of all material nodes which have the current node shadType
        materialArray = maya.cmds.ls(exactType=shadType)
        shapeMaterials.extend(materialArray)

    return shapeMaterials

#-------------------------------------------------------------------------------
def findDefaultShadingEngineForShape(shapeNodeName):
    # How do we get the default shading group? use a hard-coded name for now...
    shadEngine = 'initialShadingGroup'
    if maya.cmds.objExists(shadEngine) and maya.cmds.objectType(shadEngine, isType='shadingEngine'):
        return shadEngine

    return None

#-------------------------------------------------------------------------------
def findMaterialsFromShadingEngine(shadEngine):
    materials = list()
    if maya.cmds.objExists(shadEngine) and maya.cmds.objectType(shadEngine, isType='shadingEngine'):
        cons = maya.cmds.listConnections('{0}.message'.format(shadEngine), source=False, destination=True, type='materialInfo') or []
        if len(cons) == 0:
            srcNode = con_utils.getSourceNode( '{}.surfaceShader'.format(shadEngine))
            if srcNode:
                materials.append(srcNode)
        else:
            for c in cons:
                srcNode = con_utils.getSourceNode( '{}.material'.format(c))
                if srcNode:
                    materials.append(srcNode)
    return materials


#-------------------------------------------------------------------------------
def findShadingEngineFromMaterial(material):
    shadEngines = list()
    cons = maya.cmds.listConnections('{0}.message'.format(material), source=False, destination=True, type='materialInfo') or []
    for c in cons:
        srcNode = con_utils.getSourceNode( '{}.shadingGroup'.format(c))
        if srcNode:
            shadEngines.append(srcNode)
    return shadEngines

#-------------------------------------------------------------------------------
def createNewMaterial(materialType):
    material = maya.cmds.shadingNode(materialType, asShader=True)
    shadEngine = maya.cmds.sets(name='{}SG'.format(material), renderable=True, noSurfaceShader=True, empty=True)
    maya.cmds.defaultNavigation(connectToExisting=True, source=material, destination=shadEngine)
    return shadEngine

#-------------------------------------------------------------------------------
def createNewMaterialTemplate(shapeNodeName):
    materialTemplate = maya.cmds.createNode('materialTemplate')
    shadEngine = findDefaultShadingEngineForShape(shapeNodeName)
    if shadEngine:
        plugBase = u'{0}.assign[0]'.format(materialTemplate)
        maya.cmds.connectAttr('{}.message'.format(shadEngine), '{}.shadingEngine'.format(plugBase), f=True)
        maya.cmds.setAttr('{}.componentTagExpression'.format(plugBase), '*', type='string')
        #maya.cmds.connectAttr(_NOL10N('{}.message').format(shadEngine), _NOL10N('{}.defaultShadingEngine').format(materialTemplate), f=True)
    return materialTemplate
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
