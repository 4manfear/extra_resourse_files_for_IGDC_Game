import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Maya Instruction on how to create a control for any multi attribute

Multi attribute will delegates subelement ui creation using corresponding type

Read the Readme.md for further information
'''

from builtins import range
import maya.cmds as cmds
import maya.mel as mel
from . import template
import re
from maya.common.ui import LayoutManager, ParentManager

MaxNonNumericMultis = 20

# ------------------------------------------------------------------------------
def getAttributeUILabel(plugName):
    ovar = 'attrEditorIsLongName'
    mode = maya.cmds.optionVar(q=ovar) if maya.cmds.optionVar(ex=ovar) else 1

    if mode == 0:
        return maya.cmds.attributeName(plugName, s=True)
    elif mode == 2:
        return maya.cmds.attributeName(plugName, l=True)
    else:
        return maya.cmds.attributeName(plugName, n=True)

# ------------------------------------------------------------------------------
def replace(parent, nodeName, attribute, selectionConnection, changedCommand ):
    if selectionConnection != "":
        cmds.selectionConnection(selectionConnection, e=True, obj=nodeName)
    template.attachCallback(nodeName + "." + attribute, parent, changedCommand)

# ------------------------------------------------------------------------------
def create(nodeName, attribute, attrUiName, changedCommand):

    #evaluate global mel variable, that is bad...
    #TODO: refactor this to avoid evaluate mel and transform that to user preference
    gChannelBoxWidgetWidthIndex = mel.eval("global int $gChannelBoxWidgetWidthIndex; $gChannelBoxWidgetWidthIndex += 0")
    gTextColumnWidthIndex = mel.eval("global int $gTextColumnWidthIndex; $gTextColumnWidthIndex += 0")
    gChannelBoxWidgetHeightIndex = mel.eval("global int $gChannelBoxWidgetHeightIndex; $gChannelBoxWidgetHeightIndex += 0")


    cmds.setUITemplate("attributeEditorTemplate", pushTemplate=True)
    baseLayout = cmds.frameLayout(l=attrUiName)#outermost layout must be returned later
    with LayoutManager(baseLayout):
        with LayoutManager(cmds.columnLayout(adj=True, vis=False)) as createdLayout:
            createdConnection = cmds.selectionConnection(p=createdLayout,obj=nodeName)


            cmds.channelBox(mw=gChannelBoxWidgetWidthIndex,
                            lw=gTextColumnWidthIndex,
                            mh=gChannelBoxWidgetHeightIndex,
                            mlc=createdConnection,
                            p=createdLayout,
                            fal=[attribute],
                            aem=True)

        cmds.columnLayout(createdLayout, e=True, vis=True)


    cmds.setUITemplate(popTemplate=True)

    template.attachCallback(nodeName + "." + attribute, createdLayout, changedCommand)

    return [baseLayout, createdConnection]

# ------------------------------------------------------------------------------
def removeMultiElement(plugName):
    nodeName = template.plugNode(plugName)
    layerClip = template.isClassified(nodeName, "animation/timeEditorClip")
    connFrom = []
    if layerClip:
        clipPlugName = plugName + ".clipInput"
        connFrom = cmds.listConnections(clipPlugName, d=False, s=True)

    cmds.removeMultiInstance(plugName, b=True)

    #If this is a mental ray shader's color Attr,
    #make sure the alpha component is removed.

    multiParent = template.plugAttr(plugName)
    mpsplit = multiParent.split("[")
    attrName = mpsplit[0]

    if  (template.isClassified(nodeName, "rendernode/mentalray") and
        cmds.attributeQuery(attrName, node=nodeName, usedAsColor=True) and
        cmds.attributeQuery(attrName + "A", node=nodeName, exists=True)):

        cmds.removeMultiInstance(nodeName +
                                "." +
                                attrName +
                                "A[" +
                                 mpsplit[1], b=True)

    if layerClip:
        attrName = nodeName + _NOL10n(".") + attrName

        if len(cmds.getAttr(attrName, multiIndices=True)) == 0:
            #    When all clips on the clip node are deleted, then delete the empty clip node as well.
            try:
                cmds.delete(nodeName)
            except:
                pass


        if len(connFrom):
            connTo = cmds.listConnections(connFrom[0], d=True, s=False)
            if len(connTo) < 1:
                # The curve connected to that clip will be deleted if the curve is not connected to any other nodes.
                try:
                    cmds.delete(connFrom[0])
                except:
                    pass

# ------------------------------------------------------------------------------
def createNonNumericMultiAddNewItem(node, multiAttr):
    attr = node + "." + multiAttr

    # Find the next available index
    nextAvailable = 0

    if cmds.getAttr(attr, s=True) > 0:
        #    Get currently used indices
        #    The return value looks like this: rgb[0], rgb[0].r, rgb[0].g, rgb[0].b, rgb[3], ...
        multi = cmds.listAttr(attr, multi=True)

        for m in multi:
            #    Find index [n]
            gr = re.search("\[[0-9]+\]", m)
            index = int(gr.group(0)[1:-1])

            if index >= nextAvailable:
                nextAvailable = index + 1

    # Creat a new plug.
    plugName = "%s[%d]"%(attr, nextAvailable)

    isMentalrayNode = template.isClassified( node, "rendernode/mentalray")

    # Create a plug by accessing it
    try:
        cmds.getAttr(plugName, type=True)
    except:
        pass

    #    If this is a mental ray shader's color Attr,
    #    make sure the alpha component is removed.
    if (isMentalrayNode and
        cmds.attributeQuery(multiAttr, node=node, usedAsColor=True) and
        cmds.attributeQuery(multiAttr + "A", node=node, exists=True)):

        try:
            cmds.getAttr("%sA[%d]"%(attr,nextAvailable), type=True)
        except:
            pass

# ------------------------------------------------------------------------------
def createNonNumericMultiCreateNewControl(nodeName, attributeName, cc, attributeTypeProc, elementIndex):
    if elementIndex == -1:
        return

    # build the plug name
    plugName = "%s.%s[%d]"%(nodeName,attributeName, elementIndex)

    # build the attribute UI name
    attrName = getAttributeUILabel(plugName)

    from sys import version_info as sys_version_info
    if sys_version_info[0] >= 3:
        from . import compound
    else:
        import compound
    #if the attr is not a user-defined compound,
    #create a control and a "Delete" button in a rowLayout
    if  attributeTypeProc != compound.create:
        # Use attributeEditorMultiTemplate
        # so that the "Delete" button appears next to array elements
        cmds.setUITemplate("attributeEditorMultiTemplate", pst=True)

        # row layout to contain the attr control, "delete" button
        with LayoutManager(cmds.rowLayout(nc=4)):
            # Create a control for the attribute
            attributeTypeProc(plugName, attrName, cc)
            # Add a "Delete" button
            def deleteElement(*a): removeMultiElement(plugName) #create a named callaback to get proper undo message
            cmds.symbolButton(
                    image="smallTrash.png",
                    command=deleteElement)
            cmds.text(label="")

        cmds.setUITemplate(ppt=True)

    else:
        #    This is a multi of user-defined compound
        #    The "Delete" button will be created inside the compound frameLayout
        # Create a control for the attribute
        ##
        attributeTypeProc(plugName, attrName, cc)

# ------------------------------------------------------------------------------
def replaceNonNumericMultiReconnectControl(nodeName, attributeName, cc, attributeTypeProc, uiName, elementIndex):
    if elementIndex == -1:
        return
    from sys import version_info as sys_version_info
    if sys_version_info[0] >= 3:
        from . import compound
    else:
        import compound
    isUserDefinedCompound = attributeTypeProc == compound.replace
    plugName = "%s.%s[%d]"%(nodeName, attributeName, elementIndex)

    attrName = getAttributeUILabel(plugName)

    if not isUserDefinedCompound:
        cmds.setUITemplate("attributeEditorMultiTemplate", pst=True)

        #    Controls are in a row layout.
        #    The first child of the row layout is the control that we are looking for
        childControls = cmds.rowLayout(uiName, q=True, childArray=True)

        attributeTypeProc(childControls[0], plugName, attrName, cc)

        #    Delete button
        def deleteElement(*a): removeMultiElement(plugName) #create a named callaback to get proper undo message
        cmds.symbolButton(childControls[1], e=True, command=deleteElement)

        cmds.setUITemplate(ppt=True)
    else:
        attributeTypeProc(uiName, plugName, attrName, cc)

# ------------------------------------------------------------------------------
def tooBigNonNumericMulti(tooBig):
    # if there are elements that we cannot display, tell the user
    #
    if tooBig > 0:
        fmt = maya.stringTable[ 'y_maya_internal_common_ae_multi.kInsufficientRoom'  ]
        cmds.text(l=cmds.format(fmt,s=tooBig))

# ------------------------------------------------------------------------------
def replaceNonNumericMulti(frameName, nodeName,attributeName,changedCommand,attributeReplaceTypeProc, attributeNewTypeProc, elementIndex):
    #bind nodeName to the changedCommand
    cc = changedCommand
    if cc:
        cc = lambda *_a: changedCommand(nodeName)

    # The frame layout contains a single column layout.
    #
    children = cmds.frameLayout(frameName, q=True, ca=True)

    with ParentManager(children[0]) as columnName:
        # hide the column while we're modifying the controls inside it
        #
        cmds.columnLayout(columnName, e=True, vis=False)

        # get the number of controls currently in the columnLayout
        currentRows = cmds.columnLayout(columnName,q=True,ca=True)

        # The first control a row layout whose 2nd children is "Add New Item" button
        # Change the button command
        if  len(currentRows) > 0:
            with ParentManager(currentRows[0]) as row:
                rowChildren = cmds.rowLayout(row, q=True, childArray=True)
                if  len(rowChildren) > 1:
                    cmds.button(rowChildren[1],
                            e=True,
                            command=lambda *_a: createNonNumericMultiAddNewItem(nodeName,attributeName))

        numCurrentControls = len(currentRows) - 1

        # We don't display more than gMaxNonNumericMultis items.
        # If there are 2 more than that, then
        # it is because we are displaying the "too big" message.
        # Delete it...
        #
        if  numCurrentControls == (MaxNonNumericMultis + 2):
            cmds.deleteUI(currentRows[MaxNonNumericMultis], currentRows[MaxNonNumericMultis+1])
            numCurrentControls = MaxNonNumericMultis


        # get the number of controls needed by the new elements
        #
        numElements = len(elementIndex) if elementIndex is not None else 0

        # if there are more than twenty elements, clip them.
        #
        tooBig = 0
        if numElements > MaxNonNumericMultis:
            tooBig = numElements - MaxNonNumericMultis
            numElements = MaxNonNumericMultis

        # if we have more elements than we have controls, we'll
        # need to build more, otherwise we'll have to delete
        # the extra controls no longer needed
        #
        if numElements >= numCurrentControls:
            # reconnect the controls that we can
            #
            for i in range(numCurrentControls):
                replaceNonNumericMultiReconnectControl(
                    nodeName, attributeName, cc, attributeReplaceTypeProc,
                    currentRows[i+1], elementIndex[i] )

            # and now create the extra controls that we need
            #
            for i in range (numCurrentControls,numElements):
                createNonNumericMultiCreateNewControl(nodeName,attributeName,cc,attributeNewTypeProc, elementIndex[i])


        else:
            # reconnect the controls that we can
            #
            for i in range(numElements):
                replaceNonNumericMultiReconnectControl(
                    nodeName, attributeName, cc, attributeReplaceTypeProc,
                    currentRows[i+1], elementIndex[i] )

            # and delete the extra controls
            #
            for i in range(numElements, numCurrentControls):
                cmds.deleteUI(currentRows[i+1])


        tooBigNonNumericMulti(tooBig)

        cmds.columnLayout(columnName, e=True,vis=True)

# ------------------------------------------------------------------------------
def createNonNumericMulti(nodeName, attributeName, uiName, changedCommand, attributeProc, elementIndex):
    # create a frameLayout

    # outermost layout name is returned at end
    with LayoutManager(cmds.frameLayout(l=uiName, collapse=False)) as createdFrame:
        # create a columnLayout (hide it while we're creating the controls)
        with LayoutManager(cmds.columnLayout(adj=True, vis=False)) as createdColumn:
            # "Add New Item" button
            with LayoutManager(cmds.rowLayout(nc=2)):
                cmds.text(label="")
                cmds.button(
                    label=maya.stringTable[ 'y_maya_internal_common_ae_multi.kAddNewItem' ],
                    command=lambda *_a : createNonNumericMultiAddNewItem(nodeName,attributeName))

            # build the changedCommand
            cc = changedCommand
            if changedCommand:
                cc = lambda *_a : changedCommand(nodeName)

            # get the number of multis that need controls
            numElements = len(elementIndex) if elementIndex is not None else 0

            # if there are more than gMaxNonNumericMultis elements, clip them.

            tooBig = numElements - MaxNonNumericMultis
            numElement = MaxNonNumericMultis if tooBig > 0 else numElements

            # build the controls for the multis
            for i in range(numElement):
                createNonNumericMultiCreateNewControl(
                    nodeName,
                    attributeName,
                    cc,
                    attributeProc,
                    elementIndex[i])

            tooBigNonNumericMulti(tooBig)

        # make the columnLayout visible
        cmds.columnLayout(createdColumn, e=True, vis=True)
        return createdFrame
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
