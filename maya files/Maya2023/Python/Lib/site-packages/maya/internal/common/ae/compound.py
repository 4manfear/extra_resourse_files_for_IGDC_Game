import maya.cmds as cmds
from . import template
from . import other
from . import color
from . import int as integer
from . import float as floatingpoint
from . import boolean
from . import time
from . import enum
from . import matrix
from . import string
from . import vector
from . import message
from maya.common.utils import Singleton

CreateProcTypeMapping = {
    "long": integer.create,
    "bool": boolean.createSingleBool,
    "time": time.create,
    "enum": enum.create,
    "float": floatingpoint.create,
    "double": floatingpoint.create,
    "doubleAngle": floatingpoint.create,
    "matrix": matrix.create,
    "string": string.create,
    "float3": vector.create,
    "double3": vector.create,
    "message": message.create,
}

ReplaceProcTypeMapping = {
    "long": integer.replace,
    "bool": boolean.replaceSingleBool,
    "time": time.replace,
    "enum": enum.replace,
    "float": floatingpoint.replace,
    "double": floatingpoint.replace,
    "doubleAngle": floatingpoint.replace,
    "matrix": matrix.replace,
    "string": string.replace,
    "float3": vector.replace,
    "double3": vector.replace,
    "message": message.replace,
}


class AbstractAttributeFactory(object):
    def create(self, plugName, attrName, changedCommand):
        return None
    def replace(self, controlName, plugName, attrName, changedCommand):
        return None


class DefaultAttributeFactory(AbstractAttributeFactory):
    def __init__(self, nodeName, attributeName):
        usedAsColor = cmds.attributeQuery(attributeName, node=nodeName, usedAsColor=True)
        attrType = cmds.attributeQuery(attributeName, node=nodeName, attributeType=True)
        self._create = getAttributeTypeCreateProc(attrType, usedAsColor)
        self._replace = getAttributeTypeReplaceProc(attrType, usedAsColor)

    def create(self, plugName, attrName, changedCommand):
        return self._create(plugName, attrName, changedCommand)

    def replace(self, control, plugName, attrName, changedCommand):
        self._replace(control, plugName, attrName, changedCommand)
        return control

class Compound(object):
    def __init__(self, mapping = {}):
        self.customMapping = mapping

    def create(self, plugName, attrName, changedCommand):
        node = template.plugNode(plugName)
        compoundMultiParent = template.plugAttr(plugName)
        compoundParent = template.plugMultiAttr(plugName)
        isMulti = template.plugIsMulti(plugName)

        childAttrs = cmds.attributeQuery(compoundParent, node=node, listChildren=True)
        for childAttrName in childAttrs:
            childPlug = "%s.%s.%s"%(node, compoundMultiParent, childAttrName)
            childAttrNice = cmds.attributeName(childPlug, nice=True)
            cc = lambda *_: changedCommand(plugName) if changedCommand else None
            self.attrWidgetFactory(node, childAttrName).create(childPlug,childAttrNice, cc)


    def replace(self, controlName, plugName, attrName, changedCommand):
        node = template.plugNode(plugName)
        compoundMultiParent = template.plugAttr(plugName)
        compoundParent = template.plugMultiAttr(plugName)
        isMulti = template.plugIsMulti(plugName)

        childAttrs = cmds.attributeQuery(compoundParent, node=node, listChildren=True)
        columnLayout = cmds.frameLayout(controlName, q=True, childArray=True)
        childrenUI = cmds.columnLayout(columnLayout[0], q=True, childArray=True)

        index = 0
        for childAttrName in childAttrs:
            childPlug = "%s.%s.%s"%(node, compoundMultiParent, childAttrName)
            childAttrNice = cmds.attributeName(childPlug, nice=True)
            cc = lambda *_: changedCommand(plugName) if changedCommand else None
            childControl = cmds.setParent(q=True) + "|" + childrenUI[index]
            if index < len(childrenUI) and self.attrWidgetFactory(node, childAttrName).replace(childControl, childPlug, childAttrNice, cc):
                index += 1

    def attrWidgetFactory(self, nodeName, attributeName):
        if attributeName not in self.customMapping:
            self.customMapping[attributeName] = DefaultAttributeFactory(nodeName, attributeName)
        return self.customMapping[attributeName]

from future.utils import with_metaclass

class CompoundRegistry(with_metaclass(Singleton, object)):
    '''Class that manage the directory of custom compound AE widget'''

    def __init__(self):
        self.registry = {}

    def register(self, attrName, nodeType, compoundObject):
        if nodeType not in self.registry:
            self.registry[nodeType] = {}
        self.registry[nodeType][attrName] = compoundObject

    def _lookup(self, attrName, nodeType):
        if nodeType in self.registry and attrName in self.registry[nodeType]:
            return self.registry[nodeType][attrName]
        return None

    def lookup(self, attrName, node):
        for nodeType in reversed(cmds.nodeType(node, inherited=True)):
            compound =  self._lookup(attrName, nodeType)
            if compound != None:
                return compound
        return None




def getAttributeTypeReplaceProc(type, isColor):
    if isColor:
        return color.replace
    proc = ReplaceProcTypeMapping.get(type, None)
    if proc:
        return proc

    return other.replace


def getAttributeTypeCreateProc(type, isColor):
    if isColor:
        return color.create
    proc = CreateProcTypeMapping.get(type, None)
    if proc:
        return proc

    return other.create


def replace(controlName, plugName, attrName, changedCommand ):
    node = template.plugNode(plugName)


    # compoundMultiParent is compound parent attr with [ ] (in case multi) or without [ ] (if not multi)
    # compoundParent is compound parent attr ALWAYS WITHOUT [ ]
    compoundMultiParent = template.plugAttr(plugName)
    compoundParent = template.plugMultiAttr(plugName)
    isMulti = template.plugIsMulti(plugName)
    compoundMultiParentNice = cmds.attributeName(plugName, nice=True)


    #	attributeQuery does NOT take multi attr.
    #	For ex, `attributeQuery -node "myNode" -listChildren "colors[0]"` is error
    #	Instead, use `attributeQuery -node "myNode" -listChildren "colors"
    #	So, we have to use compoundParent
    childAttrs = cmds.attributeQuery(compoundParent, node=node, listChildren=True)

    #	No child!
    #	This attr is not compound. 
    #	Return.
    if len(childAttrs) == 0:
        return other.replace(controlName, plugName, attrName, changedCommand)

    cmds.setUITemplate("attributeEditorTemplate", pst=True)

    #First, the formLayout label
    cmds.frameLayout(controlName, e=True, l=cmds.attributeName(plugName, nice=True))
    
    #	Get the column layou
    columnLayout = cmds.frameLayout(controlName, q=True, childArray=True)
    cmds.setParent(columnLayout[0])

    #	Get the layout's children
    childrenUI = cmds.columnLayout(columnLayout[0], q=True, childArray=True)

    comp = CompoundRegistry().lookup(compoundParent, node)
    from sys import version_info as sys_version_info
    if sys_version_info[0] >= 3:
        from . import multi
    else:
        import multi
    if comp != None:
         comp.replace(controlName, plugName, attrName, changedCommand)
    else:
        # We need to use another pointer to keep track of which UI widget we are pointing to.
        # In AEnewCompound.mel, we did not construct any widgets for attributes that are hidden. 
        # Therefore, the number of childrenUI and childAttrs will not be the same.
        # We use childUIPtr to point to the correct widget in $childrenUI.
        childUIPtr = 0
        for childAttrName in childAttrs:
            if cmds.attributeQuery(childAttrName, hidden=True, node=node):
                continue
            childPlug = "%s.%s.%s"%(node, compoundMultiParent, childAttrName)
            childAttrNice = cmds.attributeName(childPlug, nice=True)
            childType = cmds.getAttr(childPlug, type=True)

            childControl = cmds.setParent(q=True) + "|" + childrenUI[childUIPtr]

            isChildMulti = cmds.attributeQuery(childAttrName, node=node, multi=True)

            if (isChildMulti and cmds.attributeQuery(compoundParent, node=node, multi=True)):
                other.replace(childControl,plugName, attrName, changedCommand)
            elif isChildMulti:
                if childType == "TdataCompound":
                        # Sometimes getAttr -type and attributeQuery -attributeType return different 
                        # values.
                        # It would return the same value if we did a call of getAttr -type on one 
                        # of the multi child.
                        childType = cmds.attributeQuery(childAttrName, node=node, attributeType=True)
                indices = cmds.getAttr(childPlug, multiIndices=True)
                usedAsColor = cmds.attributeQuery(childAttrName, node=node, usedAsColor=True)
                replaceProc = getAttributeTypeReplaceProc(childType, usedAsColor)
                createProc = getAttributeTypeCreateProc(childType, usedAsColor)
                multi.replaceNonNumericMulti(childControl,plugName,childAttrName,changedCommand,replaceProc, createProc,indices)
            else:
                proc = getAttributeTypeReplaceProc(childType, cmds.attributeQuery(childAttrName, node=node, usedAsColor=True))
                cc = changedCommand
                if changedCommand:
                    cc = lambda *_a: changedCommand(plugName)
                proc(childControl,childPlug,childAttrNice,cc)

            # Increment the UI ptr once we successfully handled a non-hidden attribute
            childUIPtr += 1
    if isMulti:
        if len(childrenUI) > 0:
            #"Delete" button is in a rowLayout
            cmds.setParent(childrenUI[-1])
            deleteButtonControls = cmds.rowLayout(childrenUI[-1], q=True, childArray=True)
            def deleteElement(*a): multi.removeMultiElement(plugName) #create a named callaback to get proper undo message
            cmds.symbolButton(deleteButtonControls[1], e=True, command=deleteElement)
            cmds.setParent("..")
    cmds.setParent("..")
    cmds.setParent("..")
    cmds.setUITemplate(popTemplate=True)


def create( plugName, attrName, changedCommand ):
    node = template.plugNode(plugName)

    # compoundMultiParent is compound parent attr with [ ] (in case multi) or without [ ] (if not multi)
    # compoundParent is compound parent attr ALWAYS WITHOUT [ ]
    compoundMultiParent = template.plugAttr(plugName)
    compoundParent = template.plugMultiAttr(plugName)
    isMulti = template.plugIsMulti(plugName)
    compoundMultiParentNice = cmds.attributeName(plugName, nice=True)



    #	attributeQuery does NOT take multi attr.
    #	For ex, `attributeQuery -node "myNode" -listChildren "colors[0]"` is error
    #	Instead, use `attributeQuery -node "myNode" -listChildren "colors"
    #	So, we have to use compoundParent
    childAttrs = cmds.attributeQuery(compoundParent, node=node, listChildren=True)

    #	No child!
    #	This attr is not compound. 
    #	Return.
    if childAttrs is None or len(childAttrs) == 0:
        return other.create(plugName, attrName, changedCommand)


    #	Build UI
    cmds.setUITemplate("attributeEditorTemplate", pst=True)
    createdControl = cmds.frameLayout(collapsable=True, label=compoundMultiParentNice, borderVisible=True, collapse=False)
    cmds.columnLayout(adjustableColumn=True)

    comp = CompoundRegistry().lookup(compoundParent, node)
    from sys import version_info as sys_version_info
    if sys_version_info[0] >= 3:
        from . import multi
    else:
        import multi

    if comp != None:
        comp.create(plugName, attrName, changedCommand)
    else:
        for childAttrName in childAttrs:
            if cmds.attributeQuery(childAttrName, hidden=True, node=node):
                continue

            childPlug = "%s.%s.%s"%(node, compoundMultiParent, childAttrName)
            childAttrNice = cmds.attributeName(childPlug, nice=True)
            childType = cmds.getAttr(childPlug, type=True)
            isChildMulti = cmds.attributeQuery(childAttrName, node=node, multi=True)

            if isChildMulti:
                if isMulti:
                    # The attribute is an array in an array and this is not supported
                    other.create(plugName, attrName, changedCommand)
                else:
                    if childType == "TdataCompound":
                        # Sometimes getAttr -type and attributeQuery -attributeType return different 
                        # values.
                        # It would return the same value if we did a call of getAttr -type on one 
                        # of the multi child.
                        childType = cmds.attributeQuery(childAttrName, node=node, attributeType=True)

                    indices = cmds.getAttr(childPlug, multiIndices=True)
                    proc = getAttributeTypeCreateProc(childType, cmds.attributeQuery(childAttrName, node=node, usedAsColor=True))
                    multi.createNonNumericMulti(plugName, childAttrName, childAttrNice, changedCommand, proc, indices)
            else:
                proc = getAttributeTypeCreateProc(childType, cmds.attributeQuery(childAttrName, node=node, usedAsColor=True))

                cc = changedCommand
                if changedCommand:
                    cc = lambda *_a: changedCommand(plugName)
                proc(childPlug, childAttrNice, cc)

    if isMulti:
        cmds.setUITemplate("attributeEditorMultiTemplate", pst=True)
        cmds.rowLayout(nc=3)
        cmds.text(label="")
        def deleteElement(*a): multi.removeMultiElement(plugName) #create a named callaback to get proper undo message
        cmds.symbolButton(
            image="smallTrash.png",
            command=deleteElement
        )
        cmds.text(label="")
        cmds.setParent("..")
        cmds.setUITemplate(ppt=True)

    cmds.setParent("..")
    cmds.setParent("..")
    cmds.setUITemplate(popTemplate=True)
    return createdControl
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
