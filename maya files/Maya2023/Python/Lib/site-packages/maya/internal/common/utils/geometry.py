"""
General geometry node utilities.
Contains methods to get shapes, original geometry, shape attributes, etc...
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)



from builtins import object
from builtins import range
from builtins import next
labelMsgInvalidUVSet = maya.stringTable['y_maya_internal_common_utils_geometry.kWrnMsgInvalidUvSet' ]

import maya.cmds
import maya.api.OpenMaya as oma
import maya.internal.common.utils.message as msg_utils
import maya.internal.common.utils.transform as xfm_utils

class GeomType(object):
    NONE = 0
    Mesh = 1
    Nurbs = 2
    Curve = 4
    Lattice = 8
    Other = 16
    # Combinations
    MeshNurbs = 3
    MeshNurbsCurve = 7
    MeshNurbsCurveLattice = 15
    All = 31

# ------------------------------------------------------------------------------
def checkGeomType(shapeNode, geomType=GeomType.All):
    '''Checks if the shapeNode is either a mesh, curve or a nurbsSurface'''
    if not shapeNode or geomType == GeomType.NONE:
        return False

    if geomType == GeomType.All:
        return maya.cmds.objectType(shapeNode, isAType='shape')

    if (geomType & GeomType.Mesh) and maya.cmds.objectType(shapeNode, isAType='mesh'):
        return True
    if (geomType & GeomType.Nurbs) and maya.cmds.objectType(shapeNode, isAType='nurbsSurface'):
        return True
    if (geomType & GeomType.Curve) and maya.cmds.objectType(shapeNode, isAType='nurbsCurve'):
        return True
    if (geomType & GeomType.Lattice) and maya.cmds.objectType(shapeNode, isAType='lattice'):
        return True
    return False

# ------------------------------------------------------------------------------
def getLocalShapeInAttr(shapeNode):
    '''Return the name of the local space input shape attribute'''
    if shapeNode is None:
        return None
    else:
        return maya.cmds.deformableShape(shapeNode, localShapeOutAttr=True)[0]

# ------------------------------------------------------------------------------
def getLocalShapeOutAttr(shapeNode):
    '''Return the name of the local space output shape attribute'''
    if shapeNode is None:
        return None
    else:
        return maya.cmds.deformableShape(shapeNode, localShapeOutAttr=True)[0]

# ------------------------------------------------------------------------------
def getWorldShapeOutAttr(shapeNode):
    '''Return the name of the world space output shape attribute'''
    if shapeNode is None:
        return None
    else:
        return maya.cmds.deformableShape(shapeNode, worldShapeOutAttr=True)[0]

# ------------------------------------------------------------------------------
def extendToShape(depNode):
    '''Find the shape node that is or is immediately under the depNode
       Return the shape node if can be found
       Return None if it can not be found
    '''
    node = depNode.split('.')[0] # remove any component part just to be sure.
    if maya.cmds.objectType(node, isAType='shape'):
        return depNode

    shapes = maya.cmds.listRelatives(node, shapes=True, noIntermediate=True, path=True )
    if shapes is not None and len(shapes) == 1:
        return shapes[0]
    else:
        return None

# ------------------------------------------------------------------------------
def extendToIntermediateShape(depNode):
    '''Find the intermediate shape node that is or is immediately under the depNode
       Return the shape node if can be found
       Return None if it can not be found
    '''

    if maya.cmds.objectType(depNode, isAType='shape'):
        ioFlag = maya.cmds.getAttr(u'{0}.io'.format(depNode))
        if ioFlag:
            return depNode
        else:
            parent = getParent(depNode)
            return extendToIntermediateShape(parent)

    # Get the shapes from the transform
    shapes = maya.cmds.listRelatives(depNode, shapes=True, path=True)
    for shape in shapes:
        ioFlag = maya.cmds.getAttr(u'{0}.io'.format(shape))
        if ioFlag:
            return shape

    return None

# ------------------------------------------------------------------------------
def getGeometryNode(depNode, displayWarning=True):
    '''Find the shape node (mesh, nurbsSurface, ...) that is or is immediately under the depNode
       Return the shape node if can be found
       Return None and (optionally) show a warning if it can not be found
    '''
    shapeNode = extendToShape(depNode)
    if checkGeomType(shapeNode, geomType=GeomType.All):
        return shapeNode

    if displayWarning:
        msg_utils.showWarning(maya.stringTable['y_maya_internal_common_utils_geometry.kWrnMsgNoGeometry' ].format(depNode))

    return None

# ------------------------------------------------------------------------------
def getSelectedShapes(geomType=GeomType.All, useComponents=False):
    '''Find the selected shape nodes (mesh or nurbsSurface)
    If useComponents is True then return it with the selected commponents

    So for example it can return
        ['ballShape']
    or:
        ['ball.f[63:64]', 'ball.f[82:84]', 'ball.f[339]']
    '''
    selectedObjects = maya.cmds.ls(selection=True, objectsOnly=True)
    selectedShapes = []
    for so in selectedObjects:
        shapeNode = extendToShape(so)
        if checkGeomType(shapeNode, geomType=geomType):
            if useComponents and hasComponentsSelected(shapeNode):
                selectedShapes.extend(maya.cmds.ls(shapeNode, sl=True))
            else:
                selectedShapes.append(shapeNode)
    return selectedShapes

# ------------------------------------------------------------------------------
def getShapes(transformNode):
    shapes = maya.cmds.ls(transformNode, dag=True, shapes=True)
    return shapes

# ------------------------------------------------------------------------------
def getOrCreateOriginalGeometry(shapeNode, create=True, displayError=True):
    '''Return the original geometry plug for the shape.
    If it does not exist and the create flag is True, create the original geometry
    '''
    try:
        orig = maya.cmds.deformableShape(shapeNode, og=True)[0]
        if orig == '':
            orig = maya.cmds.deformableShape(shapeNode, createOriginalGeometry=True)[0]
        if orig == '':
            orig = None
    except Exception:
        if displayError:
            msg_utils.showError(maya.stringTable['y_maya_internal_common_utils_geometry.kErrMsgNoOriginalGeom' ])
        return None

    return orig

# ------------------------------------------------------------------------------
def _verifyUvSet(dagOb, uvSet):
    '''Returns whether the specified uvSet is in the geometry and expands the
    name to the current uv set of the shape if an empty string was passed'''
    uvSetName = uvSet.strip() if uvSet is not None else ''
    if uvSetName == '':
        uvSetName = maya.cmds.getAttr(u'{0}.currentUVSet'.format(dagOb.fullPathName()))

    if dagOb.hasFn(oma.MFn.kMesh):
        fnMesh = oma.MFnMesh(dagOb)
        allUvSetNames = fnMesh.getUVSetNames()
        if not uvSetName in allUvSetNames:
            return False, uvSetName

    return True, uvSetName

# ------------------------------------------------------------------------------
class eCollectUvsStatus(object):
    '''The return status for the functions collecting uvs from a geometry'''
    kSuccess = 0
    kNoGeometry = 1
    kNoTransforms = 2
    kNoSelection = 3
    kIncompatibleComponents = 4
    kNoUvSet = 5
    kFail = 6

# ------------------------------------------------------------------------------
def getUvsFromSelection(geom=None, normalizedIsoParms=True, uvSet=''):
    '''
    Find the uvs from the current selected components. It will return
    a list of tuples (dagObject, uvSetName, [uv1, uv2, uv3, ....])

    This function can deal with certain component types on meshes and
    nurbsSurfaces.
             meshes: verts, faces, edges, uvs
      nurbsSurfaces: patches, isoparms

    For nurbsSurfaces it will returns (normalized) isoparms instead of uvs.
    Normalization (when normalizedIsoParms is set to True) will make the result
    more independent from the number of spans. If the surface changes number of
    spans later, the normalized isoParms can still be used for the same spot
    on the surface.
    '''

    sel = oma.MGlobal.getActiveSelectionList()
    numSel = sel.length()

    geomDagOb = None
    if geom is not None:
        geomShapeNode = getGeometryNode(geom)

        geomSelectionList = oma.MSelectionList()
        geomSelectionList.add(geomShapeNode)
        geomDagOb = geomSelectionList.getDagPath(0)

    result = list()

    if sel.length() == 0:
        return result, eCollectUvsStatus.kNoSelection

    invalidUVSets = list()

    returnStatus = eCollectUvsStatus.kSuccess

    for index in range(0, numSel):

        try:
            dagOb, comp = sel.getComponent(index)
            dagOb.extendToShape()

            if geomDagOb and dagOb != geomDagOb:
                continue

            if not dagOb.hasFn(oma.MFn.kMesh) and not dagOb.hasFn(oma.MFn.kNurbsSurface) and not dagOb.hasFn(oma.MFn.kNurbsCurve):
                continue

            validUVSet, uvSetName = _verifyUvSet(dagOb, uvSet)
            if not validUVSet:
                invalidUVSets.append(uvSetName)
                returnStatus = eCollectUvsStatus.kNoUvSet
                continue

            collectUvs = list()

            if comp.hasFn(oma.MFn.kMeshVertComponent):
                # Mesh verts
                vitr = oma.MItMeshVertex(dagOb, comp)
                while not vitr.isDone():
                    uv = vitr.getUV(uvSetName)
                    collectUvs.append(uv)
                    next(vitr)

            elif comp.hasFn(oma.MFn.kMeshPolygonComponent):
                # Mesh faces
                fitr = oma.MItMeshPolygon(dagOb, comp)
                while not fitr.isDone():
                    if fitr.hasUVs():
                        arr_u, arr_v = fitr.getUVs(uvSetName)
                        if len(arr_u) > 0:
                            uv = [ sum(arr_u)/len(arr_u), sum(arr_v)/len(arr_v) ]
                            collectUvs.append(uv)
                    next(fitr)

            elif comp.hasFn(oma.MFn.kMeshEdgeComponent):
                # Mesh edges
                fnComponent = oma.MFnSingleIndexedComponent(comp)
                eitr = oma.MItMeshEdge(dagOb, comp)
                while not eitr.isDone():
                    vtx = [ eitr.vertexId( j ) for j in [ 0, 1 ] ]
                    vtxIt = oma.MItMeshVertex( dagOb )
                    edgeUvs = []
                    for v in vtx:
                        vtxIt.setIndex(v)
                        edgeUvs.append(vtxIt.getUV(uvSetName))

                    uv = [ 0.5*(edgeUvs[0][j]+edgeUvs[1][j]) for j in [0,1] ]
                    collectUvs.append(uv)
                    next(eitr)

            elif comp.hasFn(oma.MFn.kMeshMapComponent):
                # Mesh uvs
                fnComponent = oma.MFnSingleIndexedComponent(comp)
                fnMesh = oma.MFnMesh(dagOb)
                elems = fnComponent.getElements()
                for e in elems:
                    uv = fnMesh.getUV(e)
                    collectUvs.append([uv[0], uv[1]])

            elif comp.hasFn(oma.MFn.kSurfaceFaceComponent):
                # Surface patch
                fnSurf = oma.MFnNurbsSurface(dagOb)
                domain = [ fnSurf.knotDomainInU, fnSurf.knotDomainInV ]
                spans = [ fnSurf.numSpansInU, fnSurf.numSpansInV ]
                fnComponent = oma.MFnDoubleIndexedComponent(comp)
                elems = fnComponent.getElements()

                for e in elems:
                    uv = [((e[j]+0.5)/float(spans[j])) for j in [ 0, 1 ] ]
                    if not normalizedIsoParms: # expand to domain space
                        uv = [ uv[j]*(domain[j][1]-domain[j][0]) + domain[j][0] for j in [ 0, 1 ] ]
                    collectUvs.append(uv)

            elif comp.hasFn(oma.MFn.kIsoparmComponent):
                # Surface point
                import re
                fnSurf = oma.MFnNurbsSurface(dagOb)
                domain = [ fnSurf.knotDomainInU, fnSurf.knotDomainInV ]

                selComp = maya.cmds.ls(dagOb.fullPathName(), selection=True, flatten=True)
                for p in selComp:
                    e = re.findall(r"\[(.*?)\]", p)
                    if len(e) != 2:
                        continue

                    if normalizedIsoParms:
                        uv = [(float(e[j])-domain[j][0])/(domain[j][1]-domain[j][0]) for j in [ 0, 1 ] ]
                        collectUvs.append(uv)
                    else:
                        collectUvs.append([float(e[0]), float(e[1])])

            elif comp.hasFn(oma.MFn.kCurveParamComponent):
                import re
                fnCurve = oma.MFnNurbsCurve(dagOb)
                domain = fnCurve.knotDomain

                selComp = maya.cmds.ls(dagOb.fullPathName(), selection=True, flatten=True)
                for p in selComp:
                    e = re.findall(r"\[(.*?)\]", p)
                    if len(e) != 1:
                        continue
                    if normalizedIsoParms:
                        u = (float(e[0])-domain[0])/(domain[1]-domain[0])
                        collectUvs.append([u, 0.0])
                    else:
                        collectUvs.append([float(e[0]), 0.0])
            else:
                # no compatible components
                returnStatus = eCollectUvsStatus.kIncompatibleComponents

            result.append((dagOb.fullPathName(), uvSetName, collectUvs))

        except Exception as inst:
            print(u'{0}'.format(inst))
            returnStatus = eCollectUvsStatus.kFail

    if len(invalidUVSets) > 0:
        msg_utils.showWarning(labelMsgInvalidUVSet.format(u' '.join(invalidUVSets)))
        returnStatus = eCollectUvsStatus.kNoUvSet

    return result, returnStatus

def getUvsFromClosestPointToTransforms(geom, transforms, normalizedIsoParms=True, uvSet=''):
    '''
    Find the uvs from the geometry that are closest to the list of transforms.
    It will return a tuple ([uv1, uv2, ....], [target1, target2, .....])

    For nurbsSurfaces it will returns (normalized) isoparms instead of uvs.
    Normalization (when normalizedIsoParms is set to True) will make the result
    more independent from the number of spans. If the surface changes number of
    spans later, the normalized isoParms can still be used for the same spot
    on the surface.
    '''

    geomShapeNode = getGeometryNode(geom)
    if geomShapeNode is None:
        return None, eCollectUvsStatus.kNoGeometry

    geomXformNode = xfm_utils.getParent(geomShapeNode)

    xformList = transforms
    if geomXformNode in transforms:
        xformList.remove(geomXformNode)

    if len(xformList) == 0:
        return (geomShapeNode, uvSet, [], []), eCollectUvsStatus.kNoTransforms

    selectionList = oma.MSelectionList()
    selectionList.add(geomShapeNode)
    dagOb = selectionList.getDagPath(0)

    samplePos = list()
    targets = list()

    for xform in xformList:

        xformNode = xfm_utils.getTransformNode(xform)
        if xformNode is not None:
            p = xfm_utils.getPositionFromMatrixAttribute(u'{0}.worldMatrix'.format(xformNode))
            samplePos.append(oma.MPoint(p[0], p[1], p[2]))
            targets.append(xformNode)

    uvs = list()

    if dagOb.hasFn(oma.MFn.kNurbsSurface):
        fnSurf = oma.MFnNurbsSurface(dagOb)
        domain = [ fnSurf.knotDomainInU, fnSurf.knotDomainInV ] if normalizedIsoParms else None
        uvSetName = ''

        for p in samplePos:
            closestPoint = fnSurf.closestPoint(p, space=oma.MSpace.kWorld)
            uv = [closestPoint[1], closestPoint[2]]
            #  Normalize when needed
            if domain is not None:
                uv = [(uv[j]-domain[j][0])/(domain[j][1]-domain[j][0]) for j in [ 0, 1 ] ]
            uvs.append(uv)

    elif dagOb.hasFn(oma.MFn.kMesh):
        fnMesh = oma.MFnMesh(dagOb)

        validUVSet, uvSetName = _verifyUvSet(dagOb, uvSet)
        if not validUVSet:
            msg_utils.showWarning(labelMsgInvalidUVSet.format(uvSetName))
            return None, eCollectUvsStatus.kNoUvSet

        for p in samplePos:
            closestUV = fnMesh.getUVAtPoint(p, space=oma.MSpace.kWorld, uvSet=uvSetName)
            uvs.append([closestUV[0], closestUV[1]])

    elif dagOb.hasFn(oma.MFn.kNurbsCurve):
        fnCurve = oma.MFnNurbsCurve(dagOb)
        domain = fnCurve.knotDomain  if normalizedIsoParms else None
        uvSetName = ''

        for p in samplePos:
            closestPoint = fnCurve.closestPoint(p, space=oma.MSpace.kWorld)
            u = closestPoint[1]
            #  Normalize when needed
            if domain is not None:
                u = (u-domain[0])/(domain[1]-domain[0])
            uvs.append([u, 0.0])
    else:
        return None, eCollectUvsStatus.kNoGeometry

    return (geomShapeNode, uvSetName, uvs, targets), eCollectUvsStatus.kSuccess

def hasComponentsSelected(shapeNode):
    selected = maya.cmds.ls(shapeNode, sl=True)
    if len(selected) > 0:
        validComp = [ '.f[', '.e[', '.vtx[', '.map[', '.sf[', '.uv[', '.u[' , '.pt['  ]
        return any(c in selected[0] for c in validComp)
    else:
        return False
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
