import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
General UI utilities.
'''

from builtins import object
from builtins import range
import maya.cmds
from maya.common.ui import LayoutManager

TOP =  "top"
BOTTOM = "bottom"
RIGHT = "right"
LEFT = "left"
noneNodeLabel = maya.stringTable['y_maya_internal_common_utils_ui.kLabelNoneNode' ]

dpi_scale = 1.0 if not hasattr(maya.cmds, "mayaDpiSetting") else maya.cmds.mayaDpiSetting(query=True, realScaleValue=True)

# ------------------------------------------------------------------------------
def dpiScale(value):
    return dpi_scale * value

# ------------------------------------------------------------------------------
def checkLabel(label):
    #if not label.endswith(_NOL10N(':')):
    #    print  _NOL10N(u'\"{0}\" does not end with :').format(label)

    words = label.split()

    if not label[0].isupper():
        print(u'\"{0}\" starts with a lower case'.format(label))

    if len(words) > 1:
        for w in words[1:]:
            if len(w) > 1 and w[0].isupper() and not w[1].isupper():
                print(u'\"{0}\" does have capitalized non first words \"{1}\"'.format(label, w))

# ------------------------------------------------------------------------------
def fixLabel(label):
    '''
    This method will ensure the label is formatted to be used as an item
    label in f.e. option boxes
    '''
    if label == "" or label.endswith(':'):
        return label
    return u'{0}:'.format(label)

# ------------------------------------------------------------------------------
def itemLabel(label):
    #checkLabel(label)
    return fixLabel(label)

# ------------------------------------------------------------------------------
def createOptionMenu(label, options=None, annotation='', changeCommand=None):
    '''Create an optionMenuGrp widget from list of options
    Parameters:
       label: the label for the menu
       options: a list containing pairs of (itemLabel, itemEnumType)
       annotation: optional annotation of the menu

    Returns:
        the created widget and a dict lookup from label to enum type

    Example:
        widget, lookup = createOptionMenu('Cheese',[('Stilton', 0), ('Gouda', 2), ('Wensleydale', 5)])
    '''
    if changeCommand is None:
        widget = maya.cmds.optionMenuGrp(label=itemLabel(label), annotation=annotation, height=25)
    else:
        widget = maya.cmds.optionMenuGrp(label=itemLabel(label), annotation=annotation, height=25, changeCommand=changeCommand)

    lookup = dict()
    if options is not None:
        for opt in options:
            if opt[0] == '-':
                maya.cmds.menuItem(divider=True)
            else:
                maya.cmds.menuItem(label=opt[0])
                lookup.update({ opt[0] : opt[1] })

    return widget, lookup

# ------------------------------------------------------------------------------
def createLabeledButtonRow(label, nc=1, buttonWidth=150, labelWidth=150):
    buttons = []
    with LayoutManager(maya.cmds.rowLayout(nc=(nc+2), adjustableColumn=(nc+2), columnAlign=(1, RIGHT))):
        lbl = maya.cmds.text(label=itemLabel(label), width=labelWidth)
        for _i in range(0,nc):
            b = maya.cmds.button(recomputeSize=False, width=buttonWidth, label='Button')
            buttons.append(b)

    return lbl, buttons

# ------------------------------------------------------------------------------
def createCommandDescriptionLayout(descriptionText):
    if descriptionText is None or descriptionText == "":
        return
    frmLayout = maya.cmds.frameLayout(label=maya.stringTable['y_maya_internal_common_utils_ui.kLabelDescription' ], collapsable=False, marginHeight=5)
    with LayoutManager(frmLayout):
        colLayout = maya.cmds.columnLayout(adjustableColumn=True)
        with LayoutManager(colLayout):
            maya.cmds.text(label=descriptionText, width=450, wordWrap=True, align=LEFT)
            #maya.cmds.textField(text=descriptionText, width=450, editable=False)
    return colLayout

# ------------------------------------------------------------------------------
def createCommandSettingsLayout():
    frmLayout = maya.cmds.frameLayout('Settings', label=maya.stringTable['y_maya_internal_common_utils_ui.kLabelSettings' ], collapsable=False, marginHeight=5)
    colLayout = None
    with LayoutManager(frmLayout):
        colLayout = maya.cmds.columnLayout('Contents', rowSpacing=0, adjustableColumn=True)
        with LayoutManager(colLayout):
            pass
    return colLayout

# ------------------------------------------------------------------------------
def createTimeRangeLayout():
    frmLayout = maya.cmds.frameLayout('Time Range & Preview', label=maya.stringTable['y_maya_internal_common_utils_ui.kLabelTimeRangeAndPrewview' ], collapsable=False, marginHeight=5)
    colLayout = None
    with LayoutManager(frmLayout):
        colLayout = maya.cmds.columnLayout('Contents', rowSpacing=0, adjustableColumn=True)
        with LayoutManager(colLayout):
            pass

    return colLayout
# ------------------------------------------------------------------------------

# ------------------------------------------------------------------------------
def addSeparatorLine(height=15):
    maya.cmds.separator(height=height, style='double')

# ------------------------------------------------------------------------------
def addSeparatorSpace(height=15):
    maya.cmds.separator(height=height, style='none')

# ------------------------------------------------------------------------------
class DynamicOptionMenu(object):
    '''
    Class that presents a optionMenu(Grp) item that dynamically generates the
    options when clicked.
    Two methods can be specified: one to collect the names of the candidate
    items to be presented and one to perform the action after a selection has
    been made.
    '''
    def __init__(self, label, candidateFn=None, pickedFn=None, asGrp=True):
        self.asGrp = asGrp
        if self.asGrp:
            self.ocmd = maya.cmds.optionMenuGrp
            self.control = self.ocmd(label=label,
                                     columnWidth2=(0,200), adjustableColumn=2,
                                     postMenuCommand=self._makeMenuCB,
                                     changeCommand=self._pickedCB)
        else:
            self.ocmd = maya.cmds.optionMenu
            self.control = self.ocmd(label=label,
                                     postMenuCommand=self._makeMenuCB,
                                     changeCommand=self._pickedCB)

        self.candidateFn = candidateFn
        self.pickedFn = pickedFn
        self.hasItems = False

    def _makeMenuCB(self, *args):
        menu = args[0]
        # Store selection and then delete all items from menu
        curValue = None
        n = self.ocmd(self.control, query=True, numberOfItems=True)
        if n > 0:
            curValue = self.ocmd(self.control, query=True, value=True)

        self.ocmd(self.control, edit=True, deleteAllItems=True)

        # Build new menu from candidates
        nodes = list()
        if self.candidateFn is not None:
            nodes = self.candidateFn()

        self.hasItems = (len(nodes) > 0)

        if self.hasItems:
            for n in nodes:
                maya.cmds.menuItem(n, parent=menu)

            # Restore previous selection (if it is still an option)
            if curValue and curValue in nodes:
                self.ocmd(self.control, edit=True, value=curValue)
        else:
            maya.cmds.menuItem(noneNodeLabel, parent=menu)

    def _pickedCB(self, *args):
        if self.hasItems and self.pickedFn is not None:
            self.pickedFn(args[0])

    def setValue(self, name):
        self.ocmd(self.control, edit=True, deleteAllItems=True)
        if self.asGrp:
            maya.cmds.menuItem(parent=(self.control + '|OptionMenu'), label=name)
        else:
            maya.cmds.menuItem(parent=self.control, label=name)
        self.ocmd(self.control, edit=True, value=name)

    def getValue(self):
        n = self.ocmd(self.control, query=True, numberOfItems=True)
        return self.ocmd(self.control, query=True, value=True) if n > 0 else ''

# ------------------------------------------------------------------------------
class DynamicOptionMenuPicker(object):
    '''
    Class that defines a dynamic popupMenu that will always show the
    specified selectLabel as the current value, but allows to dynamically
    pick from a set of candidates
    Two methods can be specified: one to collect the names of the candidate
    items to be presented and one to perform the action after a selection has
    been made.
    '''

    def __init__(self, selectLabel, candidateFn=None, pickedFn=None):
        self.control = maya.cmds.optionMenu(label='', postMenuCommand=self._makeMenuCB, changeCommand=self._pickedCB)
        self.selectLabel = selectLabel
        self.candidateFn = candidateFn
        self.pickedFn = pickedFn
        maya.cmds.menuItem(self.selectLabel)

    def _makeMenuCB(self, *args):
        maya.cmds.optionMenu(self.control, edit=True, deleteAllItems=True)

        nodes = list()
        if self.candidateFn is not None:
            nodes = self.candidateFn()

        maya.cmds.menuItem(self.selectLabel, parent=self.control)
        if len(nodes) > 0:
            maya.cmds.menuItem(divider=True, parent=self.control)

        for n in nodes:
            if n == '-':
                maya.cmds.menuItem(divider=True, parent=self.control)
            else:
                maya.cmds.menuItem(n, parent=self.control)

    def _pickedCB(self, *args):
        s = maya.cmds.optionMenu(self.control, query=True, select=True)
        if s > 1 and self.pickedFn is not None:
            self.pickedFn(args[0])

        maya.cmds.optionMenu(self.control, edit=True, deleteAllItems=True)
        maya.cmds.menuItem(self.selectLabel, parent=self.control)

# ------------------------------------------------------------------------------
def floatSliderGrp(label, vmin, vmax, llim=True, ulim=True, **kwargs):
    kwa = kwargs
    if not llim: kwa.update( { 'fieldMinValue' : -10000} )
    if not ulim: kwa.update( { 'fieldMaxValue' : 10000} )

    return maya.cmds.floatSliderGrp(label=itemLabel(label), minValue=vmin, maxValue=vmax, **kwa)

# ------------------------------------------------------------------------------
def floatSliderGrpNoLimit(label, vmin, vmax):
    return maya.cmds.floatSliderGrp(label=itemLabel(label), minValue=vmin, maxValue=vmax, fieldMinValue=-10000.0, fieldMaxValue=10000)

# ------------------------------------------------------------------------------
def intSliderGrp(label, vmin, vmax, llim=True, ulim=True, **kwargs):
    kwa = kwargs
    if not llim: kwa.update( { 'fieldMinValue' : -10000} )
    if not ulim: kwa.update( { 'fieldMaxValue' : 10000} )

    return maya.cmds.intSliderGrp(label=itemLabel(label), minValue=vmin, maxValue=vmax, **kwa)

# ------------------------------------------------------------------------------
def radioButtonGrp(label, **kwargs):
    return maya.cmds.radioButtonGrp(label=itemLabel(label), **kwargs)

# ------------------------------------------------------------------------------
def checkBoxGrp(label, **kwargs):
    return maya.cmds.checkBoxGrp(label=itemLabel(label), numberOfCheckBoxes=1, **kwargs)

# ------------------------------------------------------------------------------
def textFieldGrp(label, **kwargs):
    return maya.cmds.textFieldGrp(label=itemLabel(label), **kwargs)

# ------------------------------------------------------------------------------
def intFieldGrp(label, **kwargs):
    return maya.cmds.intFieldGrp(label=itemLabel(label), **kwargs)

# ------------------------------------------------------------------------------
def floatFieldGrp(label, **kwargs):
    return maya.cmds.floatFieldGrp(label=itemLabel(label), **kwargs)

# ------------------------------------------------------------------------------
class AttributeLayoutManager(LayoutManager):
    """
    This class is a simple manager that creates the default scoped layout
    for attributes in the option box dialogs
    """

    def __init__(self):
        """
        Simple constructor that just remembers the name of the given layout.
        """
        self.name = maya.cmds.columnLayout(adjustableColumn=False)

# ------------------------------------------------------------------------------
class HeaderLayoutManager(LayoutManager):
    """
    This class is a simple manager that creates the default scoped layout
    for a header in the option box dialogs
    """

    def __init__(self, label, collapsable=False):
        """
        Simple constructor that just remembers the name of the given layout.
        """
        self.name = maya.cmds.frameLayout(label=label, collapsable=collapsable, marginHeight=5)

# ------------------------------------------------------------------------------
def getMainProgressBar():
    """
    Returns the name of Maya's main progress bar, or None if the main progress
    bar is not available.

    The main progress bar may be unavailable in non-interactive/Python-only
    sessions of Maya.
    """
    from maya import mel

    whatIsProgressBar = mel.eval('whatIs \"$gMainProgressBar\";')
    if whatIsProgressBar != 'string variable':
        return None

    mainProgressBar = mel.eval('$tmp = $gMainProgressBar')
    return mainProgressBar

# ------------------------------------------------------------------------------
def createIcon(iconName):
    import maya.OpenMayaUI as mui
    from shiboken2 import wrapInstance
    from PySide2.QtGui import QIcon
    return wrapInstance(int(mui.MQtUtil.createIcon(iconName)), QIcon)

# ------------------------------------------------------------------------------
class UndoContextManager(object):
    """Safe way to manage group undo chunks using the 'with' command.
    It will close the chunk automatically on exit from the block

    Example:
        with UndoContextManager('Create Poly Cubes'):
            cmds.polyCube()
            cmds.polyCube()
        cmds.undo() # Will undo both polyCube() creation calls."""

    openChunk = True

    def __init__(self, name='unnamedOperation'):
        self.name = name
        self.closeChunk = False

    def __enter__(self):
        if UndoContextManager.openChunk:
            self.closeChunk = True
            UndoContextManager.openChunk = False
            maya.cmds.undoInfo(openChunk=True, chunkName=self.name)
        return None

    def __exit__(self, type, value, traceback):
        if self.closeChunk:
            maya.cmds.undoInfo(closeChunk=True)
            UndoContextManager.openChunk = True

# ------------------------------------------------------------------------------
def undoChunk(chunkName):
    """Undo decorator to name and group in a single chunk all commands
    inside the decorated callable."""

    # Decorator functions always take a single argument (usually the
    # decorated function), so we need to use a layered approach so we can
    # also pass in the undo chunk name.
    #
    # The top-level decorator function ("chunk") is only there to pass in
    # the undo chunk name as its single argument.  It returns the actual
    # decorator function ("decorator").  decorator is the function doing
    # the decorating: its single argument is the decorated function, and it
    # returns the wrapper ("wrapper") function, which is used instead of
    # the decorated function.  Where the decorated function would have been
    # called, wrapper is now called instead, and it uses the CtxMgr context
    # to group all undoable commands into a single, named undo chunk.

    def decorator(f):
        def wrapper(*args, **kwargs):
            with UndoContextManager(chunkName):
                return f(*args, **kwargs)
        return wrapper
    return decorator

# ------------------------------------------------------------------------------
def makeUndoable(fct):
    def internal(*args,**kwargs):
        with UndoContextManager() as undomgr:
            return fct(*args,**kwargs)
    return internal

# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
