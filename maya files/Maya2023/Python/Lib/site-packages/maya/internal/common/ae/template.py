import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
import maya.cmds as cmds
import maya.mel as mel
import maya.internal.common.ae.custom as aecustom
import re


class Layout(object):
    def __init__(self, template, name, collapse=False):
        self.template = template
        self.collapse = collapse
        self.name = name
    def __enter__(self):
        cmds.editorTemplate(beginLayout=self.name, collapse=self.collapse)
        return self.template

    def __exit__(self, mytype, value, tb):
        cmds.editorTemplate(endLayout=True)


class Template(object):
    def __init__(self, nodeName):
        self.nodeName = nodeName

        cmds.editorTemplate(beginScrollLayout=True)
        self.buildUI(nodeName)
        cmds.editorTemplate(addExtraControls=True)
        cmds.editorTemplate(endScrollLayout=True)

    @staticmethod
    def addSeparator():
        cmds.editorTemplate(addSeparator=True)

    @staticmethod
    def suppress(control):
        cmds.editorTemplate(suppress=control)

    @staticmethod
    def addControl(control, callback=None, label=None, annotation=None):
        if callback:
            cmds.editorTemplate(label=label, addControl=[control, callback], annotation=annotation)
        else:
            cmds.editorTemplate(label=label, addControl=[control], annotation=annotation)
        return

    def addControls(self, controls):
        for c in controls:
            self.addControl(c)

    def buildUI(self, nodeName):
        raise NotImplementedError(maya.stringTable['y_maya_internal_common_ae_template.kErrMsgBuildUINotImplemented' ])

    def suppressAll(self):
        attrs = cmds.listAttr(self.name) or []
        attrs = set(attrs)

        attrs = attrs.difference(set(['caching', 'frozen', 'nodeState']))

        userDefined = cmds.listAttr(self.name, ud=True) or []
        userDefined = set(userDefined)

        attrs = attrs.difference(userDefined)

        for attr in attrs:
            cmds.editorTemplate(suppress=attr)

    def callTemplate(self, templateName):
        mel.eval(u'AE{0}Template {1}'.format(templateName, self.nodeName))


    @staticmethod
    def defineCustom(customObj, attrs=[]):
        create = lambda *args : customObj.onCreate(args)
        replace = lambda *args : customObj.onReplace(args)
        cmds.editorTemplate(attrs, callCustom=[create, replace])

    @staticmethod
    def defineQtCustom(widgetClassFn, attrs=[]):
        Template.defineCustom(aecustom.QtCustomControl(widgetClassFn), attrs)

# --------------------------------------------------------------------------------------------------
def get_module(moduleName):
    import importlib
    try:
        mod = importlib.import_module(moduleName)
        return mod
    except Exception:
        return None

# --------------------------------------------------------------------------------------------------

def ae_define(nodeType, nodeName):
    
    moduleName = u'maya.internal.nodes.{0}.ae_template'.format(nodeType.lower())

    mod = get_module(moduleName)
    if mod is None:
        return False

    try:
        met = getattr(mod, 'AETemplate')
        met(nodeName)
        return True
    except Exception:
        return False


def dragCallback(dragControl, x, y, mods ):
    """
        drag Callback return the attribute related to control.
        It is used by createDraggable
    """
    objectTypeUI = cmds.objectTypeUI(dragControl)
    if objectTypeUI == "rowGroupLayout" or objectTypeUI == "checkBox":
        return [cmds.attrControlGrp(dragControl, q=True, attribute=True)]
    else:
        cmds.error("AEdragCallback - Unsupported UI object type")

def createDraggable(functor, plugName, attrName, changedCommand):
    """
        Use from TPSDatabase.cpp to setup draggable control
    """
    return cmds.control(functor(plugName, attrName, changedCommand), e=True, dragCallback=dragCallback)

def createDraggableArray(functor, plugsName, attrNames, changedCommand):
    """
        Use from TPSDatabase.cpp to setup draggable array control (3 bool for example)
    """
    draggableControl = functor(plugsName, attrNames,changedCommand)
    ca = cmds.formLayout(draggableControl, q=True, childArray=True)
    # This childArray should contain static text followed by the check boxes
    ca2 = cmds.layout(ca[0], q=True, childArray=True)
    # Skip the static text and set the drag callback for each check box.
    for ctrl in ca2:
        cmds.control(ctrl, e=True, dragCallback=dragCallback)

    return cmds.control(draggableControl, e=True)


def plugNode(plugName):
    """
    returns the node name part of plugName
    """
    return plugName.split(".")[0]


def plugAttr(plugName):
    """
    return the full attribute name node.attr.foo[4] => attr.foo[4]
    """
    return ".".join(plugName.split(".")[1:])



def plugIsMulti(plugName):
    return plugName.find('[') != -1

def plugMultiAttr(plugName):
    """
    returns the attribute name without [] parts
    node.attr.foo[4] => attr.foo
    """
    return plugAttr(plugName).split("[")[0]


def plugMultiIndex(plugName, attr):
    """ returns the indices between [] for the given attr
        ex: a[3] => return 3 if attr = a
        a.b[3].c[2].d returns 2 if attr = c
    """
    r = re.search(attr + """\\[([0-9]+)\\]""", plugName)
    return int(r.group(1)) if r else None

def plugLastMultiAttr(plugName):
    """
    return the last attribute name node.attr.foo[4].foo => foo
    """
    return (plugName.split(".")[-1]).split("[")[0]


def isClassified(node, classification):
    """
    Helper routine to check classification of a node
    """
    return cmds.getClassification(cmds.nodeType(node), satisfies=classification)


def attachCallback(plugName, control, changedCommand):
    """
    Wraps and attaches a command when attribute changed.
    It will pass to the changed command the node named specified in the plugName
    """
    if  changedCommand:
        cmds.scriptJob(p=control, rp=True, ac=(plugName, lambda *a: changedCommand(plugNode(plugName))))
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
