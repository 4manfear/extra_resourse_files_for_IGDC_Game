"""
Usage: Class Example (example calls for menuItem, menuItemDialog, and commandline)
    MenuItemDialog:      MyCommand().createDialog()
    MenuItem:            MyCommand().executeWithPreferences()
    Commandline:         MyCommand().executeWithDefaults()
    Commandline:         MyCommand().execute()

    The three execute commands above can all have optional user overrides
    Overrides:           MyCommand().executeWithDefaults(someOption=True)

Note: this class has been adapted from CommandWithOptionVars.py inside the
      bullet plugin. There are some minor modifications and additions to make
      this more general.
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


from builtins import object
import string

import maya.cmds
import maya.mel
import maya.internal.common.utils.connections as con_utils
import maya.internal.common.utils.message as msg_utils
import maya.internal.common.utils.ui as ui_utils

# ==============================================================================
# BaseClass: Command
# ==============================================================================

class Command(object):
    '''Base class that handles Maya Commands. Tailored for MenuItems.
     * Executes command from menu
     * Displays option box dialog
     * Gets/Sets OptionVars

    This is the Base Class for handling all that is needed for menuItem, the
    menuItem w/ Dialog, and commandline calls. One can derive a class
    for individual menuItems/actions with minimal code as shown below.

    :Examples:
        MenuItemDialog:      MyCommand().createDialog()
        MenuItem:            MyCommand().executeWithPreferences()
        Commandline:         MyCommand().executeWithDefaults()
        Commandline:         MyCommand().execute()

        The three execute commands above can all have optional user overrides
        Overrides:           MyCommand().executeWithDefaults(someOption=True)
    '''

    setValue1Widgets = (
        maya.cmds.checkBoxGrp,
        maya.cmds.floatFieldGrp,
        maya.cmds.intFieldGrp,
        )

    setValue4Widgets = (
        maya.cmds.floatFieldGrp,
        maya.cmds.intFieldGrp,
        )

    getValue1Widgets = (
        maya.cmds.checkBoxGrp,
        )

    def __init__(self):
        super(Command, self).__init__()

        # List of optionVars used and their default values
        self.optionVarCategory = ''
        self.optionVarPrefix = ''        # Prefix for optionVar keys.  OptionVarKey=<prefix>+<optionVarDictKey>
        self.optionVarDefaults = {}      # Key/value pair for optionVarDict defaults (without the prefix)
        self.commandName = maya.stringTable['y_maya_internal_common_cmd_base.kCommandUnspecified' ] # Used for titling in the Dialog
        self.commandHelpTag = None
        self.commandDescription = None
        self.commandTitle = None

        self.windowTag = None
        self.defaultWindowSize = [0, 0]
        self.optionVarToWidgetDict = {}  # {optionVarDictKey, (widgetClass, widget)}  Internal for addOptionDialogWidgets. Internal dict that needs to be set when adding widgets. Needed by the get/set Widget functions.
        self.optionMenuGrp_labelToEnum = {} # dict optionVarDictKeys with value as a dict of labels to values (used for optionMenuGrp).  Set in addOptionDialogWidgets.
        self.optionMenuGrp_enumToLabel = {} # generated from optionMenuGrp_labelToEnum
        self.windowBox = None

        self.mainLayout = None
        self.wantTabs = False
        self.tabLayout = None
        self.tab1 = None
        self.tab2 = None

    # ==========================================================================
    # Override
    # ==========================================================================
    @classmethod
    def command(cls, **kwargs):
        '''OVERRIDE
        Override this function for the command execute.
        Specify keywords for optional parameters.
        '''
        raise NotImplementedError(maya.stringTable['y_maya_internal_common_cmd_base.kErrMsgCommandNotImplemented' ])


    def addOptionDialogWidgets(self):
        '''OVERRIDE
        Override this function to place Widgets in OptionBox Dialog
        Make sure to return a dict of {optionVarDictKey, (widgetClass, widget)}
        Also set  self.optionMenuGrp_labelToEnum[optionVarDictKey] = {<label> : <value>,}
        if using optionMenuGrp
        '''
        raise NotImplementedError(maya.stringTable['y_maya_internal_common_cmd_base.kErrMsgAddOptionDialogNotImplemented' ])
        # widgetDict = {} # dict format: {optionVarDictKey, (widgetClass, widget)}
        # return widgetDict

    def updateWindow(self):
        '''OVERRIDE
        Override this function to update the opened option box based on a selection change.
        '''
        return None

    def windowBoxClosing(self):
        '''OVERRIDE
        Override this function to perform any cleanup operations
        '''
        return None

    def customApplyAndCloseButtonLabel(self):
        '''OVERRIDE
        Override this function to specify a custom label
        '''
        return None

    def closeWindow(self):
        self.windowBoxClosing()

        if self.windowBox:
            self.windowBox.hideWindow()
        else:
            maya.mel.eval('hideOptionBox()')

    def setDefaultDialogSize(self, force=False):
        sz = self.defaultWindowSize
        if len(sz) != 2 or sz[0] <= 0 or sz[1] <= 0:
            return

        optVarKey = self.getWindowSizeOptionVar()
        if not force and maya.cmds.optionVar(exists=optVarKey):
            return

        maya.cmds.optionVar(init=force, category=self.optionVarCategory, iv2=(optVarKey,sz[0],sz[1]))

    def getWindowSizeOptionVar(self):
        return u'optionBoxDimensions{0}'.format(self.commandHelpTag)

    def getMainLayout(self):
        return maya.mel.eval('getOptionBox()')

    # ===========
    # OptionVars
    # ===========
    def getOptionVars(self):
        '''Create a dict by retrieving the optionVars, use the default value if
        optionVar not found.
        '''
        # start with defaults
        optionVarDict = self.optionVarDefaults.copy()

        # update dict from optionVars
        for k in list(optionVarDict.keys()):
            # NOTE: optionVar has the prefix added. The optionVarDict key does not
            optVarKey = self.optionVarPrefix+k
            if (maya.cmds.optionVar(exists=optVarKey)):
                optionVarDict[k] = maya.cmds.optionVar(q=optVarKey)

        # return dict
        return optionVarDict

    def setOptionVars(self, optionVarDict):
        '''Only set the optionVars that are non-default. Remove optionVar if value=defaultValue.
        '''
        # update optionVars from dict
        from sys import version_info as sys_version_info
        text_type = str if sys_version_info[0] >= 3 else unicode
        integer_types = int if sys_version_info[0] >= 3 else (int, long)
        for k, v in list(optionVarDict.items()):
            optVarKey = self.optionVarPrefix+k
            if self.optionVarDefaults[k] == v:
                maya.cmds.optionVar(remove=optVarKey)  # remove if it exists
            else:
                if isinstance(v, (float)):
                    maya.cmds.optionVar(category=self.optionVarCategory, fv=(optVarKey,v))
                elif isinstance(v, (int)):
                    maya.cmds.optionVar(category=self.optionVarCategory, iv=(optVarKey, v))
                elif isinstance(v, (str, text_type)):
                    maya.cmds.optionVar(category=self.optionVarCategory, sv=(optVarKey, v))
                elif isinstance(v, (list)) and len(v) > 0 and isinstance(v[0], (float)):
                    maya.cmds.optionVar(category=self.optionVarCategory, fa=optVarKey)
                    for f in v:
                        maya.cmds.optionVar(fva=(optVarKey, f))
                elif isinstance(v, (list)) and len(v) > 0 and isinstance(v[0], integer_types):
                    maya.cmds.optionVar(category=self.optionVarCategory, ia=optVarKey)
                    for f in v:
                        maya.cmds.optionVar(iva=(optVarKey, f))
                elif isinstance(v, (list)) and len(v) > 0 and isinstance(v[0], (str, text_type)):
                    maya.cmds.optionVar(category=self.optionVarCategory, sa=optVarKey)
                    for f in v:
                        maya.cmds.optionVar(sva=(optVarKey,f))
                else:
                    raise Exception(u'Unknown type {0} for {1} of option var: {2}'.format(type(v), v, k))
                # end-if
            # end-if
        # end-for
    # end setOptionVars()

    def executeWithPreferences(self, **kwargs):
        '''
        Performs command with the default optionVars plus the stored
        optionVar preferences plus user overrides.
        '''
        cmdKwargs = self.optionVarDefaults.copy()
        cmdKwargs.update(self.getOptionVars())
        cmdKwargs.update(kwargs)

        return self.command(**cmdKwargs)

    def executeWithDefaults(self, **kwargs):
        '''
        Performs command with the default optionVars plus user specified overrides.
        '''

        cmdKwargs = self.optionVarDefaults.copy()
        cmdKwargs.update(kwargs)

        return self.command(**cmdKwargs)

    def execute(self, **kwargs):
        '''
        Performs command plus user specified overrides.
        '''
        return self.command(**kwargs)

    # ==========================================================================
    # Callbacks
    # ==========================================================================
    def _executeApplyCB(self, *args):
        '''Callback for "Apply" Option Dialog button.
        Saves the optionVars from the dialog and executes the command.
        Note: Requires OptionBox Dialog to be created.
        '''
        self._saveOptionVarPreferencesCB()
        returnVal = self.executeWithPreferences()
        self.updateWindow()
        return returnVal

    def _executeApplyAndCloseCB(self, *args):
        '''Callback for "Apply and Close" Option Dialog button
        Saves the optionVars from the dialog, executes the command, and hides dialog.
        Note: Requires OptionBox Dialog to be created.
        '''
        returnVal = self._executeApplyCB()

        self.closeWindow()
        return returnVal


    def _executeCloseCB(self, *args):
        '''Callback for "Close" Option Dialog button
        Saves the optionVars from the dialog, and hides dialog.
        Note: Requires OptionBox Dialog to be created.
        '''
        self._saveOptionVarPreferencesCB()
        self.closeWindow()

    def _visibilityChangedCB(self, *args):
        '''Callback for visibility changes to the Option Dialog.
        If no longer visible, saves the optionVars from the dialog,
        and hides dialog.
        Note: Requires OptionBox Dialog to be created.
        '''
        pass

    def _saveOptionVarPreferencesCB(self, *args):
        '''Callback for the "Save" Option Dialog menuitem.
        Saves the optionVars from the dialog
        Note: Requires OptionBox Dialog to be created.
        '''
        optionVarDict = self.getWidgetValues()
        self.setOptionVars(optionVarDict)

        if self.windowBox:
            self.windowBox.saveWindowSize()

    def _resetOptionVarPreferencesCB(self, *args):
        '''Callback for the "Reset" Option Dialog menuitem.
        Resets the optionVars in the dialog to the Prefs default.
        Note: Requires OptionBox Dialog to be created.
        '''
        self.setOptionVars(self.optionVarDefaults)
        self.setWidgetValues(self.optionVarDefaults)
        self.updateWindow()

    # ==========================================================================
    # Dialog
    # ==========================================================================

    def _getWidgetValue(self, optionVarDictKey, widgetClass, widget):
        if widgetClass in Command.getValue1Widgets:
            v = widgetClass(widget, query=True, value1=True)
        elif widgetClass == maya.cmds.optionMenuGrp:
            v = self.optionMenuGrp_labelToEnum[optionVarDictKey] \
                                                [widgetClass(widget, query=True,
                                                            value=True)]
        elif widgetClass == maya.cmds.textFieldGrp:
            v = widgetClass( widget, query=True, text=True)
        elif widgetClass == maya.cmds.radioButtonGrp:
            v = widgetClass( widget, query=True, select=True)
        else: # assuming value=<val> widgets
            v = widgetClass(widget, query=True, value=True)
            # convert to a single value if a single value list
            if isinstance(v, list) and len(v) == 1:
                v = v[0]

        return v

    def _setWidgetValue(self, widgetValue, optionVarDictKey, widgetClass, widget):
        '''Set the Option Dialog widget values from the supplied dict
        '''
        # REVISIT: There are some nuances with setting the values depending
        #          on the widget type and optionVar typecasting
        #
        # LIMITATION: Only supporting 1 value per widget
        #
        # List the value1=<val> widgets

        try:
            if widgetClass in Command.setValue1Widgets and not isinstance(widgetValue, list):
                widgetClass(widget, edit=True, value1=widgetValue)
            elif widgetClass == maya.cmds.optionMenuGrp:
                try:
                    widgetClass(widget, edit=True, value=self.optionMenuGrp_enumToLabel[optionVarDictKey][widgetValue])
                except RuntimeError:
                    msg_utils.showWarning(maya.stringTable['y_maya_internal_common_cmd_base.kWrnOptionMenuSetValue' ].format(optionVarDictKey, widgetValue))
            elif widgetClass in Command.setValue4Widgets and isinstance(widgetValue, list):
                # always send list of 4 floats to this
                widgetValue4 = [0,0,0,0]
                for i, value in enumerate(widgetValue):
                    widgetValue4[i] = value
                widgetClass(widget, edit=True, value=widgetValue4)
            elif widgetClass == maya.cmds.textFieldGrp:
                widgetClass(widget, edit=True, text=widgetValue)
            elif widgetClass == maya.cmds.radioButtonGrp:
                # Because the radio buttons' index starts from one according to the radioButtonGrp doc, we
                # make an offset to match the selection.
                widgetClass(widget, edit=True, select=widgetValue)
            else: # assuming value=<val> widgets
                widgetClass(widget, edit=True, value=widgetValue)
        except TypeError:
            msg_utils.showWarning(maya.stringTable['y_maya_internal_common_cmd_base.kWrnMsgRetrieve' ].format(widgetClass, optionVarDictKey, widgetValue))
            #raise

    def getWidgetValue(self, optionVarDictKey):
        widgetClass, widget = self.optionVarToWidgetDict.get(optionVarDictKey, (None, None))
        if widgetClass is None:
            return None
        return self._getWidgetValue(optionVarDictKey, widgetClass, widget)

    def getWidgetValues(self):
        '''Get the Option Dialog widget values and store them in the returned dict.
        '''
        # REVISIT: There are some nuances with setting the values depending
        #          on the widget type and optionVar typecasting
        #
        # LIMITATION: Only supporting 1 value per widget
        #
        # List the value1=<val> widgets
        optionVarDict = {} # populate this dict

        for optionVarDictKey, (widgetClass, widget) in list(self.optionVarToWidgetDict.items()):
            v = self._getWidgetValue(optionVarDictKey, widgetClass, widget)
            optionVarDict[optionVarDictKey] = v

        return optionVarDict
    # end

    def setWidgetValues(self, optionVarDict):
        '''Set the Option Dialog widget values from the supplied dict
        '''
        for optionVarDictKey, (widgetClass, widget) in list(self.optionVarToWidgetDict.items()):
            widgetValue = optionVarDict[optionVarDictKey]
            self._setWidgetValue(widgetValue, optionVarDictKey, widgetClass, widget)

    def setWidgetValue(self, optionVarDictKey, widgetValue):
        '''Set the Option Dialog widget value
        '''
        widgetClass, widget = self.optionVarToWidgetDict.get(optionVarDictKey, (None, None))
        if widgetClass is not None:
           self._setWidgetValue(widgetValue, optionVarDictKey, widgetClass, widget)

    def createDialog(self, optionVarOverrideDict=None, saveOptionVars=True):
        '''Callback for the MenuItem OptionBox.
        Create and show the Option Dialog for this command.
        Supplies the header and footer for the dialog.
        Calls `addOptionDialogWidgets` to create the widgets.
        '''
        # == Retrieve optionVars ==
        optionVarDict = self.getOptionVars()
        # override specified values with incoming dict if != None
        if optionVarOverrideDict != None:
            optionVarDict.update(optionVarOverrideDict)

        # == Dialog header ==
        self.setDefaultDialogSize(force=False)
        self.mainLayout = self.getMainLayout()

        maya.cmds.setParent(self.mainLayout)

        # Set the command name
        if self.windowBox:
            self.windowBox.setCommandName(self.commandName)
        else:
            maya.mel.eval('setOptionBoxCommandName("{0}")'.format(self.commandName))

        maya.cmds.setUITemplate('DefaultTemplate', pushTemplate=True)
        maya.cmds.waitCursor(state=True)

        # Create a tablayout with hidden tab labels and one tab...
        if self.wantTabs:
            self.tabLayout = maya.cmds.tabLayout(tv=True, scr=True)
        else:
            scrollLayout = maya.cmds.scrollLayout(horizontalScrollBarThickness=16, verticalScrollBarThickness=16, childResizable=True)
            maya.cmds.formLayout(self.mainLayout , edit=True,
                attachForm = [
                    (scrollLayout, ui_utils.TOP, 0),
                    (scrollLayout, ui_utils.LEFT, 0),
                    (scrollLayout, ui_utils.BOTTOM, 0),
                    (scrollLayout, ui_utils.RIGHT, 0)])

            self.topLayout = maya.cmds.columnLayout(adjustableColumn=True)

        # == Dialog attrs ==
        # Add parameters
        self.optionVarToWidgetDict = self.addOptionDialogWidgets()

        # If nothing returned by the function addOptionDialogWidgets(),
        # then set it to an empty dict
        if self.optionVarToWidgetDict == None:
            self.optionVarToWidgetDict = {}
        # Create reverse dict (for optionMenuGrp widget)
        self.optionMenuGrp_enumToLabel = {}
        for k_labelToEnum, v_labelToEnum in list(self.optionMenuGrp_labelToEnum.items()):
            self.optionMenuGrp_enumToLabel[k_labelToEnum] = dict([(v, k) for k, v in list(v_labelToEnum.items())])

        # Verify there is a defaultValue for each widgetKey
        missingDefaults = set(self.optionVarToWidgetDict.keys()) - set(self.optionVarDefaults.keys())
        if len(missingDefaults) > 0:
            raise ValueError(u'Missing default optionVar keys: {0}'.format(str(missingDefaults)))
        omittedWidgetKeys = set(self.optionVarDefaults.keys()) - set(self.optionVarToWidgetDict.keys())
        if len(omittedWidgetKeys) > 0:
            msg_utils.showWarning(maya.stringTable['y_maya_internal_common_cmd_base.kWrnMsgMissingWidgets' ].format(str(omittedWidgetKeys)))

        # Set Widget Values
        # REVISIT: Put a try/catch around this??
        self.setWidgetValues(optionVarDict)

        # == Dialog footer ==
        maya.cmds.waitCursor(state=False)
        maya.cmds.setUITemplate(popTemplate=True)

        # * Buttons, Titling and Help
        if self.windowBox:
            self.windowBox.setWindowTitle(self.commandTitle)
            self.windowBox.setHelpTag(self.commandHelpTag)
            self.windowBox.setWindowTag(self.windowTag)

            applyBtn = self.windowBox.applyBtn
            applyAndCloseBtn = self.windowBox.applyAndCloseBtn
            closeBtn = self.windowBox.closeBtn
            saveItem = self.windowBox.editMenuSaveItem
            resetItem = self.windowBox.editMenuResetItem

        else:
            maya.mel.eval(u'setOptionBoxTitle("{0}")'.format(self.commandTitle))
            htag = self.commandHelpTag if self.commandHelpTag else u'{0}Options'.format(self.commandName)
            maya.mel.eval(u'setOptionBoxHelpTag("{0}")'.format(htag))

            applyBtn = maya.mel.eval('getOptionBoxApplyBtn()')
            applyAndCloseBtn = maya.mel.eval('getOptionBoxApplyAndCloseBtn()')
            closeBtn = maya.mel.eval('getOptionBoxCloseBtn()')
            saveItem = maya.mel.eval('getOptionBoxEditMenuSaveItem()')
            resetItem = maya.mel.eval('getOptionBoxEditMenuResetItem()')

        # Handle apply and close button commands and set the menu items
        if applyAndCloseBtn:
            maya.cmds.button(applyAndCloseBtn, edit=True, command=self._executeApplyAndCloseCB)

            lbl = self.customApplyAndCloseButtonLabel()
            if lbl is not None:
               maya.cmds.button(applyAndCloseBtn, edit=True, label=lbl)

        if closeBtn:
            maya.cmds.button(closeBtn, edit=True, command=self._executeCloseCB)

        if applyBtn:
            maya.cmds.button(applyBtn,
                             edit=True,
                             command=self._executeApplyCB);

        if saveItem:
            maya.cmds.menuItem(saveItem, edit=True, command=self._saveOptionVarPreferencesCB)
        if resetItem:
            maya.cmds.menuItem(resetItem, edit=True, command=self._resetOptionVarPreferencesCB)

        # == Show OptionBox
        if self.windowBox:
            self.windowBox.showWindow()
        else:
            maya.mel.eval('showOptionBox()')

        maya.cmds.control(self.mainLayout, edit=True, visibleChangeCommand=self._visibilityChangedCB)

        # Allow the subclass to make any modifications
        self.updateWindow()

    @classmethod
    def finalizeCommand(cls, createdNodes=None, selectNodes=None, addToSelection=True):

        # If command echoing is off, echo this short line.
        if (not maya.cmds.commandEcho(query=True, state=True)):
            print("{0}.execute()".format(cls.__name__))
            if createdNodes and len(createdNodes) > 0:
                print("// Result: {} //".format(createdNodes))

        # Select and return
        if addToSelection:
            # if selectNodes was specified use that, otherwise use createdNodes
            selNodes = selectNodes if selectNodes is not None else createdNodes
            if selNodes and len(selNodes) > 0:
                maya.cmds.select(selNodes, add=True)

        return createdNodes

    @classmethod
    def setNodeAttributes(cls, node, argDict, settableAttrs, attrPrefix=None):
        ''' Set node  attributes using the settableAttrs as a qualifying list.
            Only set if value != None.
        '''
        plugBase = u'{0}.{1}'.format(node,attrPrefix) if attrPrefix else node
        con_utils.setAttributes(plugBase, argDict, settableAttrs)


# ==============================================================================
# UTILITIES
# ==============================================================================

def retrieveOptionVars(prefix='', stripPrefix=False):
    '''Retrieve a list of optionVars with the specified prefix

    :Parameters:
        prefix: filter optionVars and retrieve only those that start with the specified prefix
        stripPrefix: strip off the prefix string from the keys returned in the dict

    Returns:
        dict of optionVars

    Example: retrieveOptionVars(prefix='myCommand_')
    '''
    # get a list of the keys of the existing optionVars filtered by the prefix
    optionVarKeys = [str(i) for i in maya.cmds.optionVar(list=True) if i.startswith(prefix)]

    # strip off prefix from key names if desired
    prefixLength = len(prefix)
    if stripPrefix and prefixLength > 0:
        optionVarKeys = [i[prefixLength:] for i in optionVarKeys]

    # create the dictionary by retrieving the values for the keys
    optionVarDict = dict([(k,maya.cmds.optionVar(q=k)) for k in optionVarKeys])

    # return resulting dict
    return optionVarDict


# ------------------------------------------------------------------------------
def get_module(moduleName):
    import importlib
    try:
        mod = importlib.import_module(moduleName)
        return mod
    except Exception:
        return None

# ------------------------------------------------------------------------------
def getCommandClass(nodeTypeCmd):
    # f.e. nodeTypeCmd = 'tension.cmd_create'
    moduleName = u'maya.internal.nodes.{0}'.format(nodeTypeCmd.lower())
    mod = get_module(moduleName)
    if mod is None:
        return None

    try:
        met = getattr(mod, 'Command')
        return met
    except Exception:
        return None

# ------------------------------------------------------------------------------
def openCommandDialog(nodeTypeCmd):
    # f.e. nodeTypeCmd = 'tension.cmd_create'
    met = getCommandClass(nodeTypeCmd)
    if met is not None:
        met().createDialog()
        return True
    else:
        return False

# ------------------------------------------------------------------------------
def executeCommand(nodeTypeCmd):
    # f.e. nodeTypeCmd = 'tension.cmd_create'
    met = getCommandClass(nodeTypeCmd)
    if met is not None:
        met().executeWithPreferences()
        return True
    else:
        return False
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
