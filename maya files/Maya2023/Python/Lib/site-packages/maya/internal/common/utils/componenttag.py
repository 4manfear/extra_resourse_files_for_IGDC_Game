import maya.cmds
import maya.internal.common.utils.geometry as geo_utils
import maya.internal.common.utils.connections as con_utils

#===============================================================================
def getInputConnection(plugName):
    cons = maya.cmds.listConnections(plugName, plugs=False, shapes=True, destination=False)
    if cons and len(cons) > 0:
        return cons[0]
    return None

#===============================================================================
def getDotPrefix(s):
    return s.split('.')[0]

#===============================================================================
def stripDotPrefix(s):
    return s.split('.')[-1]

#===============================================================================
def selectionToCompList(shape):
    selComp = maya.cmds.ls(shape, selection=True)
    return [stripDotPrefix(s) for s in selComp if '.' in s]

#===============================================================================
def getOriginalShape(shape):
    orig = maya.cmds.deformableShape(shape, og=True)[0]
    if orig:
        return getDotPrefix(orig)
    else:
        return shape

#===============================================================================
def getFrontOfChainShape(shape):
    orig = maya.cmds.deformableShape(shape, foc=True)[0]
    if orig:
        return getDotPrefix(orig)
    else:
        return shape

#===============================================================================
def getInjectionNode(shape):
    # Get the front most injection shape that is not referenced
    # This could be the requesting shape itself
    injectionNode = maya.cmds.deformableShape(shape, ti=True)
    if injectionNode and len(injectionNode):
        return injectionNode[0]

    if maya.cmds.objectType(shape, isAType='componentTagBase'):
        return shape

    return None

#===============================================================================
def getOrCreateUpstreamInjectionNode(shape):
    # Get or create the front most injection shape that is not referenced
    # upstream from the shape
    injectionNode = maya.cmds.deformableShape(shape, cti=True)[0]
    if injectionNode:
        return injectionNode
    return None

#===============================================================================
def getOutputPlug(nodeName):
    try:
        ctb =  maya.cmds.ls(nodeName, type="componentTagBase")
        if ctb:
            return f'{nodeName}.outputGeometry'
        else:
            lso = maya.cmds.deformableShape(nodeName, lso=True)[0]
            plugName = f'{nodeName}.{lso}'
            return plugName
    except:
        return None

#===============================================================================
def getTagIndices(shape):
    try:
        indices = con_utils.getValidMultiIndices('{0}.componentTags'.format(shape))
        return indices if indices else []
    except:
        return []

#===============================================================================
def getNextTagIndex(shape):
    try:
        indices = con_utils.getValidMultiIndices('{0}.componentTags'.format(shape))
    except:
        return 0

    if not indices:
        return 0

    indexSet = set(indices)
    startIndex = 0
    while startIndex < 10000000:
        if not startIndex in indexSet:
            return startIndex
        startIndex += 1
    return None


#===============================================================================
def getPlugBase(shape, idx):
    return '{0}.componentTags[{1}]'.format(shape, idx)

#===============================================================================
def findTagIndex(shape, tagName):
    if shape is None:
        return None
    indices = getTagIndices(shape)
    for idx in indices:
        plugBase = getPlugBase(shape, idx)
        nm = maya.cmds.getAttr('{0}.gtagnm'.format(plugBase))
        if nm == tagName:
            return idx
    return None

#===============================================================================
def findOrCreateTagIndex(injectionShape, tagName):
    if injectionShape is None:
        return None
    idx = findTagIndex(injectionShape, tagName)
    if idx is not None:
        return idx

    idx = getNextTagIndex(injectionShape)
    if idx is not None:
        plugBase = getPlugBase(injectionShape, idx)
        res = _setTagName(plugBase, tagName)
        if not res:
            return None
    return idx

#===============================================================================
def selectComponents(shape, injectionShape, idx):
    if idx is None:
        return

    plugBase = getPlugBase(injectionShape, idx)
    comp = maya.cmds.getAttr('{0}.gtagcmp'.format(plugBase))
    if not comp:
        return

    args = []
    for c in comp:
        args.append('{0}.{1}'.format(shape, c))
    maya.cmds.select(*args, r=True)


#===============================================================================
def getTagNames(injectionShape):
    tagNames = list()
    if injectionShape is None:
        return tagNames
    indices = getTagIndices(injectionShape)
    if indices is None:
        return tagNames

    for idx in indices:
        plugBase = getPlugBase(injectionShape, idx)
        nm = maya.cmds.getAttr('{0}.gtagnm'.format(plugBase))
        tagNames.append(nm)

    return tagNames

#===============================================================================
def _setTagName(plugBase, newTagName):
    try:
        maya.cmds.setAttr('{0}.gtagnm'.format(plugBase), newTagName, type='string')
    except RuntimeError:
        return False
    return True

#===============================================================================
def selectTagComponent(shape, injectionShape, tagName):
    idx = findTagIndex(injectionShape, tagName)
    selectComponents(shape, injectionShape, idx)

#===============================================================================
def _updateIndexWithComponents(injectionShape, idx, selComp):
    if idx is None:
        return False

    plugBase = getPlugBase(injectionShape, idx)
    maya.cmds.setAttr('{0}.gtagcmp'.format(plugBase), len(selComp), *selComp, type='componentList')
    return True

#===============================================================================
def setTagToComponents(injectionShape, tagName, compList):
    idx = findTagIndex(injectionShape, tagName)
    if idx is None:
        return False
    return _updateIndexWithComponents(injectionShape, idx, compList)

#===============================================================================
def setTagToSelection(shape, injectionShape, tagName):
    return setTagToComponents(injectionShape, tagName, selectionToCompList(shape))

#===============================================================================
def createTag(injectionShape, tagName, compList=None):
    if tagName == '':
        return False

    idx = findOrCreateTagIndex(injectionShape, tagName)
    if idx is None:
        return False

    if compList:
        return _updateIndexWithComponents(injectionShape, idx, compList)
    else:
        return True

#===============================================================================
def createTagWithSelection(shape, injectionShape, tagName):
    return createTag(injectionShape, tagName, selectionToCompList(shape))

#===============================================================================
def renameTag(injectionShape, oldTagName, newTagName):
    if oldTagName == newTagName:
        return False

    idx = findTagIndex(injectionShape, oldTagName)
    if idx is None:
        return False

    idxNew = findTagIndex(injectionShape, newTagName)
    if idxNew is not None:
        return False

    plugBase = getPlugBase(injectionShape, idx)
    return _setTagName(plugBase, newTagName)

#===============================================================================
def deleteTag(injectionShape, tagName):
    idx = findTagIndex(injectionShape, tagName)
    if idx is None:
        return False

    plugBase = getPlugBase(injectionShape, idx)
    maya.cmds.removeMultiInstance(plugBase, b=True)
    return True

#===============================================================================
def getFreeTagName(plugName, baseName='unnamedTag'):
    existingNames = maya.cmds.geometryAttrInfo(plugName, cnm=True)
    base = baseName.rstrip('0123456789')
    numSfx = baseName[len(base):]
    i = (int(numSfx)+1) if len(numSfx) else 1

    tagName = baseName
    while tagName in existingNames:
        tagName = u'{0}{1}'.format(base,i)
        i+=1
    return tagName

#===============================================================================
def convertTagCategory(injectionShape, tagName, ctg):
    """Convert the tag on the injectionShape to another category"""
    plugName = getOutputPlug(injectionShape)
    if plugName:
        import maya.api.OpenMaya as om
        comp = maya.cmds.geometryAttrInfo(plugName, cex=tagName, cmp=True,
                ctf=(ctg==om.MFnGeometryData.kFaces),
                cte=(ctg==om.MFnGeometryData.kEdges),
                ctv=(ctg==om.MFnGeometryData.kVerts))

        return setTagToComponents(injectionShape, tagName, comp)
    else:
        return False

#===============================================================================
def createNewTag(shape, baseName='unnamedTag', withSelection=False):
    """
    Create a new tag for the shape. It will find the appropriate
    injection node to create the tag on.
    """
    plugName = getOutputPlug(shape)
    if plugName:
        tagName = getFreeTagName(plugName, baseName=baseName)
        injectionNode = getInjectionNode(shape)
        if withSelection:
            if createTagWithSelection(shape, injectionNode, tagName):
                return tagName, injectionNode
        else:
            if createTag(injectionNode, tagName):
                return tagName, injectionNode

        return None, injectionNode
    else:
        return None, None

#===============================================================================
#
# NodeInfo
#
#===============================================================================
class NodeInfo(object):
    '''
    Class to collect information about a node with regards to geometry
    and componentTags.

    It will return the information in the form of a dictionary
    '''

    # Keys used in the dictionary
    kName   = 'name'
    kRef    = 'referenceFile'
    kType   = 'geomType'
    kCnt    = 'cnt'
    kCmp    = 'cmp'
    kCtg    = 'category'
    kTags   = 'componentTags'
    kIdx    = 'idx'
    kGid    = 'groupId'
    kGex    = 'componentTagExpression'
    kPlugs  = 'plugs'
    kNode   = 'node'
    kTagHis = 'componentTagHistory'

    def __init__(self, useInput=True, useOutput=True):
        self._useInput = useInput
        self._useOutput = useOutput

    def _getQueryPlugs(self, node):

        plugs = list()

        # First find any geoemtry attributes directly based on node type
        if maya.cmds.objectType(node, isAType='geometryFilter'):
            if self._useInput:
                indices = maya.cmds.getAttr(u'{}.input'.format(node), multiIndices=True) or []
                for i in indices:
                    plugs.append(u'{}.input[{}].inputGeometry'.format(node, i))

            if self._useOutput:
                indices = maya.cmds.getAttr(u'{}.outputGeometry'.format(node), multiIndices=True) or []
                for i in indices:
                    plugs.append(u'{}.outputGeometry[{}]'.format(node, i))

        elif maya.cmds.objectType(node, isAType='shape'):
            lsi = maya.cmds.deformableShape(node, lsi=True)[0]
            lso = maya.cmds.deformableShape(node, lso=True)[0]
            wso = maya.cmds.deformableShape(node, wso=True)[0]

            if self._useInput:
                plugs.append(u'{}.{}'.format(node, lsi))
            if self._useOutput:
                plugs.append(u'{}.{}'.format(node, lso))
                plugs.append(u'{}.{}[0]'.format(node, wso))

        elif maya.cmds.objectType(node, isAType='transform'):
            shapeNode = geo_utils.extendToShape(node)
            if shapeNode is not None:
                return self._getQueryPlugs(shapeNode)

        # Finally add any other geometry connections
        cons = maya.cmds.listConnections(node, plugs=True, c=True) or []
        n = len(cons)
        for i in range(0, n, 2):
            plg = cons[i]
            attrType = maya.cmds.getAttr(plg, type=True)
            if attrType in ('mesh', 'nurbsSurface', 'nurbsCurve', 'lattice'):
                d = maya.cmds.connectionInfo(plg, isDestination=True)
                s = maya.cmds.connectionInfo(plg, isSource=True)
                if self._useOutput and s or self._useInput and d:
                    if not plg in plugs:
                        plugs.append(plg)

        return plugs

    def _getNodeDict(self, node):
        nodeDict = dict()
        nodeDict[self.kName] = node
        if maya.cmds.referenceQuery(node, isNodeReferenced=True):
            nodeDict[self.kRef] = maya.cmds.referenceQuery(node, f=True)
        return nodeDict

    def _getPlugDict(self, plg, withTags=False):
        tp = maya.cmds.getAttr(plg, type=True)
        cnt = maya.cmds.geometryAttrInfo(plg, pc=True) if tp is not None else 0

        plugDict = dict()
        plugDict[self.kName] = plg
        plugDict[self.kType] = tp
        plugDict[self.kCnt] = cnt

        if withTags and tp is not None:
            componentTagArray = list()
            cnm = maya.cmds.geometryAttrInfo(plg, cnm=True)
            for ctag in cnm:
                cmp = maya.cmds.geometryAttrInfo(plg, cex=ctag, cmp=True)
                cnt = maya.cmds.geometryAttrInfo(plg, cex=ctag, ec=True)
                ccy = maya.cmds.geometryAttrInfo(plg, cex=ctag, ccy=True)

                tagDict = dict()
                tagDict[self.kName] = ctag
                tagDict[self.kCmp] = cmp
                tagDict[self.kCnt] = cnt
                tagDict[self.kCtg] = ccy
                componentTagArray.append(tagDict)

            plugDict[self.kTags] = componentTagArray

        return plugDict


    def infoPlugs(self, node):
        ''' Show the generic node attribute information'''
        nodeDict = self._getNodeDict(node)

        plugs = self._getQueryPlugs(node)
        plugArray = list()
        for plg in plugs:
            plugDict = self._getPlugDict(plg, withTags=True)
            plugArray.append(plugDict)

        if len(plugArray) > 0:
            nodeDict[self.kPlugs] = plugArray

        return nodeDict

    def infoShape(self, node):
        ''' Show the shape node specific information'''
        shapeNode = None

        if maya.cmds.objectType(node, isAType='shape'):
            shapeNode = node
        elif maya.cmds.objectType(node, isAType='transform'):
            shapeNode = geo_utils.extendToShape(node)

        if shapeNode is None:
            return None

        nodeDict = self._getNodeDict(shapeNode)

        indices = getTagIndices(shapeNode)
        if len(indices) > 0:
            insertedTagsArray = list()
            for idx in indices:
                plugBase = getPlugBase(shapeNode, idx)
                tagDict = dict()
                tagDict[self.kName] = maya.cmds.getAttr(u'{0}.gtagnm'.format(plugBase))
                tagDict[self.kCmp] = maya.cmds.getAttr(u'{0}.gtagcmp'.format(plugBase))
                tagDict[self.kIdx] = idx
                insertedTagsArray.append(tagDict)

            nodeDict[self.kTags] = insertedTagsArray


        wso = maya.cmds.deformableShape(shapeNode, wso=True)[0]
        plg = u'{}.{}[0]'.format(node, wso)
        cth = maya.cmds.geometryAttrInfo(plg, cth=True)

        n = len(cth)
        if n > 0:
            tagHistoryArray = list()
            for i in range(0, n, 2):
                tagHisDict = dict()
                tagHisDict[self.kName] = cth[i]
                tagHisDict[self.kNode] = cth[i+1]
                tagHistoryArray.append(tagHisDict)

            nodeDict[self.kTagHis] = tagHistoryArray

        return nodeDict

    def infoDeformer(self, node):
        ''' Show the deformer node specific information'''
        if not maya.cmds.objectType(node, isAType='geometryFilter'):
            return None

        nodeDict = self._getNodeDict(node)

        plugArray = list()

        if self._useInput:
            indices = maya.cmds.getAttr(u'{}.input'.format(node), multiIndices=True) or []
            for i in indices:
                base = u'{}.input[{}]'.format(node, i)
                plg = u'{}.inputGeometry'.format(base)

                plugDict = self._getPlugDict(plg, withTags=False)

                gid = maya.cmds.getAttr(u'{}.groupId'.format(base))
                cex = maya.cmds.getAttr(u'{}.componentTagExpression'.format(base))

                plugDict[self.kIdx] = i
                plugDict[self.kGid] = gid
                plugDict[self.kGex] = cex

                if gid > 0:
                    cmp = maya.cmds.geometryAttrInfo(plg, gid=gid, cmp=True)
                    cnt = maya.cmds.geometryAttrInfo(plg, gid=gid, ec=True)
                    s = str(gid)
                else:
                    cmp = maya.cmds.geometryAttrInfo(plg, cex=cex, cmp=True)
                    cnt = maya.cmds.geometryAttrInfo(plg, cex=cex, ec=True)
                    s = cex

                plugDict[self.kCmp] = cmp
                plugDict[self.kCnt] = cnt
                plugArray.append(plugDict)

        if self._useOutput:
            indices = maya.cmds.getAttr(u'{}.outputGeometry'.format(node), multiIndices=True) or []
            for i in indices:
                plg = u'{}.outputGeometry[{}]'.format(node, i)
                plugDict = self._getPlugDict(plg, withTags=True)
                plugArray.append(plugDict)

        if len(plugArray) > 0:
            nodeDict[self.kPlugs] = plugArray

        return nodeDict

# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
