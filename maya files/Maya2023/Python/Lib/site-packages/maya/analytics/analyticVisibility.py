"""
Analytic class for examining DAG visibility information. JSON return value is a dictionary of all reasons any object is determined
to be invisible. If there is more than one reason (e.g. the object is invisible and the parent is also invisible) they will all be
included in the results. Structure of the dictionary is as follows:

    {
        KEY_INVISIBLE : ['NODE', ...] # Nodes that are statically invisible
    ,   KEY_CONNECTED : ['NODE', ...] # Nodes with invisibility controlled by a non-animated input
    ,   KEY_ANIMATED  : ['NODE', ...] # Nodes with invisibility controlled by an animated input
    }

If OPTION_DETAILS is set then the reasons are listed as well:
    {
        KEY_INVISIBLE : { 'NODE' : [REASON, ...], ... }
    ,   KEY_CONNECTED : { 'NODE' : [REASON, ...], ... }
    ,   KEY_ANIMATED  : { 'NODE' : [REASON, ...], ... }
    }

If OPTION_SUMMARY is set (and OPTION_DETAILS is not) then only counts are provided:
    {
        KEY_INVISIBLE : 5
    ,   KEY_CONNECTED : 12
    ,   KEY_ANIMATED  : 3
    }
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)

import maya.cmds as cmds
from maya.decorators import debugmethod, DebugDecorator
from .BaseAnalytic import BaseAnalytic, OPTION_DETAILS, OPTION_SUMMARY
from .decorators import addMethodDocs,addHelp,makeAnalytic

__all__ = [ 'analyticVisibility'
          , 'KEY_INVISIBLE'
          , 'KEY_ANIMATED'
          , 'KEY_CONNECTED'
          , 'KEYS_INVISIBILITY'
          , 'MSG_INVISIBLE'
          , 'MSG_INTERMEDIATE'
          , 'MSG_INVISIBLE_PARENT'
          , 'MSG_INVISIBLE_LAYER'
          , 'MSG_INVISIBLE_ISOLATED'
          ]

kAnalyticLabel = maya.stringTable['y_maya_analytics_analyticVisibility.kAnalyticLabel' ]
kAnalyticDescriptionShort = maya.stringTable['y_maya_analytics_analyticVisibility.kAnalyticDescriptionShort' ]

# Result dictionary key values
KEY_INVISIBLE = 'invisible'
KEY_ANIMATED  = 'animated'
KEY_CONNECTED = 'connected'
KEYS_INVISIBILITY = [KEY_INVISIBLE, KEY_ANIMATED, KEY_CONNECTED] # For easy iteration

# Result strings being reported
MSG_INVISIBLE = { KEY_INVISIBLE : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeInvisible' ]
                , KEY_ANIMATED  : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeInvisibilityAnimated' ]
                , KEY_CONNECTED : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeInvisibilityConnected' ]
                }
MSG_INTERMEDIATE = { KEY_INVISIBLE : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeIntermediate' ]
                   , KEY_ANIMATED  : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeIntermediateAnimated' ]
                   , KEY_CONNECTED : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeIntermediateConnected' ]
                   }
MSG_INVISIBLE_PARENT = { KEY_INVISIBLE : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeParentInvisible' ]
                       , KEY_ANIMATED  : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeParentInvisibilityAnimated' ]
                       , KEY_CONNECTED : maya.stringTable['y_maya_analytics_analyticVisibility.kDagNodeParentInvisibilityConnected' ]
                       }
MSG_INVISIBLE_LAYER = { KEY_INVISIBLE : maya.stringTable['y_maya_analytics_analyticVisibility.kInInvisibleLayer' ]
                      , KEY_ANIMATED  : maya.stringTable['y_maya_analytics_analyticVisibility.kInLayerInvisibilityAnimated' ]
                      , KEY_CONNECTED : maya.stringTable['y_maya_analytics_analyticVisibility.kInLayerInvisibilityConnected' ]
                      }
MSG_INVISIBLE_ISOLATED = maya.stringTable['y_maya_analytics_analyticVisibility.kNotInIsolateSelection' ]

# Various states possible on a boolean attribute (referred to as NODE_STATE). This need to be in numerical order of least to most restrictive
SET       = True
UNSET     = False
ANIMATED  = 2
CONNECTED = 3
VISIBILITY_STATE_KEY = { UNSET     : None
                       , SET       : KEY_INVISIBLE
                       , ANIMATED  : KEY_ANIMATED
                       , CONNECTED : KEY_CONNECTED
                       }
# Values for the as_is parameter below
kEvaluate = False
kDoNotEvaluate = True

#======================================================================
@debugmethod
def check_boolean_attribute(plug, as_is):
    '''
    Examine the state of a plug referencing a boolean attribute
    :param plug: Location of the boolean attribute to check
    :param as_is: If True extract the existing value of the attribute, otherwise evaluate it first
    :return: Current state of the named boolean attribute
    '''
    incoming_connection = cmds.listConnections( plug, destination=True, skipConversionNodes=True )
    if incoming_connection is not None:
        # Check for an animCurve on the input
        if cmds.keyframe(plug, query=True, keyframeCount=True) > 1:
            return ANIMATED
        # Check for an animated expressions on the input
        if cmds.nodeType( incoming_connection[0] ) == 'expression' and cmds.expression( incoming_connection[0], query=True, timeDependent=True ):
            return ANIMATED
        # Not a trivially animated node so fallback to a normal connection
        return CONNECTED

    # No connection so get the attribute value
    return cmds.getAttr( plug, noEvaluation=as_is )

#======================================================================
@debugmethod
def most_restrictive_state(state_values):
    '''
    Find the most restrictive state in the provided list. In order from most restrictive to each are:
        CONNECTED
        ANIMATED
        UNSET
        SET
    :param state_values: List of state values to test
    :return: The most restrictive state in the list
    '''
    return max(state_values)

#======================================================================
@debugmethod
def invert_state(state):
    '''
    Reverse the sense of the boolean state value (e.g. visible to invisible).
    This basically flips SET and UNSET and not affecting the other states.
    :param state: State to invert
    :return: The inversion of the state
    '''
    if state == SET:
        return UNSET
    if state == UNSET:
        return SET
    return state

#======================================================================
@addMethodDocs
@addHelp
@makeAnalytic(False)
class analyticVisibility(BaseAnalytic):
    """
    This analytic looks at all of the DAG visibility information and provides detailed explanations of why any particular
    DAG nodes might be considered invisible for the purposes of drawing in the viewport. This will not include any
    pseudo-invisibility such as plug-ins that purposely skip drawing, or nodes rendered with fully transparent shaders.

    The algorithm is meant to mimic what the invisibility evaluator is doing, both for informational and debugging purposes.
    Since it's not possible at this level to definitively tell whether a connected attribute is animated or not we only
    perform a quick check to see if the source node is an anim curve and otherwise presume a connection is not animated.
    It's a crude approximation since a static anim curve is considered animated, and anything with an animCurve upstream
    is not considered animated; both of which are technically incorrect.

    The brief output consists of a dictionary of all DAG nodes considered invisible, by visibility type.

        { "invisible" : [ "NODE1", "NODE2", "NODE42" ],
          "connected" : [ "NODE3" ],
          "animated"  : [ "NODE17", "NODE11" ] }

    If the 'details' option is used then output consists of a dictionary whose keys are the fully qualified names of
    DAG nodes considered invisible and values are a list of reasons that node is considered invisible. It's a list because
    there could be more than one reason for any given node - e.g. it's parent is invisible and it belongs to an invisible
    display layer.

        {
            "invisible" : {
                "NODE1" : [ "Parent NODE0 has visibility attribute set to false" ]
                "NODE2" : [ "Parent NODE0 has visibility attribute set to false" ]
                "NODE42" : [ "Parent NODE0 has visibility attribute set to false", "NODE42 has visibility attribute set to false" ]
            },
            "connected" : { "NODE3" : "Node has an unknown connection on its visibility attribute" },
            "animated"  : { "NODE17" : "Node has an anim curve connection on its visibility attribute",
                            "NODE11" : "Parent NODE0 has an anim curve connection on its visibility attribute" }
        }

    :member invisible_nodes: Dictionary with information on nodes who are considered invisible.
                             KEY=NODE_STATE, VALUE=Dictionary of (NODE, [REASONS])
                             where REASONS is a list of strings containing the reason a node was added to this list.
    :member directly_invisible_nodes: Dictionary listing the nodes who are themselves invisible.
                                      KEY=NODE_STATE, VALUE=Dictionary of (NODE, INVISIBILITY_COUNT)
                                      where INVISIBILITY_COUNT is incremented for each different way the node is directly invisible
    :member potentially_invisible_nodes: The list of all nodes to check for visibility
    """
    ANALYTIC_LABEL = kAnalyticLabel
    ANALYTIC_DESCRIPTION_SHORT = kAnalyticDescriptionShort

    #----------------------------------------------------------------------
    def __init__(self):
        """ Initialize the class members """
        super(analyticVisibility, self).__init__()
        self.invisible_nodes = None
        self.directly_invisible_nodes = None
        self.potentially_invisible_nodes = None

    #----------------------------------------------------------------------
    @debugmethod
    def add_invisible(self, dag_node, node_state, message):
        '''
        Add a newly discovered node to the appropriate invisibility list.
        :param dag_node: Node to be added to the list
        :param node_state: Type of invisibility the node was found to have
        :param message: Detailed message on how the invisibility was defined
        '''
        self.invisible_nodes[node_state][dag_node] = self.invisible_nodes[node_state].get(dag_node, []) + [message]

    #----------------------------------------------------------------------
    @debugmethod
    def add_directly_invisible(self, dag_node, node_state, message):
        '''
        Add a newly discovered node to the appropriate invisibility list
        :param dag_node: Node to be added to the list
        :param node_state: Type of invisibility the node was found to have
        :param message: Detailed message on how the invisibility was defined
        '''
        self.directly_invisible_nodes[node_state][dag_node] = self.directly_invisible_nodes[node_state].get(dag_node, 0) + 1
        self.add_invisible( dag_node, node_state, message )

    #----------------------------------------------------------------------
    @debugmethod
    def add_isolated(self, dag_node):
        '''
        Add a node not in an active isolation set to the isolate invisibility list
        '''
        self.add_invisible( dag_node, KEY_INVISIBLE, MSG_INVISIBLE_ISOLATED )

    #----------------------------------------------------------------------
    @debugmethod
    def check_isolate_select(self):
        """ Look for nodes that are invisible by virtue of them not being in an isolated selection set, when one is active """
        # Isolate selection only defines invisibility when it is only active in a single model panel
        try:
            active_model_panels = set(cmds.getPanel(vis=True)).intersection( set(cmds.getPanel(type="modelPanel")) )
            isolated_panels = [panel for panel in active_model_panels if cmds.isolateSelect(panel, query=True, state=True)]
            if len(isolated_panels) == 1:
                isolate_set = cmds.isolateSelect( isolated_panels[0], query=True, viewObjects=True )
                isolated_objects = cmds.sets( isolate_set, query=True )
                isolated_set = set(isolated_objects).union( set(cmds.listRelatives( isolated_objects, allDescendents=True )))
                # Find and report all of the nodes that are in the potentially invisible set but not part of the isolated set
                for filtered_node in self.potentially_invisible_nodes.difference( isolated_set ):
                    self.add_isolated( filtered_node )

        except Exception as ex:
            # If anything went wrong then the isolate doesn't apply to this configuration so nothing needs to be done
            print('WARN: Isolate select not applicable ({})'.format( ex ))

    #----------------------------------------------------------------------
    @debugmethod
    def check_directly_invisible(self):
        """ Look for nodes whose visibility attribute is false """
        # Walk the list of DAG nodes, adding their visibility information as we go
        for dag_node in self.potentially_invisible_nodes:
            invisibility_state = invert_state( check_boolean_attribute( '{}.visibility'.format( dag_node ), kEvaluate ) )
            if invisibility_state != UNSET:
                self.add_directly_invisible( dag_node, VISIBILITY_STATE_KEY[invisibility_state], MSG_INVISIBLE[VISIBILITY_STATE_KEY[invisibility_state]] )
            intermediate_state = check_boolean_attribute( '{}.intermediateObject'.format( dag_node ), kEvaluate )
            if intermediate_state != UNSET:
                self.add_directly_invisible( dag_node, VISIBILITY_STATE_KEY[intermediate_state], MSG_INTERMEDIATE[VISIBILITY_STATE_KEY[intermediate_state]] )

    #----------------------------------------------------------------------
    @debugmethod
    def check_in_invisible_display_layer(self):
        """ Look for nodes that are members of an invisible display layer """
        # Get the list of all display layers
        display_layers = cmds.ls( type='displayLayer' )

        # Look for members of display layers that are invisible
        for display_layer in display_layers:
            # The default layer cannot be invisible
            if display_layer == 'defaultLayer':
                continue

            # Disabled layers have no effect on the nodes
            enabled_state = check_boolean_attribute( '{}.enabled'.format( display_layer ), kEvaluate )
            if enabled_state == UNSET:
                continue

            # Layers without the visibility attribute set to False do not make their members invisible
            visibility_state = check_boolean_attribute( '{}.visibility'.format( display_layer ), kEvaluate )
            if visibility_state == SET:
                continue

            # Get the members of all of the invisibile display layers
            layer_members = cmds.editDisplayLayerMembers( display_layer, query=True )

            # Add the layer members to the most restrictive state's list
            final_state = most_restrictive_state( [enabled_state, invert_state(visibility_state)] )
            if final_state != UNSET:
                for dag_node in layer_members:
                    # Only the potentially invisible nodes need checking, to account for pre-filtering
                    if dag_node in self.potentially_invisible_nodes:
                        self.add_directly_invisible( dag_node, VISIBILITY_STATE_KEY[final_state], MSG_INVISIBLE_LAYER[VISIBILITY_STATE_KEY[final_state]].format(display_layer) )

    #----------------------------------------------------------------------
    @debugmethod
    def check_parent_invisible(self):
        """ Look for nodes who are children of invisible parents """
        for invisibility_type in KEYS_INVISIBILITY:
            # Walk down from all directly invisible nodes to report indirectly invisible nodes
            for dag_node in list(self.directly_invisible_nodes[invisibility_type].keys()):
                child_list = cmds.listRelatives( dag_node, children=True )
                while child_list:
                    grandchildren = []
                    for child in child_list:
                        self.add_invisible( child, invisibility_type, MSG_INVISIBLE_PARENT[invisibility_type].format( dag_node ) )
                        my_grandchildren = cmds.listRelatives( child, children=True )
                        if my_grandchildren is not None:
                            grandchildren = grandchildren + my_grandchildren
                    # Run through a set conversion to avoid duplication in the presence of instancing
                    child_list = list( set( grandchildren ) )

    #----------------------------------------------------------------------
    @debugmethod
    def run(self):
        """
        Run the analytic on the current scene.
        :return: JSON results as described in the class doc
        """
        # Uncomment this to turn on debugging for this class
        DebugDecorator.ENABLED = False

        self.directly_invisible_nodes = dict((key,{}) for key in KEYS_INVISIBILITY)
        self.invisible_nodes = dict((key, {}) for key in KEYS_INVISIBILITY)

        # The nodes to check are all DAG nodes, not including the default cameras as those are almost always invisible
        self.potentially_invisible_nodes = set(cmds.ls( type='dagNode' )) - set(['persp','perspShape','top','topShape','side','sideShape','front','frontShape'])

        # Check the various reasons for invisibility. The ordering is important as intermediate
        # information is gathered for efficiency.
        self.check_isolate_select()
        self.check_directly_invisible()
        self.check_in_invisible_display_layer()
        self.check_parent_invisible()

        # Return either the entire results dictionary, a count of entries in it, or just a list of the invisible nodes,
        # depending on which return options are set.
        if self.option(OPTION_DETAILS):
            return dict((key, self.invisible_nodes[key]) for key in KEYS_INVISIBILITY)
        elif self.option(OPTION_SUMMARY):
            return dict((key, len(self.invisible_nodes[key])) for key in KEYS_INVISIBILITY)

        return dict((key, list(self.invisible_nodes[key].keys())) for key in KEYS_INVISIBILITY)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
