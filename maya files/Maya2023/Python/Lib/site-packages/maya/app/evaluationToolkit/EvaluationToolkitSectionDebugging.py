"""
Support for the Evaluation Toolkit UI section containing tools that debug the evaluation graph.
"""
from __future__ import print_function
import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
__all__ = ['EvaluationToolkitSectionDebugging']

from functools import partial
import maya.cmds as cmds
from maya.debug.TODO import TODO
from maya.common.ui import LayoutManager, showMessageBox, callback_tool
from maya.debug.emModeManager import emModeManager
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import BUTTON_WIDTH
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import section_layout
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import EvaluationToolkitSection, EvaluationToolkitSubsection
from maya.debug.em_debug_utilities import get_minimal_scene_objects_from, get_default_directory, open_file
from maya.debug.em_debug_utilities import select_inverse_visible_dag_objects
from maya.debug.em_debug_utilities import dbg_nodes, dbg_graph, dbg_scheduling_types, dbg_scheduling_graph
from maya.debug.em_debug_utilities import dbg_graph_to_dot, dbg_scheduling_graph_to_dot, require_evaluation_graph

#======================================================================
# Debugging traces.
DEBUGGING_TRACES = [ ('evalMgrGraphValid',   maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kValidationTrace' ],
                                             maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kValidationTraceAnnotation' ],
                                             lambda: 'serial' in emModeManager().mode
                     )
                   , ('compute',             maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kComputeTrace' ],
                                             maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kComputeTraceAnnotation' ],
                                             lambda: 'parallel' != emModeManager().mode
                     )
                   ]

# Shared values
LABEL_REMOVE = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelRemove' ]
LABEL_SHOW = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelShow' ]
WIDGET_HEIGHT = 26

# ----------------------------------------------------------------------
class OutputHelper(object):
    '''
    Helper class to direct output to the proper location from the debugging section.
    This avoids a bunch of code duplication for selecting and using separate output
    locations.
    '''
    def __init__(self, tool):
        '''Set up the output location from the tool data'''
        from sys import stdout as sys_stdout
        self.output_file = sys_stdout
        self.output_file_name = 'stdout'
        use_file_type = (cmds.optionMenu(tool.widgets['textOutputLocations'], query=True, select=True) != 1)
        if use_file_type:
            self.output_file_name = cmds.textField( tool.widgets['textFile'], query=True, text=True )
            try:
                self.output_file = open(self.output_file_name, 'w')
            except Exception as ex:
                cmds.error(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kCouldNotWriteToFile' ].format(self.output_file_name, ex))

    def write(self, msg):
        '''Print "msg" to the currently selected output location'''
        print(msg, file=self.output_file)

    def close(self):
        '''Close the file, if one was selected'''
        from sys import stdout as sys_stdout
        if self.output_file != sys_stdout:
            self.output_file.close()
            self.output_file = sys_stdout   # Don't leave this dangling
            print(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kOutputFileLocation' ].format( self.output_file_name ))

#======================================================================
class SubsectionTools(EvaluationToolkitSubsection):
    '''
    Class managing the "tools" subsection of the debugging section.
    It will contain trace objects and buttons to launch windows.

    :member checkbox_traces: Checkbox widgets for the trace object controls
    :member textfield_traces: Textfield widgets for the trace object controls
    '''
    #----------------------------------------------------------------------
    def update_ui(self):
        '''Updates the trace object UI to match the trace object states'''
        for trace in DEBUGGING_TRACES:
            checkbox = self.checkbox_traces[trace[0]]
            enable = trace[3]()
            value = trace[0] in cmds.dbtrace(query=True)
            cmds.checkBox(checkbox, edit=True, enable=enable, value=value)

            output = cmds.dbtrace(keyword=trace[0], query=True, output=True)[1]
            textfield = self.textfield_traces[trace[0]]
            cmds.textField(textfield, edit=True, text=output)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_trace_enable(tool, trace):
        '''Callback invoked whenever the enabled state of the trace object changes'''
        checkbox = tool.checkbox_traces[trace[0]]
        value = cmds.checkBox(checkbox, query=True, value=True)
        if value:
            cmds.dbtrace( keyword=trace )
        else:
            cmds.dbtrace( keyword=trace, off=True )

        tool.update_ui()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_trace_output(tool, trace):
        '''Callback invoked whenever the location of the trace output changes'''
        textfield = tool.textfield_traces[trace[0]]
        output = cmds.textField( textfield, query=True, text=True )
        cmds.dbtrace( keyword=trace[0], output=output )

        tool.update_ui()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_show_trace_help(tool, trace):
        '''Callback invoked when asking for help on a particular trace object'''
        TODO('IMPROVEMENT', 'This hard-coded list can be removed when traces are properly localized.', None)
        trace_summaries = {
            'evalMgrGraphValid': maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kValidationTraceSummary' ],
            'compute': maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kComputeTraceSummary' ],
        }
        assert tool
        assert trace[0] in trace_summaries, 'Trace {} does not have a localized descriptions'.format( trace[0] )

        window_title = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTraceDescription' ]
        window_message = trace_summaries[trace[0]]

        showMessageBox( title=window_title, message=window_message, icon="information" )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_launch_profiler(tool):
        '''Callback invoked from the button that launches the profiler'''
        assert tool
        cmds.ProfilerTool()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_launch_analytics_window(tool):
        '''Callback invoked from the button that launches the analytics window'''
        assert tool
        from maya.analytics.Window import analytics_ui
        analytics_ui()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_launch_scene_lint_window(tool):
        '''Callback invoked from the button that launches the scene lint window'''
        assert tool
        from maya.debug.SceneLintWindow import SceneLintWindow
        scene_lint_window = SceneLintWindow()
        scene_lint_window.show_window()

    #----------------------------------------------------------------------
    def __init__(self):
        '''Set up the widgets used in the subsection'''
        self.checkbox_traces = {}
        self.textfield_traces = {}

        with LayoutManager(cmds.rowColumnLayout(numberOfColumns=3, rowSpacing=(1,5), columnSpacing=[(1,10), (2,10), (3,10)])):
            for trace in DEBUGGING_TRACES:
                self.checkbox_traces[trace[0]] = cmds.checkBox( label=trace[1]
                                               , annotation=trace[2]
                                               , changeCommand=callback_tool(self, partial(self.callback_trace_enable, trace=trace))
                                               )
                self.textfield_traces[trace[0]] = cmds.textField( alwaysInvokeEnterCommandOnReturn=True
                                                , width=150
                                                , enterCommand=callback_tool(self, partial(self.callback_trace_output, trace=trace))
                                                )
                cmds.button( label=' ? ' , command=callback_tool(self, partial(self.callback_show_trace_help, trace=trace)) )

            # Layout here could probably be better as it is artifically aligning to the trace
            # columns, but not aligning at all would be worse.
            cmds.button( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelLaunchProfiler' ]
                       , command=callback_tool(self, self.callback_launch_profiler) )
            cmds.button( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelLaunchAnalyticsWindow' ]
                       , command=callback_tool(self, self.callback_launch_analytics_window) )
            cmds.button( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelLaunchSceneLintWindow' ]
                       , command=callback_tool(self, self.callback_launch_scene_lint_window) )

#======================================================================
class SubsectionDynamicAttributes(EvaluationToolkitSubsection):
    '''
    Class managing the "dynamic attribute" subsection of the debugging section
    '''
    #----------------------------------------------------------------------
    @staticmethod
    def process_connections(disconnect):
        """
        Looks for dynamic attribute connections in and out of DAG nodes as they
        are a potential source of ineffeciency.

        Prints the details and action to be performed on matching connections.
        Last line to print is the count of each action type.

        :param disconnect: If true then remove the connections that were found
        """
        nodes = cmds.ls()
        disconnected_count = 0
        skipped_count = 0

        for node in nodes:
            dynAttrList = cmds.listAttr(node, userDefined=True, connectable=True) or []

            for dynAttr in dynAttrList:
                full_name = '{}.{}'.format(node, dynAttr)

                try:
                    src_list = cmds.listConnections(full_name, plugs=True, destination=False, source=True)
                    dst_list = cmds.listConnections(full_name, plugs=True, destination=True, source=False)

                    if src_list and dst_list:
                        if not cmds.affects(dynAttr, node, by=True):
                            # This is not optimal, but we want the full list of attributes.
                            if 'dagNode' in cmds.nodeType(node, inherited=True):
                                message = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kDisconnectMessage' ]
                                print(message % full_name)
                                disconnected_count += 1
                                if disconnect:
                                    cmds.setAttr(full_name, lock=False)
                                    for src_attr in src_list:
                                        cmds.disconnectAttr(src_attr, full_name)
                            else:
                                message = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kSkippedMessage' ]
                                print(message.format( full_name ))
                                skipped_count += 1
                except Exception:
                    pass

        message = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kExtraAttributeFinalMessage' ]
        print(message.format(disconnected_count, skipped_count))

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_print_extra_connections(tool):
        '''Callback invoked when asking to print extra dynamic attribute connections'''
        tool.process_connections(False)

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_remove_extra_connections(tool):
        '''Callback invoked when asking to remove extra dynamic attribute connections'''
        tool.process_connections(True)

    #----------------------------------------------------------------------
    def __init__(self):
        '''Set up the widgets used in the subsection'''
        with LayoutManager(cmds.frameLayout(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kDynamicAttributes' ], **section_layout(True))):

            cmds.text( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kDynamicAttributesExplanation' ] )

            with LayoutManager( cmds.rowColumnLayout(numberOfColumns=2,  columnAlign=[(1, 'right'), (2, 'left')], columnSpacing=[(1,10), (2,10)]) ):
                cmds.text(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintExtraConnections' ])
                cmds.button( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelPrint' ]
                           , width=BUTTON_WIDTH
                           , command=callback_tool(self, self.callback_print_extra_connections)
                           )

                cmds.text( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kRemoveExtraConnections' ] )
                cmds.button( label=LABEL_REMOVE
                           , width=BUTTON_WIDTH
                           , command=callback_tool(self, self.callback_remove_extra_connections)
                           )

#======================================================================
class SubsectionSceneSimplification(EvaluationToolkitSubsection):
    '''
    Class managing the "scene simplification" subsection of the debugging section
    '''
    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_select_minimal_scene(tool):
        '''Callback invoked when the "select minimal scene" button is pressed'''
        assert tool
        selection = cmds.ls(selection=True)
        if not selection:
            cmds.error(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kSelectMinimalSceneErrorMessage' ])
            return

        # Use the EM to get the required upstream nodes
        minimal_scene_objects = get_minimal_scene_objects_from( selection )
        cmds.select(minimal_scene_objects, replace=True)
        return minimal_scene_objects

    #----------------------------------------------------------------------
    # No need to mark this one "@require_evaluation_graph"
    # because its first task is to call another callback that does.
    @staticmethod
    def callback_remove_all_but_minimal_scene(tool):
        '''Callback invoked when the "remove all but minimal scene" button is pressed'''

        startCount = len(cmds.ls())

        # select everything we want to keep
        minimal_scene_objects = tool.callback_select_minimal_scene(tool)

        # invert selection so we have everything we want to delete selected
        select_inverse_visible_dag_objects(minimal_scene_objects)

        # Just to be sure remove some stuff frpom the selection that we do not want to delete
        default_nodes = cmds.ls( defaultNodes=True )
        undeletable_nodes = ['sideShape', 'perspShape', 'persp', 'frontShape', 'front', 'side', 'topShape', 'top', 'renderLayerManager', 'poseInterpolatorManager', 'defaultLayer', 'defaultRenderLayer', 'shapeEditorManager', 'lightLinker1', 'layerManager']

        cmds.select(default_nodes, deselect=True)
        cmds.select(undeletable_nodes, deselect=True)

        #  Now delete the selection
        cmds.delete()

        endCount = len(cmds.ls())
        message = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kReducedSceneMessage' ]
        print(message.format( startCount, endCount ))

    #----------------------------------------------------------------------
    def __init__(self):
        '''Set up the widgets used in the subsection'''
        with LayoutManager( cmds.frameLayout(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kSceneSimplification' ], **section_layout(True)) ):

            cmds.text( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kSceneSimplificationExplanation' ] )

            with LayoutManager( cmds.rowColumnLayout(numberOfColumns=2,  columnAlign=[(1, 'right'), (2, 'left')], columnSpacing=[(1,10), (2,10)]) ):
                cmds.text(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kSelectMinimalScene' ])
                cmds.button( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelSelect' ]
                           , width=BUTTON_WIDTH
                           , command=callback_tool(self, self.callback_select_minimal_scene)
                           )

                cmds.text(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kRemoveAllButMinimalScene' ])
                cmds.button( label=LABEL_REMOVE
                           , width=BUTTON_WIDTH
                           , command=callback_tool(self, self.callback_remove_all_but_minimal_scene)
                           )

#======================================================================
class SubsectionGraphInspection(EvaluationToolkitSubsection):
    '''
    Class managing the "evaluation graph inspection" subsection of the debugging section

    There are a lot of magic numbers in here, normally frowned on but deemed okay in
    this situation since they create the alignment and offsets needed to make the UI
    look good, and any names would be mostly meaningless.
    '''
    #----------------------------------------------------------------------
    def get_output_file_info(self):
        ''':return: 2-tuple containing
                    1. Name of the .dot file to generate
                    2. Name of the graphical(.svg/.png/...) file to generate (None if only DOT format was requested)
        '''
        graph_file = cmds.textField( self.widgets['graphicalFile'], query=True, text=True )
        from os import path as os_path
        if graph_file is None or len(graph_file) == 0:
            graph_file = os_path.join(get_default_directory(), u'SchedulingGraph.dot')

        graphical_format = cmds.optionMenu(self.widgets['graphicalFormats'], query=True, select=True)

        # Ignore the extension and replace with .dot/.pdf/.svg as appropriate
        (file_name,_) = os_path.splitext( graph_file )
        out_dot = '{}.dot'.format( file_name )

        if graphical_format == 1:
            out_img = '{}.pdf'.format( file_name )
        elif graphical_format == 2:
            out_img = '{}.svg'.format( file_name )
        elif graphical_format == 3:
            out_img = '{}.png'.format( file_name )
        else:
            out_img = None

        return (out_dot, out_img)

    #----------------------------------------------------------------------
    def get_selection_info(self):
        ''':return: 2-tuple containing:
            1. A boolean that's True if the selection list should be respected
            2. A depth value indicating how many steps away from the current selection the operation
               should look.
        '''
        use_selected = (cmds.optionMenu(self.widgets['types'], query=True, select=True) != 1)
        try:
            depth = int(cmds.intFieldGrp(self.widgets['depth'], query=True, value1=True))
        except ValueError:
            # Illegal characters cause the depth to be ignored
            depth = 0
        return (use_selected, depth)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_scope(tool):
        '''Callback invoked when node inspection scope type is changed'''
        use_selected = (cmds.optionMenu(tool.widgets['types'], query=True, select=True) != 1)
        cmds.intFieldGrp( tool.widgets['depth'], edit=True, visible=use_selected )

    #----------------------------------------------------------------------
    def main_frame_layout(self):
        '''Add the frame that contains the shared graph inspection features'''

        self.widgets['types'] = cmds.optionMenuGrp( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kWhatToInspect' ]
                                                  , columnAlign2=('right', 'left')
                                                  , columnWidth2=(100, 125)
                                                  , changeCommand=callback_tool(self, self.callback_update_scope)
                                                  ) + '|OptionMenu'
        cmds.menuItem( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectAll' ] )
        cmds.menuItem( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectSelected' ] )
        self.widgets['depth'] = cmds.intFieldGrp( extraLabel=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLevelDepth' ]
                                                , value1=0
                                                , columnWidth2=(35, 185)
                                                , visible=False )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_graphical_output_format(tool):
        '''Callback invoked when graphical inspection output format is changed'''
        graphical_format = cmds.optionMenu(tool.widgets['graphicalFormats'], query=True, select=True)
        from os import path as os_path
        (path,_) = os_path.splitext( cmds.textField( tool.widgets['graphicalFile'], query=True, text=True ) )
        new_file = path + ['.pdf','.svg','.png','.dot'][graphical_format-1]
        cmds.textField( tool.widgets['graphicalFile'], edit=True, text=new_file )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_choose_graphical_output_location(tool):
        '''Callback invoked when the graphical inspection file browser button is selected'''
        graphical_format = cmds.optionMenu(tool.widgets['graphicalFormats'], query=True, select=True)
        current_file = cmds.textField( tool.widgets['graphicalFile'], query=True, text=True )
        file_filter = ['PDF file (*.pdf)','SVG file (*.svg)', 'PNG file (*.png)', 'DOT file (*.dot)'][graphical_format-1]
        from os import path as os_path
        result = cmds.fileDialog2(
                      caption=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kGraphicalInspectionChooseOutputFile' ]
                    , fileMode=0
                    , fileFilter=file_filter
                    , okCaption=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kGraphicalInspectionChooseButton' ]
                    , startingDirectory=os_path.dirname(current_file)
                    )
        if result:
            assert len(result) == 1
            chosen_file = os_path.normpath(result[0])
            cmds.textField(tool.widgets['graphicalFile'], edit=True, text=chosen_file)

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_visualize_evaluation_graph(tool):
        '''Callback invoked when the visual style evaluation graph printing button is pushed'''
        include_plugs = cmds.checkBox( tool.widgets['graphIncludePlugs'], query=True, value=True )
        (out_dot, out_img) = tool.get_output_file_info()
        (use_selected, depth) = tool.get_selection_info()

        try:
            out_dot = dbg_graph_to_dot( include_plugs, use_selected, depth, out_dot )

            if out_img is not None:
                gv_mgr = tool.get_graphviz_manager()
                do_transitive_reduction = cmds.checkBox(tool.widgets['graphTransitiveReduction'], query=True, value=True)
                if not gv_mgr.convert_dot_to(out_dot, out_img, do_transitive_reduction):
                    raise RuntimeError( 'Could not generate image file {}'.format(out_img) )
                open_file( out_img )
            else:
                open_file( out_dot )
        except RuntimeError as ex:
            cmds.warning(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintSchedulingVizFailed' ].format(ex))

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_visualize_scheduling_graph(tool):
        '''Callback invoked when the visual style scheduling graph printing button is pushed'''
        include_clusters = cmds.checkBox( tool.widgets['graphIncludeClusters'], query=True, value=True )
        (out_dot, out_img) = tool.get_output_file_info()
        (use_selected, depth) = tool.get_selection_info()

        try:
            out_dot = dbg_scheduling_graph_to_dot( include_clusters, use_selected, depth, out_dot )

            if out_img is not None:
                gv_mgr = tool.get_graphviz_manager()
                do_transitive_reduction = cmds.checkBox(tool.widgets['graphTransitiveReduction'], query=True, value=True)
                if not gv_mgr.convert_dot_to(out_dot, out_img, do_transitive_reduction):
                    raise RuntimeError( 'Could not generate image file {}'.format(out_img) )
                open_file( out_img )
            else:
                open_file( out_dot )
        except RuntimeError as ex:
            cmds.warning(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintVizFailed' ].format(ex))

    #----------------------------------------------------------------------
    def graphical_frame_layout(self):
        '''Add the frame that contains the graph visual inspection features'''

        with LayoutManager( cmds.rowColumnLayout( **self.three_column_layout ) ):

            # - - - - - - - - - - - - - - - - - - - -
            # Format type selection

            cmds.text( label=self.format_text, align='right', height=WIDGET_HEIGHT)
            self.widgets['graphicalFormats'] = cmds.optionMenu( height=WIDGET_HEIGHT
                                             , changeCommand=callback_tool(self, self.callback_update_graphical_output_format)
                                             )
            cmds.menuItem(parent=self.widgets['graphicalFormats'], label='PDF')
            cmds.menuItem(parent=self.widgets['graphicalFormats'], label='SVG')
            cmds.menuItem(parent=self.widgets['graphicalFormats'], label='PNG')
            cmds.menuItem(parent=self.widgets['graphicalFormats'], label='DOT')
            self.widgets['graphTransitiveReduction'] = cmds.checkBox( value=False
                    , annotation=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTransitiveReductionAnnotation' ]
                    , label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTransitiveReductionLabel' ]
                    )

            # - - - - - - - - - - - - - - - - - - - -
            # Output file name

            cmds.text( label=self.output_location_text, align='right', height=WIDGET_HEIGHT )
            from os import path as os_path
            scene_name = os_path.splitext(os_path.basename(cmds.file(q=True, sceneName=True)))[0]
            outfile_name = '{}.eg.pdf'.format(scene_name)
            self.widgets['graphicalFile'] = cmds.textField( text=os_path.join( get_default_directory(), outfile_name ) )
            self.widgets['graphicalBrowse'] = cmds.symbolButton( image='navButtonBrowse.png'
                                                               , command=callback_tool(self, self.callback_choose_graphical_output_location)
                                                               )

            # - - - - - - - - - - - - - - - - - - - -
            # Visualize the evaluation graph

            cmds.text( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kVisualizeGraph'], align='right', height=WIDGET_HEIGHT )
            cmds.button( label=LABEL_SHOW
                       , command=callback_tool(self, self.callback_visualize_evaluation_graph) )
            self.widgets['graphIncludePlugs'] = cmds.checkBox( annotation=self.include_plug_annotation
                                                             , label=self.include_plug_label
                                                             , value=False
                                                             )

            # - - - - - - - - - - - - - - - - - - - -
            # Visualize the scheduling graph

            cmds.text( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kVisualSchedulingGraph'], align='right', height=WIDGET_HEIGHT )
            cmds.button( label=LABEL_SHOW
                       , command=callback_tool(self, self.callback_visualize_scheduling_graph) )
            self.widgets['graphIncludeClusters'] = cmds.checkBox( annotation=self.include_cluster_annotation
                                                                , label=self.include_cluster_label
                                                                , value=False
                                                                )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_text_output_format(tool):
        '''Callback invoked when text inspection output format is changed'''
        text_format = cmds.optionMenu(tool.widgets['textFormats'], query=True, select=True)
        from os import path as os_path
        (path,_) = os_path.splitext( cmds.textField( tool.widgets['textFile'], query=True, text=True ) )
        new_file = path + ['.json','.txt'][text_format-1]
        cmds.textField( tool.widgets['textFile'], edit=True, text=new_file )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_text_output_location(tool):
        '''Callback invoked when text inspection output location is changed'''
        use_file_type = (cmds.optionMenu(tool.widgets['textOutputLocations'], query=True, select=True) != 1)
        # It would have been nicer to collapse this row when not in use but there doesn't seem to
        # be an easy way to do that.
        cmds.text( tool.widgets['textFileLabel'], edit=True, enable=use_file_type )
        cmds.textField( tool.widgets['textFile'], edit=True, enable=use_file_type )
        cmds.symbolButton( tool.widgets['textBrowse'], edit=True, enable=use_file_type )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_choose_text_output(tool):
        '''Callback invoked when the text inspection file browser button is selected'''
        text_format = cmds.optionMenu(tool.widgets['textFormats'], query=True, select=True)
        current_file = cmds.textField(tool.widgets['textFile'], query=True, text=True)
        file_filter = ['JSON file (*.json)', 'TXT file (*.txt);;All files (*.*)'][text_format-1]
        from os import path as os_path
        result = cmds.fileDialog2( caption=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTextInspectionChooseOutputFile' ]
                                 , fileMode=0
                                 , fileFilter=file_filter
                                 , okCaption=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTextInspectionChooseButton' ]
                                 , startingDirectory=os_path.dirname(current_file)
                                 )
        if result:
            assert len(result) == 1
            chosen_file = os_path.normpath(result[0])
            cmds.textField(tool.widgets['textFile'], edit=True, text=chosen_file)

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_print_nodes(tool):
        '''Callback invoked when the text style node printing button is pushed'''
        include_plugs = cmds.checkBox( tool.widgets['textNodeIncludePlugs'], query=True, value=True )
        summarize = (cmds.optionMenu(tool.widgets['textFormats'], query=True, select=True) != 1)
        (use_selected, depth) = tool.get_selection_info()

        try:
            node_info = dbg_nodes(summarize, include_plugs, use_selected, depth)

            output_fd = OutputHelper(tool)
            output_fd.write( node_info )
            output_fd.close()
        except RuntimeError as ex:
            cmds.warning(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintEGNodesFailed' ].format(ex))

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_print_graph(tool):
        '''Callback invoked when the text style graph printing button is pushed'''
        include_plugs = cmds.checkBox( tool.widgets['textGraphIncludePlugs'], query=True, value=True )
        summarize = (cmds.optionMenu(tool.widgets['textFormats'], query=True, select=True) != 1)
        (use_selected, depth) = tool.get_selection_info()

        try:
            graph_info = dbg_graph(summarize, include_plugs, use_selected, depth)

            output_fd = OutputHelper(tool)
            output_fd.write( graph_info )
            output_fd.close()
        except RuntimeError as ex:
            cmds.warning(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintEGFailed' ].format(ex))

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_print_scheduling_types(tool):
        '''Callback invoked when the text style scheduling type printing button is pushed'''
        summarize = (cmds.optionMenu(tool.widgets['textFormats'], query=True, select=True) != 1)
        (use_selected, depth) = tool.get_selection_info()

        try:
            scheduling_info = dbg_scheduling_types(summarize, use_selected, depth)

            output_fd = OutputHelper(tool)
            output_fd.write( scheduling_info )
            output_fd.close()
        except RuntimeError as ex:
            cmds.warning(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintSchedulingTypesFailed' ].format(ex))

    #----------------------------------------------------------------------
    @staticmethod
    @require_evaluation_graph
    def callback_print_scheduling_graph(tool):
        '''Callback invoked when the text style scheduling printing button is pushed'''
        include_clusters = cmds.checkBox( tool.widgets['textIncludeClusters'], query=True, value=True )
        summarize = (cmds.optionMenu(tool.widgets['textFormats'], query=True, select=True) != 1)
        (use_selected, depth) = tool.get_selection_info()

        try:
            scheduling_info = dbg_scheduling_graph(summarize, include_clusters, use_selected, depth)

            output_fd = OutputHelper(tool)
            output_fd.write( scheduling_info )
            output_fd.close()
        except RuntimeError as ex:
            cmds.warning(maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kPrintSchedulingFailed' ].format(ex))

    #----------------------------------------------------------------------
    def text_frame_layout(self):
        '''Add the frame that contains the graph text inspection features'''

        with LayoutManager( cmds.rowColumnLayout( **self.three_column_layout ) ):

            # - - - - - - - - - - - - - - - - - - - -
            # Format type selection

            cmds.text( label=self.format_text, align='right', height=WIDGET_HEIGHT )
            self.widgets['textFormats'] = cmds.optionMenu( height=WIDGET_HEIGHT
                                                         , changeCommand=callback_tool(self, self.callback_update_text_output_format)
                                                         )
            cmds.menuItem(parent=self.widgets['textFormats'], label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectTextJSON' ])
            cmds.menuItem(parent=self.widgets['textFormats'], label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectTextSummary' ])
            cmds.separator(style='none', height=1)

            # - - - - - - - - - - - - - - - - - - - -
            # Output location selection

            cmds.text( label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTextOutputLocation'], align='right', height=WIDGET_HEIGHT )
            self.widgets['textOutputLocations'] = cmds.optionMenu( height=WIDGET_HEIGHT
                                                , changeCommand=callback_tool(self, self.callback_update_text_output_location)
                                                )
            cmds.menuItem(parent=self.widgets['textOutputLocations'], label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectTextOutputToWindow' ])
            cmds.menuItem(parent=self.widgets['textOutputLocations'], label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectTextOutputToFile' ])
            cmds.separator(style='none', height=1)

            # - - - - - - - - - - - - - - - - - - - -
            # Output file location (for "File" location only)

            self.widgets['textFileLabel'] = cmds.text( label=self.output_location_text, enable=False )
            from os import path as os_path
            self.widgets['textFile'] = cmds.textField( text=os_path.join( get_default_directory(), 'EvaluationGraph.json' ), enable=False )
            self.widgets['textBrowse'] = cmds.symbolButton( image='navButtonBrowse.png'
                                                          , enable=False
                                                          , command=callback_tool(self, self.callback_choose_text_output) )

            # - - - - - - - - - - - - - - - - - - - -
            # Evaluation node printing

            cmds.text( maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTextPrintNodes' ] )
            cmds.button( label=LABEL_SHOW
                       , command=callback_tool(self, self.callback_print_nodes) )
            self.widgets['textNodeIncludePlugs'] = cmds.checkBox( annotation=self.include_plug_annotation
                                                                , label=self.include_plug_label
                                                                , value=False
                                                                )

            # - - - - - - - - - - - - - - - - - - - -
            # Evaluation graph printing

            cmds.text( maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTextPrintGraph' ] )
            cmds.button( label=LABEL_SHOW
                       , command=callback_tool(self, self.callback_print_graph) )
            self.widgets['textGraphIncludePlugs'] = cmds.checkBox( annotation=self.include_plug_annotation
                                                                 , label=self.include_plug_label
                                                                 , value=False
                                                                 )

            # - - - - - - - - - - - - - - - - - - - -
            # Scheduling types printing

            cmds.text( maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kShowSchedulingTypes' ] )
            cmds.button( label=LABEL_SHOW
                       , command=callback_tool(self, self.callback_print_scheduling_types) )
            cmds.separator(style='none', height=1)

            # - - - - - - - - - - - - - - - - - - - -
            # Scheduling graph printing

            cmds.text( maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kShowSchedulingGraph' ] )
            cmds.button( label=LABEL_SHOW
                       , command=callback_tool(self, self.callback_print_scheduling_graph) )
            self.widgets['textIncludeClusters'] = cmds.checkBox( annotation=self.include_cluster_annotation
                                                               , label=self.include_cluster_label
                                                               , value=False
                                                               )

    #----------------------------------------------------------------------
    def __init__(self, get_graphviz_manager):
        '''
        Set up the widgets used in the subsection
        :param get_graphviz_manager: Function to retrieve an up-to-date GraphVizManager
        '''
        self.widgets = {}
        self.get_graphviz_manager = get_graphviz_manager

        self.format_text                = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kChooseFormatText' ]
        self.output_location_text       = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kInspectionOutputLocation' ]
        self.include_cluster_annotation = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kAnnotationIncludeClusters' ]
        self.include_cluster_label      = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelIncludeClusters' ]
        self.include_plug_annotation    = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kAnnotationIncludePlugs' ]
        self.include_plug_label         = maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kLabelIncludePlugs' ]
        self.three_column_layout        = dict( numberOfColumns=3
                                              , adjustableColumn=2
                                              , columnAlign=[(1, 'right'), (2, 'center'), (3, 'left')]
                                              , columnAttach=[(1, 'right', 0), (2, 'both', 0), (3, 'left', 0)]
                                              , columnSpacing=[(1,10), (2,10), (3,10)]
                                              , columnWidth=[(1,130), (3,130)]
                                              , rowSpacing=(1,6)
                                              )


        with LayoutManager( cmds.frameLayout(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kGraphInspection' ], **section_layout(True)) ):

            with LayoutManager( cmds.columnLayout(rowSpacing=6, adjustableColumn=True) ):

                with LayoutManager( cmds.rowLayout( numberOfColumns=2, columnWidth2=(190, 100), columnAlign2=('left', 'left') ) ):
                    self.main_frame_layout()

                with LayoutManager( cmds.frameLayout(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kGraphOutputInspection' ], **section_layout(False)) ):
                    self.graphical_frame_layout()

                with LayoutManager( cmds.frameLayout(label=maya.stringTable['y_maya_app_evaluationToolkit_EvaluationToolkitSectionDebugging.kTextOutputInspection' ], **section_layout(True)) ):
                    self.text_frame_layout()

#======================================================================
class EvaluationToolkitSectionDebugging(EvaluationToolkitSection):
    '''
    Class providing support for UI and functionality of the evaluation toolkit debugging section.
    '''
    #----------------------------------------------------------------------
    def __init__(self, title, start_closed, get_graphviz_manager):
        '''
        Set up the framework for the debugging tools
        :param title: Name of the main debugging section
        :param start_closed: True means the section should be initially closed when the UI window is created
        :param get_graphviz_manager: Callback to retrieve a GraphVizManager for use in DOT/PDF file generation
        '''
        self.subsections = []
        with LayoutManager( cmds.frameLayout(label=title, **section_layout(start_closed)) ):
            self.subsections.append( SubsectionTools() )
            self.subsections.append( SubsectionGraphInspection( get_graphviz_manager ) )
            self.subsections.append( SubsectionSceneSimplification() )
            self.subsections.append( SubsectionDynamicAttributes() )

    #----------------------------------------------------------------------
    def update_ui(self):
        '''Update the UI values for all of the subsections'''
        for subsection in self.subsections:
            subsection.update_ui()
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
