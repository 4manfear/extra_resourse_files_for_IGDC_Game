import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Encapsulation of the optionVar values as a Python object of type OptionVar.
The encapsulation handles preference-related functions such as:
    - getting optionVar value
    - setting optionVar value
    - setting default value on uninitialized optionVar
    - saving and restoring optionVar value (for undo)

In addition to the native types float, int, and string, this class provides
abstract support for boolean types and enum types. It performs basic validation
on the type of data passed in (e.g. you cannot pass "3" to a boolean)

    b_var = OptionVar( 'bVar', OPTION_VAR_TYPE_BOOL, False )
    e_var = OptionVar( 'eVar', [ 'red', 'green', 'blue' ], 'red' )

Note: Although this currently doesn't handle array optionVars it could easily be extended to do so.
'''

from builtins import object
__all__ = [ 'OptionVar'
          , 'OPTION_VAR_TYPE_BOOL'
          , 'OPTION_VAR_TYPE_FLOAT'
          , 'OPTION_VAR_TYPE_INT'
          , 'OPTION_VAR_TYPE_STRING'
          , 'OPTION_VAR_TYPE_RGB'
          ]

from functools import partial
if __name__ != '__main__': # Testing mode defines its own cmds class
    import maya.cmds as cmds
else:
    class cmds(object):
        '''Proxy implementation of the maya commands that are used in the class'''
        JOBS_ACTIVE = []
        NEXT_JOB = 0

        @staticmethod
        def scriptJob( kill=None, optionVarChanged=None ):
            '''Proxy implementation of the Maya scriptJob command.  Does not actually monitor anything
            but it does keep track of monitoring job IDs for proper management'''
            assert optionVarChanged is None or kill is None
            if kill is not None:
                assert kill in cmds.JOBS_ACTIVE
                del cmds.JOBS_ACTIVE[kill]
                return kill
            cmds.JOBS_ACTIVE.append( cmds.NEXT_JOB )
            cmds.NEXT_JOB = cmds.NEXT_JOB + 1
            return cmds.NEXT_JOB-1

        # Global map containing the test optionVars
        #   KEY=var_name, VALUE=[var_type,var_value]
        global_option_vars = {}
        @staticmethod
        def optionVar( intValue=None, intValueAppend=None, floatValue=None, floatValueAppend=None, stringValue=None, exists=None, query=None):
            ''' Simulate the operation of an optionVar for testing purposes '''
            if exists is not None:
                return exists in cmds.global_option_vars
            if query is not None:
                if query in cmds.global_option_vars:
                    return cmds.global_option_vars[query][1]
                return None
            if intValue is not None:
                assert isinstance(intValue, list)
                assert len(intValue) == 2
                (name, value) = intValue
                cmds.global_option_vars[name] = [OPTION_VAR_TYPE_INT, value]
            elif intValueAppend is not None:
                assert isinstance(intValueAppend, list)
                assert len(intValueAppend) == 2
                (name, value) = intValueAppend
                if name in cmds.global_option_vars:
                    cmds.global_option_vars[name] = cmds.global_option_vars[name] + [value]
                else:
                    cmds.global_option_vars[name] = [OPTION_VAR_TYPE_RGB, value]
            elif floatValue is not None:
                assert isinstance(floatValue, list)
                assert len(floatValue) == 2
                (name, value) =  floatValue
                cmds.global_option_vars[name] = [OPTION_VAR_TYPE_FLOAT, value]
            elif floatValueAppend is not None:
                assert isinstance(floatValueAppend, list)
                assert len(floatValueAppend) == 2
                (name, value) = floatValueAppend
                if name in cmds.global_option_vars:
                    cmds.global_option_vars[name] = cmds.global_option_vars[name] + [value]
                else:
                    cmds.global_option_vars[name] = [OPTION_VAR_TYPE_RGB, value]
            elif stringValue is not None:
                assert isinstance(stringValue, list)
                assert len(stringValue) == 2
                (name, value) =  stringValue
                cmds.global_option_vars[name] = [OPTION_VAR_TYPE_STRING, value]
            return None


#======================================================================
#
# Provide sandbox for the unit test since running that from the command 
# line may not have access to the module and it's not necessary for the
# test.
#
CREATE_DEBUG_PROXY = __name__ == '__main__'
if CREATE_DEBUG_PROXY:
    class DebugTrace(object):
        '''Proxy implementation of the debug trace class'''
        def dbg(self,_):
            '''Nothing to do'''
            pass
else:
    from maya.debug.DebugTrace import DebugTrace
DBG = DebugTrace()
# DBG.debugging = True # Uncomment this line to enable debugging

#======================================================================

if __name__ == '__main__':
    # Facade to allow the localization macros to work in standalone mode
    # Has to be hacked through a string to prevent the preprocessor from complaining.
    exec('def _L10N(_, english_string):  return english_string')

# Constants representing the allowable types of optionVars supported by this module.
# There isn't really a "boolean" option var type. It's introduced here to provide a
# more natural interface to preferences that are boolean values.
OPTION_VAR_TYPE_BOOL = 0
OPTION_VAR_TYPE_FLOAT = 1
OPTION_VAR_TYPE_INT = 2
OPTION_VAR_TYPE_STRING = 3
OPTION_VAR_TYPE_RGB = 4
OPTION_VAR_TYPES = [ OPTION_VAR_TYPE_BOOL
                   , OPTION_VAR_TYPE_FLOAT
                   , OPTION_VAR_TYPE_INT
                   , OPTION_VAR_TYPE_STRING
                   , OPTION_VAR_TYPE_RGB
                   ]

# Dictionary of dynamically added enum optionVar types (strings with limited values).
# KEY=Index into OPTION_VAR_TYPES of the enum type
# VALUE=List of allowed types for this enum
ENUM_LISTS = {}

# Errors encountered when a mismatch of data and optionVar type is found
ERR_OV_NOT_BOOL       = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotBool'     ]
ERR_OV_NOT_FLOAT      = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotFloat'    ]
ERR_OV_NOT_INT        = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotInt'      ]
ERR_OV_NOT_STRING     = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotString'   ]
ERR_OV_NOT_RGB        = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotRGB'      ]
ERR_OV_NOT_RGB_INT    = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotRGBInt'   ]
ERR_OV_NOT_RGB_FLOAT  = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotRGBFloat' ]
ERR_OV_NOT_ENUM       = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarIllegalEnum' ]
ERR_OV_NOT_LEGAL_ENUM = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarNotEnum'     ]
ERR_OV_TYPE_UNKNOWN   = maya.stringTable['y_maya_app_prefs_OptionVar.kOptionVarTypeUnknown' ]

#======================================================================
def var_type_info(var_type):
    '''Utility method to return a debug string representing a variable type'''
    if var_type <= OPTION_VAR_TYPE_RGB:
        return ['boolean', 'float', 'int', 'string', 'rgb'][var_type]

    return 'enum[{}] ({})'.format( var_type, ENUM_LISTS[var_type] )

#======================================================================
def option_var_initialize(var_name, var_type, var_value, var_category):
    '''
    Set the value of an optionVar, with input type validation
    :param var_name: Name of the optionVar to retrieve
    :param var_type: Type of optionVar this is
    :param var_value: New value to be set
    :param var_category: OptionVar category
    :raise ValueError: If the var_value type is not compatible with var_type
                       This is slightly more restrictive than normal usage:
                           - non-string types to strings.
                           - integers are converted to floats but not booleans
                           - booleans are converted to ints (0, 1) but not floats
                           - colours are converted to ints (0, 1) but not floats
                           - enum string matches the known string types
    '''
    DBG.dbg( 'Initializing optionVar {} to {} ({})'.format( var_name, var_value, var_type_info(var_type)) )
    assert var_type in OPTION_VAR_TYPES
    if var_type == OPTION_VAR_TYPE_BOOL:
        if not isinstance(var_value,bool):
            raise ValueError( ERR_OV_NOT_BOOL.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( init=False, category=var_category, intValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_FLOAT:
        if not isinstance(var_value,int) and not isinstance(var_value, float):
            raise ValueError( ERR_OV_NOT_FLOAT.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( init=False, category=var_category, floatValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_INT:
        if not isinstance(var_value,int):
            raise ValueError( ERR_OV_NOT_INT.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( init=False, category=var_category, intValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_STRING:
        if not isinstance(var_value,str):
            raise ValueError( ERR_OV_NOT_STRING.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( init=False, category=var_category, stringValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_RGB:
        if not isinstance(var_value,list) or len(var_value) != 3:
            raise ValueError( ERR_OV_NOT_RGB.format(var_name, var_value, type(var_value)) )
        # Integer colours are in [0,255], floats are in [0.0,1.0]
        if isinstance(var_value[0], int) and isinstance(var_value[1], int) and isinstance(var_value[2], int):
            if var_value[0] > 255 or var_value[1] > 255 or var_value[2] > 255 or var_value[0] < 0 or var_value[1] < 0 or var_value[2] < 0:
                raise ValueError( ERR_OV_NOT_RGB_INT.format(var_name, var_value, type(var_value)) )
            cmds.optionVar( init=False, category=var_category, intValue3=[var_name, var_value[0], var_value[1], var_value[2]] )
        elif isinstance(var_value[0], float) and isinstance(var_value[1], float) and isinstance(var_value[2], float):
            if var_value[0] > 1.0 or var_value[1] > 1.0 or var_value[2] > 1.0 or var_value[0] < 0.0 or var_value[1] < 0.0 or var_value[2] < 0.0:
                raise ValueError( ERR_OV_NOT_RGB_FLOAT.format(var_name, var_value, type(var_value)) )
            cmds.optionVar( init=False, category=var_category, floatValue3=[var_name, var_value[0], var_value[1], var_value[2]] )
        else:
            raise ValueError( ERR_OV_NOT_RGB.format(var_name, var_value, type(var_value)) )
    #
    elif var_type in ENUM_LISTS:
        from sys import version_info as sys_version_info
        text_type = str if sys_version_info[0] >= 3 else unicode
        if not isinstance(var_value, str) and not isinstance(var_value, text_type):
            raise ValueError( ERR_OV_NOT_ENUM.format(var_name, var_value, type(var_value)) )
        if str(var_value) not in ENUM_LISTS[var_type]:
            raise ValueError( ERR_OV_NOT_LEGAL_ENUM.format(var_name, var_value, ENUM_LISTS[var_type]) )
        cmds.optionVar( init=False, category=var_category, stringValue=[var_name, str(var_value)] )
    #
    else:
        raise ValueError( ERR_OV_TYPE_UNKNOWN.format( var_name, var_type, var_value ) )

#======================================================================
def option_var_set_value(var_name, var_type, var_value):
    '''
    Set the value of an optionVar, with input type validation
    :param var_name: Name of the optionVar to retrieve
    :param var_type: Type of optionVar this is
    :param var_value: New value to be set
    :raise ValueError: If the var_value type is not compatible with var_type
                       This is slightly more restrictive than normal usage:
                           - non-string types to strings.
                           - integers are converted to floats but not booleans
                           - booleans are converted to ints (0, 1) but not floats
                           - colours are converted to ints (0, 1) but not floats
                           - enum string matches the known string types
    '''
    DBG.dbg( 'Setting optionVar {} to {} ({})'.format( var_name, var_value, var_type_info(var_type)) )
    assert var_type in OPTION_VAR_TYPES
    if var_type == OPTION_VAR_TYPE_BOOL:
        if not isinstance(var_value,bool):
            raise ValueError( ERR_OV_NOT_BOOL.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( intValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_FLOAT:
        if not isinstance(var_value,int) and not isinstance(var_value, float):
            raise ValueError( ERR_OV_NOT_FLOAT.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( floatValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_INT:
        if not isinstance(var_value,int):
            raise ValueError( ERR_OV_NOT_INT.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( intValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_STRING:
        if not isinstance(var_value,str):
            raise ValueError( ERR_OV_NOT_STRING.format(var_name, var_value, type(var_value)) )
        cmds.optionVar( stringValue=[var_name, var_value] )
    #
    elif var_type == OPTION_VAR_TYPE_RGB:
        if not isinstance(var_value,list) or len(var_value) != 3:
            raise ValueError( ERR_OV_NOT_RGB.format(var_name, var_value, type(var_value)) )
        # Integer colours are in [0,255], floats are in [0.0,1.0]
        if isinstance(var_value[0], int) and isinstance(var_value[1], int) and isinstance(var_value[2], int):
            if var_value[0] > 255 or var_value[1] > 255 or var_value[2] > 255 or var_value[0] < 0 or var_value[1] < 0 or var_value[2] < 0:
                raise ValueError( ERR_OV_NOT_RGB_INT.format(var_name, var_value, type(var_value)) )
            cmds.optionVar( intValue3=[var_name, var_value[0], var_value[1], var_value[2]] )
        elif isinstance(var_value[0], float) and isinstance(var_value[1], float) and isinstance(var_value[2], float):
            if var_value[0] > 1.0 or var_value[1] > 1.0 or var_value[2] > 1.0 or var_value[0] < 0.0 or var_value[1] < 0.0 or var_value[2] < 0.0:
                raise ValueError( ERR_OV_NOT_RGB_FLOAT.format(var_name, var_value, type(var_value)) )
            cmds.optionVar( floatValue3=[var_name, var_value[0], var_value[1], var_value[2]] )
        else:
            raise ValueError( ERR_OV_NOT_RGB.format(var_name, var_value, type(var_value)) )
    #
    elif var_type in ENUM_LISTS:
        from sys import version_info as sys_version_info
        text_type = str if sys_version_info[0] >= 3 else unicode
        if not isinstance(var_value, str) and not isinstance(var_value, text_type):
            raise ValueError( ERR_OV_NOT_ENUM.format(var_name, var_value, type(var_value)) )
        if str(var_value) not in ENUM_LISTS[var_type]:
            raise ValueError( ERR_OV_NOT_LEGAL_ENUM.format(var_name, var_value, ENUM_LISTS[var_type]) )
        cmds.optionVar( stringValue=[var_name, str(var_value)] )
    #
    else:
        raise ValueError( ERR_OV_TYPE_UNKNOWN.format( var_name, var_type, var_value ) )

#======================================================================
def option_var_get_value(var_name, var_type):
    '''
    Type-safe method of retrieving the current value of the optionVar. Converts from
    the raw value to the var_type the optionVar is expected to be.
    :param var_name: Name of the optionVar to retrieve
    :param var_type: Type of optionVar this is
    :raise ValueError: If the var_value type is not compatible with retrieved value.
                       - A boolean is not 0 or 1
                       - An enum is not part of the allowed enum string list
                       - Floats are truncated to integers
    '''
    assert var_type in OPTION_VAR_TYPES
    from sys import version_info as sys_version_info
    text_type = str if sys_version_info[0] >= 3 else unicode
    var_value = cmds.optionVar( query=var_name )
    if var_type == OPTION_VAR_TYPE_BOOL:
        if not isinstance(var_value,int) or var_value not in [0,1]:
            raise ValueError( ERR_OV_NOT_BOOL.format(var_name, var_value) )
        var_value = True if var_value else False
    #
    elif var_type == OPTION_VAR_TYPE_FLOAT:
        if not isinstance(var_value,int) and not isinstance(var_value, float):
            raise ValueError( ERR_OV_NOT_FLOAT.format(var_name, var_value) )
    #
    elif var_type == OPTION_VAR_TYPE_INT:
        if not isinstance(var_value,int):
            raise ValueError( ERR_OV_NOT_INT.format(var_name, var_value) )
        var_value = int(var_value)
    #
    elif var_type == OPTION_VAR_TYPE_STRING:
        if not isinstance(var_value, str) and not isinstance(var_value, text_type):
            raise ValueError( ERR_OV_NOT_STRING.format(var_name, var_value) )
    #
    elif var_type in ENUM_LISTS:
        if not isinstance(var_value, str) and not isinstance(var_value, text_type):
            raise ValueError( ERR_OV_NOT_ENUM.format(var_name, var_value, type(var_value)) )
        if str(var_value) not in ENUM_LISTS[var_type]:
            raise ValueError( ERR_OV_NOT_LEGAL_ENUM.format(var_name, var_value, ENUM_LISTS[var_type]) )
    #
    elif var_type == OPTION_VAR_TYPE_RGB:
        if not isinstance(var_value,list) or len(var_value) != 3:
            raise ValueError( ERR_OV_NOT_RGB.format(var_name, var_value, type(var_value)) )
        # Integer colours are in [0,255], floats are in [0.0,1.0]
        if isinstance(var_value[0], int) and isinstance(var_value[1], int) and isinstance(var_value[2], int):
            if var_value[0] > 255 or var_value[1] > 255 or var_value[2] > 255 or var_value[0] < 0 or var_value[1] < 0 or var_value[2] < 0:
                raise ValueError( ERR_OV_NOT_RGB_INT.format(var_name, var_value, type(var_value)) )
        elif isinstance(var_value[0], float) and isinstance(var_value[1], float) and isinstance(var_value[2], float):
            if var_value[0] > 1.0 or var_value[1] > 1.0 or var_value[2] > 1.0 or var_value[0] < 0.0 or var_value[1] < 0.0 or var_value[2] < 0.0:
                raise ValueError( ERR_OV_NOT_RGB_FLOAT.format(var_name, var_value, type(var_value)) )
        else:
            raise ValueError( ERR_OV_NOT_RGB.format(var_name, var_value, type(var_value)) )

    else:
        raise ValueError( ERR_OV_TYPE_UNKNOWN.format( var_name, var_type, var_value ) )

    return var_value

#======================================================================
class OptionVar(object):
    '''
    Class that manages an optionVar synced preference variable. It understands all of the various
    types of optionVars as well as some metatypes (e.g. boolean implemented as int, enum
    implemented as string).
        :member name: Name of the optionVar (i.e. what you pass to the optionVar command)
        :member value_default: The default value of the optionVar (i.e. the value it gets when prefs are reset)
        :member value_type: One of the OPTION_VAR_TYPE_xxx constants indicating what type of variable this is
        :member value_remembered: Value that was remembered when requested
        :member category: Category title (for grouping related preferences)
        :member title: Short title describing the preference
        :member info: Longer description of the preference
        :member option_var_job: scriptJob ID for the job that updates the preference when the optionVar changes
        :member categories: Bit mask for any category this OptionVar belongs to
        :member clients: Dictionary of client methods to call when the OptionVar changes,
                         either directly or via the Maya state - usually for UI. KEY=client, VALUE=callback
    '''
    CATEGORY_LIST = {} # Map of category name -> bit mask for categories member
                       # Dynamically grows as OptionVars are added to new categories

    def __init__(self, name, value_type, value_default, value_category=''):
        '''
        Initialize a new optionVar sync object
        :param name: Name of the optionVar (i.e. what you pass to the optionVar command)
        :param value_type: One of the OPTION_VAR_TYPE_xxx constants indicating what type of variable this is
                           If this is a list instead then it is considered to be the list of valid
                           strings for an enum type.
        :param value_default: The default value of the optionVar (i.e. the value it gets when prefs are reset)
        :param value_category: The optionVar category (used to group optionVars in userPrefs file)
        :param category: The category of the optionVar (for grouping related optionVars)
        '''
        self.name = name
        self.value_default = value_default
        self.value_category = value_category
        self.clients = {}
        self.title = name
        self.info = name
        self.option_var_job = None
        self.categories = 0

        if isinstance(value_type, list):
            OPTION_VAR_TYPES.append( len(OPTION_VAR_TYPES) )
            new_type = len(OPTION_VAR_TYPES) - 1
            ENUM_LISTS[new_type] = value_type
            self.value_type = new_type
        else:
            assert value_type in OPTION_VAR_TYPES
            self.value_type = value_type

        # Initialize the optionVar
        option_var_initialize(self.name, self.value_type, self.value_default, self.value_category)

        # Remember the current value so that initialization can be verified
        self.value_remembered = self.get_value()

        self.monitor_preference = True

    #----------------------------------------------------------------------
    class StateError(ValueError):
        '''
        Exception raised to indicate that state information was not available. This is used to
        differentiate a state that couldn't be set from an attempt to set up an illegal state value

        pylint warning is caused by the fact that this class does nothing, its only contribution is type information.
        '''
        def __init__(self, msg): # pylint: disable=useless-super-delegation
            '''Initialize the message in the ValueError, this class has no information of its own'''
            super( OptionVar.StateError, self ).__init__( msg )

    #----------------------------------------------------------------------
    def read_preference_from_state(self):
        '''Override this to read the new value of the optionVar from the scene state. Do not call directly.'''
        DBG.dbg( 'No override of read_preference_from_state({})'.format( self.name ) )
        return False

    #----------------------------------------------------------------------
    def set_state_from_preference(self):
        '''Override this to apply the current value of the optionVar to the scene state. Do not call directly.'''
        DBG.dbg( 'No override of set_state_from_preference({})'.format( self.name ) )

    #----------------------------------------------------------------------
    def do_read_preference_from_state(self):
        '''
        Wrapper around read_preference_from_state that ensures monitoring is off and values are legal.
        :return: True if the preference changed value
        '''
        DBG.dbg( 'do_read_preference_from_state({})'.format( self.name ) )
        value_changed = False
        old_preference = self.monitor_preference
        self.monitor_preference = False
        try:
            value_changed = self.read_preference_from_state()
        except OptionVar.StateError as ex:
            DBG.dbg( 'State information unavailable for {}, retaining current preference ({})'.format( self.name, ex ) )
        except ValueError as ex:
            DBG.dbg( 'Failed to get new value of {} from state, retaining old value ({})'.format( self.name, ex ) )
        self.monitor_preference = old_preference
        return value_changed

    #----------------------------------------------------------------------
    def do_set_state_from_preference(self):
        '''Wrapper around set_state_from_preference that ensures monitoring is off and values are legal'''
        DBG.dbg( 'do_set_state_from_preference({})'.format( self.name ) )
        old_preference = self.monitor_preference
        self.monitor_preference = False
        try:
            self.set_state_from_preference()
        except OptionVar.StateError as ex:
            DBG.dbg( 'Preference value could not be set into the state at the moment' )
        except ValueError as ex:
            DBG.dbg( 'Preference value of {} was illegal, retrieving value from state ({})'.format( self.name, ex ) )
            try:
                self.read_preference_from_state()
            except ValueError as ex:
                DBG.dbg( '--> That failed as well ({})'.format( ex ) )
        self.monitor_preference = old_preference

    #----------------------------------------------------------------------
    def __str__(self):
        ''':return: String representation of the optionVar'''
        callbacks = ', '.join( [listener.__class__.__name__ for listener in self.clients] )

        if self.value_type in ENUM_LISTS:
            values = ENUM_LISTS[self.value_type]
        else:
            values = ['boolean','integer','float','string','rgb'][self.value_type]

        return '{} (type {}, default {}, remembered {} - callbacks ({}))'.format( self.name, values, self.value_default, self.value_remembered, callbacks )

    #----------------------------------------------------------------------
    def update_clients(self):
        '''Notify the list of clients that the value has changed'''
        DBG.dbg( 'update_clients of {}'.format( self.name ) )
        for client_callback in list(self.clients.values()):
            client_callback()

    #----------------------------------------------------------------------
    def update_all_clients_but_me(self, who_am_i):
        '''
        Notify the list of clients that the value has changed, not including the one passed in
        :param who_am_i: The client that initiated the changed (which is why it won't be notified)
        '''
        DBG.dbg( 'update_all_clients_but_me of {}'.format( self.name ) )
        for client, client_callback in list(self.clients.items()):
            if client != who_am_i:
                client_callback()

    #----------------------------------------------------------------------
    def add_client(self, client, client_callback):
        '''
        Add a new client function to be called when this OptionVar value changes
        :param client: Name of client owning the callback
        :param client_callback: Function to be called when the OptionVar changes
                                Takes this OptionVar as the parameter.
        '''
        assert client not in self.clients
        self.clients[client] = client_callback

    #----------------------------------------------------------------------
    def remove_client(self, client):
        '''
        Remove all clients
        '''
        assert client in self.clients
        del self.clients[client]

    #----------------------------------------------------------------------
    def get_value(self):
        '''
        Get the current value of this managed variable. If the value has not yet
        been defined as an optionVar then return the default (not 0 as the optionVar
        command normally would).
        :raise ValueError: If the var_name is not known to the manager
        '''
        current_value = self.value_default
        if cmds.optionVar( exists=self.name ):
            try:
                current_value = option_var_get_value( self.name, self.value_type )
                DBG.dbg( 'Getting current value of {} from optionVar {}'.format( current_value, self.name ) )
            except ValueError:
                DBG.dbg( 'Current value of {} is illegal, returning the default {}'.format( self.name, self.value_default ) )
        else:
            DBG.dbg( 'Option var {} does not exist - getting default value of {}'.format( self.name, self.value_default ) )

        return current_value

    #----------------------------------------------------------------------
    def set_value(self, var_value):
        '''
        Set the value of the managed variable. The value passed in must match
        the type the variable has been defined as.
        :param var_value: New value of the optionVar
        :return: True if the value was different from the original value
        '''
        value_changed = False
        try:
            old_value = self.get_value()
            DBG.dbg( 'OptionVar.set_value of {} to {} from {}'.format( self.name, var_value, old_value ) )

            # Only update the state if the preference wasn't being read from it in the first
            # place, and it has a new value
            value_changed = old_value != var_value
            if value_changed:
                option_var_set_value( self.name, self.value_type, var_value )
                if self.monitor_preference:
                    self.do_set_state_from_preference()
                    self.update_clients()
        except ValueError:
            DBG.dbg( 'Tried to set illegal value of {} on {}'.format( var_value, self.name ) )
        return value_changed

    #----------------------------------------------------------------------
    def set_value_directly(self, client, var_value):
        '''
        Same as set_value, except that monitoring is disabled and the state is updated
        directly after the new optionVar is set, including any clients (not including
        the client that set the value).
        :param var_value: New value of the optionVar
        :param client: Who set the value directly
        :return: True if the value was different from the original value
        :raise ValueError: If the value was not a legal value for this optionVar
        '''
        old_monitor = self.monitor_preference
        self.monitor_preference = False
        value_changed = False
        try:
            old_value = self.get_value()
            DBG.dbg( 'OptionVar.set_value_directly of {} to {} from {}'.format( self.name, var_value, old_value ) )
            value_changed = old_value != var_value
            if value_changed:
                option_var_set_value( self.name, self.value_type, var_value )
                self.set_state_from_preference()
                self.update_all_clients_but_me( client )
        except ValueError:
            DBG.dbg( 'Tried to set illegal value of {} on {}'.format( var_value, self.name ) )
        finally:
            self.monitor_preference = old_monitor

        return value_changed

    #----------------------------------------------------------------------
    def remember_current(self):
        '''
        Remember the current states of all managed optionVars
        '''
        self.value_remembered = self.get_value()
        DBG.dbg( 'Remember optionVar {} value {}'.format( self.name, self.value_remembered ) )

    #----------------------------------------------------------------------
    def restore_remembered(self):
        '''
        Restore the remembered states of all managed optionVars
        '''
        DBG.dbg( 'Restore optionVar {} value {}'.format( self.name, self.value_remembered ) )
        self.set_value( self.value_remembered )

    #----------------------------------------------------------------------
    def revert_to_default(self):
        '''
        Restore the states of all managed optionVars to their factory defaults
        '''
        DBG.dbg( 'Revert optionVar {} to default {}'.format( self.name, self.value_default ) )
        self.set_value( self.value_default )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_preference_changed(option_var):
        '''
        Callback invoked when the optionVar has been modified via the optionVar command
        :param option_var: OptionVar object generating the callback
        '''
        DBG.dbg( '{}.callback_preference_changed'.format( option_var.name ) )
        try:
            option_var.set_state_from_preference()
            option_var.update_clients()
        except ValueError as ex:
            DBG.dbg( 'Preference value of {} was illegal, retrieving value from state ({})'.format( option_var.name, ex ) )
            try:
                option_var.read_preference_from_state()
            except ValueError as ex:
                DBG.dbg( '--- state retrieval failed as well ({})'.format( ex ) )

    #----------------------------------------
    def in_category(self, category):
        '''
        :return: True if the OptionVar belongs to the given category
        Current implementation of category is a bitfield but something more complex could
        be used if the future direction warrants it
        '''
        if category in self.CATEGORY_LIST:
            return 0 != (self.categories & self.CATEGORY_LIST[category])

        # Cannot be in a category that does not exist, though the "None" category means no filter
        return category is not None

    def set_in_category(self, category, new_value):
        '''
        Set the membership of this OptionVar into the category. If the category isn't known
        then it is added to the global category list.
        :param category: Unique category ID
        :param new_value: True if the OptionVar should belong to the category, False if it should not
        '''
        DBG.dbg( '{}.set_in_category( {} = {} )'.format( self.name, category, new_value ) )
        if category not in self.CATEGORY_LIST:
            if not new_value:
                # If removing from a non-existent category there is no need to create the category
                return
            bit_mask = 2 ** len(self.CATEGORY_LIST)
            self.CATEGORY_LIST[category] = bit_mask
        else:
            bit_mask = self.CATEGORY_LIST[category]

        if new_value:
            self.categories |= bit_mask
        else:
            self.categories &= ~bit_mask
        DBG.dbg( '.... bitmask is now {}'.format( self.categories ) )

    #----------------------------------------
    @property
    def monitor_preference(self):
        '''Return the resource guard state value'''
        return self.option_var_job is not None

    @monitor_preference.setter
    def monitor_preference(self, new_value):
        '''
        Set the state the the preference monitoring.
        :param new_value: New preference monitoring state.  True means a script job
                          will be run (or let continue) that provides a callback when
                          this class's optionVar changes value.
        '''
        # Skip the cases where the monitoring is unchanged
        if new_value and self.option_var_job is not None:
            return
        if not new_value and self.option_var_job is None:
            return

        if new_value:
            self.option_var_job = cmds.scriptJob( optionVarChanged=[self.name, partial(self.callback_preference_changed, option_var=self)] )
        else:
            cmds.scriptJob( kill=self.option_var_job )
            self.option_var_job = None

#######################################################################
# Unit testing module
#######################################################################

if __name__ == '__main__':
    import unittest
    #----------------------------------------------------------------------
    class MyOptionVar(OptionVar):
        '''Class to provide testable behaviour in an OptionVar override'''
        my_state = 0
        def __init__(self):
            '''Create a known type of OptionVar'''
            super( MyOptionVar, self ).__init__('MyOptionVar', OPTION_VAR_TYPE_INT, 0)
            self.title = 'My Option Var'
            self.info  = 'This is My Option Var'
        def read_preference_from_state(self):
            '''Set the preference to an internal value'''
            if MyOptionVar.my_state < 0:
                raise ValueError( 'MyOptionVar must be positive' )
            return self.set_value( MyOptionVar.my_state )
        def set_state_from_preference(self):
            '''Set the internal value to the preference value'''
            MyOptionVar.my_state = self.get_value()

    #----------------------------------------------------------------------
    class OptionVarTest(unittest.TestCase):
        ''' Class that contains the unit tests for the OptionVar class '''
        #----------------------------------------
        def test_simple(self):
            '''
            Test simple creation and initialization of optionVars
            '''
            # Create one of each type of optionVar
            i_option_var = OptionVar( 'intVar', OPTION_VAR_TYPE_INT, 5 )
            self.assertEqual( i_option_var.get_value(), 5 )
            b_option_var = OptionVar( 'boolVar', OPTION_VAR_TYPE_BOOL, True )
            self.assertEqual( b_option_var.get_value(), True )
            f_option_var = OptionVar( 'floatVar', OPTION_VAR_TYPE_FLOAT, 2.5 )
            self.assertEqual( f_option_var.get_value(), 2.5 )
            s_option_var = OptionVar( 'stringVar', OPTION_VAR_TYPE_STRING, 'hello' )
            self.assertEqual( s_option_var.get_value(), 'hello' )
            ri_option_var = OptionVar( 'rgbVarInt', OPTION_VAR_TYPE_RGB, [0,0,255] )
            self.assertEqual( ri_option_var.get_value(), [0,0,255] )
            rf_option_var = OptionVar( 'rgbVarFlt', OPTION_VAR_TYPE_RGB, [0.0,0.0,1.0] )
            self.assertEqual( rf_option_var.get_value(), [0.0,0.0,1.0] )

            # Test the sync functions
            my_option_var = MyOptionVar()
            my_option_var.set_value( 6 )
            self.assertEqual( my_option_var.get_value(), 6 )
            self.assertEqual( MyOptionVar.my_state, 6 )
            MyOptionVar.my_state = 10
            my_option_var.read_preference_from_state()
            self.assertEqual( my_option_var.get_value(), 10 )
            MyOptionVar.my_state = 1
            my_option_var.set_state_from_preference()
            self.assertEqual( MyOptionVar.my_state, 10 )

            # Test attempts to set illegal values
            with self.assertRaises( ValueError ):
                i_option_var.set_value( 'hello' )
            with self.assertRaises( ValueError ):
                i_option_var.set_value( 2.4 )
            with self.assertRaises( ValueError ):
                f_option_var.set_value( 'hello' )
            with self.assertRaises( ValueError ):
                b_option_var.set_value( 'hello' )
            with self.assertRaises( ValueError ):
                b_option_var.set_value( 3.0 )
            with self.assertRaises( ValueError ):
                b_option_var.set_value( 1 )
            for bad_rgb_int in [ 'hello', 0, [0], [0,0], [0,0,0,1], [-1,0,0], [0,0,256] ]:
                with self.assertRaises( ValueError ):
                    ri_option_var.set_value( bad_rgb_int )
            for bad_rgb_flt in [ 'hello', 0.0, [0.0], [0.0,0.0], [0.0,0.0,0.0,1.0], [-1.0,0.0,0.0], [0.0,0.0,2.0] ]:
                with self.assertRaises( ValueError ):
                    rf_option_var.set_value( bad_rgb_flt )
            with self.assertRaises( ValueError ):
                MyOptionVar.my_state = -1
                my_option_var.read_preference_from_state()

        #----------------------------------------
        def test_enum(self):
            '''
            Test creation and initialization of a custom enum optionVar
            '''
            enums = [ 'yes', 'no', 'maybe so', 'makes sense' ]
            e_option_var = OptionVar( 'enumVar', enums, enums[0] )
            self.assertEqual( e_option_var.get_value(), enums[0] )

            e_option_var.set_value( enums[2] )
            self.assertEqual( e_option_var.get_value(), enums[2] )

            with self.assertRaises( ValueError ):
                e_option_var.set_value( 1 )
            with self.assertRaises( ValueError ):
                e_option_var.set_value( 1.5 )
            with self.assertRaises( ValueError ):
                e_option_var.set_value( 'doubt it' )

    if __name__ == '__main__':
        unittest.main()
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
