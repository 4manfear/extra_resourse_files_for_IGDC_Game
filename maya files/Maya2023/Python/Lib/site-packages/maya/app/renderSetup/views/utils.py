import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import int
from builtins import object
from builtins import range
import maya.cmds as cmds
import maya.mel as mel

from maya import OpenMayaUI as omui

from PySide2.QtCore import Qt, Slot, QSize
from PySide2.QtGui import QMouseEvent, QPixmap, QIcon
from PySide2.QtWidgets import QLabel, QLineEdit, QWidget, QHBoxLayout, QVBoxLayout, QPushButton, QFrame, QSizePolicy, QMainWindow, QTreeWidget, QTreeWidgetItem, QCheckBox, QAbstractItemView
from shiboken2 import wrapInstance

import maya.app.renderSetup.common.utils as commonUtils
from maya.app.renderSetup.model.progressObservable import ProgressObservable
from maya.app.renderSetup.views.propertyEditor.collectionPropertyEditorStrings import kNbObjects, kOK, kSelectAll
from functools import partial
import maya.app.renderSetup.model.selector as selector
from future.utils import with_metaclass

kImageNotFoundError = maya.stringTable['y_maya_app_renderSetup_views_utils.kImageNotFoundError' ]
kIconNotFoundError = maya.stringTable['y_maya_app_renderSetup_views_utils.kIconNotFoundError' ]

_DPI_SCALE = 1.0 if not hasattr(cmds, "mayaDpiSetting") else cmds.mayaDpiSetting(query=True, realScaleValue=True)

def dpiScale(value):
    return value * _DPI_SCALE

def updateMouseEvent(event):
    # Handles one and two button mice CMD-click and Control-click events in
    # order to make it possible to right click and middle click with those mice.
    if cmds.about(mac=True):
        numMouseButtons = cmds.mouse(mouseButtonTrackingStatus=True)
        if numMouseButtons == 1:
            if event.modifiers() & Qt.MetaModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   Qt.RightButton,
                                   event.buttons(),
                                   event.modifiers() & ~Qt.MetaModifier,
                                   event.source())
            elif int(event.buttons()) & int(Qt.LeftButton) and event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   event.button(),
                                   Qt.MouseButtons(int(event.buttons())|Qt.MiddleButton&~Qt.LeftButton),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())
            elif event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   Qt.MiddleButton,
                                   event.buttons(),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())

        elif numMouseButtons == 2:
            if event.button() == Qt.LeftButton and event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   Qt.MiddleButton,
                                   event.buttons(),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())
            elif int(event.buttons()) & int(Qt.LeftButton) and event.modifiers() & Qt.ControlModifier:
                return QMouseEvent(event.type(),
                                   event.localPos(),
                                   event.windowPos(),
                                   event.screenPos(),
                                   event.button(),
                                   Qt.MouseButtons(int(event.buttons())|Qt.MiddleButton&~Qt.LeftButton),
                                   event.modifiers() & ~Qt.ControlModifier,
                                   event.source())
    return event

def createPixmap(imageName, width=0, height=0):
    rawPixmap = omui.MQtUtil.createPixmap(imageName)
    if rawPixmap is None:
        raise RuntimeError(kImageNotFoundError % imageName)
    pixmap = wrapInstance(int(rawPixmap), QPixmap)
    if (width != 0 and height != 0):
        return pixmap.scaled(width, height)
    return pixmap

def createIcon(iconName):
    rawIcon = omui.MQtUtil.createIcon(iconName)
    if rawIcon is None:
        raise RuntimeError(kIconNotFoundError + iconName)
    icon = wrapInstance(int(rawIcon), QIcon)
    return icon

def createIconWithOnOffStates(pixmapOffState, pixmapOnState):
    """ Create an icon with on/off states. Each state has a different pixmap."""
    rawIcon = omui.MQtUtil.createIcon(pixmapOffState)
    if rawIcon is None:
        raise RuntimeError(kImageNotFoundError + pixmapOffState)
    icon = wrapInstance(int(rawIcon), QIcon)
    icon.addPixmap(createPixmap(pixmapOnState), QIcon.Normal, QIcon.On)
    return icon

class ProgressBar(with_metaclass(commonUtils.SingletonMetaClass, object)):
    def __init__(self):
        super(ProgressBar, self).__init__()
        # Variable used to store the progress bar used in the class
        # and monitor active progress.
        self.mainProgressBar = None
        self.progressPercentage = 0

    def stepProgressBar(self, progress, info):
        newProgressPercentage = (int)(100*progress)
        if self.mainProgressBar and newProgressPercentage - self.progressPercentage:
            self.progressPercentage = newProgressPercentage
            cmds.progressBar(self.mainProgressBar, edit=True, progress=self.progressPercentage, status=info)

    def createProgressBar(self):
        self.mainProgressBar = mel.eval('$tmp = $gMainProgressBar')
        if self.mainProgressBar:
            cmds.progressBar(self.mainProgressBar,
                             edit=True,
                             beginProgress=True,
                             isInterruptable=False,
                             status="",
                             maxValue=100)
            self.progressPercentage = 1
            cmds.progressBar(self.mainProgressBar, edit=True, progress=self.progressPercentage, status="")
            cmds.waitCursor(state=True)

    def endProgressBar(self):
        if self.mainProgressBar:
            cmds.progressBar(self.mainProgressBar, edit=True, endProgress=True)
            self.progressPercentage = 0
            self.mainProgressBar = None
            cmds.waitCursor(state=False)

    def registerAsProgressObserver(self):
        assert ProgressObservable().hasItemObserver(self.reactToItemChangedNotification) == False
        ProgressObservable().addItemObserver(self.reactToItemChangedNotification)

    def unregisterAsProgressObserver(self):
        assert ProgressObservable().hasItemObserver(self.reactToItemChangedNotification) == True
        ProgressObservable().removeItemObserver(self.reactToItemChangedNotification)

    def reactToItemChangedNotification(self, *posArgs, **kwArgs):
        """ The subject of observation sends messages in the form of classes to
            indicate that progress has started or ended. Otherwise, it sends
            information about the progress estimated to be done
            (as a value from 0 to 1) and a message to be displayed.
        """
        assert len(posArgs) > 0 and len(posArgs) <=2
        if posArgs[0] == ProgressObservable.StartProgressNotification:
            self.createProgressBar()
        elif posArgs[0] == ProgressObservable.EndProgressNotification:
            self.endProgressBar()
        elif self.mainProgressBar:
            self.stepProgressBar(posArgs[0], posArgs[1])

def browse(fileNameAttr):
    result = cmds.fileDialog2(returnFilter=1, dialogStyle=2, fileMode=1)
    if result and len(result) > 0:
        cmds.setAttr(fileNameAttr, result[0], type='string')

class NodeListView(object):
    def __init__(self, title):
        self.title = title
        # self.first is used for efficient selection command
        # on first selection => replace the current selection (~= clear + select)
        # on other selections => add/remove to the current selection
        self.first = True

    def showNodeListView(self, names):
        self.first = True
        cmds.layoutDialog(ui=partial(self.buildViewObjects, names=names), title=self.title)

    def buildViewObjects(self, names):
        vSpc = 3
        hSpc = 10
        # Get the layoutDialog's formLayout.
        #
        form = cmds.setParent(q=True)

        # layoutDialog's are unfortunately not resizable, so hard code a size
        # here, to make sure all UI elements are visible.
        #
        cmds.formLayout(form, e=True, width=500, height=500)

        nbObjects = cmds.text(label=(kNbObjects % len(names)))

        treeView = cmds.treeView(allowDragAndDrop=False, allowReparenting=False, attachButtonRight=False)
        cmds.treeView(treeView, e=True, addItem = [(name,"") for name in names], itemDblClickCommand=lambda x:False)
        cmds.treeView(treeView, e=True, selectCommand=self.selectTreeCallBack)

        selectAllBtn = cmds.button(label=kSelectAll,command=partial(self.onSelectAllButton, treeView=treeView, names=names))
        okBtn = cmds.button(label=kOK,command=partial(self.onOKButton, msg='ok'))

        cmds.formLayout(
            form, edit=True,
            attachForm=[(nbObjects,   'top',    vSpc),
                        (nbObjects,   'left',   hSpc),
                        (treeView,    'left',   hSpc),
                        (treeView,    'right',  hSpc),
                        (okBtn,       'bottom', vSpc),
                        (okBtn,       'right',  hSpc),
                        (selectAllBtn,'bottom', hSpc)],
            attachControl=[(treeView, 'top', vSpc, nbObjects),
                           (treeView, 'bottom', vSpc, okBtn),
                           (selectAllBtn, 'top', vSpc, treeView),
                           (selectAllBtn, 'right', hSpc, okBtn)])

    def onSelectAllButton(self, data, treeView, names):
        for name in names:
            cmds.treeView(treeView, e=True, selectItem=(name,1))
        commonUtils.echoSelect(names, noExpand=True, add=(not self.first))
        self.first = False

    def onOKButton(self, data, msg):
        cmds.layoutDialog(dismiss=msg)

    def selectTreeCallBack(self, *args):
        cmds.select(args[0], noExpand=True, add=(not self.first), deselect=(not args[1]))
        self.first = False
        return True

class TreeWidgetItem(QTreeWidgetItem):
    def __init__(self, parent, label):
        super(TreeWidgetItem, self).__init__(parent, label)

    def data(self, column, role):
        '''
        Override the data function to add more spacing to the treewidgetitems
        '''
        if role == Qt.SizeHintRole:
            # No settings for width, but set height to 45px
            return QSize(0,dpiScale(20))
        else:
            return super(TreeWidgetItem, self).data(column, role)

class ViewAllWindow(QMainWindow):
    def __init__(self, RSNodeListView, title, parent, names, objects):
        super(ViewAllWindow, self).__init__(parent)

        self.RSNodeListView = RSNodeListView

        self.setWindowModality(Qt.ApplicationModal)

        self.setWindowTitle(title)

        self.widget = QWidget()
        self.setCentralWidget(self.widget)

        self.layout =  QVBoxLayout()

        self.treeWidget = QTreeWidget()
        self.treeWidget.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.treeWidget.itemSelectionChanged.connect(RSNodeListView.selectTreeCallBack)

        self.treeWidget.setColumnCount(1)

        self.numObjects = QLabel(kNbObjects % len(list(names.keys())))

        self.layout.addWidget(self.numObjects)

        # Keep track of the different nodes to add to the tree
        itemsToAdd = []

        for name in names:
            # Add the top-level parent nodes
            parent_node = TreeWidgetItem(None, [name])
            itemsToAdd.append(parent_node)

        # Store the generated items to be used in the toggle function later
        self.itemsToAdd = itemsToAdd

        self.treeWidget.insertTopLevelItems(0, itemsToAdd)
        self.treeWidget.setHeaderHidden(True)

        self.layout.addWidget(self.treeWidget)

        self.bottomControls = QHBoxLayout()

        self.viewDependenciesCheckBox = QCheckBox(maya.stringTable['y_maya_app_renderSetup_views_utils.kViewDependencies' ])
        self.viewDependenciesCheckBox.toggled.connect(RSNodeListView.toggleViewAll)

        self.selectAllButton = QPushButton(maya.stringTable['y_maya_app_renderSetup_views_utils.kSelectAll' ])

        self.selectAllButton.setFixedSize(QSize(dpiScale(80), dpiScale(25)))
        self.selectAllButton.clicked.connect(self.selectAllClicked)

        self.OKButton = QPushButton(maya.stringTable['y_maya_app_renderSetup_views_utils.kOK' ])
        self.OKButton.setFixedSize(QSize(dpiScale(80), dpiScale(25)))
        self.OKButton.clicked.connect(self.onOKButton)

        self.bottomControls.addWidget(self.viewDependenciesCheckBox)
        self.bottomControls.addWidget(self.selectAllButton)
        self.bottomControls.addWidget(self.OKButton)

        self.layout.addLayout(self.bottomControls)

        self.widget.setLayout(self.layout)

    def selectAllClicked(self, *args):
        list_to_select = []
        for i in range(self.treeWidget.topLevelItemCount()):
            item = self.treeWidget.topLevelItem(i)
            item.setSelected(True)
            list_to_select.append(item.text(0))

        commonUtils.echoSelect(list_to_select, noExpand=True, add=(not self.RSNodeListView.first))
        self.RSNodeListView.first = False
        return True

    def onOKButton(self):
        self.close()

class RenderSetupNodeListView(NodeListView):

    def __init__(self, title, parent):
        # Flag for whether the dependencies should be shown
        self.viewAll = False

        # The treeview object in the View All window
        self.treeview = None

        # Nodes representing the contents of the View All pane
        self.itemsToAdd = None

        # Maya nodes for the top-level of the View All pane
        self.objs = None

        # Cache the found dependencies after the first computation
        self.dependencyCache = None

        self.parent = parent

        self.viewAllWindow = None

        NodeListView.__init__(self, title)


    @Slot(bool)
    def toggleViewAll(self, state):
        if self.viewAll:
            self.viewAll = False

            # Remove the child nodes from each parent
            for i in range(self.viewAllWindow.treeWidget.topLevelItemCount()):
                parent = self.viewAllWindow.treeWidget.topLevelItem(i)
                for j in reversed(list(range(parent.childCount()))):
                    parent.removeChild(parent.child(j))

        else:
            self.viewAll = True

            # Only use traversal strategy for the nodes if it has not been done already
            # The data won't become stale after the first iteration because
            # the View All window is a modal window (prevents data changes
            # while the window is still open)
            if not self.dependencyCache:

                self.dependencyCache = selector.populateDependencies(self.objs)

            # Convert dictionary into a list of nodes to be displayed
            itemsToAdd = []

            for i in range(self.viewAllWindow.treeWidget.topLevelItemCount()):
                parent = self.viewAllWindow.treeWidget.topLevelItem(i)
                parent_text = parent.text(0)
                # Add the top-level parent node
                for dependency in self.dependencyCache[parent_text]:
                    itemsToAdd.append(TreeWidgetItem(parent, [dependency]))

            # Store the generated items to be used in the toggle function later
            self.itemsToAdd = itemsToAdd

            self.viewAllWindow.treeWidget.insertTopLevelItems(0, itemsToAdd)

            for i in range(self.viewAllWindow.treeWidget.topLevelItemCount()):
                self.viewAllWindow.treeWidget.expandItem(self.viewAllWindow.treeWidget.topLevelItem(i))
            self.viewAllWindow.treeWidget.update()

    def showViewAllWindow(self, names, objects):
        self.first = True
        self.objs = objects

        self.viewAllWindow = ViewAllWindow(self, self.title, self.parent, names, objects)
        self.viewAllWindow.resize(dpiScale(500),dpiScale(500))
        self.viewAllWindow.show()

    def selectTreeCallBack(self, *args):
        '''
        Callback function for when an item in the ViewAllWindow is selected
        '''
        selectedItems = self.viewAllWindow.treeWidget.selectedItems()

        # Find out which items need to be added or deleted from the selection
        currentlySelected = cmds.ls(selection=True)
        new_selected = []
        for item in selectedItems:
            # ls() shows the item with the extra path delimiter so ignore it
            # in the comparison
            new_selected.append(item.text(0).strip('|'))

        currentlySelectedSet = set(currentlySelected)
        newSelectedSet = set(new_selected)

        # Remove the items that are in the old set but not the new set
        # Add the items that are in the new set but not the old set
        toDelete = currentlySelectedSet.difference(newSelectedSet)
        toAdd = newSelectedSet.difference(currentlySelectedSet)

        for item in toDelete:
            cmds.select(item, deselect=True)

        for item in toAdd:
            cmds.select(item, noExpand=True, add=(not self.first))

        self.first = False
        return True

class LabelFieldButtonGrp(QWidget):
    '''Same as cmds.textFieldButtonGrp, but with better controls on each different widgets.
    (ex: more control on callbacks, tooltips and such).'''

    def __init__(self, label=None, text=None, placeholder=None, tooltip=None, button=None):
        super(LabelFieldButtonGrp, self).__init__()
        self._layout = QHBoxLayout()
        self.setLayout(self._layout)

        # label
        self._label = QLabel(label) if label else QLabel()
        self._layout.addWidget(self._label)

        # text field
        self._field = QLineEdit()
        if tooltip:
            self._field.setToolTip(tooltip)
        if placeholder:
            self._field.setPlaceholderText(placeholder)
        self._layout.addWidget(self._field)

        # button
        self._button = QPushButton(button) if button else QPushButton()
        self._layout.addWidget(self._button)

    @property
    def layout(self):
        return self._layout

    @property
    def label(self):
        return self._label

    @property
    def field(self):
        return self._field

    @property
    def button(self):
        return self._button

class Separator(QWidget):
    '''Same as cmds.separator(), except it allows to add a text in the middle of the separator.
    Ex: -------------- My Section --------------'''

    def __init__(self, text=None):
        super(Separator,self).__init__()

        layout = QHBoxLayout()
        self.setLayout(layout)

        def createLine():
            line = QFrame()
            line.setFrameShape(QFrame.HLine)
            return line
        layout.addWidget(createLine())
        if text:
            label = QLabel(text)
            label.setAlignment(Qt.AlignCenter)
            label.setSizePolicy(QSizePolicy.Maximum, QSizePolicy.Fixed)
            layout.addWidget(label)
            layout.addWidget(createLine())
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
