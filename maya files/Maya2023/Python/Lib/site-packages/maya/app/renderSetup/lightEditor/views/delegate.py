from __future__ import division
import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
from builtins import range
from PySide2.QtCore import Qt, QRect
from PySide2.QtGui import QColor, QPen, QCursor, QFontMetrics

import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya
from copy import deepcopy
import math

import maya.app.renderSetup.views.renderSetupDelegate as renderSetupDelegate
import maya.app.renderSetup.views.proxy.renderSetup as renderSetup
import maya.app.renderSetup.views.proxy.renderSetupRoles as renderSetupRoles
import maya.app.renderSetup.views.utils as utils
import maya.app.renderSetup.lightEditor.views.proxy as proxy
import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
import maya.app.renderSetup.model.applyOverride as applyOverride
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.views.baseDelegate as baseDelegate

def _isOverriddenPlug(plg):
    if plg and plg.isDestination:
        fn = OpenMaya.MFnDependencyNode(plg.source().node())
        return isinstance(fn.userNode(), applyOverride.ApplyOverride)
    return False

class DataDelegate(object):
    def draw(self, painter, rect, data, mapped):
        painter.drawText(rect, Qt.AlignLeft | Qt.AlignVCenter, " - ")

class FloatDelegate(DataDelegate):
    def draw(self, painter, rect, data, mapped):
        # Handling of decreased precision as the number of digits increase.
        # Wasn't able to make the general format "{:.3g}" work as I wanted
        # with always showing decimal points, so ended up with this manual
        # method instead.
        magnitude = math.fabs(data)
        formatStr = "{:.3e}"
        if magnitude < 100:
            formatStr = "{:.3f}"
        elif magnitude < 1000:
            formatStr = "{:.2f}"
        elif magnitude < 10000:
            formatStr = "{:.1f}"
        elif magnitude < 100000:
            formatStr = "{:.0f}"
        painter.drawText(rect, Qt.AlignLeft | Qt.AlignVCenter, formatStr.format(data))

class IntDelegate(DataDelegate):
    def draw(self, painter, rect, data, mapped):
        text = "{:d}".format(data) if data < 100000 else "{:.3e}".format(data)
        painter.drawText(rect, Qt.AlignLeft | Qt.AlignVCenter, text)

class BoolDelegate(DataDelegate):
    def draw(self, painter, rect, data, mapped):
        text = "on" if data is True else "off"
        painter.drawText(rect, Qt.AlignLeft | Qt.AlignVCenter, text)

class ColorDelegate(DataDelegate):

    COLOR_SWATCH_WIDTH = utils.dpiScale(25)

    def draw(self, painter, rect, data, mapped):
        w = rect.width()
        ad = max(w/2 - self.COLOR_SWATCH_WIDTH, 0)
        rect2 = rect.adjusted(ad-utils.dpiScale(10), utils.dpiScale(5), -ad-utils.dpiScale(10), utils.dpiScale(-5))

        # Draw the color swatch
        if mapped:
            # Draw a cross pattern to show we have a texture mapped
            painter.fillRect(rect2, QColor(200,200,200))
            painter.fillRect(rect2, Qt.DiagCrossPattern)
        else:
            # Transform color to display space and clamp to [0,1] range
            # to make sure QT will draw it correctly
            displayColor = cmds.colorManagementConvert(toDisplaySpace = data)
            displayColor = [max(min(v, 1.0), 0.0) for v in displayColor]
            displayColorQ = QColor.fromRgbF(*displayColor)
            painter.fillRect(rect2, displayColorQ)

class LightEditorDelegate(renderSetupDelegate.RenderSetupDelegate):
    """
    This class provides customization of the appearance of items in the model.
    """

    # Constants
    LIGHT_ICON_SIZE = utils.dpiScale(20)
    LIGHT_ICON_OFFSET_X = utils.dpiScale(10)
    LIGHT_ICON_OFFSET_Y = utils.dpiScale(4)
    TEXT_LEFT_OFFSET  = utils.dpiScale(15)
    TEXT_RIGHT_OFFSET = utils.dpiScale(30)
    LIGHT_ATTR_WIDTH  = utils.dpiScale(90)
    OVERRIDDEN_COLOR = QColor(229, 105, 41)

    BOLD_STYLE_OFFSET_X = utils.dpiScale(4)

    # Set delegates per data type
    dataDelegates = {"float":FloatDelegate(), "int":IntDelegate(), "bool": BoolDelegate(), "color": ColorDelegate()}

    kToolTipDisableLight = maya.stringTable['y_maya_app_renderSetup_lightEditor_views_delegate.kDisableLight' ]
    kToolTipDisableGroup = maya.stringTable['y_maya_app_renderSetup_lightEditor_views_delegate.kDisableGroup' ]

    def __init__(self, treeView):
        super(LightEditorDelegate, self).__init__(treeView)

        self.lightTypeIcon = {}

    def _drawColorBar(self, painter, rect, item):
        rect2 = deepcopy(rect)
        rect2.setRight(rect2.left() + self.COLOR_BAR_WIDTH)
        painter.fillRect(rect2, item.data(renderSetupRoles.NODE_COLOR_BAR))

        if item.type() == proxy.LIGHT_ITEM_TYPE:
            lightType = item.model.getLightType()

            # Create the icon if it's not already cached
            if lightType not in self.lightTypeIcon:
                iconFile = typeMgr.getIcon(lightType)
                icon = utils.createIcon(iconFile)
                self.lightTypeIcon[lightType] = icon

            icon = self.lightTypeIcon[lightType]
            rect2 = deepcopy(rect)
            rect2.setLeft(rect.left() + self.LIGHT_ICON_OFFSET_X)
            rect2.setRight(rect.left() + self.LIGHT_ICON_OFFSET_X + self.LIGHT_ICON_SIZE-1)
            rect2.setTop(rect.top() + self.LIGHT_ICON_OFFSET_Y)
            rect2.setBottom(rect.bottom() - self.LIGHT_ICON_OFFSET_Y)
            pixmap = icon.pixmap(self.LIGHT_ICON_SIZE, self.LIGHT_ICON_SIZE)
            painter.drawPixmap(rect2, pixmap, pixmap.rect())

    def _drawText(self, painter, rect, item):

        oldPen = painter.pen()
        painter.setPen(QPen(item.data(Qt.TextColorRole), 1))
        painter.setFont(item.data(Qt.FontRole))
        textRect = self.getTextRect(rect, item)

        maxNameWidth = utils.dpiScale(150)
        fm = painter.fontMetrics()
        name = fm.elidedText(item.data(Qt.DisplayRole), Qt.TextElideMode.ElideRight, maxNameWidth)
        painter.drawText(textRect, Qt.AlignLeft | Qt.AlignVCenter, name)

        if item.type() == proxy.LIGHT_ITEM_TYPE:

            indent = item.depth() * self.treeView().indentation()
            textRect.setLeft(textRect.left() + utils.dpiScale(157) - indent)
            textRect.setRight(textRect.left() + self.LIGHT_ATTR_WIDTH)

            for column in range(0, len(typeMgr.getAllAttributes())):

                attrLabel, dataType = list(typeMgr.getAllAttributes().items())[column]
                attrValue = item.columnData(Qt.DisplayRole, column)

                if attrValue is not None and dataType in LightEditorDelegate.dataDelegates:

                    # Draw the attribute label
                    painter.setPen(QPen(item.columnData(Qt.TextColorRole, column), 1))
                    painter.drawText(textRect, Qt.AlignLeft | Qt.AlignVCenter, attrLabel[0] + ":")

                    # Draw the attribute data
                    tempRect = deepcopy(textRect)
                    tempRect.setLeft(tempRect.left() + utils.dpiScale(12))
                    painter.setPen(QPen(item.data(Qt.TextColorRole), 1))
                    LightEditorDelegate.dataDelegates[dataType].draw(painter, tempRect, attrValue, item.model.isConnected(column))

                textRect.setLeft(textRect.left() + self.LIGHT_ATTR_WIDTH)
                textRect.setRight(textRect.right() + self.LIGHT_ATTR_WIDTH)

        painter.setPen(oldPen)

    def _drawWarning(self, painter, rect, item):
        # Draw the warning icon if a warning is set
        warning = item.data(renderSetupRoles.NODE_WARNING)
        if warning and len(warning) > 0:
            fm = QFontMetrics(self.treeView().font())
            left = self.getTextRect(rect, item).left() + fm.boundingRect(item.data(Qt.DisplayRole)).width() + baseDelegate.BaseDelegate.ACTION_BORDER + LightEditorDelegate.BOLD_STYLE_OFFSET_X
            top = rect.top() + baseDelegate.BaseDelegate.ICON_TOP_OFFSET
            painter.drawPixmap(left, top, baseDelegate.BaseDelegate.WARNING_IMAGE)

            iconRect = QRect(left, top, baseDelegate.BaseDelegate.WARNING_ICON_WIDTH, baseDelegate.BaseDelegate.WARNING_ICON_WIDTH)
            p = self.treeView().mapFromGlobal(QCursor.pos())
            if iconRect.contains(p):
                item.setToolTip(warning)

    def getTextRect(self, rect, item):
        textRect = super(LightEditorDelegate, self).getTextRect(rect, item)
        textRect.setLeft(textRect.left() + self.TEXT_LEFT_OFFSET)
        warning = item.data(renderSetupRoles.NODE_WARNING)
        if not warning:
            textRect.setRight(textRect.right() - self.TEXT_RIGHT_OFFSET)
        else:
            textRect.setRight(rect.right() - (self.TEXT_RIGHT_OFFSET + baseDelegate.BaseDelegate.WARNING_ICON_WIDTH + baseDelegate.BaseDelegate.ACTION_BORDER))

        return textRect

    def updateEditorGeometry(self, editor, option, index):
        """ Sets the location for the double-click editor for renaming light editor entries. """
        item = self._getItem(index)
        rect = self.getTextRect(option.rect, item)

        indent = item.depth() * self.treeView().indentation()
        leftOffset = indent + self.LEFT_NON_TEXT_OFFSET
        rect.setLeft(leftOffset)

        editor.setGeometry(rect)

    def _addActionIcons(self, painter, rect, item, highlightedColor):
        top = rect.top() + (self.ICON_TOP_OFFSET)
        start = self.ACTION_BORDER
        count = item.getActionButtonCount()

        # draw the darkened toolbar frame
        self.drawToolbarFrame(painter, rect, count)

        for iconIndex in range(0, count):
            actionName = item.getActionButton(iconIndex)
            pixmap = None
            drawDisclosure = False
            extraPadding = 0
            checked = False
            overridden = False
            isLight = item.model.typeId() == typeIDs.lightItem

            borderColor = None
            if (actionName == renderSetup.SET_ENABLED_ACTION):
                if isLight and not item.model.linkedVisibility():
                    borderColor = self.INFO_COLOR
                pixmap = self.DISABLED_IMAGE
                checked = not item.data(renderSetupRoles.NODE_SELF_ENABLED)
                overridden = _isOverriddenPlug(item.model.getSelfEnabledPlug())
            elif (actionName == renderSetup.SET_ISOLATE_SELECTED_ACTION):
                pixmap = self.ISOLATE_IMAGE
                checked = item.data(renderSetupRoles.NODE_ISOLATE_SELECTED)
                overridden = _isOverriddenPlug(item.model.getIsolatePlug())

            if borderColor is None and overridden:
                borderColor = self.OVERRIDDEN_COLOR

            start += self.ACTION_WIDTH + extraPadding
            self.drawAction(painter, actionName, pixmap, rect.right() - start, top, highlightedColor if checked else None, drawDisclosure, borderColor)

        if self.lastHitAction:
            # MAYA-66647 - This should be made into a separate action instead of a conditional action
            if self.lastHitAction == renderSetup.SET_VISIBILITY_ACTION and item.data(renderSetupRoles.NODE_NEEDS_UPDATE):
                item.setToolTip(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_delegate.kUpdateVisibilityToolTip' ])
            elif self.lastHitAction == renderSetup.SET_RENDERABLE_ACTION:
                self._setToolTipForRenderableAction(item)
            else:
                item.setToolTip(self.kTooltips[self.lastHitAction])
        else:
            item.setToolTip("")
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
