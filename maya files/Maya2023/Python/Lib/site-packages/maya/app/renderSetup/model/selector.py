"""Selector node classes and utility functions.

   In the render setup system, a selector is a node that identifies which
   nodes (or more properly instances) to apply overrides to.  One selector
   node is associated with each collection: the collection is
   considered to own its associated selector.  The output of a selector
   node is a multi-line string, with one node name (or instance name) per
   line."""
import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
from builtins import range
from builtins import next
from builtins import filter
import maya.api.OpenMaya as OpenMaya
import maya.cmds as cmds
import re as re
import itertools
import weakref

import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.model.sceneObservable as sceneObservable
import maya.app.renderSetup.model.plug as plugModel

import maya.app.renderSetup.model.algorithm as algorithm
from maya.app.renderSetup.model.selection import Selection
from maya.app.renderSetup.common.devtools import abstractmethod
from functools import partial

from maya.app.renderSetup.model.dagPath import DagPath
import maya.app.renderSetup.model.context as context

import maya.app.renderSetup.common.utils as commonUtils

# Python 1.0 API for MFileIO.  Remember that Python 1.0 API MObject's
# are not compatible with Python 2.0 API MObject's.
import maya.OpenMaya as OpenMaya1_0

import logging
from functools import reduce

logger = logging.getLogger(__name__)

# List of undo titles
kSet = maya.stringTable['y_maya_app_renderSetup_model_selector.kSet' ]

# Internal error messages
kNodeNotInStaticSelection  = "Node '%s' is not in static selection"
kNodeToAbsoluteNameFailure = "Failed to get the absolute name for '%s'"

# Status
kParentMissing = maya.stringTable['y_maya_app_renderSetup_model_selector.kParentMissing' ]
kInvalidParent = maya.stringTable['y_maya_app_renderSetup_model_selector.kInvalidParent' ]
kHasMissingObjects = maya.stringTable['y_maya_app_renderSetup_model_selector.kHasMissingObjects' ]

rsIncludes = []

# Populate dependencies for the given dictionary of {item:set([dependencies])}
def populateDependencies(object_iter):
    # List of traversal strategies with items() methods
    strategies = [
        ShadingStrategy(surface=True,
                        displace=True,
                        volume=True,
                        network=True),
        GeneratorStrategy(),
        SetStrategy(),
        NonDagStrategy(),
        DagStrategy(Filters.kAll),
        ShadingEngineStrategy()
    ]

    dependencies = {}
    for obj in object_iter:
        # There should only be 1 name per node
        obj_selection = Selection([obj])
        object_name = next(obj_selection.names())

        # Initialize the set of dependencies
        dependencies[object_name] = set([])
        # Collect the dependencies found using each of
        # the traversal strategies into the values of the dictionary
        for strategy in strategies:
            strategy_items = list(strategy.items(obj_selection))
            for item in strategy_items:
                names = Selection([item]).names()
                for name in names:
                    # Filter out the hidden nodes and the parent itself
                    if not cmds.getClassification(cmds.objectType(name),
                                                  satisfies="hidden") and \
                                                  name != object_name:
                        dependencies[object_name].add(name)
    return dependencies

def getRSIncludes():
    global rsIncludes
    if not rsIncludes:
        rsIncludes = list(utils.getRenderSetupNodeTypesNames() + utils.getLegacyRenderLayerNodeTypesNames())
    return rsIncludes

def createTypeFilter(types):
    includes = [t for t in types if not t.startswith('-')]
    excludes = [t[1:] for t in types if t.startswith('-')]
    def filterFunction(name):
        for type in excludes:
            if cmds.objectType(name, isAType=type):
                return False
        for type in includes:
            if cmds.objectType(name, isAType=type):
                return True
        return len(includes) == 0
    return filterFunction

def createCustomFilter(customs):
    '''"customs" is a string of types and classifications. ex: 'shader/surface -blinn'
       returns a filter function over a node name that returns True if the name passes the custom filtering, False otherwise.'''
    filters = [_f for _f in re.split(r';|,|\s', customs) if _f]
    includes = [t for t in filters if not t.startswith('-')]
    excludes = [t[1:] for t in filters if t.startswith('-')]
    includeTypes = list(filter(utils.isExistingType, includes))
    excludeTypes = list(filter(utils.isExistingType, excludes))
    includeClassifications = list(filter(utils.isExistingClassification, includes))
    excludeClassifications = list(filter(utils.isExistingClassification, excludes))

    def filterFunction(name):
        for type in excludeTypes:
            if cmds.objectType(name, isAType=type):
                return False
        for classif in excludeClassifications:
            if cmds.getClassification(cmds.objectType(name), satisfies=classif):
                return False
        for type in includeTypes:
            if cmds.objectType(name, isAType=type):
                return True
        for classif in includeClassifications:
            if cmds.getClassification(cmds.objectType(name), satisfies=classif):
                return True
        return False
    return filterFunction

def createClassificationFilter(classification):
    def filterFunction(name):
        return cmds.getClassification(cmds.objectType(name), satisfies=classification)
    return filterFunction

def isFilterLightsAndTransforms(name):
    def filterFunction(name):
        if cmds.objectType(name, isAType="transform"):
            import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
            node = commonUtils.nameToNode(name)
            return typeMgr.isValidLightTransformObject(node)
        if cmds.getClassification(cmds.objectType(name), satisfies='light'):
            return True
        return False
    return filterFunction

class Filters(object):
    kAll                     = 0
    kTransforms              = 1
    kShapes                  = 2
    kShaders                 = 3
    kLights                  = 4
    kSets                    = 5
    kTransformsAndShapes     = 6
    kCameras                 = 7
    kCustom                  = 8
    kTransformsShapesShaders = 9
    kGenerators              = 10
    kShadingEngines          = 11
    kLightsAndTransforms     = 12


    _filterNames = {
        kCustom                  : "Custom",
        kAll                     : "All",
        kTransforms              : "Transforms",
        kShapes                  : "Shapes",
        kShaders                 : "Shaders",
        kLights                  : "Lights",
        kSets                    : "Sets",
        kTransformsAndShapes     : "Transforms and Shapes",
        kCameras                 : "Cameras",
        kGenerators              : "Geometry Generators",
        kTransformsShapesShaders : "Transforms, Shapes and Shaders",
        kShadingEngines          : "Shading engines",
        kLightsAndTransforms     : "Lights and Transforms"
    }
    # MFnEnumAttribute.addField uses non-localized strings, the UI makes use of
    # these localized ones.
    _filterUINames = {
        kCustom                  : maya.stringTable['y_maya_app_renderSetup_model_selector.kCustomFilter' ],
        kAll                     : maya.stringTable['y_maya_app_renderSetup_model_selector.kAllFilter' ],
        kTransforms              : maya.stringTable['y_maya_app_renderSetup_model_selector.kTransformsFilter' ],
        kShapes                  : maya.stringTable['y_maya_app_renderSetup_model_selector.kShapesFilter' ],
        kShaders                 : maya.stringTable['y_maya_app_renderSetup_model_selector.kShadersFilter' ],
        kLights                  : maya.stringTable['y_maya_app_renderSetup_model_selector.kLightsFilter' ],
        kSets                    : maya.stringTable['y_maya_app_renderSetup_model_selector.kSetsFilter' ],
        kTransformsAndShapes     : maya.stringTable['y_maya_app_renderSetup_model_selector.kTransformsAndShapesFilter' ],
        kCameras                 : maya.stringTable['y_maya_app_renderSetup_model_selector.kCamerasFilter' ],
        kGenerators              : maya.stringTable['y_maya_app_renderSetup_model_selector.kGeneratorsFilter' ],
        kTransformsShapesShaders : maya.stringTable['y_maya_app_renderSetup_model_selector.kTransformsShapesShadersFilter' ],
        kShadingEngines          : maya.stringTable['y_maya_app_renderSetup_model_selector.kShadingEnginesFilter' ],
        kLightsAndTransforms     : maya.stringTable['y_maya_app_renderSetup_model_selector.kLightsAndTransformsFilter']
    }
    names = { # names used to create subcollection's names suffixes
        kTransforms              : "transforms",
        kShapes                  : "shapes",
        kShaders                 : "shaders",
        kLights                  : "lights",
        kSets                    : "sets",
        kCameras                 : "cameras",
        kGenerators              : "generators",
        kShadingEngines          : "shadingEngines"
    }

    @staticmethod
    def filterName(ftype):
        return Filters._filterNames[ftype]

    @staticmethod
    def filterUIName(ftype):
        return Filters._filterUINames[ftype]

    _filterTypes = {
        kAll                 : ["-renderSetup", "-renderSetupLayer", "-renderLayerManager", "-renderLayer", "-collection", "-selector", "-override", "-applyOverride"],
        kTransforms          : ["transform"],
        kShapes              : ["shape"],
        kSets                : ["objectSet"],
        kTransformsAndShapes : ["transform", "shape"],
        kCameras             : ["camera"],
        kGenerators          : ["polyCreator", "primitive"],
        kShadingEngines      : ["shadingEngine"]
    }
    _filterClassifications = {
        kShaders : 'shader',
        kLights  : 'light'
    }
    @staticmethod
    def filterTypes(ftype):
        if ftype in Filters._filterTypes:
            return Filters._filterTypes[ftype]
        if ftype == Filters.kLightsAndTransforms:
            return cmds.listNodeTypes(Filters._filterClassifications[Filters.kLights]) + \
                   Filters._filterTypes[Filters.kTransforms]
        if ftype in Filters._filterClassifications:
            return cmds.listNodeTypes(Filters._filterClassifications[ftype])
        if ftype == Filters.kTransformsShapesShaders:
            return Filters._filterTypes[Filters.kTransformsAndShapes] + \
                   cmds.listNodeTypes(Filters._filterClassifications[Filters.kShaders])

    @staticmethod
    def filterFunction(ftype):
        if ftype in Filters._filterTypes:
            return createTypeFilter(Filters._filterTypes[ftype])
        if ftype in Filters._filterClassifications:
            return createClassificationFilter(Filters._filterClassifications[ftype])
        if ftype == Filters.kLightsAndTransforms:
            return isFilterLightsAndTransforms(ftype)
        raise RuntimeError('Unknown type')

    @staticmethod
    def getFiltersFor(typeName):
        inherited = cmds.nodeType(typeName, inherited=True, isTypeName=True)
        def inherit(types):
            return reduce(lambda out,x : out or x in inherited, types, False)
        tests = itertools.chain(
            ((Filters.kShaders, lambda: utils.isSurfaceShaderType(typeName)),
            (Filters.kLights, lambda: 'light' in OpenMaya.MFnDependencyNode.classification(typeName))),
            ((filterType, lambda: inherit(Filters._filterTypes[filterType])) for filterType in ( Filters.kShadingEngines, Filters.kSets, Filters.kGenerators, Filters.kTransforms, Filters.kShapes )))
        for filterType,predicate in tests:
            if predicate():
                return (filterType, '')
        return (Filters.kCustom, typeName)

    @staticmethod
    def acceptsSetsContent(ftype):
        """ Returns whether the passed filter type accepts the content of sets."""
        return ftype != Filters.kSets

    @staticmethod
    def acceptsSets(ftype):
        """ Returns whether the passed filter type accepts the sets themselves."""
        return ftype == Filters.kSets or ftype == Filters.kAll

    _dagTypes = ( kAll, kTransforms, kShapes, kLights, kTransformsAndShapes, kCustom )
    _nonDagTypes = ( kAll, kShaders, kGenerators, kShadingEngines, kSets, kCustom )
    _allTypes = ( kAll, kTransforms, kShapes, kShaders, kLights, kShadingEngines, kSets, kGenerators, kCustom )


def _mSelectionListToAbsoluteNames(selection):
    '''Generator that converts nodes in a MSelectionList to long names.
       i.e. absolute path for dag nodes or instances and names for dependency (non-dag) nodes.'''
    for i in range(0,selection.length()):
        try:
            yield selection.getDagPath(i).fullPathName()
        except TypeError:
            node = selection.getDependNode(i)
            # Filter out Render Setup and Legacy Render Layer nodes
            # from the selection
            if not isRenderSetupOrLegacyRenderLayerNode(node):
                yield OpenMaya.MFnDependencyNode(node).name()

def _nodesToLongNames(selection, permissive=False):
    '''Generator that converts name/MObject/MDagPath/MDagNode/MFnDependencyNode to long names.
       i.e. absolute paths for dag nodes or instances and names for dependency (non-dag) nodes.
       NOTE: All Render Setup nodes are filtered out of the resulting generator.
    '''
    sl = OpenMaya.MSelectionList()
    for name in selection:
        sl.clear()
        try:
            sl.add(name)
        except RuntimeError:
            # name not found
            from sys import version_info as sys_version_info
            string_type = str if sys_version_info[0] >= 3 else basestring
            if permissive and isinstance(name, string_type):
                yield name
                continue
            else:
                # this should never happen
                raise RuntimeError(kNodeToAbsoluteNameFailure % str(name))
        try:
            yield sl.getDagPath(0).fullPathName()
        except TypeError:
            node = sl.getDependNode(0)
            # Filter out Render Setup and Legacy Render Layer nodes
            # from the selection
            if permissive or not isRenderSetupOrLegacyRenderLayerNode(node):
                yield OpenMaya.MFnDependencyNode(node).name()

def selectionToAbsoluteNames(selection, permissive=False):
    '''Generator that converts selected nodes to long names.
       i.e. absolute paths for dag nodes or instances and names for dependency (non-dag) nodes.
       "selection" can either be a MSelectionList or an iterable of nodes.
       if permissive, invalid nodes names (strings) are kept.'''
    if isinstance(selection, OpenMaya.MSelectionList):
        return _mSelectionListToAbsoluteNames(selection)
    return _nodesToLongNames(selection, permissive)

def isRenderSetupOrLegacyRenderLayerNode(node):
    """ Returns whether or not the node is a Render Setup or Legacy Render Layer node. """
    return node.hasFn(OpenMaya.MFn.kRenderLayer) or\
           node.hasFn(OpenMaya.MFn.kRenderLayerManager) or\
           typeIDs.isRenderSetupType(OpenMaya.MFnDependencyNode(node).typeId)

def _getUpdateSetFunctionExcludingAndUpdatedPattern(pattern):
    excluding = False
    update = set.update
    if pattern.startswith(r'-'):
        excluding = True
        pattern = pattern[1:]
        update = set.difference_update
    return update, excluding, pattern

def ls(patterns, types=None):
    '''
    Returns a set containing all the nodes matching patterns and types.
    '''
    # Default argument correction
    if types is None:
        types = []

    # NOTE: Render Setup and Legacy Render Layer nodes should never be
    # added as members of a selector, hence why includeTypes filters out
    # any nodeTypeName inside getRSIncludes.
    includeTypes = [t for t in types
                    if not t.startswith('-') and
                       t not in getRSIncludes()]

    def addPattern(selection, pattern):
        update, _, pattern = _getUpdateSetFunctionExcludingAndUpdatedPattern(pattern)
        update(selection,
               cmds.ls(pattern, type=includeTypes, long=True) if pattern != '*' \
                   else cmds.ls(type=includeTypes, long=True))
        return selection

    selection = reduce(addPattern, patterns, set())

    # Apparently, ls -excludeType cannot be used in conjunction with a pattern...
    # it does the same as -type when we do so...
    # i.e. ls -excludeType transform "*" returns all the transforms...
    # => must exclude types ourselves
    excludeTypes = [t for t in types if t.startswith('-')]

    if excludeTypes:
        selection = list(filter(createTypeFilter(excludeTypes), selection))

    return set(selection)

class Selector(OpenMaya.MPxNode):
    '''Selector node base class (abstract).

    A selector is a node that is responsible for finding nodes and/or dag paths
    given some search criterions.'''

    kTypeId = typeIDs.selector
    kTypeName = "selector"

    # aIn, aOut are integer attributes, they are only used to specify
    # relationships between selectors and allow dirty propagation
    aIn   = OpenMaya.MObject()
    aOut  = OpenMaya.MObject()

    # Attribute for message connection to collection node which owns
    # this selector.  We use a source message attribute, which doesn't
    # correspond to the intended data model, as a selector is owned by a
    # single collection, but the collection's selector
    # attribute is also a destination, and destination to destination
    # message connections produce errors on connection lookup.
    collection = OpenMaya.MObject()

    # Optional callbacks
    # These are functions of the form onSomeEvent(self, **kwargs)
    # kwargs are defined such as in sceneObservable.py
    # Subclasses can override them to handle the corresponding event
    onNodeAdded = None
    onNodeRemoved = None
    onNodeRenamed = None
    onNodeReparented = None
    onConnectionChanged = None

    kDagOnly = 1
    kNonDagOnly = 2
    kDagOrNonDag = 3 # (kDagOnly | kNonDagOnly)

    @abstractmethod
    def contentType(self):
        pass

    def hasDagNodes(self):
        return self.contentType() != Selector.kNonDagOnly

    @staticmethod
    def synced(f):
        '''Decorator for Selector's functions to guarantee selection is up to date (_update() is called if needed).
        Must decorate an instance function (starting with self).'''
        def wrapper(*args, **kwargs):
            self = args[0]
            OpenMaya.MPlug(self.thisMObject(), Selector.aOut).asInt() # trigger update if plug is dirty
            return f(*args, **kwargs)
        return wrapper

    @classmethod
    def create(cls, name):
        fn = OpenMaya.MFnDependencyNode()
        fn.create(cls.kTypeId, name)
        return fn.userNode()

    @classmethod
    def creator(cls):
        return cls()

    @staticmethod
    def createInput(attr, args):
        obj = attr.create(*args)
        attr.storable = True
        attr.writable = True
        return obj

    @classmethod
    def affectsOutput(cls, attr):
        cls.attributeAffects(attr, Selector.aOut)

    @staticmethod
    def initializer():
        attrFn = OpenMaya.MFnNumericAttribute()
        def createDirtyAttr(longName, shortName):
            obj = attrFn.create(longName, shortName, OpenMaya.MFnNumericData.kInt, 0)
            attrFn.hidden = True
            Selector.addAttribute(obj)
            return obj

        Selector.aIn  = createDirtyAttr( 'input',  'in')
        Selector.aOut = createDirtyAttr('output', 'out')
        Selector.affectsOutput(Selector.aIn)

        Selector.collection = utils.createSrcMsgAttr('collection', 'c')
        Selector.addAttribute(Selector.collection)

    def __init__(self):
        super(Selector, self).__init__()
        self._selection = None
        self._callbacks = None
        self._cbId = None
        self._bulkChangeCallbacks = None

    def postConstructor(self):
        # Don't observe during file open; wait until file open is over.
        if OpenMaya1_0.MFileIO.isReadingFile():
            sceneObservable.instance().register(
                sceneObservable.SceneObservable.FILE_OPENED, self.onFileOpened)
        else:
            self.activate()

    def isAbstractClass(self):
        # Used only as base class, cannot be created.
        return True

    def _onNodeRemoved(self, obj, clientData):
        if obj == self.thisMObject():
            self.deactivate()

    def beforeBulkChange(self, *args, **kwargs):
        self._deactivateGranular()

    def onBulkChange(self, *args, **kwargs):
        self._activateGranular()
        if not self.isDirty():
            self.selectionChanged()

    def onFileOpened(self):
        # Called only if selector is created during file open.
        logger.debug('Selector onFileOpened called.')
        self.activate()

        # After file open, the active render layer state and the selector state
        # must be consistent.  As saved, the render layer was applied, and its
        # members were correct (see RenderSetup._beforeSaveSceneCB).  However,
        # during load, a Maya file will set attributes on the selector (e.g.
        # static selection) that will cause its out attribute to be dirty.  A
        # dirty selector will not report further changes to its clients, as
        # they have been notified of a change, but have not pulled on the
        # selector output yet.  After file open, the selector should be clean,
        # as this is consistent will the state of the scene.
        #
        # Simply pull on the output to make it clean.
        OpenMaya.MPlug(self.thisMObject(), Selector.aOut).asInt()

        sceneObservable.instance().unregister(
                sceneObservable.SceneObservable.FILE_OPENED, self.onFileOpened)

    def isActivated(self):
        return self._callbacks is not None

    def _activateGranular(self):
        '''Adds granular scene observation callbacks.'''
        if self._callbacks:
            return # already activated

        self._cbId = None
        self._callbacks = {
            sceneObservable.SceneObservable.NODE_ADDED : self.onNodeAdded,
            sceneObservable.SceneObservable.NODE_REMOVED : self.onNodeRemoved,
            sceneObservable.SceneObservable.NODE_RENAMED : self.onNodeRenamed,
            sceneObservable.SceneObservable.NODE_REPARENTED : self.onNodeReparented,
            sceneObservable.SceneObservable.CONNECTION_CHANGED : self.onConnectionChanged }

        # create the callbacks if they are defined
        observable = sceneObservable.instance()
        for cbtype, callback in list(self._callbacks.items()):
            if callback:
                observable.register(cbtype, callback)
                if not self._cbId:
                    self._cbId = OpenMaya.MDGMessage.addNodeRemovedCallback(self._onNodeRemoved, Selector.kTypeName)

    def _deactivateGranular(self):
        '''Removes granular scene observation callbacks.'''
        if not self._callbacks:
            return # already deactivated

        if self._cbId:
            OpenMaya.MMessage.removeCallback(self._cbId)

        # remove the callbacks if they are defined
        observable = sceneObservable.instance()
        for cbtype, callback in list(self._callbacks.items()):
            if callback:
                observable.unregister(cbtype, callback)

        self._callbacks = self._cbId = None

    def activate(self):
        '''Creates observation callbacks.
        This is called when a selector is created or connected to a collection.
        Override this method to do any scene specific initialization.'''
        self._activateGranular()

        if self._bulkChangeCallbacks: # already has bulk callbacks
            return

        # Listen to reference load events directly.
        #
        # Reference unload events are different: render setup listens to
        # reference load events and distributes them to selectors, because it
        # performs a visible layer refresh switch on reference unload.  This
        # layer switch must occur after selectors are dirtied by the reference
        # unload, so we avoid reference unload callback order dependency issues
        # and let the render setup instance notify selectors first and do its
        # layer switch second.  See RenderSetup._beforeUnloadReferenceCB and
        # RenderSetup._afterUnloadReferenceCB.
        self._bulkChangeCallbacks = {
            sceneObservable.SceneObservable.BEFORE_REFERENCE_LOAD : self.beforeBulkChange,
            sceneObservable.SceneObservable.BEFORE_FILE_IMPORT    : self.beforeBulkChange,
            sceneObservable.SceneObservable.REFERENCE_LOADED      : self.onBulkChange,
            sceneObservable.SceneObservable.FILE_IMPORTED         : self.onBulkChange
        }

        observable = sceneObservable.instance()
        for cbtype, callback in list(self._bulkChangeCallbacks.items()):
            observable.register(cbtype, callback)


    def deactivate(self):
        '''Removes all observation callbacks.
        This is called when a selector is deleted or disconnected from a collection.
        Override this method to do any scene specific deinitialization.'''
        self._deactivateGranular()

        if not self._bulkChangeCallbacks: # already deactivated bulk callbacks
            return
        observable = sceneObservable.instance()
        for cbtype, callback in list(self._bulkChangeCallbacks.items()):
            observable.unregister(cbtype, callback)

        self._bulkChangeCallbacks = None

    def parent(self):
        '''Returns the parent of this selector if any, None otherwise.'''
        return utils.getSrcUserNode(OpenMaya.MPlug(self.thisMObject(), self.aIn))

    def setParent(self, parent):
        with undo.NotifyCtxMgr('Set selector\'s parent', self.selectionChanged):
            prevParent = self.parent()
            if prevParent:
                cmds.disconnectAttr(prevParent.name()+".out", self.name()+".in")
            if parent:
                cmds.connectAttr(parent.name()+".out", self.name()+".in")

    def isTraversingConnections(self):
        return False

    # functions for subclasses to override
    @abstractmethod
    def _update(self, dataBlock):
        '''Update the selection cache of this selector using dataBlock. Must be overridden by subclasses.
        This is called in Selector.compute() function, when output is dirty.'''
        pass

    def nodes(self):
        '''Return selection content as MObjects iterable.'''
        return ()

    def paths(self):
        '''Return selection content as DagPath iterable.'''
        return ()

    def names(self):
        '''Return selection content as name string iterable.'''
        return ()

    def members(self):
        '''Return selection content as MDagPath iterable representing the layer members.'''
        return ()

    def templateNodeName(self):
        '''Returns a node name in this selector's selection.'''
        return next((n for n in self.names()), None)

    def status(self):
        '''Returns the status of this selector (a string warning/error or None).'''
        return None

    def minimalClone(self, other):
        '''Does a minimal copy of other (Selector) to search for the same kind of objects.
           "other" must be the same type as "self".
           To be overriden by subclasses if needed.'''
        return

    def _setDirty(self):
        cmds.dgdirty(self.name()+".out", propagation=True)

    def isDirty(self):
        return cmds.isDirty(self.name()+".out", d=True)

    @context.selectionChanged
    def selectionChanged(self):
        self._setDirty()
        owner = self.owner()
        if owner:
            owner._selectedNodesChanged()

    def compute(self, plug, dataBlock):
        # to ensure that self._selection cache is rebuilt on self.selection() call
        self._selection = None
        if plug == Selector.aOut:
            self._update(dataBlock)
            # need to set the input clean to allow correct dirty propagation
            # since we're using it only for this but not actually pulling its value.
            # (setting the output clean implies nothing on the cleanliness of the inputs and
            # dirty propagation recursion stops on already dirtied plugs)
            dataBlock.setClean(self.aIn)
            dataBlock.setClean(plug)

            # The plug was successfully computed
            return self

        # Let the Maya parent class compute the plug
        return None

    def owner(self):
        """ Find the collection owner of this selector."""
        # Since we're forced to use a source attribute, the return type is
        # an array, but its length must be one.
        dst = utils.getDstUserNodes(OpenMaya.MPlug(self.thisMObject(), self.collection))
        return dst[0] if dst else None

    # for backward compatibility
    def getAbsoluteNames(self):return self.names()

    def getSelectionStandIn(self, nodeName):
        '''Return a selection string to use as stand-in for the given nodeName.
           Can be overridden by derived classes if another node should be used as
           stand-in for the given node.'''
        return None

class StaticSelection(object):
    '''
    Class that represents a static selection of nodes, without duplicates (a set).
    It has specialized functions to add/remove/set nodes and optimized query functions.
    '''

    def __init__(self, selector):
        '''Constructor of the StaticSelection.
        "selector" is the BasicSelector this static selection belongs to.'''
        super(StaticSelection, self).__init__()
        self._selector = weakref.ref(selector)
        # caches
        self._cList = None # selection as a list with deterministic order
        self._cSet = None # selection as a set for quick queries
        self._cFilteredOut = None # dictionary <name(string)> : <is name filtered out(bool)>
        self._cHasMissing = None # bool
        self._cHasFilteredOut = None # bool

    # mutators
    def set(self, selection):
        '''Sets the given nodes as the new static selection.
           "selection" can either be a MSelectionList or an iterable of node names or dag paths or dag nodes or dependency nodes.'''
        self._setStr('\n'.join(selectionToAbsoluteNames(selection)))

    def setWithoutExistenceCheck(self, selection):
        '''Sets the given nodes as the new static selection.
           "selection" can either be a MSelectionList or an iterable of node names or dag paths or dag nodes or dependency nodes.
           NOTE: Do not use. Reserved for Render Settings nodes.'''
        self._setList(selectionToAbsoluteNames(selection, True))

    def addOnlyLightsToSelection(self, selection):
        '''Adds only lights shapes from the given selection to the static selection.
           "selection" can either be a MSelectionList or an iterable of node names or dag paths or dag nodes or dependency nodes.'''
        lights = Filters.filterTypes(Filters.kLights)
        # only add light shapes to selection
        toAddStr = ""
        for s in selectionToAbsoluteNames(selection):
            selectionShape = cmds.listRelatives(s, f=True, s=True)
            # get the type of s, if s is a transform get the type of it's shape
            selectionType = cmds.objectType(s) if cmds.objectType(s, isAType="shape") else cmds.objectType(selectionShape[0])

            # We need to handle three edge case:
            # 1. Selection is a light object
            # 2. Selection is not part of existing static selection set
            # 3. If selection is a transform than it's shape is not part of existing selection set
            # 4. When the user selects both transform and shape of a light that only the shape gets added to the static selection
            # First check if the selection is a light object
            if selectionType in lights:
                # Check to see if selection is already part of existing set
                if s not in self.asSet():
                    if cmds.objectType(s, isAType="transform"):
                        # if s is a transform, make sure that the shape is not in the set
                        # make sure that the we haven't alreaded added selection to the list
                        # example: when we have selected both transform and shape nodes, this will ensure only one instance is added
                        if selectionShape[0] not in self.asSet() and selectionShape[0] not in toAddStr :
                            toAddStr = '\n'.join([selectionShape[0], toAddStr])
                    elif cmds.objectType(s, isAType="shape"):
                        # s is a shape so we can add it to set
                        if s not in toAddStr:
                            toAddStr = '\n'.join([s, toAddStr])
            else:
                # Selection is not a light object and will not be accepted
                cmds.warning('You can only add lights to this collection')
        if len(toAddStr) != 0:
            prev = self._getStr()
            self._setStr((prev+'\n' if len(prev) != 0 else prev) + toAddStr)

    def add(self, selection):
        '''Adds the given nodes to the static selection.
           "selection" can either be a MSelectionList or an iterable of node names or dag paths or dag nodes or dependency nodes.'''
        toAddStr = '\n'.join(s for s in selectionToAbsoluteNames(selection) if s not in self.asSet())
        if len(toAddStr) != 0:
            prev = self._getStr()
            self._setStr((prev+'\n' if len(prev) != 0 else prev) + toAddStr)

    def remove(self, selection):
        '''Removes the given nodes from the static selection.
           "selection" can either be a MSelectionList or an iterable of node names or dag paths or dag nodes or dependency nodes.'''
        toRemove = set( s for s in selectionToAbsoluteNames(selection, True) if s in self.asSet() )
        if len(toRemove) != 0:
            self._setList(item for item in self.asList() if item not in toRemove)

    # queries
    def __iter__(self):
        '''Generator over the all the selection in deterministic order.'''
        return ( key for key in self.asList() )

    def __contains__(self, node):
        '''Return True if node is in the static selection. False otherwise.'''
        return self._key(node) in self.asSet()

    def __len__(self):
        '''Return the length of the static selection (including missing/filtered out items).'''
        return len(self.asList())

    def asList(self):
        '''Returns the static selection items as a list.'''
        if self._cList is None:
            self._cList = self._getStr().split()
        return self._cList

    def setCache(self, names):
        '''Caches the static selection items as a list.'''
        self.dirtySelectionCB()
        self._cList = names.split()

    def asSet(self):
        '''Returns the static selection items as a set.'''
        if self._cSet is None:
            self._cSet = set(self.asList())
        return self._cSet

    def isMissing(self, node):
        '''Returns True if the given node is in the static selection but missing in the scene.
           Raises RuntimeError if given node is not in the static selection.'''
        return self._isMissing(self._existingKey(node))

    def isFilteredOut(self, node):
        '''Returns True if given node is in the static selection but filtered out.
           Raises RuntimeError if given node is not in the static selection.'''
        return self._isFilteredOut(self._existingKey(node))

    def hasMissingObjects(self):
        '''Returns True if static selection contains an object that doesn't exist in the scene. False otherwise.'''
        hasMissing = self._cHasMissing
        if hasMissing is None:
            self._cHasMissing = hasMissing = False
            for key in self.asList():
                if self._isMissing(key):
                    return True
        return hasMissing

    def hasFilteredOutObjects(self):
        '''Returns True if static selection contains filtered out nodes. False otherwise.'''
        hasFilteredOut = self._cHasFilteredOut
        if hasFilteredOut is None:
            self._cHasFilteredOut = hasFilteredOut = False
            for key in self.asList():
                if self._isFilteredOut(key):
                    return True
        return hasFilteredOut

    # encoding / decoding
    def encode(self):
        '''Encodes the static selection into a string.'''
        return self._getStr()

    def decode(self, string):
        '''Decodes the static selection from a string.'''
        self._setStr(string)

    # private methods
    def _setList(self, lst):
        self.dirtySelectionCB()
        self._cList = list(lst)
        self._setStr('\n'.join(self._cList))

    def _setStr(self, string):
        self._selector()._setStaticSelectionString(string)

    def _getStr(self):
        return self._selector()._getStaticSelectionString()

    def _key(self, node):
        '''Returns the key string unambiguously representing the given node.'''
        from sys import version_info as sys_version_info
        string_type = str if sys_version_info[0] >= 3 else basestring
        if isinstance(node, string_type) and node in self.asSet():
            return node
        return list(selectionToAbsoluteNames([node], True))[0]

    def _existingKey(self, node):
        '''Returns the key string unambiguously reprensenting the given node
        if it is in the static selection. Raises RuntimeError otherwise.'''
        key = self._key(node)
        if key not in self.asSet():
            raise RuntimeError(kNodeNotInStaticSelection % key)
        return  key

    def _isMissing(self, key):
        isMissing = not cmds.objExists(key)
        if isMissing:
            self._cHasMissing = True
        return isMissing

    def _isFilteredOut(self, key):
        if self._isMissing(key):
            return False
        filteredOut = self._cFilteredOut
        if filteredOut is None:
            self._cFilteredOut = filteredOut = dict()
        if key not in filteredOut:
            filteredOut[key] = not self._selector().acceptsTypeOrIsSet(cmds.nodeType(key))
            if filteredOut[key]:
                self._cHasFilteredOut = True
        return filteredOut[key]

    # callbacks
    def dirtySelectionCB(self):
        '''Clears all cache.'''
        self._cList, self._cSet = (None, None)
        self.dirtyFilterCB()
        self.dirtyMissingCB()

    def dirtyFilterCB(self):
        '''Clears filter-related cache.'''
        self._cFilteredOut, self._cHasFilteredOut = (None, None)

    def dirtyMissingCB(self):
        '''Clears missing objects related cache.'''
        self._cHasMissing = None

    def _onSceneChanged(self, item):
        if item in self:
            self.dirtyMissingCB()
            return True
        return False

    def onNodeAdded(self, obj):
        return self._onSceneChanged(OpenMaya.MFnDagNode(obj).getPath() if obj.hasFn(OpenMaya.MFn.kDagNode) else obj)

    def onNodeRemoved(self, obj):
        item = OpenMaya.MFnDagNode(obj).getPath() if obj.hasFn(OpenMaya.MFn.kDagNode) else obj
        if item in self:
            self._cHasMissing = True
            return True
        return False

    def onNodeRenamed(self, obj, oldName):
        newList = list(self.asList())

        if obj.hasFn(OpenMaya.MFn.kDagNode):
            paths = (path.fullPathName() for path in OpenMaya.MFnDagNode(obj).getAllPaths())
            replacements = { path[:path.rfind('|')+1]+oldName:path for path in paths }
        else:
            replacements = { oldName:OpenMaya.MFnDependencyNode(obj).name() }

        hasChanged = False
        for i, name in enumerate(newList):
            for before, after in list(replacements.items()):
                if name.startswith(before) and (len(name) == len(before) or name[len(before)]=='|'):
                    newList[i] = after+name[len(before):]
                    hasChanged = True
                elif name.startswith(after) and cmds.objExists(name):
                    # object is no longer missing
                    hasChanged = True
        if hasChanged:
            self._setList(newList)
        return hasChanged

    def onNodeReparented(self, msgType, child, parent):
        return self._onSceneChanged(child)


class Strategy(object):
    '''Abstract parent class for strategies for finding nodes given an input Selection.
       items(self, selection) returns an iterable of items found by the strategy.
       An item can be a MObject, a MDagPath or a string (existing node name or existing dag path).'''

    @abstractmethod
    def create(cls, filterType, customs):
        '''Returns a Strategy specialized for the given filters or None if the strategy doesn't apply to the given filter.
           Must be redefined by subclasses.'''
        pass

    @abstractmethod
    def items(self, selection):
        '''Returns the items found using the strategy.
           Must be redefined by subclasses.'''
        pass

    @abstractmethod
    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        pass

    @abstractmethod
    def isTraversingConnections(self):
        pass

    def members(self, selector):
        return selector.selection().paths()

    @abstractmethod
    def contentType(self):
        pass


class NonDagStrategy(Strategy):
    '''Concrete strategy that returns non-DAG nodes without searching.

        The default strategy is a catch-all for all node type filtering, or for
    custom type filtering.
    '''

    @staticmethod
    def create(filterType, customs):
        if filterType in { Filters.kAll, Filters.kCustom }:
            return NonDagStrategy()
        return None

    def items(self, selection):
        return selection.nonDagNodes()

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        pass

    def isTraversingConnections(self):
        return False

    def contentType(self):
        return Selector.kNonDagOnly


class DagStrategy(Strategy):
    '''Strategy for searching in the dag hierarchy.'''

    def __init__(self, filterType):
        self.shapesOnly = filterType in { Filters.kShapes, Filters.kLights }
        self.filterFunct = {
            Filters.kAll        : None,
            Filters.kTransforms : (lambda path: path.node().hasFn(OpenMaya.MFn.kTransform)),
            Filters.kShapes     : (lambda path: path.node().hasFn(OpenMaya.MFn.kShape)),
            Filters.kLights     : (lambda path: cmds.getClassification(OpenMaya.MFnDependencyNode(path.node()).typeName, satisfies='light')),
            Filters.kCustom     : None
        }[filterType]

    @staticmethod
    def create(filterType, customs):
        if filterType in { Filters.kAll, Filters.kTransforms, Filters.kShapes, Filters.kLights }:
            return DagStrategy(filterType)
        if filterType==Filters.kCustom and reduce(lambda out,x: out or utils.isInheritedType('dagNode',x), customs, False):
            return DagStrategy(filterType)
        return None

    def items(self, selection):
        sets = [OpenMaya.MFnDependencyNode(s).name() for s in selection.sets()]
        setmembers = (name for name in utils.findSetMembersDagPathsRecursively(sets))
        return list(filter(self.filterFunct, itertools.chain(selection.shapes() if self.shapesOnly else selection.hierarchy(), setmembers)))

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        if selector.containsSet(dstPlug.node()):
            srcNode = srcPlug.node()
            if srcNode.hasFn(OpenMaya.MFn.kDagNode) or \
               srcNode.apiType() == OpenMaya.MFn.kSet:
                selector.selectionChanged()

    def isTraversingConnections(self):
        return False

    def contentType(self):
        return Selector.kDagOnly

class TraversingConnectionStrategy(Strategy):
    def isTraversingConnections(self):
        return True

class ShadingEngineStrategy(TraversingConnectionStrategy):
    '''Strategy for finding assigned materials (shading engines).

    This strategy will return the union of shading engines assigned to shapes
    in its input, and shading engines directly in its input.
    '''

    @staticmethod
    def create(filterType, customs):
        if filterType in { Filters.kAll, Filters.kShadingEngines }:
            return ShadingEngineStrategy()
        if filterType==Filters.kCustom and reduce(lambda out,x: out or utils.isInheritedType('shadingEngine',x), customs, False):
            return ShadingEngineStrategy()
        return None

    @staticmethod
    def _findShadingEngines(dagPaths):
        treated = set()
        for dagPath in dagPaths:
            for engine in dagPath.findShadingEngines():
                name = OpenMaya.MFnDependencyNode(engine).name()
                if name not in treated:
                    treated.add(name)
                    yield engine

    def items(self, selection):
        return itertools.chain(ShadingEngineStrategy._findShadingEngines(DagPath(p) for p in selection.shapes()),
            (o for o in selection.nonDagNodes() if o.hasFn(OpenMaya.MFn.kShadingEngine)))

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        srcNode, dstNode = srcPlug.node(), dstPlug.node()
        if selector.parent():
            # shape => shadingEngine
            if srcNode.hasFn(OpenMaya.MFn.kShape) and dstNode.hasFn(
                    OpenMaya.MFn.kShadingEngine):
                selector.selectionChanged()
                return
        if selector.containsSet(dstNode):
            if srcNode.hasFn(OpenMaya.MFn.kShadingEngine) or \
               srcNode.apiType() == OpenMaya.MFn.kSet:
                selector.selectionChanged()

    def contentType(self):
        return Selector.kNonDagOnly

class ShadingStrategy(TraversingConnectionStrategy):
    '''Strategy for finding shading nodes in shading networks of assigned materials.'''

    def __init__(self, surface, displace, volume, network):
        # booleans telling if the strategy needs to search for surface shaders,
        # volume shaders, displacement shaders and input nodes (networks) of those
        self.surface  = surface
        self.displace = displace
        self.volume   = volume
        self.network  = network

    @staticmethod
    def create(filterType, customs):
        def createCustom():
            shading  = set(filter(utils.isShadingType, customs))
            if len(shading)==0:
                return None # nothing related to shading nodes
            surface  = set([t for t in customs if 'shader/surface' in OpenMaya.MFnDependencyNode.classification(t)])
            displace = set([t for t in customs if 'shader/displacement' in OpenMaya.MFnDependencyNode.classification(t)])
            volume   = set([t for t in customs if 'shader/volume' in OpenMaya.MFnDependencyNode.classification(t)])
            network  = ( surface | displace | volume ) != shading
            if network:
                surface = displace = volume = True
            else:
                surface, displace, volume = (len(s)>0 for s in (surface, displace, volume))
            return ShadingStrategy(surface, displace, volume, network)

        return {
            Filters.kShaders : partial(ShadingStrategy, surface=True, displace=False, volume=False, network=False),
            Filters.kAll     : partial(ShadingStrategy, surface=True, displace=True,  volume=True,  network=True),
            Filters.kCustom  : createCustom,
        }.get(filterType, lambda:None)()

    @staticmethod
    def _findSurfaceShaders(engines):
        return [_f for _f in (utils.findSurfaceShader(engine, True) for engine in engines) if _f]

    @staticmethod
    def _findDisplacementShaders(engines):
        return [_f for _f in (utils.findDisplacementShader(engine, False) for engine in engines) if _f]

    @staticmethod
    def _findVolumeShaders(engines):
        return [_f for _f in (utils.findVolumeShader(engine, False) for engine in engines) if _f]

    def items(self, selection):
        engines = list(ShadingEngineStrategy._findShadingEngines(DagPath(p) for p in selection.shapes()))
        objs = itertools.chain(
            ShadingStrategy._findSurfaceShaders(engines) if self.surface else (),
            ShadingStrategy._findDisplacementShaders(engines) if self.displace else (),
            ShadingStrategy._findVolumeShaders(engines) if self.volume else ())
        if self.network:
            objs = algorithm.traverse(objs, predicate=utils.isShadingNode)
        return itertools.chain(objs,
            (o for o in selection.nonDagNodes() if utils.isShadingNode(o)))

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        srcNode, dstNode = srcPlug.node(), dstPlug.node()
        if selector.containsSet(dstNode):
            if utils.isShadingNode(srcNode) or \
               srcNode.apiType() == OpenMaya.MFn.kSet:
                selector.selectionChanged()
                return
        if selector.parent():
            # shape => shadingEngine <= shader [<= shading nodes]*
            # skip shaders we don't need to find and shading nodes if we don't need to traverse network
            if dstNode.hasFn(OpenMaya.MFn.kShadingEngine):
                if srcNode.hasFn(OpenMaya.MFn.kShape):
                    selector.selectionChanged()
                else:
                    classification = OpenMaya.MFnDependencyNode.classification(OpenMaya.MFnDependencyNode(srcNode).typeName)
                    if (self.surface and 'shader/surface' in classification) or \
                        (self.volume and 'shader/volume' in classification) or \
                        (self.displace and 'shader/displacement' in classification):
                        selector.selectionChanged()
            elif self.network and utils.isShadingNode(srcNode) and utils.isShadingNode(dstNode):
                selector.selectionChanged()

    def contentType(self):
        return Selector.kNonDagOnly

class GeneratorStrategy(TraversingConnectionStrategy):
    '''Strategy for finding geometry generators.

    This strategy will return the union of geometry generators creating shapes
    in its input, and geometry generators directly in its input.
    '''

    @staticmethod
    def create(filterType, customs):
        if filterType in { Filters.kAll, Filters.kGenerators }:
            return GeneratorStrategy()
        if filterType==Filters.kCustom and \
            reduce(lambda out,x: out or utils.isInheritedType('primitive',x) or utils.isInheritedType('polyCreator',x), customs, False):
            return GeneratorStrategy()
        return None

    @staticmethod
    def _findGeometryGenerators(dagPaths):
        return [_f for _f in (dagPath.findGeometryGenerator() for dagPath in dagPaths) if _f]

    def items(self, selection):
        return itertools.chain(GeneratorStrategy._findGeometryGenerators(DagPath(p) for p in selection.shapes()),
            (o for o in selection.nonDagNodes() if o.hasFn(OpenMaya.MFn.kPolyCreator) or o.hasFn(OpenMaya.MFn.kPrimitive)))

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        srcNode, dstNode = srcPlug.node(), dstPlug.node()
        if selector.containsSet(dstNode):
            # If the destination node is a set in the current selector, then
            # the selection has to be updated if the source node is one of
            # interest to the GeneratorStrategy, which includes polyCreators,
            # primitives and other sets.
            if srcNode.hasFn(OpenMaya.MFn.kPolyCreator) or \
               srcNode.hasFn(OpenMaya.MFn.kPrimitive) or \
               srcNode.apiType() == OpenMaya.MFn.kSet:
                selector.selectionChanged()
                return

        if selector.parent():
            # shape [<= groupParts]* <= generator (geom/nurbs)
            srcTypes = (OpenMaya.MFn.kPolyCreator, OpenMaya.MFn.kPrimitive, OpenMaya.MFn.kGroupParts)
            dstTypes = (OpenMaya.MFn.kShape, OpenMaya.MFn.kGroupParts)

            if reduce(lambda out,x: out or srcNode.hasFn(x), srcTypes, False) and \
                reduce(lambda out,x: out or dstNode.hasFn(x), dstTypes, False):
                selector.selectionChanged()

    def contentType(self):
        return Selector.kNonDagOnly

class SetStrategy(TraversingConnectionStrategy):
    '''Strategy for finding sets containing the DAG paths in the selection.

    This strategy will return the union of sets containing DAG paths
    in its input, and sets directly in its input.
    '''

    @staticmethod
    def create(filterType, customs):
        if filterType in { Filters.kAll, Filters.kSets }:
            return SetStrategy()
        if filterType==Filters.kCustom and reduce(lambda out,x: out or not utils.isInheritedType('shadingEngine',x) and utils.isInheritedType('objectSet',x), customs, False):
            return SetStrategy()
        return None

    @staticmethod
    def _findSets(dagPaths, findMtd=DagPath.findSets):
        """ Return a generator to all sets connected to the given dag paths. """
        treated = set()
        for dagPath in dagPaths:
            for objectSet in findMtd(dagPath):
                name = OpenMaya.MFnDependencyNode(objectSet).name()
                if name not in treated:
                    treated.add(name)
                    yield objectSet

    def items(self, selection):

        def _findSetsRecursive(nodes):
            """ Return a generator of all sets and nested sets among the given
                nodes.
            """
            for node in nodes:
                if node.hasFn(OpenMaya.MFn.kSet):
                    yield node
                    # Yield all nested sets inside of the current set (node)
                    # recursively
                    selListMembers = OpenMaya.MFnSet(node).getMembers(flatten=False)
                    members = (selListMembers.getDependNode(i) for i in range(0, selListMembers.length()))
                    for childNode in _findSetsRecursive(members):
                        yield childNode

        return itertools.chain(SetStrategy._findSets(DagPath(p) for p in selection.paths()),
                _findSetsRecursive(selection.nonDagNodes()))

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        # dag => set or set => set
        if selector.containsSet(dstPlug.node()):
            srcNode = srcPlug.node()
            if srcNode.hasFn(OpenMaya.MFn.kDagNode) or \
                srcNode.hasFn(OpenMaya.MFn.kSet):
                selector.selectionChanged()

    def members(self, selector):
        ''' Return all dag members of the sets in the selector recursively.'''
        return utils.findSetMembersDagPathsRecursively(selector.names())

    def contentType(self):
        return Selector.kDagOrNonDag

class CompositeStrategy(Strategy):
    def __init__(self, strategies):
        self._strategies = strategies

    def __str__(self):
        return str(self._strategies)

    def items(self, selection):
        return itertools.chain.from_iterable(strategy.items(selection) for strategy in self._strategies)

    def onConnectionChanged(self, selector, srcPlug, dstPlug, made):
        for strategy in self._strategies:
            if selector.isDirty():
                return
            strategy.onConnectionChanged(selector, srcPlug, dstPlug, made)

    def isTraversingConnections(self):
        return reduce(lambda isTraversing, strategy: isTraversing or strategy.isTraversingConnections(), self._strategies, False)

    def members(self, selector):
        return itertools.chain.from_iterable((strategy.members(selector) for strategy in self._strategies))

    def contentType(self):
        return reduce(lambda contentType, strategy: contentType | strategy.contentType(), self._strategies, 0)

class SimpleSelector(Selector):
    '''Selector node with both dynamic wildcard-based selection and static
       list of names selection.

       Output is the union of both selections (dynamic and static).

       This class maintains caches for its static and dynamic selections.
       These caches become invalid (see selectionChanged) when the selector
       observes nodes being added or removed, or for selectors that traverse
       connections, when the selector observes connections being made or
       removed (see isTraversingConnections).  The caches are updated when the
       selector node compute is called.

       This observation of scene changes can be costly, for large numbers of
       changes, and is in large part unnecessary during layer switch, where
       unapply and apply are called.  Unapply deletes apply override nodes, and
       apply creates apply override nodes, none of which are interesting to
       selectors.  Unapply disconnects apply override nodes, and performs
       disconnections for connection overrides.  In some circumstances (see the
       context module documentation), this can affect the result of selectors
       that traverse connection.  Finally, apply connects apply override nodes
       and performs connections for connection overrides.  Connections made by
       lower priority collections can affect the result of higher priority
       collections that traverse connections (again, see the context module
       documentation).
    '''

    kTypeId = typeIDs.simpleSelector
    kTypeName = 'simpleSelector'

    # Attributes
    aPattern           = OpenMaya.MObject()  # Pattern for dynamic selection.
    aPrevPattern       = OpenMaya.MObject()  # Pattern for dynamic selection.
    aStaticSelection   = OpenMaya.MObject()  # Static list of node names.
    aTypeFilter        = OpenMaya.MObject()  # typeFilter as attribute
    aCustomFilterValue = OpenMaya.MObject()  # custom filter value as attribute

    @classmethod
    def getDefaultFilter(cls):
        return Filters.kTransforms

    @classmethod
    def getAvailableFilters(cls):
        return list(Filters._allTypes) + [Filters.kLightsAndTransforms]

    def contentType(self):
        return self.strategy().contentType()

    def isAbstractClass(self):
        return False

    def isTraversingConnections(self):
        '''Returns True if this selector traverses connections to populate its content, False otherwise.'''
        return False if self.parent() is None else self.strategy().isTraversingConnections()

    @classmethod
    def initializer(cls):
        cls.inheritAttributesFrom(Selector.kTypeName)

        default = OpenMaya.MFnStringData().create('')
        attr = OpenMaya.MFnTypedAttribute()
        cls.aPattern = cls.createInput(attr,["pattern", "pat", OpenMaya.MFnData.kString, default])
        cls.aPrevPattern = cls.createInput(attr,["previousPattern", "ppa", OpenMaya.MFnData.kString, default])
        cls.aStaticSelection = cls.createInput(attr, ["staticSelection", "ssl", OpenMaya.MFnData.kString, default])
        cls.aCustomFilterValue = cls.createInput(attr, ["customFilterValue", "cfv", OpenMaya.MFnData.kString, default])

        attr = OpenMaya.MFnEnumAttribute()
        cls.aTypeFilter = cls.createInput(attr, ["typeFilter", "tf", cls.getDefaultFilter()])
        for ftype in cls.getAvailableFilters():
            attr.addField(Filters.filterName(ftype), ftype)

        for attr in [cls.aPattern, cls.aPrevPattern, cls.aStaticSelection, cls.aTypeFilter, cls.aCustomFilterValue]:
            cls.addAttribute(attr)
            cls.affectsOutput(attr)

    def __init__(self):
        super(SimpleSelector, self).__init__()
        self._staticSelection = StaticSelection(self)
        self._activated = False
        self._strategy = None
        self._staticCache = set()
        self._dynamicCache = set()
        self._cache = set()
        self._setsCache = set()

    # CALLBACKS
    # TODO optimize pattern check
    def onNodeAdded(self, obj):
        logger.debug('onNodeAdded')
        if self.staticSelection.onNodeAdded(obj) or \
            not self.isDirty() and len(self.patterns()) > 0 and self.acceptsTypeOrIsSet(OpenMaya.MFnDependencyNode(obj).typeName):
            self.selectionChanged()

    def onNodeRenamed(self, obj, oldName):
        logger.debug('onNodeRenamed')
        if self.staticSelection.onNodeRenamed(obj, oldName) or \
            not self.isDirty() and len(self.patterns()) > 0 and self.acceptsTypeOrIsSet(OpenMaya.MFnDependencyNode(obj).typeName):
            self.selectionChanged()

    def onNodeRemoved(self, obj):
        logger.debug('onNodeRemoved')
        if self.staticSelection.onNodeRemoved(obj) or \
            not self.isDirty() and len(self.patterns()) > 0 and self.acceptsTypeOrIsSet(OpenMaya.MFnDependencyNode(obj).typeName):
            self.selectionChanged()

    def onNodeReparented(self, msgType, child, parent):
        if self.staticSelection.onNodeReparented(msgType, child, parent) or \
            not self.isDirty() and (len(self.patterns()) > 0 or self.parent()) and self.hasDagNodes():
            self.selectionChanged()

    def onBulkChange(self, *args, **kwargs):
        super(SimpleSelector, self).onBulkChange(*args, **kwargs)
        self.staticSelection.dirtyMissingCB()

    def onConnectionChanged(self, srcPlug, dstPlug, made):
        logger.debug('onConnectionChanged')
        if not self.isDirty():
            self.strategy().onConnectionChanged(self, srcPlug, dstPlug, made)

    def _filtersChanged(self):
        self.staticSelection.dirtyFilterCB()
        self._strategy = None
        self.selectionChanged()

    def _patternChanged(self):
        self.selectionChanged()

    def _staticSelectionChanged(self):
        self.staticSelection.dirtySelectionCB()
        self.selectionChanged()

    # ACCESSORS / MUTATORS / QUERIES
    def _getInputAttr(self, attr, dataBlock=None):
        return dataBlock.inputValue(attr) if dataBlock else OpenMaya.MPlug(self.thisMObject(), attr)

    def isEmpty(self):
        return len(self.getPattern()) == 0 and len(self.staticSelection) == 0

    def getPattern(self, dataBlock=None):
        return self._getInputAttr(self.aPattern, dataBlock).asString()

    def setPattern(self, val):
        if val != self.getPattern():
            with undo.NotifyCtxMgr(kSet % (self.name(), 'pattern', val), self._patternChanged):
                cmds.setAttr(self.name() + '.pattern', val, type='string')

    def setPreviousPattern(self, val):
        cmds.setAttr(self.name() + '.previousPattern', val, type='string')

    def getPreviousPattern(self, dataBlock=None):
        return self._getInputAttr(self.aPrevPattern, dataBlock).asString()

    def getFilterType(self, dataBlock=None):
        return self._getInputAttr(self.aTypeFilter, dataBlock).asShort()

    def setFilterType(self, val):
        if val not in self.getAvailableFilters():
            cmds.warning(maya.stringTable['y_maya_app_renderSetup_model_selector.kInvalidTypeFilter' ] % (self.name(), Filters.filterUIName(val)))
            return
        if val != self.getFilterType():
            with undo.NotifyCtxMgr(kSet % (self.name(), 'typeFilter', val), self._filtersChanged):
                cmds.setAttr(self.name() + '.typeFilter', val)

    def getCustomFilterValue(self, dataBlock=None):
        return self._getInputAttr(self.aCustomFilterValue, dataBlock).asString()

    def setCustomFilterValue(self, val):
        if val != self.getCustomFilterValue():
            with undo.NotifyCtxMgr(kSet % (self.name(), 'customFilterValue', val), self._filtersChanged):
                cmds.setAttr(self.name() + '.customFilterValue', val, type='string')

    def patterns(self, dataBlock=None):
        return [_f for _f in re.split(r';|,|\s', self.getPattern(dataBlock)) if _f]

    def getTypeFilters(self, dataBlock=None):
        type = self.getFilterType(dataBlock)
        if type != Filters.kCustom:
            return Filters.filterTypes(type)
        filters = [_f for _f in re.split(r';|,|\s', self.getCustomFilterValue(dataBlock)) if _f]
        def expand(f):
            '''If f is a classification string, expands it to an iterable of node types satifying that classification.
               If f is already a valid node type, simply returns it in a tuple.
               Otherwise, returns an empty tuple.'''
            negate = f.startswith('-')
            if negate: f = f[1:]
            types = cmds.listNodeTypes(f) or ((f,) if utils.isExistingType(f) else ())
            if negate: types = ["-"+t for t in types]
            return types
        return list(itertools.chain.from_iterable(expand(f) for f in filters))

    @property
    def staticSelection(self):
        return self._staticSelection

    def _setStaticSelectionString(self, string):
        with undo.NotifyCtxMgr(kSet % (self.name(), 'staticSelection', string), self._staticSelectionChanged):
            cmds.setAttr(self.name() + '.staticSelection', string, type='string')

    def _getStaticSelectionString(self):
        return OpenMaya.MPlug(self.thisMObject(), self.aStaticSelection).asString()

    def minimalClone(self, other):
        filterType = other.getFilterType()
        self.setFilterType(filterType)
        if filterType == Filters.kCustom:
            self.setCustomFilterValue(other.getCustomFilterValue())

    def strategy(self, dataBlock=None):
        if dataBlock or not self._strategy:
            filterType = self.getFilterType(dataBlock)
            customs = self.getTypeFilters() if filterType==Filters.kCustom else []
            strategies = [_f for _f in (cls.create(filterType, customs) for cls in [DagStrategy, ShadingStrategy, ShadingEngineStrategy, GeneratorStrategy, SetStrategy, NonDagStrategy]) if _f]
            self._strategy = strategies[0] if len(strategies)==1 else CompositeStrategy(strategies)
        return self._strategy

    def acceptsType(self, typeName, dataBlock=None):
        """ Return whether or not the selector accepts the given typeName
            (depending on its FilterType).
            NOTE: While any selector can now gather the content of sets
            (MAYA-93515), only some filter types accept the sets themselves
            (and allow overrides on set nodes). That distinction is needed,
            for instance, by model/collection.py, to create the appropriate
            subcollection during the creation of an override.
        """
        if self.getFilterType(dataBlock) == Filters.kShaders:
            return utils.isSurfaceShaderType(typeName)
        includes = [t for t in self.getTypeFilters(dataBlock) if not t.startswith('-')]
        if len(includes) == 0:
            return (self.getFilterType(dataBlock) != Filters.kCustom)

        try: parents = set(cmds.nodeType(typeName, inherited=True, isTypeName=True) or ())
        except: return False # typeName doesn't exist
        for typeName in includes:
            if typeName in parents:
                return True
        return False

    def acceptsTypeOrIsSet(self, typeName, dataBlock=None):
        return typeName == 'objectSet' or self.acceptsType(typeName, dataBlock)

    def templateNodeName(self):
        '''Returns a node name in this selector's selection or a node in the scene that
        would be accepted by this selector if empty.'''
        return super(SimpleSelector, self).templateNodeName() or \
            next((n for n in ls(["*"], types=self.getTypeFilters())),None) # pick first node in scene that matches filters as template

    def containsSets(self):
        """ Returns whether the current selector contains any set."""
        return len(self._setsCache) > 0

    def containsSet(self, node):
        """ Returns whether the node passed as argument is a set node in the
            current selector."""
        name = OpenMaya.MFnDependencyNode(node).name()
        filterType = self.getFilterType()

        if Filters.acceptsSetsContent(filterType):
            return self.containsSets() and node.apiType() == OpenMaya.MFn.kSet \
                   and name in self._setsCache
        if Filters.acceptsSets(self.getFilterType()):
            if name in self._cache: return True

        return False


    def _update(self, dataBlock):
        self._setsCache = set()
        current = self.parent()
        # Groups do not have selectors so continue to recurse upwards until you find a parent collection
        while current and current.owner() and not current.owner().hasSelector():
            current = current.parent()

        return self._updateFromWorld(dataBlock) if not current else \
            self._updateFromSelection(dataBlock, Selection(self.strategy(dataBlock).items(current.selection())))

    def _updateStaticSelection(self, dataBlock):
        # compute static selection
        self.staticSelection.setCache(dataBlock.inputValue(self.aStaticSelection).asString())
        filterType = self.getFilterType(dataBlock)
        filterFunc = Filters.filterFunction(filterType) if filterType != Filters.kCustom else \
                    createCustomFilter(self.getCustomFilterValue(dataBlock))

        def getSelectorMembers():
            for name in self.staticSelection:
                if cmds.objExists(name):
                    if filterFunc(name):
                        yield name
                    if Filters.acceptsSetsContent(filterType) and cmds.objectType(name, isType='objectSet'):
                        self._setsCache.update(utils.findValidNestedSetsRecursively(name))
                        for member in filter(filterFunc, utils.findSetMembersNamesRecursively(members=[name])):
                            yield member

        return getSelectorMembers()

    def _updateDynamicSelection(self, dataBlock):
        patterns = self.patterns(dataBlock)
        selection = ls(patterns, types=self.getTypeFilters(dataBlock))

        filterType = self.getFilterType(dataBlock)
        filterFunc = Filters.filterFunction(
            filterType) if filterType != Filters.kCustom else \
            createCustomFilter(self.getCustomFilterValue(dataBlock))

        if Filters.acceptsSetsContent(filterType):
            selection = self._addSetsWithProperTypeRecursively(selection, patterns, filterFunc)

        return selection

    def _addSetsWithProperTypeRecursively(self, selection, patterns, filterFunc):
        """ Return the selection with the content of the sets found using
            the given pattern, or just the selection if no sets were found.
        """
        for pattern in patterns:
            # Make sure the pattern is not the one that includes all, since it
            # would be useless to search the content of the sets in that case.
            if pattern == '*': continue
            update, excluding, pattern = _getUpdateSetFunctionExcludingAndUpdatedPattern(pattern)
            sets = cmds.ls(pattern, exactType='objectSet', long=True)
            if sets:
                if not excluding:
                    for setName in sets:
                        self._setsCache.update(utils.findValidNestedSetsRecursively(setName))
                else:
                    for setName in sets:
                        for nestedSet in utils.findValidNestedSetsRecursively(setName):
                            self._setsCache.discard(nestedSet)
                update(selection, list(filter(filterFunc, (n for n in utils.findSetMembersNamesRecursively(sets) if cmds.objExists(n)))))
        return selection

    def _updateFromWorld(self, dataBlock):
        self._setsCache = set()
        self._staticCache  = set(self._updateStaticSelection(dataBlock))
        self._dynamicCache = set(self._updateDynamicSelection(dataBlock))
        self._cache = self._staticCache | self._dynamicCache

    def _updateFromSelection(self, dataBlock, selection):
        # compute static selection
        self._staticCache = set([n for n in self._updateStaticSelection(dataBlock) if n in selection])

        # compute dynamic selection
        patterns = self.patterns(dataBlock)
        names = selection.ls(patterns)
        names = self._addSetsContentFromSelection(names, patterns)

        if self.getFilterType(dataBlock) == Filters.kCustom:
            typeFilter = createCustomFilter(self.getCustomFilterValue(dataBlock))
            names = list(filter(typeFilter, names))
        elif self.getFilterType(dataBlock) == Filters.kAll:
            names = list(filter(Filters.filterFunction(Filters.kAll), names))
        self._dynamicCache = set(names)

        self._cache = self._dynamicCache | self._staticCache

    def _updateSetsCache(self, sets, update):
        """ Update setsCache by either adding the sets passed as argument to
            the setsCache or removing them, depending on the update function
            passed as argument.
        """
        for setName in sets:
            update(self._setsCache, utils.findValidNestedSetsRecursively(setName))

    def _addSetsContentFromSelection(self, names, patterns):
        """ Add any nodes in the sets found with the patterns passed as
            argument that are in the parent's cache to the set of names and
            return it.
            This is used so that child selectors can gather the content of the
            sets found with the given patterns and add any of that content that
            is also in the parent selector.
        """
        for pattern in patterns:
            # Make sure the pattern is not the one that includes all, since it
            # would be useless to search the content of the sets in that case.
            if pattern == '*': continue
            if pattern.startswith('-'):
                pattern = pattern[1:]
                update = set.difference_update
            else:
                update = set.update
            sets = cmds.ls(pattern, exactType='objectSet', long=True)
            # Update the setsCache of the current selector accordingly.
            self._updateSetsCache(sets, update)
            update(names, [nodeName for nodeName in utils.findSetMembersNamesRecursively(sets) if nodeName in self.parent()._cache])
        return names

    def selection(self):
        names = self.names()
        if not self._selection:
            self._selection = Selection(names)
        return self._selection

    @Selector.synced
    def paths(self):
        return (DagPath(p) for p in self.selection().paths())

    @Selector.synced
    def shapes(self):
        return (DagPath(p) for p in self.selection().shapes())

    @Selector.synced
    def nodes(self):
        return self.selection().nodes()

    @Selector.synced
    def names(self):
        return self._cache

    @Selector.synced
    def members(self):
        return self.strategy().members(self)

    @Selector.synced
    def getStaticNames(self):
        return self._staticCache

    @Selector.synced
    def getDynamicNames(self):
        return self._dynamicCache

    def getInvalidFilters(self, dataBlock=None):
        return [] if self.getFilterType(dataBlock) != Filters.kCustom else \
            [t for t in [t[1:] if t.startswith('-') else t for t in [_f for _f in re.split(r';|,|\s', self.getCustomFilterValue(dataBlock)) if _f]] if not utils.isExistingType(t) and not utils.isExistingClassification(t)] # get custom filters

    def status(self, dataBlock=None):
        invalidFilters = self.getInvalidFilters(dataBlock)
        if len(invalidFilters) > 0:
            return maya.stringTable['y_maya_app_renderSetup_model_selector.kInvalidTypes' ] % ' '.join(invalidFilters)
        if self.staticSelection.hasMissingObjects():
            return kHasMissingObjects
        return None

    def setStaticSelection(self, ss):
        """Deprecated method.

        Use methods on SimpleSelector.staticSelection instead."""

        return self.staticSelection._setStr(ss)

    def getStaticSelection(self):
        """Deprecated method.

        Use methods on SimpleSelector.staticSelection instead."""

        return self.staticSelection._getStr()

    def hasMissingObjects(self):
        return self.staticSelection.hasMissingObjects()

    def hasFilteredOutObjects(self):
        return self.staticSelection.hasFilteredOutObjects()

    def _encodeProperties(self, dict):
        encoders = (
            (self.aPattern,           self.getPattern),
            (self.aStaticSelection,   self.staticSelection.encode),
            (self.aTypeFilter,        self.getFilterType),
            (self.aCustomFilterValue, self.getCustomFilterValue),
            (self.aPrevPattern,        self.getPreviousPattern))
        for attr, encode in encoders:
            dict[OpenMaya.MPlug(self.thisMObject(), attr).partialName(useLongNames=True)] = encode()

    def _decodeProperties(self, dict):
        decoders = (
            (self.aPattern,           self.setPattern),
            (self.aStaticSelection,   self.staticSelection.decode),
            (self.aTypeFilter,        self.setFilterType),
            (self.aCustomFilterValue, self.setCustomFilterValue),
            (self.aPrevPattern,        self.setPreviousPattern))
        for attr, decode in decoders:
            name = OpenMaya.MPlug(self.thisMObject(), attr).partialName(useLongNames=True)
            if name in dict:
                decode(dict[name])

class LightsCollectionSelector(SimpleSelector):
    """ A custom selector only to be used with the LightsCollection and LightsChildCollection.
    Will select light source and light groups, but also add in any light editor items
    attached to light sources. This makes it possible to override attributes on both the
    light source and its corresponding light editor item. """

    kTypeId = typeIDs.lightsCollectionSelector
    kTypeName = 'lightsCollectionSelector'

    @classmethod
    def initializer(cls):
        cls.inheritAttributesFrom(SimpleSelector.kTypeName)

    def __init__(self):
        super(LightsCollectionSelector, self).__init__()

    def typeId(self):
        return LightsCollectionSelector.kTypeId

    def typeName(self):
        return LightsCollectionSelector.kTypeName

    def isAbstractClass(self):
        return False

    @staticmethod
    def _findRelatedNodes(names):
        # Find transform nodes and light item nodes which are related to the given
        # light shape nodes. These need to be part of the selector result in order
        # for overrides to work. But they are hidden and not listed as members.
        nodes = set()
        for name in names:
            plug = plugModel.findPlug(name, 'message')
            if plug.node().hasFn(OpenMaya.MFn.kShape):
                # Get the transform
                transform = cmds.listRelatives(name, p=True, f=True)
                nodes.add(transform[0])
                # Get the light item
                dest = utils.plugDst(plug.plug)
                for d in dest if dest else []:
                    fn = OpenMaya.MFnDependencyNode(d.node())
                    if fn.typeId == typeIDs.lightItem:
                        nodes.add(fn.name())
        return nodes

    def _update(self, dataBlock):
        self._setsCache = set()
        # There is no need to update from the parent since the light collection
        # by definition includes all lights, and every light child collection
        # can only include a single light which is obviously in the parent
        # collection.
        self._updateFromWorld(dataBlock)

        # Add in related nodes (transform and light items) attached to the light shapes.
        self._cache |= LightsCollectionSelector._findRelatedNodes(self._cache)

    def isTraversingConnections(self):
        return False

    def onConnectionChanged(self, srcPlug, dstPlug, made):
        if srcPlug.node().hasFn(OpenMaya.MFn.kShape) and OpenMaya.MFnDependencyNode(dstPlug.node()).typeId == typeIDs.lightItem:
            # If a light item is attached or detached to a
            # light shape we must update the selection.
            self.selectionChanged()
        else:
            super(LightsCollectionSelector, self).onConnectionChanged(srcPlug, dstPlug, made)

    def getSelectionStandIn(self, nodeName):
        # If this is a light item the connected light source should be used
        node = commonUtils.nameToNode(nodeName)
        if OpenMaya.MFnDependencyNode(node).typeId == typeIDs.lightItem:
            plg = plugModel.findPlug(node, 'light')
            src = utils.plugSrc(plg.plug)
            return OpenMaya.MFnDagNode(src.node()).fullPathName() if src and \
                src.node().hasFn(OpenMaya.MFn.kShape) else None
        return None

    def onNodeReparented(self, msgType, child, parent):
        # Override the parent's onNodeReparented method
        # Maya-97343: Lights added to a Light Collection will now auto-repath when its hierarchy is changed in the scene
        # Reparenting a light (i.e. making light hierachy change) can happen in 3 ways via the Outliner:
        # 1) The user creates a new group in Outliner and then drag and drop a light into the new group as a child.
        #    the resulting path will look like this: parentPath/oldLightPath
        # 2) The user selects a light in Outliner or a group containing light(s) in Outliner and then 'ctrl+g' to create top level nested groups
        #    the resulting path will look like this: new_group/...(new_groups if successive ctrl+g).../oldpath.
        #    Note that if an old group has multiple child lights and is selected, creating a new group parent on top of the old group will change the path of all the lights in the old group. (i.e. all affected light paths must be updated.)
        # 3) The user drags and drops a group with one or multiple lights into an existing group
        #    the resulting path will look like this: drop_group_path/old_group_path
        #    Note that if an old group has multiple child lights, drag and dropping it into a new group parent will change the path of all the lights in the old group. (i.e. all affected light paths must be updated.)
        # 4) Counter-case: The user imports a collection with missing lights. The ancestor of the missing light exists and is changed before the missing light is brought back.
        #    since the light does not currently exist in the scene, we should not update its path.
        # -------------------------------------------------
        # The current callback allows us to access two variables: the parent in the reparenting event, a MDagPath object. From which we can get its partial name, full path, its children, etc.
        # It also returns the child in the reparenting event, a MDagPath object. From which we can get its partial name, full path, its children, etc.
        # -------------------------------------------------
        # There are 2 key insights used to handle all these cases elegantly with a single logic:
        # 1) Each group name (i.e. partial name) is unique in Maya and has already been pre-processed and checked. There can't be two groups with the same name in Maya.
        # 2) The path name works similarly to a file/folder system. There's no need to check what's inside the folder to know that all its content's paths will be changed when it gets reparented -> we know for a fact they will.
        # -------------------------------------------------
        # Therefore, all that is needed to handle these edge cases is to check, for every path contained in the current collection, if the callback `child.partialPathName()` is contained in the collection's string sets.
        # This is equivalent to checking if a file has been moved by checking if one of its parent folder has been moved. If yes:
        # change the current collection string path to newpath = callback's `parent.FullPath` + oldPath_minus_the_prefix_before_child.partialPathName()
        # i.e. newPath = ParentDirectoryFullPath/oldPathStartingFromChildFolder/.../lightItem
        # -------------------------------------------------
        # Time Complexity-wise, this can be done in O(n) with Python's built-in Knuth-Morris-Pratt, n being the number of elements in the collection's list.
        # This could be done a bit faster if collections use a Trie datastructure instead of a list, but the difference in performance is minimal and it should not bottleneck performance.
        '''
        Here's some concrete examples:

        Say that the light collection currently have two lights with paths:
        - group1/light1/lightpoint1
        - group1/light2/lightpoint2
        And the Outliner has two existing groups in it: group1, group2 (without any children)

        An example of scenario 1) from above would be: Starting from the initial conditions above, we Drag light1/lightpoint1 and drop it into group2, then onNodeReparented will receive this
            callback 'parent'= group2
            callback 'child' = light1

            old light path:  group1/light1/lightpoint1 -> new light path: group2/light1/lightpoint1

        An example of scenario 2) from above would be: Starting from the initial conditions above, we select group1 in Outliner and click "ctrl + g"
            if click ctlr+g once:
            callback 'parent'= group3 (newly created group from ctrl+g)
            callback 'child' = group1

            old light path 1:  group1/light1/lightpoint1 -> new light path 1: group3/group1/light1/lightpoint1
            old light path 2:  group1/light2/lightpoint2 -> new light path 1: group3/group1/light2/lightpoint2


            if click ctrl+g twice:
            callback 'parent'= group4 (newly created group from ctrl+g)
            callback 'child' = group3 (created by the first ctrl+g)

            old light path 1:  group3/group1/light1/lightpoint1 -> new light path 1: group4/group3/group1/light1/lightpoint1
            old light path 2:  group3/group1/light2/lightpoint2 -> new light path 1: group4/group3/group1/light2/lightpoint2

            So one and so forth for each ctrl+g statements.

        An example of scenario 3) from above would be: Starting from the initial conditions above, we drag group1 in the Outliner and drop it into group2
            This time, the item isn't being reparented like in 1), but one of its ancestor is
            callback 'parent'= group2
            callback 'child' = group1

            old light path 1:  group1/light1/lightpoint1 -> new light path 1: group2/group1/light1/lightpoint1
            old light path 2:  group1/light2/lightpoint2 -> new light path 1: group2/group1/light2/lightpoint2

        An example of sceneario 4) from above would be: Starting with these initial conditions:
            An imported Collection contains two lights:
            - group1/light1/lightpoint1 -> Is currently 'Missing'
            - group1/light2/lightpoint2 -> object exists
            And the Outliner has two existing groups in it: group1, group2 (without any children)
            Attempting to apply scenario 2) and 3) should only update the path of light2/lightpoint2.
            Since light1/lightpoint1 does not currently exists in the scene, its path should not be updated when group1's reparented

        The code handles each case in the same way:

        For each lightpath in the current collection list:
            is 'child' in the current lightpath?
                If yes-> one of the ancestor of the light has just been moved, so we need to update the path-> return parent.fullpath + | + child + | + currentLightPath.split(child)[1] if said path's light exists, else light is missing (scenario 4)-> do not update.
                If not-> the current child is not an ancestor of the light-> no need to update the path-> return original path
        '''

        obj = commonUtils.nameToNode(str(parent))
        if obj and obj.hasFn(OpenMaya.MFn.kDagNode):
            parentFullPathName = commonUtils.nodeToLongName(obj)
            childPartialPathName = str(child.partialPathName())
            newlist = list(self.staticSelection.asList())
            newlist = [path if childPartialPathName not in path or not cmds.objExists(str(parentFullPathName) + "|" + childPartialPathName + path.split(childPartialPathName)[1]) else str(parentFullPathName) + "|" + childPartialPathName + path.split(childPartialPathName)[1] for path in newlist]
            self.staticSelection._setList(newlist)
        self.selectionChanged()

class BasicSelector(SimpleSelector):

    kTypeId = typeIDs.basicSelector
    kTypeName = 'basicSelector'

    aIncludeHierarchy = OpenMaya.MObject()

    # 2016 May 24, this is used only for backward compatibility in the tests
    # basic selector are no longer supported in Maya 2017 => they should gather no nodes
    # they need to be converted in Maya 2017 (see conversion.py)
    # use force compute = true in the tests until we translate them all to use the new selectors
    kForceCompute = False

    @classmethod
    def getDefaultFilter(cls):
        return Filters.kAll

    @classmethod
    def getAvailableFilters(cls):
        return list(Filters._allTypes) + [Filters.kTransformsAndShapes, Filters.kTransformsShapesShaders]

    @classmethod
    def initializer(cls):
        cls.inheritAttributesFrom(SimpleSelector.kTypeName)

        attr = OpenMaya.MFnNumericAttribute()
        cls.aIncludeHierarchy = cls.createInput(attr, ("includeHierarchy", "ih", OpenMaya.MFnNumericData.kBoolean, True))
        cls.addAttribute(cls.aIncludeHierarchy)
        cls.affectsOutput(cls.aIncludeHierarchy)

    def isAbstractClass(self):
        return False

    def status(self):
        from maya.app.renderSetup.model.conversion import kIssueShortDescription
        return super(BasicSelector, self).status() if self.kForceCompute else kIssueShortDescription

    @Selector.synced
    def shapes(self):
        paths = [_f for _f in (DagPath.create(name) for name in self._cache) if _f]
        return (p for p in paths if p.node().hasFn(OpenMaya.MFn.kShape))

    @staticmethod
    def _findHierarchy(names):
        # get dag paths + dag hierarchy
        def addRelatives(selection, parent):
            selection.update(cmds.listRelatives(parent, allDescendents=True, fullPath=True) or ())
            return selection
        parents   = set(name for name in names if name.startswith('|'))
        children = reduce(addRelatives, parents, set())
        dagPaths = [DagPath.create(name) for name in set(parents)|set(children)]
        # find shading nodes from dag paths
        engines = list(ShadingEngineStrategy._findShadingEngines(dagPaths))
        shadingNodes = algorithm.traverse(
            itertools.chain(
                ShadingStrategy._findSurfaceShaders(engines),
                ShadingStrategy._findDisplacementShaders(engines),
                ShadingStrategy._findVolumeShaders(engines)),
            predicate=utils.isShadingNode)
        # find generators from dag paths
        generators = GeneratorStrategy._findGeometryGenerators(dagPaths)
        objs = itertools.chain(engines, shadingNodes, generators)
        return itertools.chain(children, (OpenMaya.MFnDependencyNode(o).name() for o in objs))

    def _update(self, dataBlock):
        if not self.kForceCompute:
            self._cache = self._staticCache = self._dynamicCache = set()
            return
        self.staticSelection.setCache(dataBlock.inputValue(self.aStaticSelection).asString())
        self._staticCache = set(filter(cmds.objExists, self.staticSelection.asList()))
        self._dynamicCache = ls(self.patterns())

        if dataBlock.inputValue(self.aIncludeHierarchy).asBool():
            self._staticCache.update(BasicSelector._findHierarchy(self._staticCache))
            self._dynamicCache.update(BasicSelector._findHierarchy(self._dynamicCache))

        # must do post filtering because of include hierarchy
        # with basic selector, static selection is also filtered...
        types = self.getTypeFilters(dataBlock)
        if len(types) > 0:
            filterFunction = createTypeFilter(types)
            self._staticCache = set(filter(filterFunction, self._staticCache))
            self._dynamicCache = set(filter(filterFunction, self._dynamicCache))

        parent = self.parent()
        if parent:
            self._staticCache.intersection_update(parent.names())
            self._dynamicCache.intersection_update(parent.names())

        self._cache = self._staticCache | self._dynamicCache

    def getIncludeHierarchy(self):
        return OpenMaya.MPlug(self.thisMObject(), self.aIncludeHierarchy).asBool()

    def setIncludeHierarchy(self,val):
        cmds.setAttr(self.name()+".includeHierarchy", val)

    def _encodeProperties(self, dict):
        super(BasicSelector, self)._encodeProperties(dict)
        encoders = [(self.aIncludeHierarchy,  self.getIncludeHierarchy)]
        for attr, encode in encoders:
            dict[OpenMaya.MPlug(self.thisMObject(), attr).partialName(useLongNames=True)] = encode()

    def _decodeProperties(self, dict):
        super(BasicSelector, self)._decodeProperties(dict)
        decoders = [(self.aIncludeHierarchy,  self.setIncludeHierarchy)]
        for attr, decode in decoders:
            name = OpenMaya.MPlug(self.thisMObject(), attr).partialName(useLongNames=True)
            if name in dict:
                decode(dict[name])

    def onNodeAdded(self, **kwargs):
        super(BasicSelector, self).onNodeAdded(**kwargs)
        if not self.isDirty() and self.getIncludeHierarchy():
            self.selectionChanged()

    def onNodeRemoved(self, **kwargs):
        super(BasicSelector, self).onNodeRemoved(**kwargs)
        if not self.isDirty() and self.getIncludeHierarchy():
            self.selectionChanged()

    def onNodeRenamed(self, **kwargs):
        super(BasicSelector, self).onNodeRenamed(**kwargs)
        if not self.isDirty() and self.getIncludeHierarchy():
            self.selectionChanged()

    def onNodeReparented(self, **kwargs):
        super(BasicSelector, self).onNodeReparented(**kwargs)
        if not self.isDirty() and self.getIncludeHierarchy():
            self.selectionChanged()

    def onConnectionChanged(self, **kwargs):
        if self.getIncludeHierarchy():
            self.selectionChanged()


def create(name, typeid):
    fn = OpenMaya.MFnDependencyNode()
    fn.create(typeid, name)
    return fn.userNode()
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
