import maya
maya.utils.loadStringResourcesForModule(__name__)

import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya

import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.model.applyOverride as applyOverride
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.common.guard as guard

import maya.app.renderSetup.lightEditor.model.editor as editorModel
import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
import maya.app.renderSetup.lightEditor.model.item as itemModel
import maya.app.renderSetup.lightEditor.model.update as update

kLightHasNoVisibilityAttribute = maya.stringTable['y_maya_app_renderSetup_lightEditor_model_light.kLightHasNoVisibilityAttributeStr' ]
kVisibilityConnectionExists = maya.stringTable['y_maya_app_renderSetup_lightEditor_model_light.kVisibilityConnectionExistsStr' ]

class LightItem(itemModel.LightItemBase):
    """  Light editor item for light sources """

    kTypeId = typeIDs.lightItem
    kTypeName = "lightItem"

    # Attributes
    light = OpenMaya.MObject()

    @classmethod
    def creator(cls):
        return cls()

    @staticmethod
    def initializer():
        LightItem.inheritAttributesFrom(itemModel.LightItemBase.kTypeName)

        LightItem.light = utils.createDstMsgAttr('light', 'lgt')
        LightItem.addAttribute(LightItem.light)

    def __init__(self):
        super(LightItem, self).__init__()
        self._trackVisibility = True
        self._lightCallbackIds = []

        # Some changes might need a UI rebuild,
        # to update the UI properly. If so set this
        # flag to True during the call to itemChanged()
        self.needUIRebuildWhenChanged = False

    def dispose(self, deleteLight):
        # Remove all callbacks that have been registered
        OpenMaya.MMessage.removeCallbacks(self._lightCallbackIds)
        self._lightCallbackIds = []

        # Remove the light node if requested
        if deleteLight:
            xform = self.getLightTransform()
            if xform:
                cmds.delete(OpenMaya.MFnDagNode(xform).fullPathName())

        super(LightItem, self).dispose(deleteLight)

    def isAbstractClass(self):
        return False

    def _onLightShapePreRemovalCB(self, obj, clientData):
        if editorModel.hasInstance():
            # Find the corresponding item and delete it
            item = editorModel.LightEditor.findEditorItem(obj)
            if item:
                itemModel.deleteItem(item, deleteLight=False)

    def _onLightNameChangedCB(self, obj, oldName, clientData):
        # Rename the item according to the new light name
        newName = itemModel.getLightItemName(obj)
        dgMod = OpenMaya.MDGModifier()
        dgMod.renameNode(self.thisMObject(), newName)
        dgMod.doIt()
        longName = self.getLightName(fullPath= True)
        # Check if new name matches an imported group's missing item and move it accordingly
        # Note that the long name must match. Simply changing shortname to match missing item will not always trigger the if statements since the order of creation matters
        importedParent = editorModel.LightEditorImportExportHelper.getImportedParent(longName)
        if importedParent:
            oldParent = self.parent()
            oldParent.detachChild(self)
            importedParent.appendChild(self)
            # The following pop does not support undo/redo by design. Pop is permanent. 
            # i.e. if an user adds a missing light into an imported group and then undo the added light, the group will no longer consider said light to be missing in the future
            # Reason for design: it is too time consumming to implement our own doIt()/undoIt() fnc with MDGModifier just to keep track of light addition when the user can simply re-import from json again
            # This is similar to collections in render setup, which does not fully support undo/redo.
            editorModel.LightEditorImportExportHelper.missingLightToParent.pop(longName, None)
        self.itemChanged()

    def _onLightAttrChangedCB(self, msg, plg, otherPlug, clientData):
        if msg & OpenMaya.MNodeMessage.kConnectionMade or msg & OpenMaya.MNodeMessage.kConnectionBroken:
            # For connection changes we need to requild the UI,
            # in case this was a connection to a relative override.
            with guard.MemberGuardCtx(self, 'needUIRebuildWhenChanged', True):
                self.itemChanged()
        else:
            # Non-connection change so just update the item
            # without a UI rebuild.
            self.itemChanged()

    def _getLightPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), LightItem.light)

    def _onDirtyCB(self, nodeObj, plug, data):
        # Needed to update the UI when override values are changed in render setup
        update.requestRefresh(refreshType = update.kRefreshUI)

    def registerCallbacks(self, lightShapeObj):
        # Add the callbacks if they have not been added for this light shape already
        if len(self._lightCallbackIds) == 0 or lightShapeObj != self.getLightShape():
            OpenMaya.MMessage.removeCallbacks(self._lightCallbackIds)
            self._lightCallbackIds = []
            self._lightCallbackIds.append(OpenMaya.MNodeMessage.addNodePreRemovalCallback(lightShapeObj, self._onLightShapePreRemovalCB))
            self._lightCallbackIds.append(OpenMaya.MNodeMessage.addNameChangedCallback(lightShapeObj, self._onLightNameChangedCB))
            self._lightCallbackIds.append(OpenMaya.MNodeMessage.addAttributeChangedCallback(lightShapeObj, self._onLightAttrChangedCB))
            self._lightCallbackIds.append(OpenMaya.MNodeMessage.addNodeDirtyPlugCallback(lightShapeObj, self._onDirtyCB))

    def unregisterCallbacks(self):
        OpenMaya.MMessage.removeCallbacks(self._lightCallbackIds)
        self._lightCallbackIds = []

    def setLightShape(self, lightShapeObj):
        lightsPlug = self._getLightPlug()
        enabledPlug = self._getEnabledPlug()
        if lightShapeObj is None:
            # Disconnect an existing light shape.
            # Make sure there is a connection first, to handle the case of
            # clearing out an already cleared light item.
            if lightsPlug.isDestination:
                dgMod = OpenMaya.MDGModifier()
                lightNode = lightsPlug.source().node()
                # Disconnect the enabled plug
                for dst in enabledPlug.destinations():
                    if dst.node() == lightNode:
                        dgMod.disconnect(enabledPlug, dst)
                        break
                # Disonnect the light plug
                dgMod.disconnect(lightsPlug.source(), lightsPlug)
                dgMod.doIt()
        else:
            dgMod = OpenMaya.MDGModifier()
            # Connect the light shape's message.
            msgPlug = plug.findPlug(lightShapeObj, 'message')
            if msgPlug and not cmds.isConnected(msgPlug.name, lightsPlug.name()):
                dgMod.connect(msgPlug.plug, lightsPlug)

            # Connect the light shape's visibility.
            # But make sure the attribute exists and is not already connected.
            visPlug = plug.findPlug(lightShapeObj, 'visibility')
            if visPlug:
                if visPlug.plug.isDestination:
                    if not cmds.isConnected(enabledPlug.name(), visPlug.name):
                        # Already connected to something else. Light Editor visibility
                        # will not be functional so display a warning about this.
                        cmds.warning(kVisibilityConnectionExists % visPlug.name)
                else:
                    dgMod.connect(enabledPlug, visPlug.plug)
            else:
                # Visibility attribute doesn't exists on the node. Light Editor visibility
                # will not be functional so display a warning about this.
                cmds.warning(kLightHasNoVisibilityAttribute % OpenMaya.MFnDependencyNode(lightShapeObj).name())
            dgMod.doIt()
            # Add callbacks on the light shape
            self.registerCallbacks(lightShapeObj)

    def getLightShape(self):
        plg = self._getLightPlug()
        src = plg.source()
        return None if src.isNull else src.node()

    def linkedVisibility(self):
        # Make sure we have a light connected and check
        # if the enabled plug is connected to the light.
        lightsPlug = self._getLightPlug()
        if lightsPlug.isDestination:
            lightNode = lightsPlug.source().node()
            enabledPlug = self._getEnabledPlug()
            for dst in enabledPlug.destinations():
                if dst.node() == lightNode:
                    return True
        return False

    def getLightTransform(self):
        shape = self.getLightShape()
        return typeMgr.findLightTransformObject(shape)

    def getLightName(self, fullPath = False):
        shape = self.getLightShape()
        if shape:
            return OpenMaya.MFnDagNode(shape).fullPathName() if fullPath else OpenMaya.MFnDagNode(shape).name()
        return None

    def getLightTransformName(self, fullPath = False):
        trans = self.getLightTransform()
        if trans:
            return OpenMaya.MFnDagNode(trans).fullPathName() if fullPath else OpenMaya.MFnDagNode(trans).name()
        return None

    def getLightType(self):
        shape = self.getLightShape()
        return cmds.nodeType(OpenMaya.MFnDagNode(shape).fullPathName()) if shape else 'unknown'

    def rename(self, newName):
        oldName = self.getLightName()
        # Get light name will return None if no light source is
        # connected to this item. So make sure we have a valid
        # oldName before trying to change it.
        if oldName and newName != oldName:
            cmds.rename(self.getLightName(True), newName)

    def isAcceptableChild(self, model):
        """ Check if the model could be a child """
        return False

    def getAttrName(self, index):
        lightType = self.getLightType()
        if lightType and index < len(list(typeMgr.getAllAttributes().items())):
            attrLabel, _ = list(typeMgr.getAllAttributes().items())[index]
            attributes = typeMgr.getAttributesForLightType(lightType)
            if attrLabel in attributes:
                return attributes[attrLabel]
        return None

    def getAttrPlug(self, index):
        attrName = self.getAttrName(index)
        if attrName:
            shape = self.getLightShape()
            return plug.findPlug(shape, attrName)
        return None

    def getAttrValue(self, index):
        plg = self.getAttrPlug(index)
        return plg.uiUnitValue if plg else None

    def getTransformPlug(self, attrName):
        transform = self.getLightTransform()
        if attrName and transform:
            return plug.findPlug(transform, attrName)
        return None

    def getShapePlug(self, attrName):
        shape = self.getLightShape()
        if attrName and shape:
            return plug.findPlug(shape, attrName)
        return None

    def isConnected(self, index):
        plg = self.getAttrPlug(index)
        if plg is None or not plg.plug.isDestination:
            return False

        # Check if the connection is an override
        source = plg.plug.source()
        fn = OpenMaya.MFnDependencyNode(source.node())
        return not isinstance(fn.userNode(), applyOverride.ApplyOverride)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
