"""Collection node class and utility functions.

   This module provides the collection class, as well as utility
   functions to operate on collections.

   The collection owns its associated selector node: on collection
   delete, the collection is deleted as well.

   Conceptually, a collection fulfills four roles in render setup:

   1) It is a container of overrides.  If enabled, the collection will
      apply all its enabled overrides on nodes it selects (see (2)).
   2) It selects nodes onto which overrides will be applied.  These nodes
      can be DAG or DG nodes.
   3) It is a container of child collections.  Child collections always
      select nodes based on their parent's selected nodes (see (2)).
   4) It defines render layer membership.  Members of a render layer can
      only be DAG nodes.  These are always a subset of the nodes selected
      by the collection (see (2)).  The members of the render layer are the
      union of the top-level collection members; children collections can
      exclude or re-include members.  See RenderLayer.getMembers for more
      details (including the effect of isolate select mode).

   The application of overrides only obeys enabled / disabled status.

   Render layer membership is determined from enabled / disabled, in
   conjunction with isolate select."""
import maya
maya.utils.loadStringResourcesForModule(__name__)


import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya

import maya.app.renderSetup.model.nodeList as nodeList
import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.model.selector as selector
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.model.override as override
import maya.app.renderSetup.model.overrideUtils as overrideUtils
import maya.app.renderSetup.model.enabled as computeEnabled
import maya.app.renderSetup.model.rendererCallbacks as rendererCallbacks
import maya.app.renderSetup.model.clipboardData as clipboardData

import maya.app.renderSetup.common.utils as commonUtils
import maya.app.renderSetup.model.jsonTranslatorUtils as jsonTranslatorUtils
import maya.app.renderSetup.model.jsonTranslatorGlobals as jsonTranslatorGlobals

import maya.app.renderSetup.model.container as container

# List all error messages below
kOverrideCreationFailed    = maya.stringTable['y_maya_app_renderSetup_model_collection.kOverrideCreationFailed'    ]
kCollectionMissingSelector = maya.stringTable['y_maya_app_renderSetup_model_collection.kCollectionMissingSelector' ]
kIncorrectChildType        = maya.stringTable['y_maya_app_renderSetup_model_collection.kIncorrectChildType'        ]

# List of undo messages
kChildAttached = maya.stringTable['y_maya_app_renderSetup_model_collection.kChildAttached' ]

class Collection(container.Container):
    """
    Collection node.

    A collection has an ordered list of children, and a selector to
    determine nodes to which the children apply.

    MAYA-59277:
      - When we start implementing proper hierarchical collections we
        need to decide on the relationship between parent and child
        selectors. Do we always consider a parent collection to be the
        union of its child collections, and propagate the selector
        information upwards when a child collection is added or changed?
        Or do we go the opposite direction and restrict the child collection
        to use the intersection between its selector and its parent's selector?

      - Light child collections always have a single light source member.
        We should utilize this and create a specific selector for such
        use cases for better performance.

    """

    kTypeId = typeIDs.collection
    kTypeName = container.Container.kCollectionTypeName

    # Attribute for message connection to selector node associated with the
    # collection. This attribute is a destination, as only one selector
    # can be associated with each collection.
    aSelector = OpenMaya.MObject()

    # the SimpleSelector is the default.
    kDefaultSelectorTypeName = selector.SimpleSelector.kTypeName

    @staticmethod
    def creator():
        return Collection()

    @staticmethod
    def initializer():
        Collection.inheritAttributesFrom(container.Container.kTypeName)
        Collection.aSelector = utils.createDstMsgAttr('selector', 'sel')
        Collection.addAttribute(Collection.aSelector)

    def isCollection(self):
        return True

    def typeId(self):
        return Collection.kTypeId

    def typeName(self):
        return Collection.kTypeName

    def _createSelector(self, parent=None, selArgs=None):
        """Create a selector node, and attach it to the collection.

        parent is an optional parent collection.  This method must be
        overridden by derived classes."""

        self.setSelectorType(parent.getSelector().kTypeName if parent and parent.getSelector() else \
                             self.kDefaultSelectorTypeName)

        if parent and parent.getSelector():
            self.getSelector().minimalClone(parent.getSelector())

    def _createAndConnectSelector(self, typeName, selArgs=None):
        """Engine method for _createSelector.

        selArgs is an optional dictionary passed to _createSelectorNode."""

        newSelector = self._createSelectorNode(
            typeName, self.name()+'Selector', selArgs)
        cmds.connectAttr(newSelector + '.c', self.name() + '.selector')

    def _createSelectorNode(self, typeName, selectorName, selArgs):
        """Create the selector node.

        Can be overridden by derived classes."""
        return cmds.createNode(typeName, name=selectorName, skipSelect=True)

    def getSelectorType(self):
        try: return self.getSelector().kTypeName
        except: return None

    def setSelectorType(self, typeName):
        '''Sets the selector type of this collection.'''

        if self.getSelectorType() == typeName:
            return
        with undo.NotifyCtxMgr("Set selector type", self._selectorChanged):
            children = [child for child in self.getChildren() if isinstance(child, Collection)]
            # need to disconnect all selector children
            # otherwise they get deleted along with their parent selector
            for child in children:
                child.getSelector().setParent(None)

            try: self._deleteSelector()
            except: pass

            self._createAndConnectSelector(typeName)
            parent = self.parent()
            selector = self.getSelector()
            if isinstance(parent, Collection):
                selector.setParent(parent.getSelector())
            for child in children:
                child.getSelector().setParent(selector)

    def _deleteSelector(self):
        # Because of unloaded or missing plugin, selector might be unknown node,
        # in which case getSelector() will raise.
        selectorName = utils.getSrcNodeName(
            utils.findPlug(self, Collection.aSelector))

        cmds.disconnectAttr(selectorName + '.c', self.name() + '.selector')
        utils.deleteNode(selectorName)

    def _findSubcollectionForType(self, typeName):
        '''Finds the subcollection of this collection that will handle that typeName
           or creates it and returns it if it doesn't exist.'''

        if self.getSelector().getFilterType() == selector.Filters.kSets and \
                typeName != 'transform':
            xformCol = self._findSubcollectionForType('transform')
            return xformCol._findSubcollectionForType(typeName)

        filterType, customFilter = selector.Filters.getFiltersFor(typeName)

        def predicate(child):
            if not isinstance(child, Collection):
                return False
            sel = child.getSelector()
            return sel.kTypeName == selector.SimpleSelector.kTypeName and \
                   sel.getPattern() == "*" and \
                   len(sel.staticSelection) == 0 and \
                   sel.getFilterType() == filterType and \
                   (filterType != selector.Filters.kCustom or sel.getCustomFilterValue() == customFilter)

        def creator():
            name = self.name() + "_" + selector.Filters.names.get(filterType, customFilter)
            col = create(name)
            col.setSelectorType(selector.SimpleSelector.kTypeName)
            sel = col.getSelector()
            sel.setPattern('*')
            sel.setFilterType(filterType)
            sel.setCustomFilterValue(customFilter)
            return col

        return self.findChild(predicate, creator)

    @undo.chunk('Create and append an override')
    def createOverride(self, overrideName, overrideType):
        """ Add an override to the Collection using its node type id or type name."""
        # Note: No need to propagate the change notification
        #       as an empty override does not affect the collection
        over = override.create(overrideName, overrideType)
        if not over:
            raise Exception(kOverrideCreationFailed % overrideName)

        def selectorHasSetsFilter():
            return self.getSelector().getFilterType() == selector.Filters.kSets

        col = self
        if over.typeId() == typeIDs.shaderOverride:
            # special handle for shader override as they apply to shading
            # engines => create subcollection of shading engines
            if selectorHasSetsFilter() or not self.getSelector().acceptsType('shadingEngine'):
                col = self._findSubcollectionForType('shadingEngine')
        elif over.typeId() == typeIDs.materialOverride or over.typeId() == typeIDs.materialTemplateOverride:
            # special handle for material override as they apply to dag nodes
            # when selector is filter on sets.
            if selectorHasSetsFilter():
                col = self._findSubcollectionForType('transform')
        col.appendChild(over)
        return over

    def _getOverrideType(self, plg, overrideType):
        '''Returns the override type that should be created for the given
        plg in the given collection (self). Overrides that can't be relative will become absolute.'''
        if overrideType == typeIDs.connectionOverride:
            return overrideType
        return plg.overrideType(overrideType)

    @undo.chunk('Create and append an override')
    def _createOverride(self, plg, overrideType):
        over = override.create(plg.attributeName, self._getOverrideType(plg, overrideType))
        if not over:
            raise Exception(kOverrideCreationFailed % plg.attributeName)
        over.finalize(plg.name)
        typeName = OpenMaya.MFnDependencyNode(plg.node()).typeName
        collection = self if self.getSelector().acceptsType(typeName) else \
            self._findSubcollectionForType(typeName)
        collection.appendChild(over)
        return over

    @undo.chunk('Create and append an absolute override')
    def createAbsoluteOverride(self, nodeName, attrName):
        """ Add an absolute override to a collection """
        return self._createOverride(plug.Plug(nodeName,attrName), typeIDs.absOverride)

    @undo.chunk('Create and append a relative override')
    def createRelativeOverride(self, nodeName, attrName):
        """ Add a relative override to a collection """
        return self._createOverride(plug.Plug(nodeName,attrName), typeIDs.relOverride)

    @undo.chunk('Create and append a connection override')
    def createConnectionOverride(self, nodeName, attrName):
        """ Add a connection override to a collection """
        return self._createOverride(plug.Plug(nodeName,attrName), typeIDs.connectionOverride)

    def getCollectionByName(self, collectionName, nested=False):
        for collection in nodeList.forwardListNodeClassGenerator(self, cls=Collection):
            if collection.name() == collectionName:
                return collection
            elif nested:
                collection2 = collection.getCollectionByName(collectionName, True)
                if collection2:
                    return collection2
        return None

    @undo.chunk('Append to collection')
    def appendChild(self, child):
        """ Add a child as the highest-priority child."""

        if child.typeId()==RenderSettingsCollection.kTypeId \
            or child.typeId()==LightsCollection.kTypeId:
            raise RuntimeError(kIncorrectChildType % child.typeName())

        nodeList.append(self, child)

        self._childAttached(child)


    @undo.chunk('Attach to collection')
    def attachChild(self, pos, child):
        """ Attach a child at a specific position. """

        if child.typeId()==RenderSettingsCollection.kTypeId \
            or child.typeId()==LightsCollection.kTypeId:
            raise RuntimeError(kIncorrectChildType % child.typeName())

        nodeList.insert(self, pos, child)
        self._childAttached(child)

    def getCollections(self):
        return self.getChildren(cls=Collection)

    def isAbstractClass(self):
        # Override method inherited from base class: not an abstract class.
        return False

    def getSelector(self):
        """Return the selector user node for this collection.

        If there is no selector node, or if the selector node does not
        have an MPxNode interface (e.g. an unknown node), an exception
        of type Exception is raised.
        """
        selector = utils.getSrcUserNode(
            utils.findPlug(self, Collection.aSelector))
        if (selector is None):
            raise Exception(kCollectionMissingSelector % self.name())
        return selector

    def hasSelector(self):
        return True

    def hasApplyOverridesRecursive(self):
        # Check if the collection or any of its subcollections
        # have any apply overrides at all.
        for ovr in utils.getOverridesRecursive(self):
            if ovr.hasApplyOverrides():
                return True
        return False

    def getOverrides(self):
        return self.getChildren(cls=override.Override)

    def _encodeProperties(self, dict):
        super(Collection, self)._encodeProperties(dict)
        dict[self._getSelfEnabledPlug().partialName(useLongNames=True)] = self.isSelfEnabled()
        dict[self._getIsolatePlug().partialName(useLongNames=True)] = self.isIsolateSelected()

        if self.getSelectorType() == selector.BasicSelector.kTypeName: # backward comp with 2016 R2
            selectorDict = dict
        else:
            selectorDict = {}
            dict[jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME] = { self.getSelectorType() : selectorDict }
        self.getSelector()._encodeProperties(selectorDict)

        dict[jsonTranslatorGlobals.CHILDREN_ATTRIBUTE_NAME] = jsonTranslatorUtils.encodeObjectArray(self.getChildren())

    def _decodeProperties(self, dict, mergeType, prependToName):
        super(Collection, self)._decodeProperties(dict, mergeType, prependToName)

        oldStaticSelectionList = [] if not hasattr(self.getSelector(), 'staticSelection') else self.getSelector().staticSelection.asList()

        if self._getSelfEnabledPlug().partialName(useLongNames=True) in dict:
            self.setSelfEnabled(dict[self._getSelfEnabledPlug().partialName(useLongNames=True)])

        if self._getIsolatePlug().partialName(useLongNames=True) in dict:
            self.setIsolateSelected(dict[self._getIsolatePlug().partialName(useLongNames=True)])

        if jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME not in dict: # backward comp with 2016 R2
            self.setSelectorType(selector.BasicSelector.kTypeName)
            selectorProperties = dict
        else:
            selectorType = list(dict[jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME].keys())[0]
            if self.getSelectorType() != selectorType:
                self.setSelectorType(selectorType)
            selectorProperties = list(dict[jsonTranslatorGlobals.SELECTOR_ATTRIBUTE_NAME].values())[0]
        self.getSelector()._decodeProperties(selectorProperties)

        if jsonTranslatorGlobals.CHILDREN_ATTRIBUTE_NAME in dict:
            self._decodeChildren(dict[jsonTranslatorGlobals.CHILDREN_ATTRIBUTE_NAME],
                                 mergeType,
                                 prependToName)
        # Collection will merge previous static selection list with the new imported selection list if mergeType != overwrite
        if mergeType != jsonTranslatorGlobals.DECODE_AND_ADD and hasattr(self.getSelector(), 'staticSelection'):
            newStaticSelectionList = self.getSelector().staticSelection.asList()
            newStaticSelectionSet = set(newStaticSelectionList)
            for item in oldStaticSelectionList:
                if item not in newStaticSelectionSet:
                    newStaticSelectionList.append(item)
            self.getSelector().staticSelection._setList(newStaticSelectionList)

class LightsCollection(Collection):
    """
    LightsCollection node.

    A collection node specific for grouping light sources
    and overrides on those light sources.

    This collection should have all light sources as member by default. All nodes
    matching the light classification should be returned by the selector
    on this collection.

    """

    kTypeId = typeIDs.lightsCollection
    kTypeName = 'lightsCollection'

    @staticmethod
    def creator():
        return LightsCollection()

    @staticmethod
    def initializer():
        # Inherit all attributes from parent class
        LightsCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(LightsCollection, self).__init__()

    def typeId(self):
        return LightsCollection.kTypeId

    def typeName(self):
        return LightsCollection.kTypeName

    @staticmethod
    def containsNodeName(nodeName):
        import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
        node = commonUtils.nameToNode(nodeName)
        # TODO: For improved separation of concerns, we should untangle the light editor data model
        # and the render setup data model at some point. Logged as MAYA-84151.
        return ((typeMgr.isLight(node) or typeMgr.isValidLightTransformObject(node) or typeMgr.isLightEditorItem(node)) if node else False)

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(selector.LightsCollectionSelector.kTypeName)

        self.getSelector().setFilterType(selector.Filters.kLights)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def createCollection(self, collectionName):
        """ Add a lights child collection to the Collection. """
        return super(LightsCollection, self).createCollection(collectionName, LightsChildCollection.kTypeName)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection.

           We want to prevent copying LightsChildCollections in the same
           LightsCollection at the expense of not being able to copy
           LightsChildCollections between different LightsCollections.
        """
        return False

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

class LightsChildCollection(Collection):
    """
        LightsChildCollection node.

        A child collection node specific for one single light source
        and overrides on this light source.

    """

    kTypeId = typeIDs.lightsChildCollection
    kTypeName = 'lightsChildCollection'

    @staticmethod
    def creator():
        return LightsChildCollection()

    @staticmethod
    def initializer():
        # Inherit all attributes from parent class
        LightsChildCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(LightsChildCollection, self).__init__()

    def typeId(self):
        return LightsChildCollection.kTypeId

    def typeName(self):
        return LightsChildCollection.kTypeName

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(selector.LightsCollectionSelector.kTypeName)

        # Only accepts light sources.
        self.getSelector().setFilterType(selector.Filters.kLightsAndTransforms)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection.

           Pasting is prevented because the Light Editor considers only the
           first override in the LightsChildCollection. Additionally dragging
           is prevented between overrides in LightsChildCollections to prevent
           dragging between incompatible LightsChildCollection types
           (ie. point light, spot light)
        """
        return False


class RenderSettingsCollection(Collection):
    """
    Render Settings Collection node.

    This collection has an ordered list of children, and a static & const selector
    to determine nodes to which the children apply. The list of nodes is based
    on the selected renderer at the time of creation.

    MAYA-66757:
    - A base collection will be needed to factorize commonalities and segregate differences.
    - A static selector is needed which could be the existing static selection or an object set.
    - The name is read-only.
    - The selector content is read-only
    - The render name should be part of the collection so that the settings are clearly linked
      to the used renderer, or linked using a plug

    """

    kTypeId = typeIDs.renderSettingsCollection
    kTypeName = 'renderSettingsCollection'

    # Type of selector created by this collection
    kSelectorTypeName = selector.SimpleSelector.kTypeName

    # The number of isolate selected children in a Render Settings Collection
    numIsolatedRenderSettingsChildren = OpenMaya.MObject()

    @staticmethod
    def creator():
        return RenderSettingsCollection()

    @staticmethod
    def initializer():
        # A render settings collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other attributes.
        RenderSettingsCollection.inheritAttributesFrom(Collection.kTypeName)

        # Setup our attribute for keeping track of the number of isolated render settings children
        RenderSettingsCollection.numIsolatedRenderSettingsChildren = computeEnabled.createHiddenIntAttribute("numIsolatedRenderSettingsChildren", "nrc")
        RenderSettingsCollection.addAttribute(RenderSettingsCollection.numIsolatedRenderSettingsChildren)

    def __init__(self):
        super(RenderSettingsCollection, self).__init__()

    @staticmethod
    def containsNodeName(nodeName):
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        return nodeName in renderSettings.getDefaultNodes()

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(self.kSelectorTypeName)

        # Set the default nodes as static selection
        # Note: Some renderers could return nodes which do not exist yet.
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        self.getSelector().staticSelection.setWithoutExistenceCheck(renderSettings.getDefaultNodes())
        self.getSelector().setFilterType(selector.Filters.kAll)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def typeId(self):
        return RenderSettingsCollection.kTypeId

    def typeName(self):
        return RenderSettingsCollection.kTypeName

    def appendChild(self, child):
        if not isinstance(child, RenderSettingsChildCollection) and isinstance(child, Collection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsCollection, self).appendChild(child)

    def attachChild(self, pos, child):
        if isinstance(child, Collection) and not isinstance(child, RenderSettingsChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsCollection, self).attachChild(pos, child)

    def createCollection(self, collectionName):
        """ Add a child collection to the Collection. """
        return super(RenderSettingsCollection, self).createCollection(collectionName, RenderSettingsChildCollection.kTypeName)

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection."""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            isOverride = modelOrData.typeName() in _overrideTypes
            parentTypeName = modelOrData.parentTypeName
        else:
            isOverride = isinstance(modelOrData, override.Override)
            parentTypeName = modelOrData.parent().typeName()

        return modelOrData.typeName() == RenderSettingsChildCollection.kTypeName or \
            modelOrData.typeName() not in _specialCollectionTypes and \
            (isOverride and parentTypeName in [RenderSettingsCollection.kTypeName, RenderSettingsChildCollection.kTypeName]) or \
            (modelOrData.typeName() == self.typeName() and self.isSelfAcceptableChild() and self.typeName() != RenderSettingsCollection.kTypeName)


    def _getOverrideType(self, plg, overrideType):
        overrideType = super(RenderSettingsCollection, self)._getOverrideType(plg, overrideType)
        return {  typeIDs.absOverride.id() : typeIDs.absUniqueOverride,
                  typeIDs.relOverride.id() : typeIDs.relUniqueOverride,
                  typeIDs.connectionOverride.id() : typeIDs.connectionUniqueOverride }[overrideType.id()]

    def _getNumIsolatedRenderSettingsChildrenPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), RenderSettingsCollection.numIsolatedRenderSettingsChildren)

    # The passed in value is an integer offset on the number of isolate
    # selected children in this layer.
    def _updateIsolateSelected(self, val):
        # Use a command to support the undo mechanism
        if val != 0:
            newVal = self._getNumIsolatedRenderSettingsChildrenPlug().asInt() + val
            cmds.setAttr(self._getNumIsolatedRenderSettingsChildrenPlug().name(), newVal)


class RenderSettingsChildCollection(Collection):
    """
    Render Settings Sub Collection node.
    """

    kTypeId = typeIDs.renderSettingsChildCollection
    kTypeName = 'renderSettingsChildCollection'

    # Type of selector created by this collection
    kSelectorTypeName = selector.SimpleSelector.kTypeName

    @staticmethod
    def creator():
        return RenderSettingsChildCollection()

    @staticmethod
    def initializer():
        # A render settings collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other attributes.
        RenderSettingsChildCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(RenderSettingsChildCollection, self).__init__()

    @staticmethod
    def containsNodeName(nodeName):
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        return nodeName in renderSettings.getDefaultNodes()

    def getRenderSettingsChildCollections(self):
        return self.getChildren(cls=RenderSettingsChildCollection)

    def _createSelector(self, parent=None, selArgs=None):
        self._createAndConnectSelector(self.kSelectorTypeName)

        # Set the default nodes as static selection
        # Note: Some renderers could return nodes which do not exist yet.
        # Collections should not need to know about renderSettings, this was done to avoid a cyclic dependency
        import maya.app.renderSetup.model.renderSettings as renderSettings
        self.getSelector().staticSelection.setWithoutExistenceCheck(renderSettings.getDefaultNodes())
        self.getSelector().setFilterType(selector.Filters.kAll)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def typeId(self):
        return RenderSettingsChildCollection.kTypeId

    def typeName(self):
        return RenderSettingsChildCollection.kTypeName

    def superTypeName(self):
        return Collection.kTypeName

    def appendChild(self, child):
        if not isinstance(child, RenderSettingsChildCollection) and isinstance(child, Collection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsChildCollection, self).appendChild(child)

    def attachChild(self, pos, child):
        if isinstance(child, Collection) and not isinstance(child, RenderSettingsChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(RenderSettingsChildCollection, self).attachChild(pos, child)

    def createCollection(self, collectionName):
        """ Add a child collection to the Collection. """
        col = container.create(collectionName, RenderSettingsChildCollection.kTypeName, parent=self)
        self.appendChild(col)
        return col

    def compute(self, plug, dataBlock):
        return super(RenderSettingsChildCollection, self).compute(plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """Check if the argument can be a child of this collection."""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            isOverride = modelOrData.typeName() in _overrideTypes
            parentTypeName = modelOrData.parentTypeName
        else:
            isOverride = isinstance(modelOrData, override.Override)
            parentTypeName = modelOrData.parent().typeName()

        return modelOrData.typeName() not in _specialCollectionTypes and \
            (isOverride and parentTypeName in [RenderSettingsCollection.kTypeName, RenderSettingsChildCollection.kTypeName]) or \
            (modelOrData.typeName() == self.typeName() and self.isSelfAcceptableChild())

    def _getOverrideType(self, plg, overrideType):
        overrideType = super(RenderSettingsChildCollection, self)._getOverrideType(plg, overrideType)
        return typeIDs.absUniqueOverride if overrideType == typeIDs.absOverride else typeIDs.relUniqueOverride

    def _getRenderSettingsCollection(self):
        ancestors = self.ancestors()
        for a in ancestors:
            if isinstance(a, RenderSettingsCollection):
                return a
        return None

    def _updateAncestorsIsolatedChildren(self, val):
        rsc = self._getRenderSettingsCollection()
        if rsc:
            rsc._updateIsolateSelected(val)
        for c in self.ancestorContainers():
            c._updateNumIsolatedChildren(val)

    def _connectSelfLayerIsolatedChildren(self, layer):
        if layer and isinstance(self, RenderSettingsChildCollection):
            rsc = self._getRenderSettingsCollection()
            # Use existing command for undo / redo purposes.
            cmds.connectAttr(rsc.name() + '.numIsolatedRenderSettingsChildren',
                             self.name() + '.parentNumIsolatedChildren')

    def _disconnectSelfLayerIsolatedChildren(self, layer):
        if layer:
            rsc = self._getRenderSettingsCollection()
            # Use existing command for undo / redo purposes.
            cmds.disconnectAttr(rsc.name() + '.numIsolatedRenderSettingsChildren',
                                self.name() + '.parentNumIsolatedChildren')

    def getRenderSettingsChildCollectionByName(self, renderSettingsChildCollectionName, nested=False):
        for rscc in nodeList.forwardListNodeClassGenerator(self, cls=RenderSettingsChildCollection):
            if rscc.name() == renderSettingsChildCollectionName:
                return rscc
            elif nested:
                rscc2 = rscc.getRenderSettingsChildCollectionByName(renderSettingsChildCollectionName, True)
                if rscc2:
                    return rscc2
        return None

    def isTraversingConnections(self):
        return False

class AOVCollection(Collection):
    """
    AOV (arbitrary output variable) parent collection node.
    """

    kTypeId = typeIDs.aovCollection
    kTypeName = 'aovCollection'


    @staticmethod
    def creator():
        return AOVCollection()

    @staticmethod
    def initializer():
        # An AOV collection is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other attributes.
        AOVCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(AOVCollection, self).__init__()

    @staticmethod
    def containsNodeName(nodeName):
        callbacks = rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS)
        try:
            callbacks.getAOVName(nodeName)
            return True
        except:
            return False

    def _createSelector(self, parent=None, selArgs=None):
        # Selector type name argument is ignored.
        self._createAndConnectSelector('')

    def _createSelectorNode(self, typeName, selectorName, selArgs):
        # Ignore the argument selector type name: get the AOV collection
        # selector from the AOV renderer callback.
        callbacks = rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS)
        return callbacks.getCollectionSelector(selectorName)

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def typeId(self):
        return AOVCollection.kTypeId

    def typeName(self):
        return AOVCollection.kTypeName

    def appendChild(self, child):
        if isinstance(child, Collection) and not isinstance(child, AOVChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(AOVCollection, self).appendChild(child)

    def attachChild(self, pos, child):
        if isinstance(child, Collection) and not isinstance(child, AOVChildCollection):
            raise RuntimeError(kIncorrectChildType % child.typeName())
        else:
            super(AOVCollection, self).attachChild(pos, child)

    # This should never be called, as AOVCollections are created in renderLayer.py in aovCollectionInstance()
    def _createCollection(self, collectionName, typeName):
        raise RuntimeError(kIncorrectChildType % typeName)

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isAcceptableChild(self, modelOrData):
        """ Check if the model could be a child"""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            parentTypeName = modelOrData.parentTypeName
        else:
            parentTypeName = modelOrData.parent().typeName()
        return parentTypeName == self.typeName() and modelOrData.typeName() == AOVChildCollection.kTypeName

class AOVChildCollection(Collection):
    """
        AOV (arbitrary output variable) Child Collection node.
    """

    kTypeId = typeIDs.aovChildCollection
    kTypeName = 'aovChildCollection'

    @staticmethod
    def creator():
        return AOVChildCollection()

    @staticmethod
    def initializer():
        # Inherit all attributes from parent class
        AOVChildCollection.inheritAttributesFrom(Collection.kTypeName)

    def __init__(self):
        super(AOVChildCollection, self).__init__()

    def containsNodeName(self, nodeName):
        return nodeName in self.getSelector().getAbsoluteNames()

    def typeId(self):
        return AOVChildCollection.kTypeId

    def typeName(self):
        return AOVChildCollection.kTypeName

    def _createSelector(self, parent=None, selArgs=None):
        # Selector type name argument is ignored.
        self._createAndConnectSelector('', selArgs)

    def _createSelectorNode(self, typeName, selectorName, selArgs):
        # Ignore the argument selector type name: get the AOV child
        # collection selector from the AOV renderer callback.
        #
        # selArgs is a dictionary for selector argument
        # construction.  It must contain a value for 'aovName'.
        callbacks = rendererCallbacks.getCallbacks(rendererCallbacks.CALLBACKS_TYPE_AOVS)
        return callbacks.getChildCollectionSelector(selectorName, selArgs['aovName'])

    def setSelectorType(self, typeName):
        raise RuntimeError('Illegal call to derived class method.')

    def compute(self, plug, dataBlock):
        return computeEnabled.compute(self, plug, dataBlock)

    def isSelfAcceptableChild(self):
        """This code prevents copy/paste of AOV child collections to themselves/other AOV child collections."""
        return False

def getAllCollectionClasses():
    """ Returns the list of Collection subclasses """
    return commonUtils.getSubClasses(Collection)

def create(name, nodeType=container.Container.kCollectionTypeName, parent=None, **selArgs):
    return container.create(name, nodeType, parent, **selArgs)

def delete(collection):
    container.delete(collection)

def unapply(collection):
    container.unapply(collection)

_specialCollectionTypes = { c.kTypeName for c in getAllCollectionClasses() if c != Collection }
_overrideTypes = { o.kTypeName for o in overrideUtils.getAllOverrideClasses() }
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
