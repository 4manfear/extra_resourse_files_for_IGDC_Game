import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya

import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.model.namespace as namespace
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.common.utils as commonUtils
import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
import maya.app.renderSetup.lightEditor.model.item as itemModel
from maya.app.renderSetup.lightEditor.model.group import LightGroup

import maya.app.renderSetup.model.serializableNode as serializableNode
import maya.app.renderSetup.model.nodeNotes as nodeNotes
import maya.app.renderSetup.model.jsonTranslatorGlobals as jsonTranslatorGlobals

# Name of the singleton node, and its type.
# The light editor singleton must be in the root namespace.
_LIGHT_EDITOR_NODE_TYPE = 'lightEditor'
_LIGHT_EDITOR_NODE_NAME = ':' + _LIGHT_EDITOR_NODE_TYPE

kLightEditorNodeNameMismatch = maya.stringTable['y_maya_app_renderSetup_lightEditor_model_editor.kLightEditorNodeNameMismatch'             ]
kImportWarning               = maya.stringTable['y_maya_app_renderSetup_lightEditor_model_editor.kImportWarning'                           ]
kLightEnabledChangedWarning  = maya.stringTable['y_maya_app_renderSetup_lightEditor_model_editor.kImpokLightEnabledChangedWarningrtWarning']

def hasInstance():
    """ Return true if the light editor node exists """
    return commonUtils.nameToNode(_LIGHT_EDITOR_NODE_NAME) is not None

@namespace.root
def _createInstance():
    wasSceneDirty = cmds.file(query=True, modified=True)
    fn = OpenMaya.MFnDependencyNode()
    lightEditorObj = fn.create(LightEditor.kTypeId, _LIGHT_EDITOR_NODE_NAME)
    
    if not wasSceneDirty:
        cmds.file(modified=False)

    if ':' + fn.name() != _LIGHT_EDITOR_NODE_NAME:
        cmds.delete(fn.name())
        exceptionInfo = (LightEditor.kTypeName, _LIGHT_EDITOR_NODE_NAME)
        raise ValueError(kLightEditorNodeNameMismatch % exceptionInfo)

    return lightEditorObj

def instance():
    """Return the light editor singleton node, creating it if required."""
    lightEditorObj = commonUtils.nameToNode(_LIGHT_EDITOR_NODE_NAME)
    if not lightEditorObj:
        # No lightEditor node, create one
        # Creation of the light editor node singleton must not affect
        # undo stack, disable it for the creation only
        swf = cmds.undoInfo(query=True, stateWithoutFlush=True)
        try:
            cmds.undoInfo(stateWithoutFlush=False)
            lightEditorObj = _createInstance()
        finally:
            cmds.undoInfo(stateWithoutFlush=swf)

    fn = OpenMaya.MFnDependencyNode(lightEditorObj)
    # If the lightEditor node isn't the proper type, blow up.
    if fn.typeId != LightEditor.kTypeId:
        exceptionInfo = (_LIGHT_EDITOR_NODE_NAME, LightEditor.kTypeName)
        raise TypeError(kLightEditorNodeNameMismatch % exceptionInfo)

    return fn.userNode()

class LightEditorImportExportHelper(object):
    '''
    For import/export light editor group schema, the following information is encoded and decoded:

    On encode:
    Snapshots of
    - 'LightGroup (string name) to LightItem (string name) connections'
    - 'LightItem (string name) to LightGroup (string name) connections'
    - 'LightGroups enabled/isolate status and color label'
    On decode:
    The above snapshots are taken and compared with the snapshot found in imported json in O(n)
    During this comparison traversal, missing light groups are created, lights/lightgroups are moved to the appropriate parents, enable/isolate/color label are set to match json file
    And a missingLightToParent (string to string) and missingLightgroupToChild (string to string) dictionaries are populated from the results of the comparison.
    Additional helper dictionaries are used to keep track of renaming events including undo/redo.
    No weakreference of models are used in this process to avoid dirty reference issues, only string names.

    General Overview (See MAYA-96952)
    Import/Export ligh groups supports the following features by design:
    - Import light group works irrespective of the order of light import. i.e. the user can import group first and then the lights, or lights first then group, or some light first + group + rest of the lights
    - Import has two modes: merge and overwrite. Merge attempts to preserve current light editor status and only overwrite a group when there is a conflict. Override erases all light groups in current light editor and recreates them
    - Import/Export is integrated into render setup import/export all. From Render Setup, the user can have access all light group import/export option even when a light editor instance has not yet been created
    - A warning icon appears next to lights when the light's visibility has been changed by an import
    - Item affected by imported groups are shown as bold and italic in editorUI views, including the imported groups themselves
    - To help the user locate imported items quickly, the order of the imported group is always the same: alphabetical. The order of lights within the imported group corresponds to its pre-import order.
    - (cont) For merge, items not affected by import appears above imported items, who are in bold and italic
    - User can export already imported light group with missing items. The missing item list will be preserved upon next import
    - Partial support for Maya undo/redo similar to Render Setup

    Difference with Render Setup Collections:
    - Unlike a RS collection, a light Item can only belong to 1 and only 1 group at a time
    - Light groups are inheritenced based and not selector based
    '''
    WARNING_MESSAGE_FADE_TIME = 3000
    WARNING_MESSAGE_COLOR = 0xFFFF00

    kIsSelfEnabledIndex = 0
    kIsIsolatedSelectedIndex = 1
    kLabelColorIndex = 2

    nameToObjectDict = None
    lightToIsEnabled = {}

    lightToParentSnapshot = {}
    lightgroupToChild = {}
    lightGroupProperties = {}
    missingLightToParent = {}
    lightgroupToMissingChild = {}
    
    oldParentNameToNewName = {}
    parentHasNewName = {}

    @staticmethod
    def resetSnapshot(includingMissing = True):
        '''Resets the dictionaries in LightEditor as well as the helper dictionaries in LightEditorImportExportHelper'''
        LightEditorImportExportHelper.lightToParentSnapshot = {}
        LightEditorImportExportHelper.lightgroupToChild = {}
        LightEditorImportExportHelper.lightGroupProperties = {}
        if includingMissing:
            LightEditorImportExportHelper.missingLightToParent = {}
            LightEditorImportExportHelper.lightgroupToMissingChild = {}
            LightEditorImportExportHelper.oldParentNameToNewName = {}
            LightEditorImportExportHelper.parentHasNewName = {}

        # Used to determine if importing a group changes a light's scene visibility. If yes, set warning icon.
        LightEditorImportExportHelper.lightToIsEnabled = {}

    @staticmethod
    def populatePresentSnapshots():
        ''' Populate the dictionaries by taking a snapshot of all the items in light editor, their parents, label color, enabled isolate status, etc.'''
        # First query to get all the light groups names
        lightgroupsNames = cmds.ls(type= "lightGroup", long=True)
        if lightgroupsNames and len(lightgroupsNames)>0:
            for groupName in lightgroupsNames:
                group = commonUtils.nameToNode(groupName)
                if group:
                    # We got the MObject from the name, the following gets the lightGroup object from the MObject
                    fn = OpenMaya.MFnDependencyNode(group)
                    lightgroup = fn.userNode()
                    lightgroupName = lightgroup.name()
                     # We got the lightGroup object, let's now save its enable/isolate status and color label
                    LightEditorImportExportHelper.lightGroupProperties[lightgroupName] = [None]*3
                    LightEditorImportExportHelper.lightGroupProperties[lightgroupName][LightEditorImportExportHelper.kIsSelfEnabledIndex] = lightgroup.isSelfEnabled()
                    LightEditorImportExportHelper.lightGroupProperties[lightgroupName][LightEditorImportExportHelper.kIsIsolatedSelectedIndex] = lightgroup.isIsolateSelected()
                    LightEditorImportExportHelper.lightGroupProperties[lightgroupName][LightEditorImportExportHelper.kLabelColorIndex] = str(lightgroup.getLabelColor())
                    # Fetching and storing info on the group's children
                    LightEditorImportExportHelper.lightgroupToChild[lightgroupName] = []
                    lightgroupChildren = lightgroup.getChildren()
                    for child in lightgroupChildren:
                        if child.kTypeId == typeIDs.lightItem:
                            LightEditorImportExportHelper.lightgroupToChild[lightgroupName].append(child.getLightName(fullPath= True))
                            LightEditorImportExportHelper.lightToParentSnapshot[child.getLightName(fullPath= True)] = lightgroupName
                            LightEditorImportExportHelper.lightToIsEnabled[child.getLightName(fullPath= True)] = child.isEnabled()
                        else:
                            LightEditorImportExportHelper.lightgroupToChild[lightgroupName].append(child.name())
                            LightEditorImportExportHelper.lightToParentSnapshot[child.name()] = lightgroupName
        # If a light group has missing lights, we want to add them to the snapshot as well so that it gets included in the export
        for lightName in LightEditorImportExportHelper.missingLightToParent:
            parentLightGroupName = LightEditorImportExportHelper.missingLightToParent[lightName]
            # Light groups are not garbage collected even when its deleted due to undo/redo support
            # We need to check if the object actually exists before storing it
            LightEditorImportExportHelper.lightToParentSnapshot[lightName] = parentLightGroupName
            LightEditorImportExportHelper.lightgroupToChild[parentLightGroupName].append(lightName)

    @staticmethod
    def resetParentOnAllLightItems(importedData=None, LEInstance = None):
        """
            Reset all current light list item's position.
            When used in decode, will move current lights to match importedData schema while leaving light position not in schema intact

            Order of resetted lightItems matches the editor top to down order pre-reset.
            Order of resetted lightgroups is alphabetical. If decode type == merge, non-imported groups will appear first before imported items.
            This is by designed to help user find items more easily after an import: Groups always get loaded in the same order, items within groups keeps order pre-import.
        """
        if LEInstance == None:
            LEInstance = instance()
        if importedData == None:
            importedData = {}
        lightItemList = LEInstance.getTraversal()
        # Resetting lights
        for itemName in lightItemList:
            item = LightEditor.nameToEditorItem(itemName)
            if item and item.kTypeId == typeIDs.lightItem:
                lightItem = item
                oldParent = lightItem.parent()
                oldParent.detachChild(lightItem)
                shapeName = lightItem.getLightName(fullPath= True)
                if shapeName not in LightEditorImportExportHelper.lightToParentSnapshot:
                    LEInstance.appendChild(lightItem)
                else:
                    newParent = LightEditor.nameToEditorItem(LightEditorImportExportHelper.lightToParentSnapshot[shapeName]) if LightEditor.nameToEditorItem(LightEditorImportExportHelper.lightToParentSnapshot[shapeName]) else LEInstance
                    newParent.appendChild(lightItem)
                if "lightItemToParent" in importedData and lightItem.getLightName(fullPath= True) in importedData["lightItemToParent"]:
                    lightItem.setImportedStatus(True)
        # Resetting light groups to correct parents if importedData is available
        for groupPair in sorted(importedData["lightGroupToChildren"].items()):
            groupName = groupPair[0]
            if groupName != "lightEditor" and cmds.objExists(groupName):
                groupParentName = importedData["lightItemToParent"][groupName]
                groupItem = LightEditor.nameToEditorItem(groupName)
                groupParentItem =  LightEditor.nameToEditorItem(groupParentName)
                if groupItem and groupParentItem:
                    groupItem.parent().detachChild(groupItem)
                    groupParentItem.appendChild(groupItem)

    @staticmethod
    def decode(importedData, importType = jsonTranslatorGlobals.DECODE_AND_MERGE, LEInstance = None):
        '''
            Decode importedData dict, compare current snapshot with importedData (json)
            create missing lightGroups found in json, match light item and light group's parents with importedData
            match light groups' respective isolate, enable and labelcolor values to corresponding values in json file
            Set warning status if light visibility affected by import

            Decode has two type:
            - 0: Overwrite. Will fully replace current scene content
            - 1 or 2: Merge. Will replace identical content and leave untouched non identical content (merged content will be set to Text Bold)
            - 2 in Render Setup is reserved for renaming namespace on import. This option is not used by light editor import.
        '''
        if LEInstance == None:
            LEInstance = instance()
        # Check if importedData contains the right dictionaries
        if not importedData or "lightGroupToChildren" not in importedData or "lightItemToParent" not in importedData:
            OpenMaya.MGlobal.displayWarning(kImportWarning)
            return
        # Taking a snapshot for comparison later
        LightEditorImportExportHelper.resetSnapshot()
        LightEditorImportExportHelper.populatePresentSnapshots()
        # If type == overwrite, we reset the parents on all lights to lightEditor and look up all the light group. Light group that are not found in the json file will be deleted
        # We also save the visibility status of all lights taken on the current snapshot above. Snapshot are relatively cheap to take, so we can afford to take it again for convenience.
        # The visiblity status will be used to determine whether a warning icon should be displayed or not
        oldlightgroup = []
        if (importType == jsonTranslatorGlobals.DECODE_AND_ADD):
            lightItemList = LEInstance.getTraversal()
            lightgroupNames = []
            # Although the following delete operation can be done in a single traversal if we reverse the pre-order traversal, we use 2 traversals to help maintain the up-to-down order of the lights
            for itemName in lightItemList:
                item = LightEditor.nameToEditorItem(itemName)
                # Verifying that the item still exists
                if not item:
                    continue
                if item.kTypeId == typeIDs.lightItem:
                    oldParent = item.parent()
                    oldParent.detachChild(item)
                    LEInstance.appendChild(item)
                if item.kTypeId == typeIDs.lightGroup:
                    oldparent = item.parent()
                    lightgroupNames.append(itemName)
                    if oldparent:
                        oldparent.detachChild(item)
                        oldlightgroup.append(item.name())
                        LEInstance.appendChild(item)
            for groupName in lightgroupNames:
                if groupName not in importedData["lightGroupToChildren"]:
                    item = LightEditor.nameToEditorItem(groupName)
                    if item:
                        if item.isIsolateSelected():
                            item.setIsolateSelected(False)
                            item.deactivate()
                        itemModel.deleteItem(item)
            # Retaking snapshot but keeping current snapshot's light visibility
            temp = LightEditorImportExportHelper.lightToIsEnabled
            LightEditorImportExportHelper.resetSnapshot()
            LightEditorImportExportHelper.populatePresentSnapshots()
            LightEditorImportExportHelper.lightToIsEnabled = temp
        # Importing the light groups with right label color, enable and isolate status. Recreating light groups when currently missing.
        # Used by both imported type 0, 1 or 2
        for lightgroupName in importedData["lightGroupToChildren"]:
            if lightgroupName == "lightEditor":
                continue
            if not cmds.objExists(lightgroupName):
                item = itemModel.createItem(lightgroupName, 'lightGroup')
                LEInstance.appendChild(item)
                LightEditorImportExportHelper.lightgroupToChild[lightgroupName] = []
            group = LightEditor.nameToEditorItem(lightgroupName)
            if group:
                if "lightGroupProperties" in importedData and lightgroupName in importedData["lightGroupProperties"]:
                    group.setSelfEnabled(importedData["lightGroupProperties"][lightgroupName][LightEditorImportExportHelper.kIsSelfEnabledIndex])
                    group.setIsolateSelected(importedData["lightGroupProperties"][lightgroupName][LightEditorImportExportHelper.kIsIsolatedSelectedIndex])
                    group.setLabelColor(importedData["lightGroupProperties"][lightgroupName][LightEditorImportExportHelper.kLabelColorIndex])
                # Setting the imported status of the light group to true and saving the original name of the group on import. This will be useful if the group is later renamed.
                group.setImportedStatus(True)
                group.originalImportName = lightgroupName
                # Removing from missing light dictionary
        # Checking for missing lights
        for lightName in importedData["lightItemToParent"]:
            if not cmds.objExists(lightName):
                parentName = importedData["lightItemToParent"][lightName]
                LightEditorImportExportHelper.missingLightToParent[lightName] = parentName
                if parentName not in LightEditorImportExportHelper.lightgroupToMissingChild:
                    LightEditorImportExportHelper.lightgroupToMissingChild[parentName] = [lightName]
                else:
                    LightEditorImportExportHelper.lightgroupToMissingChild[parentName].append(lightName)
            else:
                LightEditorImportExportHelper.lightToParentSnapshot[lightName] = importedData["lightItemToParent"][lightName]
        # Moving lights and light groups to their correct parent
        LightEditorImportExportHelper.resetParentOnAllLightItems(importedData, LEInstance)
        # A user can have lights that are not part of the original import json (e.g. user added more lights later after export)
        # Following checks if those lights' enable\isolate visibility have been affected by the import
        # If affected, setWarning icon to let the user know
        itemList = LEInstance.getTraversal()
        displayOnScreenWarning = False
        for itemName in itemList:
            item = LightEditor.nameToEditorItem(itemName)
            if item and item.kTypeId == typeIDs.lightItem:
                lightName = itemName
                if lightName in LightEditorImportExportHelper.lightToIsEnabled:
                    if LightEditorImportExportHelper.lightToIsEnabled[lightName] != item.isEnabled():
                        item.setWarning(True)
                        displayOnScreenWarning = True
                        item.itemChanged()
                    else:
                        item.setWarning(False)
                        item.itemChanged()
        if displayOnScreenWarning:
            OpenMaya.MGlobal.displayWarning(kLightEnabledChangedWarning)
            cmds.inViewMessage(pos='midCenter', bkc=LightEditorImportExportHelper.WARNING_MESSAGE_COLOR, fade=True, fst=LightEditorImportExportHelper.WARNING_MESSAGE_FADE_TIME, amg=kLightEnabledChangedWarning)

    @staticmethod
    def getImportedParent(longName):
        '''Given the name of a lightItem, return its imported parent if exists.'''
        if longName in LightEditorImportExportHelper.missingLightToParent:
            originalParentName = LightEditorImportExportHelper.missingLightToParent[longName]
            return LightEditor.nameToEditorItem(originalParentName) if originalParentName not in LightEditorImportExportHelper.parentHasNewName else LightEditor.nameToEditorItem(LightEditorImportExportHelper.oldParentNameToNewName[originalParentName])
        return None

    def __init__(self):
        pass


class LightEditor(LightGroup, nodeNotes.NodeNotes, serializableNode.SerializableNode):
    """Singleton group item that is the root of the light editor items.

    The light editor node is a singleton: at most one can exist in a scene.
    It is not implemented as a default node, and therefore is not created
    on file new, but rather created on demand."""

    kTypeId = typeIDs.lightEditor
    kTypeName = _LIGHT_EDITOR_NODE_TYPE

    @staticmethod
    def creator():
        return LightEditor()

    @staticmethod
    def initializer():
        LightEditor.inheritAttributesFrom(LightGroup.kTypeName)
        LightEditorImportExportHelper.resetSnapshot()

    @staticmethod
    def getMissingChildren(groupItem):
        """Returns the missing children of a light group"""
        return LightEditorImportExportHelper.lightgroupToMissingChild[groupItem]

    @staticmethod
    def findEditorItem(obj):
        # Find the editor item for a Maya object
        if typeMgr.isValidLightTransformObject(obj):
            obj = typeMgr.findLightShapeObject(obj)
        if obj:
            plg = plug.findPlug(obj, "message")
            dst = utils.plugDst(plg.plug)
            for d in dst if dst else []:
                fn = OpenMaya.MFnDependencyNode(d.node())
                if fn.typeId == typeIDs.lightItem:
                    return fn.userNode()
        return None

    @staticmethod
    def nameToEditorItem(name):
        node = commonUtils.nameToNode(name)
        if not node:
            return None
        editorItem = LightEditor.findEditorItem(node)
        return editorItem if editorItem else OpenMaya.MFnDependencyNode(node).userNode()

    def __init__(self):
        super(LightEditor, self).__init__()

    def postConstructor(self):
        # Call parent class postConstructor
        super(LightEditor, self).postConstructor()

    def isAbstractClass(self):
        return False

    def parent(self):
        """Returns None, as the render setup node is the root of the hierarchy."""
        return None

    def ancestors(self):
        """Returns a single-element deque with the render setup node itself."""
        return deque([self])

    def encode(notes=None):
        '''
           Traverse through Light Editor tree and encode lights and groups into a dictionary along with parents and child info.
        '''
        LightEditorImportExportHelper.resetSnapshot(False)
        LightEditorImportExportHelper.populatePresentSnapshots()
        encodedData = super(LightEditor, LightEditor).encode(notes)
        encodedData["lightGroupToChildren"] = LightEditorImportExportHelper.lightgroupToChild
        encodedData["lightItemToParent"] = LightEditorImportExportHelper.lightToParentSnapshot
        encodedData["lightGroupProperties"] = LightEditorImportExportHelper.lightGroupProperties
        return encodedData

    @undo.chunk('Import light editor groups')
    def decode(self, importedData, importType = 1):
        '''
            Decode importedData dict. See LightEditorImportExportHelper description for more details.
        '''
        LightEditorImportExportHelper.decode(importedData, importType, self)

    def getTraversal(self, groupItem = None):
        traversalList = []
        self._getTraversal(groupItem = groupItem, result = traversalList)
        return traversalList

    def _getTraversal(self, groupItem = None, result = None):
        """ Get all items in lightEditor in pre-order format (top to bottom tree traversal)"""
        if groupItem == None:
            groupItem = self
        if result == None:
            result = []
        childrenList = groupItem.getChildren()
        for child in childrenList:
            result.append(child.getLightName(fullPath= True) if child.kTypeId == typeIDs.lightItem else child.name())
            if child.kTypeId == typeIDs.lightGroup:
                self._getTraversal(child, result)

    @undo.chunk('Remove warning status')
    def removeAllWarningsAndImportedStatus(self):
        """ Remove the warning status on all light editor items"""
        itemList = self.getTraversal()
        for itemName in itemList:
            item = LightEditor.nameToEditorItem(itemName)
            if item:
                item.setWarning(False)
                item.setImportedStatus(False)
                item.itemChanged()

    @undo.chunk('Create and append a light item')
    def createLightItem(self, lightShapeObj, parent=None):
        """ Create and append a new light list item """
        name = itemModel.getLightItemName(lightShapeObj)
        item = itemModel.createItem(name, 'lightItem')
        item.setLightShape(lightShapeObj)

        longName = item.getLightName(fullPath= True)
        importedParent = LightEditorImportExportHelper.getImportedParent(longName)

        if importedParent:
            importedParent.appendChild(item)
            # The following pop does not support undo/redo by design. Pop is permanent.
            # i.e. if an user adds a missing light into an imported group and then undo the added light, the group will no longer consider said light to be missing in the future
            # Reason for design: it is too time consumming to implement our own doIt()/undoIt() fnc with MDGModifier just to keep track of light addition when the user can simply re-import from json again
            # This is similar to collections in render setup, which does not fully support undo/redo.
            LightEditorImportExportHelper.missingLightToParent.pop(longName, None)
            item.setImportedStatus(True)
        elif parent:
            parent.appendChild(item)
        else:
            self.appendChild(item)
        return item

    @undo.chunk('Create and append a group item')
    def createGroupItem(self, parent=None):
        """ Create and append a new group list item """
        item = itemModel.createItem('lightGroup1', 'lightGroup')

        if parent:
            parent.appendChild(item)
        else:
            self.appendChild(item)
        return item


    def rebuildScene(self):
        wasSceneDirty = cmds.file(query=True, modified=True)

        # Rebuild the type manager in case a new plugin
        # with new light types were loaded
        typeMgr.rebuild()

        # Find any imported light editor nodes and transfer its
        # children to this light editor node
        lightEditorNames = cmds.ls(type=_LIGHT_EDITOR_NODE_TYPE, long=True)
        for lightEditorName in lightEditorNames if lightEditorNames else []:
            lightEditor = utils.nameToUserNode(lightEditorName)

            # Ignore our own instance and also ignore any referenced nodes
            # since we don't support mixing in referenced light editor items.
            # For referenced lights new editor items will be created instead below.
            if lightEditor != self and not OpenMaya.MFnDependencyNode(lightEditor.thisMObject()).isFromReferencedFile:
                # Detach the children from the other editor and add it to this editor.
                children = lightEditor.getChildren()
                for child in children:
                    lightEditor.detachChild(child)
                for child in children:
                    self.appendChild(child)

                # Delete the other editor node
                cmds.delete(lightEditor.name())

        # Iterate over each light item and see if a light source exists
        lightItems = cmds.ls(type="lightItem")
        for item in lightItems:
            # shape name is the light item name without __LEitem
            shapeName = item.rsplit('_', 2)[0]
            # check to see if shape exists
            shape = cmds.ls(shapeName, long=True)
            if not shape:
                itemNode = utils.nameToUserNode(item)
                if item:
                    itemModel.deleteItem(itemNode, deleteLight=False)

        # Iterate all lights in the scene and make sure they have
        # a light editor item assigned.
        lightTypes = typeMgr.lights()
        lightShapeNames = cmds.ls(type=lightTypes, long=True)
        if lightShapeNames and len(lightShapeNames)>0:
            for shapeName in lightShapeNames:
                shape = commonUtils.nameToNode(shapeName)
                lightItem = LightEditor.findEditorItem(shape)

                # We don't support light editor items from referenced files
                # so ignore such items and create new once below instead.
                if lightItem and OpenMaya.MFnDependencyNode(lightItem.thisMObject()).isFromReferencedFile:
                    # Disconnect the light shape from this referenced item.
                    lightItem.setLightShape(None)
                    lightItem = None

                if lightItem:
                    # A valid light item exists already.
                    # Make sure the connections and callbacks are setup for this light shape.
                    lightItem.setLightShape(shape)
                else:
                    # No valid light item exists so create one.
                    self.createLightItem(shape)


        # Make sure isolate state is up to date
        self.updateIsolateState()

        if not wasSceneDirty:
            cmds.file(modified=False)

# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
