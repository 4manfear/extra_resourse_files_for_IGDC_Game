import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import int
from builtins import range
from maya.app.general.mayaMixin import MayaQWidgetBaseMixin

from PySide2.QtWidgets import QGroupBox, QVBoxLayout, QHBoxLayout, QListWidget, QListWidgetItem, QAbstractItemView, QAction, QMenu, QShortcut, QWidget, QPushButton
from PySide2.QtGui import QFont, QKeySequence, QPainter, QPen, QColor
from PySide2.QtCore import Qt

from shiboken2 import getCppPointer
from functools import partial

from maya.app.renderSetup.views.propertyEditor.layout import Layout
import maya.app.renderSetup.views.utils as utils
import maya.app.renderSetup.model.utils as modelUtils
import maya.app.renderSetup.common.utils as commonUtils
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.model.applyOverride as applyOverride
import maya.app.renderSetup.lightEditor.model.typeManager as typeMgr
import maya.app.renderSetup.lightEditor.model.editor as editorModel
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.lightEditor.model.item as itemModel

import maya.app.renderSetup.model.undo as undo

import maya.OpenMayaUI as OpenMayaUI
import maya.cmds as cmds
import weakref


kEnable = maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kEnableStr' ]
kIsolate = maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kIsolateStr' ]
kCouldNotSelectMissingObject = maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kCouldNotSelectMissingObject' ]

def _createControl(plg, attrLabel, propertyEditor, connectable=True, enabled=True):
    """ Create a UI control for the given attribute,
    matching its type and considering if it's connectable."""
    attr = plg.name
    hideButton = not (connectable and plg.isConnectable)
    ctrl = None

    # Vectors must be handled explicitly with attrFieldGrp. If the more general attrControlGrp is used
    # no map button is created. This is a bug with the attrControlGrp command and vector types.
    if plg.isVector:
        ctrl = cmds.attrFieldGrp(attribute=attr, label=attrLabel, enable=enabled, forceAddMapButton=not hideButton, hideMapButton=hideButton, preventOverride=True, precision=3,
            changeCommand=partial(_attrFieldGrpChanged, attrName=attr, propertyEditor=propertyEditor))

    # Bools must also be handled explicitly. The general command attrControlGrp gives error messages
    # when creating a bool control.
    elif plg.type is plug.Plug.kBool:
        ctrl = cmds.checkBoxGrp(label=attrLabel, enable=enabled, numberOfCheckBoxes=1, preventOverride=True,
            changeCommand=partial(_attrCheckBoxGrpChanged, attrName=attr, propertyEditor=propertyEditor))
        cmds.connectControl(ctrl, attr, index=2)

    # Floats must be handled separately to set their precision
    elif plg.type is plug.Plug.kFloat or plg.type is plug.Plug.kDouble:
        ctrl = cmds.attrFieldSliderGrp(attribute=attr, label=attrLabel, enable=enabled, annotation=attr, forceAddMapButton=not hideButton, hideMapButton=hideButton, preventOverride=True, precision=3,
            changeCommand=partial(_attrFieldSliderGrpChanged, attrName=attr, propertyEditor=propertyEditor))

    # Strings must also be handled explicitly. The general command attrControlGrp gives error messages
    # when creating a string control.
    elif plg.type is plug.Plug.kString:
        ctrl = cmds.textFieldGrp(label=attrLabel, enable=enabled, preventOverride=True)
        cmds.connectControl(ctrl, attr, index=2)
    elif plg.type is plug.Plug.kFilename:
        cmds.rowLayout(numberOfColumns=2)
        ctrl = cmds.textFieldGrp(label=attrLabel, enable=enabled, preventOverride=True, fileName=True)
        cmds.connectControl(ctrl, attr, index=2, fileName=True)
        cmds.symbolButton(image='navButtonBrowse.png', command=lambda data: utils.browse(attr))
        cmds.setParent('..') # rowLayout

    # Handled all other types with attrControlGrp, if supported
    elif cmds.attrControlGrp(query=True, handlesAttribute=attr):
        ctrl = cmds.attrControlGrp(attribute=attr, label=attrLabel, enable=enabled, hideMapButton=hideButton, preventOverride=True,
            changeCommand=partial(_attrControlGrpChanged, attrName=attr, propertyEditor=propertyEditor))

    # If no control was created above, fallback to a navigation control group,
    # so that connections can be made on the attribute.
    if ctrl is None:
        ctrl = cmds.attrNavigationControlGrp(label=attrLabel, attribute=attr, enable=enabled,
                createNew="connectionOverrideNewNode " + attr, connectToExisting="connectionOverrideReplaceNode " + attr)

    return ctrl

def _attrFieldGrpChanged(args, attrName, propertyEditor):
    propertyEditor.lightAttrChanged(attrName)

def _attrFieldSliderGrpChanged(floatVal, doubleVal, attrName, propertyEditor):
    propertyEditor.lightAttrChanged(attrName)

def _attrCheckBoxGrpChanged(boolVal, attrName, propertyEditor):
    propertyEditor.lightAttrChanged(attrName)

def _attrControlGrpChanged(attrName, propertyEditor):
    propertyEditor.lightAttrChanged(attrName)

class LightProperties(MayaQWidgetBaseMixin, QGroupBox):
    """
    This class represents the property editor view of a light editor light item.
    """

    def __init__(self, item, parent):
        super(LightProperties, self).__init__(parent=parent)
        self.item = weakref.ref(item)
        self.propertyEditor = parent
        layout = QVBoxLayout()
        layout.setObjectName('light_editor_light_vertical_box_layout')
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(utils.dpiScale(2))

        self._setupMainGroupBox(layout)
        self.setLayout(layout)

        # Unwrap the layout into a pointer to be able to get the UI name.
        # We use fullName() to ensure a unique name is used
        layoutName = OpenMayaUI.MQtUtil.fullName(int(getCppPointer(layout)[0]))
        cmds.setParent(layoutName)


        self._uiLayout = cmds.columnLayout(adjustableColumn=True)
        self._createAttributeControls()

    def _setupMainGroupBox(self, layout):
        mainGroupBox = QGroupBox()
        mainGroupBox.setContentsMargins(0, 0, 0, 0)
        mainGroupBoxLayout = Layout()
        mainGroupBoxLayout.setVerticalSpacing(utils.dpiScale(2))
        mainGroupBox.setLayout(mainGroupBoxLayout)
        layout.addWidget(mainGroupBox)

    def _createAttributeControls(self):
        attrSelfEnabled = self.item().model.name() + ".selfEnabled"
        attrIsolateSelected = self.item().model.name() + ".isolateSelected"

        ctrl = cmds.checkBoxGrp(label="", numberOfCheckBoxes=2, label1=kEnable, label2=kIsolate,
            changeCommand1=partial(_attrCheckBoxGrpChanged, attrName=attrSelfEnabled, propertyEditor=self.propertyEditor),
            changeCommand2=partial(_attrCheckBoxGrpChanged, attrName=attrIsolateSelected, propertyEditor=self.propertyEditor))
        cmds.connectControl(ctrl, attrSelfEnabled, index=2)
        cmds.connectControl(ctrl, attrIsolateSelected, index=3)

        for column in range(0, len(typeMgr.getAllAttributes())):
            plg = self.item().model.getAttrPlug(column)
            if plg:
                attrLabel, _ = list(typeMgr.getAllAttributes().items())[column]

                # Check if a relative override is applied
                src = modelUtils.plugSrc(plg.plug)
                if src and commonUtils.isNodeInstance(src.node(), applyOverride.ApplyRelOverride):
                    enabledPlg = plug.findPlug(src.node(), "enabled")
                    src = modelUtils.plugSrc(enabledPlg.plug)
                    multiplyPlg = plug.findPlug(src.node(), "multiply")
                    offsetPlg = plug.findPlug(src.node(), "offset")

                    cmds.separator()
                    _createControl(plg, attrLabel, self.propertyEditor)
                    _createControl(multiplyPlg, maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kMultiply' ], self.propertyEditor)
                    _createControl(offsetPlg, maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kOffset' ], self.propertyEditor)
                else:
                    _createControl(plg, attrLabel, self.propertyEditor)

        # Add the transform attributes
        cmds.separator()
        translatePlg = self.item().model.getTransformPlug("translate")
        rotatePlg = self.item().model.getTransformPlug("rotate")
        scalePlg = self.item().model.getTransformPlug("scale")
        _createControl(translatePlg, maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kTranslate' ], self.propertyEditor)
        _createControl(rotatePlg, maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kRotate' ], self.propertyEditor)
        _createControl(scalePlg, maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kScale' ], self.propertyEditor)

class GroupStaticSelectionWidget(QListWidget):
    '''
    This class creates the static selection list view of group properties

    The implementation mirrors several methods found in CollectionStaticSelectionWidget from propertyEditor/collectionStaticSelectionWidget.py
    It does not however inherit from the latter. This is because they are numerous disparities between them:
        - The requirements are much simpler for selection list than collection layers
        - Unlike CollectionStaticSelectionWidget, GroupStaticSelectionWidget are not selector based, but rather group child
        - Unlike render setup, the lights in LE are unique (i.e. light group cannot overlap).
    In lieu of a selector, a simpler and serialized dictionarires are used
    '''
    ROW_HEIGHT = utils.dpiScale(21)
    MIN_VISIBLE_ENTRIES = 4
    MAX_VISIBLE_ENTRIES = 10
    PLACEHOLDER_TEXT_PEN_ENABLED = QPen(QColor(128, 128, 128))

    kEntryActionRemoveEntry = 1
    kEntryActionRemoveMissingObjects = 2
    kEntryActionRemoveAllEntry = 3

    def __init__(self, item, parent=None):
        super(GroupStaticSelectionWidget, self).__init__(parent=parent)
        self.item = weakref.ref(item)
        self.count = 0
        self.hasMissingItems = False
        self.setAcceptDrops(True)
        self.setDropIndicatorShown(True)
        self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.customContextMenuRequested.connect(self.rightClicked)
        self.contextMenu = QMenu(self)
        self.selectAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kSelectFromMenu' ], self.contextMenu)
        self.selectAction.triggered.connect(self.selectEntry)
        self.selectAllAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kSelectAllFromMenu' ], self.contextMenu)
        self.selectAllAction.triggered.connect(self.selectAllEntry)
        self.removeAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kRemoveSelected'], self.contextMenu)
        self.removeAction.triggered.connect(self.removeEntry)
        self.removeAllAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kRemoveAll'], self.contextMenu)
        self.removeAllAction.triggered.connect(self.removeAllEntry)
        self.deleteAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kDeleteSelected'], self.contextMenu)
        self.deleteAction.triggered.connect(self.deleteEntry)
        self.deleteAllAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kDeleteAll'], self.contextMenu)
        self.deleteAllAction.triggered.connect(self.deleteAllEntry)
        self.removeMissingAction = QAction(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kRemoveAllMissing' ], self.contextMenu)
        self.removeMissingAction.triggered.connect(self.removeMissingObjects)
        self.itemDoubleClicked.connect(self.selectEntry)

        # The group static selection widget was handling deletion even when
        # its parent did not have focus, thus preventing collections from being
        # deleted with the delete key, thus the need for the:
        # Qt.WidgetWithChildrenShortcut
        removeShortcut = QShortcut(QKeySequence(Qt.Key_Delete), self, None, None, Qt.WidgetWithChildrenShortcut)
        removeShortcut.activated.connect(self.removeEntry)
        self.setSelectionMode(QAbstractItemView.ExtendedSelection)

        self.INITIAL_HEIGHT = self.sizeHintForRow(0) * self.MIN_VISIBLE_ENTRIES + 2 * self.frameWidth()
        self.MAX_HEIGHT = self.sizeHintForRow(0) * self.MAX_VISIBLE_ENTRIES + 2 * self.frameWidth()

        self.setSortingEnabled(True)

    def rightClicked(self, point):
        """ Displays the right click context menu """
        actions = []

        if self.count == 0:
            return

        if len(self.selectedItems()) > 0:
            actions.append(self.selectAction)
            sep = QAction("", self.contextMenu)
            sep.setSeparator(True)
            actions.append(self.removeAction)
            actions.append(self.deleteAction)
            actions.append(sep)
            actions.append(self.selectAllAction)
            actions.append(self.removeAllAction)
            actions.append(self.deleteAllAction)

        if self.hasMissingItems:
            actions.append(self.removeMissingAction)
            sep = QAction("", self.contextMenu)
            sep.setSeparator(True)

        self.contextMenu.exec_(actions, self.mapToGlobal(point))

    def _textContainsCommands(self, text):
        """ Determines whether all objects separated by a newline character exist or not """
        objs = text.rstrip().split('\n')
        for i in range(0, len(objs)):
            # the split('.') prevents strings like 'node.attribute' to be accepted
            if len(objs[i].split('.')) != 1 or not cmds.objExists(objs[i]):
                return False
        return True

    def dragEnterEvent(self, event):
        """ Accepts drag events if the dragged event text contains only commands """
        if event.mimeData().hasText() and self._textContainsCommands(event.mimeData().text()):
            event.accept()
        else:
            event.ignore()

    def dragMoveEvent(self, event):
        """ Accepts drag move events. Validation is already done in the enter event"""
        event.accept()

    def dropEvent(self, event):
        """ Adds the dropped object names to the list group (if they are light items). This will reparent the lights within Light Editor """
        self._addOnlyLightsToSelection(event.mimeData().text().rstrip().split())

    def _addOnlyLightsToSelection(self, itemList):
        """ Adds the dropped object names to the list group (if they are light items). This will reparent the lights within Light Editor """
        editorItems = editorModel.instance().getTraversal()
        lightLookoutTable = {}
        for lightName in editorItems:
            lightLookoutTable[lightName] = True

        for itemName in itemList:
            selectionShape = cmds.listRelatives(itemName, f=True, s=True) or []
            for relativeName in selectionShape:
                if relativeName in lightLookoutTable:
                    lightItem = editorModel.LightEditor.nameToEditorItem(relativeName)
                    if lightItem:
                        oldParent = lightItem.parent()
                        oldParent.detachChild(lightItem)
                        self.item().model.appendChild(lightItem)
                        lightLookoutTable.pop(relativeName, None)
                        break
        self.repopulate()

    def addAction(self):
        selected = cmds.ls(sl=True,long=True) or []
        self._addOnlyLightsToSelection(selected)

    @undo.chunk('Light group delete action')
    def deleteEntry(self):
        editorItems = editorModel.instance().getTraversal(self.item().model)
        selectedItems = self.selectedItems()
        selectedItemsLookout = {}
        for item in selectedItems:
            selectedItemsLookout[item.text()] = True
        # Traversing the treeview in reversed pre-order allows us to safely delete items in a single pass
        for itemName in reversed(editorItems):
            if itemName in selectedItemsLookout and cmds.objExists(itemName):
                selectedItemsLookout.pop(itemName, None)
                item =  editorModel.LightEditor.nameToEditorItem(itemName)
                if item:
                    if item.isIsolateSelected():
                        item.setIsolateSelected(False)
                        item.deactivate()
                    itemModel.deleteItem(item)
            elif itemName in editorModel.LightEditorImportExportHelper.missingLightToParent:
                editorModel.LightEditorImportExportHelper.lightgroupToMissingChild.pop(itemName, None)
        self.repopulate()

    def deleteAllEntry(self):
        self.selectAll()
        self.deleteEntry()

    def selectEntry(self):
        """ Selects the selected items from the list """
        missing = []
        cmds.select(deselect=True)
        cmds.select(self.item().model.name(), add=True)
        for item in self.selectedItems():
            if cmds.objExists(item.text()):
                cmds.select(item.text(), add=True)
            else:
                missing.append(item.text())
        if len(missing) > 0:
            cmds.warning(kCouldNotSelectMissingObject % ', '.join(missing))

    def selectAllEntry(self):
        self.selectAll()
        self.selectEntry()

    def removeEntry(self):
        self._entryAction(actionType = GroupStaticSelectionWidget.kEntryActionRemoveEntry)

    def removeMissingObjects(self):
        self._entryAction(actionType = GroupStaticSelectionWidget.kEntryActionRemoveMissingObjects)

    def removeAllEntry(self):
        self._entryAction(actionType = GroupStaticSelectionWidget.kEntryActionRemoveAllEntry)

    @undo.chunk('Light group menu action')
    def _entryAction(self, actionType):
        """ Used for removal of the selected items from the list, removal of all entries from the list, or removal of all missing entries only"""
        lightEditorModel = editorModel.instance()
        groupChildrensItemList = lightEditorModel.getTraversal(self.item().model)
        nameToItem = weakref.WeakValueDictionary()

        if actionType == GroupStaticSelectionWidget.kEntryActionRemoveMissingObjects or actionType == GroupStaticSelectionWidget.kEntryActionRemoveAllEntry:
            self.selectAll()

        if actionType == GroupStaticSelectionWidget.kEntryActionRemoveEntry or actionType == GroupStaticSelectionWidget.kEntryActionRemoveAllEntry:
            for itemName in groupChildrensItemList:
                item = editorModel.LightEditor.nameToEditorItem(itemName)
                if item and  item.kTypeId == typeIDs.lightItem:
                    nameToItem[item.getLightName(fullPath= True)] = item
                if item and item.kTypeId == typeIDs.lightGroup:
                    nameToItem[item.name()] = item

        for item in self.selectedItems():
            if item.text() in nameToItem:
                itemModel = nameToItem[item.text()]
                oldParent = itemModel.parent()
                oldParent.detachChild(itemModel)
                lightEditorModel.appendChild(itemModel)

            elif item.text() in editorModel.LightEditorImportExportHelper.missingLightToParent:
                editorModel.LightEditorImportExportHelper.missingLightToParent.pop(item.text(), None)

        self.repopulate()

    def populate(self, lightGroup=None):
        # Recursively add child and child's child into the item display box
        staticSelectionList = None
        if self.count == 0:
            self.clear()
            self.setUniformItemSizes(True)
            staticSelectionList = self.item().model.getChildren()
            lightGroup = self.item().model
        else:
            staticSelectionList = lightGroup.getChildren()

        if len(staticSelectionList) != 0:
            for item in staticSelectionList:
                if item.kTypeId == typeIDs.lightItem:
                    self.count += 1
                    self.addItem(item.getLightName(fullPath= True))

                if item.kTypeId == typeIDs.lightGroup:
                    self.count += 1
                    self.addItem(item.name())
                    self.populate(lightGroup = item)

        #Populating missing items as strike out
        if lightGroup.originalImportName and editorModel.LightEditorImportExportHelper.lightgroupToMissingChild and lightGroup.originalImportName in editorModel.LightEditorImportExportHelper.lightgroupToMissingChild:
            missingList = editorModel.LightEditorImportExportHelper.lightgroupToMissingChild[lightGroup.originalImportName]
            for missingLightName in missingList:
                if missingLightName in editorModel.LightEditorImportExportHelper.missingLightToParent:
                    self.hasMissingItems = True
                    self.count += 1
                    newLabel = QListWidgetItem(missingLightName)
                    font = newLabel.font()
                    font.setStrikeOut(True)
                    newLabel.setFont(font)
                    newLabel.setForeground(Qt.gray)
                    self.addItem(newLabel)

        contentSizeHeight = self.sizeHintForRow(0) * self.count + 2 * self.frameWidth()
        contentSizeHeight = self.INITIAL_HEIGHT if contentSizeHeight < self.INITIAL_HEIGHT else self.MAX_HEIGHT if contentSizeHeight > self.MAX_HEIGHT else contentSizeHeight
        self.setFixedHeight(contentSizeHeight)

    def repopulate(self):
        self.hasMissingItems = False
        self.count = 0
        self.populate()

    def paintEvent(self, e):
        """ Overrides the paint event to make it so that place holder text is displayed when the list is empty. """
        super(GroupStaticSelectionWidget, self).paintEvent(e)
        # If empty, add default empty text
        if self.count == 0:
            painter = QPainter(self.viewport())
            oldPen = painter.pen()
            painter.setPen(self.PLACEHOLDER_TEXT_PEN_ENABLED)
            painter.drawText(self.contentsRect(), Qt.AlignCenter | Qt.TextWordWrap, maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kDragObjectsUsingOutlinerSelectFromViewportOrAddWithLightEditor' ])
            painter.setPen(oldPen)

    def sizeHintForRow(self, row):
        return self.ROW_HEIGHT

class GroupProperties(MayaQWidgetBaseMixin, QGroupBox):
    """
    This class represents the property editor view of a light editor group item.
    """
    LIST_BOX_HEIGHT = utils.dpiScale(100)
    EXPRESSION_BUTTON_WIDTH = utils.dpiScale(50)
    MAYA_HIGHLIGHTED_COLOR = [0.322,0.52,0.65]

    def __init__(self, item, parent):
        super(GroupProperties, self).__init__(parent=parent)
        self.item = weakref.ref(item)

        layout = QVBoxLayout()
        layout.setObjectName('light_editor_group_vertical_box_layout')
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(utils.dpiScale(2))

        self._setupMainGroupBox(layout)
        self.setLayout(layout)
        self.propertyEditor = parent

        # Unwrap the layout into a pointer to be able to get the UI name.
        # We use fullName() to ensure a unique name is used
        layoutName = OpenMayaUI.MQtUtil.fullName(int(getCppPointer(layout)[0]))
        cmds.setParent(layoutName)

        self._uiLayout = cmds.columnLayout(adjustableColumn=True, width=self.EXPRESSION_BUTTON_WIDTH)
        #Adding pin icon
        self._pinLayout = cmds.columnLayout(adjustableColumn=False, width=utils.dpiScale(10))
        pinValue = True if self.item().model.name() in self.propertyEditor.pinnedItemsLightEditor else False
        cmds.iconTextCheckBox(parent= self._pinLayout, style='iconOnly', image1 = ":/pinItem.png", ebg = pinValue, backgroundColor= self.MAYA_HIGHLIGHTED_COLOR,
            changeCommand =partial(self._pinControlGrpChanged))
        self._createAttributeControls()

        # Adding the title
        addToCollectionGroupBox = QGroupBox(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kTitle' ])
        font = QFont()
        font.setBold(True)
        addToCollectionGroupBox.setFont(font)
        addToCollectionGroupBox.setContentsMargins(0, utils.dpiScale(12), 0, 0)
        addToCollectionGroupBoxLayout = Layout()
        addToCollectionGroupBoxLayout.setVerticalSpacing(utils.dpiScale(2))
        addToCollectionGroupBox.setLayout(addToCollectionGroupBoxLayout)
        layout.addWidget(addToCollectionGroupBox)

        # Adding the contain box
        self.staticSelector = GroupStaticSelectionWidget(item)
        self.staticSelector.setFixedHeight(self.LIST_BOX_HEIGHT)
        self.staticSelector.populate()
        staticSelectionWidget = QWidget()
        staticSelectionLayout = QHBoxLayout()
        staticSelectionLayout.setContentsMargins(0, 0, 0, 0)
        staticSelectionLayout.setSpacing(utils.dpiScale(2))
        staticSelectionLayout.addWidget(self.staticSelector)

        # Adding the menu buttons
        dragDropButtonLayout = QVBoxLayout()
        dragDropButtonLayout.setSpacing(utils.dpiScale(2))
        dragDropButtonLayout.setContentsMargins(0, 0, 0, 0)
        addButton = QPushButton(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kAdd'])
        addButton.setToolTip(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kAddTooltipStr'])
        addButton.setMinimumWidth(self.EXPRESSION_BUTTON_WIDTH)
        addButton.clicked.connect(self.staticSelector.addAction)
        dragDropButtonLayout.addWidget(addButton)
        removeButton = QPushButton(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kRemove' ])
        removeButton.setToolTip(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kRemoveTooltipStr' ])
        removeButton.setMinimumWidth(self.EXPRESSION_BUTTON_WIDTH)
        removeButton.clicked.connect(self.staticSelector.removeEntry)
        dragDropButtonLayout.addWidget(removeButton)
        dragDropButtonLayout.addStretch(1)
        selectButton = QPushButton(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kSelect'])
        selectButton.setToolTip(maya.stringTable['y_maya_app_renderSetup_lightEditor_views_properties.kSelectTooltipStr'])
        selectButton.setMinimumWidth(self.EXPRESSION_BUTTON_WIDTH)
        selectButton.clicked.connect(self.staticSelector.selectEntry)
        dragDropButtonLayout.addWidget(selectButton)
        dragDropButtonWidget = QWidget()
        staticSelectionLayout.addWidget(dragDropButtonWidget)
        dragDropButtonWidget.setLayout(dragDropButtonLayout)
        staticSelectionWidget.setLayout(staticSelectionLayout)

        layout.addWidget(staticSelectionWidget)

    def _setupMainGroupBox(self, layout):
        mainGroupBox = QGroupBox()
        mainGroupBox.setContentsMargins(0, 0, 0, 0)
        mainGroupBoxLayout = Layout()
        mainGroupBoxLayout.setVerticalSpacing(utils.dpiScale(2))
        mainGroupBox.setLayout(mainGroupBoxLayout)
        layout.addWidget(mainGroupBox)

    def _createAttributeControls(self):
        ctrl = cmds.checkBoxGrp(label="", numberOfCheckBoxes=2, label1=kEnable, label2=kIsolate)
        cmds.connectControl(ctrl, self.item().model.name() + ".selfEnabled", index=2)
        cmds.connectControl(ctrl, self.item().model.name() + ".isolateSelected", index=3)

    def _pinControlGrpChanged(self, *args):
        from maya.app.renderSetup.views.propertyEditor.main import PropertyEditor
        if self.item():
            pinValue = True if self.item().model.name() in PropertyEditor.pinnedItemsLightEditor else False
            PropertyEditor.pinListChanged(not pinValue, self.item().model.name())
        self.propertyEditor.triggerRebuild()

# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
