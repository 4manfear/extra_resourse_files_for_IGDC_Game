"""The parent class for groups and collections"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


from builtins import next
import re
import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya

import maya.app.renderSetup.model.nodeList as nodeList
import maya.app.renderSetup.model.utils as utils
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.model.undo as undo
import maya.app.renderSetup.model.override as override
import maya.app.renderSetup.model.overrideUtils as overrideUtils
import maya.app.renderSetup.model.childNode as childNode
import maya.app.renderSetup.model.namespace as namespace
import maya.app.renderSetup.model.clipboardData as clipboardData
import maya.app.renderSetup.model.traverse as traverse
import maya.app.renderSetup.common.utils as commonUtils
import maya.app.renderSetup.model.enabled as computeEnabled

import maya.app.renderSetup.model.jsonTranslatorUtils as jsonTranslatorUtils

import maya.app.renderSetup.common.profiler as profiler
import maya.app.renderSetup.model.context as context
from functools import reduce

# List all error messages below
kInvalidChildName          = maya.stringTable['y_maya_app_renderSetup_model_container.kInvalidChildName'          ]
kUnknownChild              = maya.stringTable['y_maya_app_renderSetup_model_container.kUnknownChild'              ]

# List of undo messages
kChildAttached = maya.stringTable['y_maya_app_renderSetup_model_container.kChildAttached' ]
kChildDetached = maya.stringTable['y_maya_app_renderSetup_model_container.kChildDetached' ]
kSet           = maya.stringTable['y_maya_app_renderSetup_model_container.kSet'           ]

class Container(nodeList.ListBase, childNode.TreeOrderedItem,
                 childNode.ChildNode):
    """
    Container node.

    A container has an ordered list of children (groups or collections)

    """

    kTypeId = typeIDs.container
    kTypeName = 'RScontainer'
    kGroupTypeName = 'group'
    kCollectionTypeName = 'collection'

    # Attributes for container as list of children.
    #
    # Connections to lowest-priority and highest-priority child
    # on children linked list.  The lowest-priority child
    # is considered to be the front of the list, and the highest-priority
    # child the back of the list.
    childLowest  = OpenMaya.MObject()
    childHighest = OpenMaya.MObject()

    # Connection to all children in the list.
    children = OpenMaya.MObject()

    # Enabled behavior.  See enabled module for documentation.
    enabled       = OpenMaya.MObject()
    selfEnabled   = OpenMaya.MObject()
    parentEnabled = OpenMaya.MObject()

    # isolateSelected flag as attribute.
    isolateSelected = OpenMaya.MObject()

    # The number of isolate selected children in a container's subtree.
    numIsolatedChildren = OpenMaya.MObject()

    # The number of isolate selected ancestors of this container.
    numIsolatedAncestors = OpenMaya.MObject()

    @staticmethod
    def initializer():

        # A container is a render layer list element.
        # inheritAttributesFrom() must be called before adding any other
        # attributes.
        Container.inheritAttributesFrom(nodeList.ListItem.kTypeName)

        # A container is a list of children.
        Container.children = Container.initListItems()

        Container.childLowest = utils.createDstMsgAttr(
            'childLowest', 'cl')
        Container.addAttribute(Container.childLowest)

        Container.childHighest = utils.createDstMsgAttr(
            'childHighest', 'ch')
        Container.addAttribute(Container.childHighest)

        # Set up enabled attribute.
        computeEnabled.initializeAttributes(Container)

        # Add isolateSelected attribute
        Container.numIsolatedChildren = computeEnabled.createNumIsolatedChildrenAttribute()
        Container.addAttribute(Container.numIsolatedChildren)

        Container.numIsolatedAncestors = computeEnabled.createHiddenIntAttribute(
            "numIsolatedAncestors", "nia")
        Container.addAttribute(Container.numIsolatedAncestors)

        # Add isolateSelected attribute
        numAttrFn = OpenMaya.MFnNumericAttribute()
        Container.isolateSelected = numAttrFn.create("isolateSelected", "is", OpenMaya.MFnNumericData.kBoolean, 0)
        numAttrFn.storable = True
        numAttrFn.keyable = False
        numAttrFn.readable = True
        numAttrFn.writable = True
        numAttrFn.hidden = True
        OpenMaya.MPxNode.addAttribute(Container.isolateSelected)

        Container.attributeAffects(Container.numIsolatedChildren, Container.enabled)
        Container.attributeAffects(Container.numIsolatedAncestors, Container.enabled)
        Container.attributeAffects(Container.isolateSelected, Container.enabled)

    def isGroup(self):
        return False

    def isCollection(self):
        return False

    def getRenderLayer(self):
        # For hierarchical containers the parent
        # could be another container, otherwise
        # the parent is always the render layer
        parent = self.parent()
        if isinstance(parent, Container):
            return parent.getRenderLayer()
        return parent

    def itemChangedRecursive(self):
        for n in nodeList.forwardListGenerator(self):
            n.itemChangedRecursive()
        self.itemChanged()

    def _computeIsolatedAncestors(self):
        return reduce(
            lambda nb, c: nb + 1 if c.isIsolateSelected() else nb,
            self.ancestorContainers(), 0)

    def _updateAncestorsIsolatedChildren(self, val):
        layer = self.getRenderLayer()
        if layer:
            layer._updateIsolateSelected(val)
        for c in self.ancestorContainers():
            c._updateNumIsolatedChildren(val)

    def setIsolateSelected(self, value):
        if value != self.isIsolateSelected() and not cmds.about(batch=True):
            with undo.NotifyCtxMgr(kSet % (self.name(), 'isolateSelected', value), self._notifyLayerIsolateSelectedChanged):
                with undo.NotifyDecorateMgr(None, context.beforeIsolated(self), context.afterIsolated(self)):
                    # Change this to just isolate all the children if you're turning on an isolation
                    cmds.setAttr(self._getIsolatePlug().name(), value)
                    self._updateIsolateSelected(1 if value else -1)

    def _notifyLayerIsolateSelectedChanged(self):
        layer = self.getRenderLayer()
        if layer:
            layer._containerChanged(self)
            layer.itemChangedRecursive()

    def isIsolateSelected(self, dataBlock=None):
        """ Get if isolate selected. Will always return False in batch mode """
        return False if cmds.about(batch=True) else self._getInputAttr(self.isolateSelected, dataBlock).asBool()

    def getLayerNumIsolatedChildren(self):
        return OpenMaya.MPlug(self.thisMObject(), Container.layerNumIsolatedChildren).asInt()

    def _getNumIsolatedChildrenPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Container.numIsolatedChildren)

    def getNumIsolatedChildren(self, includeSelf=False):
        nic = self._getNumIsolatedChildrenPlug().asInt()
        if includeSelf and self.isIsolateSelected():
            nic += 1
        return nic

    def _getNumIsolatedAncestorsPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Container.numIsolatedAncestors)

    def getNumIsolatedAncestors(self):
        return self._getNumIsolatedAncestorsPlug().asInt()

    # See comments in RenderLayer._updateIsolateSelected.
    def _updateNumIsolatedChildren(self, val):
        # Use a command to support the undo mechanism
        if val != 0:
            newVal = self.getNumIsolatedChildren() + val
            cmds.setAttr(self._getNumIsolatedChildrenPlug().name(), newVal)

    def _updateNumIsolatedAncestors(self, val):
        # Use a command to support the undo mechanism
        if val != 0:
            newVal = self.getNumIsolatedAncestors() + val
            cmds.setAttr(self._getNumIsolatedAncestorsPlug().name(), newVal)

    def _updateIsolateSelected(self, val):
        self._updateAncestorsIsolatedChildren(val)
        self._updateChildrenIsolatedAncestors(val)


    def _connectSelfLayerIsolatedChildren(self, layer):
        if layer:
            # Use existing command for undo / redo purposes.
            cmds.connectAttr(layer.name() + '.numIsolatedChildren',
                             self.name() + '.parentNumIsolatedChildren')

    def _disconnectSelfLayerIsolatedChildren(self, layer):
        if layer:
            # Use existing command for undo / redo purposes.
            cmds.disconnectAttr(layer.name() + '.numIsolatedChildren',
                                self.name() + '.parentNumIsolatedChildren')

    @undo.chunk('Create and append a child group')
    def createGroup(self, groupName, typeName=kGroupTypeName):
        """ Add a child group to the container. """
        col = create(groupName, typeName, parent=self)
        self.appendChild(col)
        return col

    @undo.chunk('Create and append a child collection')
    def createCollection(self, collectionName, typeName=kCollectionTypeName):
        col = create(collectionName, typeName, parent=self)
        self.appendChild(col)
        return col

    def getChildren(self, cls=childNode.ChildNode):
        """ Get the list of all children.
        Optionally only the children matching the given class. """
        return list(nodeList.forwardListNodeClassGenerator(self, cls))

    def getContainers(self):
        return self.getChildren(cls=Container)

    def hasChildren(self):
        return self.findChild(lambda child: True) is not None

    def findChild(self, predicate, creator=None):
        '''Find the child of this container satisfying the predicate function or creates it
        with the creator function if not found and a creator function is specified.
        Function signatures are:
          predicate(childNode): returns boolean.
          creator(void) : returns the created node.'''
        for child in nodeList.forwardListNodeClassGenerator(self, childNode.ChildNode):
            if predicate(child):
                return child
        if not creator:
            return None
        child = creator()
        self.appendChild(child)
        return child

    def getChild(self, childName, cls=childNode.ChildNode):
        """ Look for an existing child by name and optionally class.

            @type childName: string
            @param childName: Name of child to look for
            @type cls: class name
            @param cls: Class name for the type of class to look for
            @rtype: Child model instance
            @return: Found instance or throw an exception
        """
        if not childName:
            raise Exception(kInvalidChildName)

        for child in nodeList.forwardListNodeClassGenerator(self, cls):
            if child.name() == childName:
                return child

        raise Exception(kUnknownChild % (childName, self.name()))

    def _attach(self, layer):
        """Attach this container."""

        self._connectLayerIsolatedChildren(layer)

        # Number of isolated children doesn't change when we attach.
        # Update isolated children of our ancestors.
        self._updateAncestorsIsolatedChildren(self.getNumIsolatedChildren(includeSelf=True))

        # Update isolated ancestors of ourselves and our children.
        self._updateChildrenIsolatedAncestors(self._computeIsolatedAncestors(), includeSelf=True)

    def _childAttached(self, child):
        '''Perform work to attach a child.

        The child has already been added to container's list when this
        method is called.'''

        with undo.NotifyCtxMgr(kChildAttached % (self.name(), child.name()), self.itemChanged):
            # Once inserted, hook up the child's parentEnabled input to our
            # enabled output.  Use existing command for undo / redo purposes.
            cmds.connectAttr(self.name() + '.enabled',
                             child.name() + '.parentEnabled')

            if child.isCollection():
                # Find the closest parent collection to attach the selector
                current = self
                while not current.hasSelector() and current.parent():
                    current = current.parent()

                if current and current.isCollection() and child.getSelector():
                    child.getSelector().setParent(current.getSelector())

            if isinstance(child, Container):
                child._attach(self.getRenderLayer())

            layer = self.getRenderLayer()
            if layer:
                layer.descendantAdded(child)

    def acceptImport(self):
        super(Container, self).acceptImport()
        for child in self.getChildren():
            child.acceptImport()

    @undo.chunk('Detach from container')
    def detachChild(self, child):
        """ Detach a child whatever its position. """
        unapply(child) # NoOp if not applied; otherwise commands are used
        # Must perform detach operations before removing from list,
        # otherwise parenting information is gone.
        self._detachChild(child)
        nodeList.remove(self, child)

    def _detachChild(self, child):
        '''Perform work to detach a child.

        The child has not yet been removed from the container's list when
        this method is called.'''

        with undo.NotifyCtxMgr(kChildDetached % (self.name(), child.name()), self.itemChanged):
            # Disconnect the child's parentEnabled input from our enabled
            # output.  Use existing command for undo / redo purposes.
            childParentEnabled = child.name() + '.parentEnabled'
            cmds.disconnectAttr(self.name() + '.enabled', childParentEnabled)

            # Child parentEnabled will retain its last value, so set it
            # to True in case the container gets parented to the render layer.
            cmds.setAttr(childParentEnabled, 1)

            # Handle unknown selector type (e.g. from unavailable plugin)
            # gracefully.
            if child.isCollection() and child.getSelectorType() is not None:
                child.getSelector().setParent(None)

            if isinstance(child, Container):
                child._detach(self.getRenderLayer())

    def _detach(self, layer):
        """Detach this container."""
        self._disconnectLayerIsolatedChildren(layer)

        # Number of isolated children doesn't change when we detach.
        # Update isolated children of our ancestors.
        self._updateAncestorsIsolatedChildren(-self.getNumIsolatedChildren(includeSelf=True))

        # Update isolated ancestors of ourselves and our children.
        self._updateChildrenIsolatedAncestors(-self.getNumIsolatedAncestors(), includeSelf=True)

    def _getInputAttr(self, attr, dataBlock=None):
        return dataBlock.inputValue(attr) if dataBlock else OpenMaya.MPlug(self.thisMObject(), attr)

    def _getSelfEnabledPlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Container.selfEnabled)

    def _getIsolatePlug(self):
        return OpenMaya.MPlug(self.thisMObject(), Container.isolateSelected)

    def hasIsolatedAncestors(self, dataBlock=None):
        return self._getInputAttr(self.numIsolatedAncestors, dataBlock).asInt() > 0

    def hasIsolatedChildren(self, dataBlock=None):
        return self._getInputAttr(self.numIsolatedChildren, dataBlock).asInt() > 0

    def _preChildDelete(self, child):
        # Private interface for child to inform its parent that it is
        # about to be deleted.  Remove the child from our list.
        self.detachChild(child)

    def _importChild(self, childName, nodeType, selArgs=None):
        name = cmds.createNode(nodeType, name=childName, skipSelect=True)
        child = utils.nameToUserNode(name)
        # Only Collections have selectors
        if child.isCollection():
            child._createSelector(None, selArgs)
        self.appendChild(child)
        return child

    def compute(self, plug, dataBlock):
        if plug == self.enabled:
            # We are enabled if:
            #
            # o The normal enabled computation is true (self enabled is true AND
            #   parent enabled is true).
            #
            # AND
            #
            # o We're in batch mode OR
            # o No node is isolated OR
            # o This node is isolated OR
            # o This node has isolate selected children OR
            # o This node has isolate selected ancestors.
            #
            value = computeEnabled.computeEnabled(self, dataBlock) and \
                (cmds.about(batch=True) or \
                dataBlock.inputValue(self.layerNumIsolatedChildren).asInt()==0 or \
                self.isIsolateSelected(dataBlock) or \
                self.hasIsolatedAncestors(dataBlock) or \
                self.hasIsolatedChildren(dataBlock))
            computeEnabled.setEnabledOutput(self, dataBlock, value)

            # The plug was successfully computed
            return self

        # Let the Maya parent class compute the plug
        return None

    def enabledChanged(self):
        layer = self.getRenderLayer()
        if layer:
            layer._containerChanged(self)
        self.itemChangedRecursive()

    def isEnabled(self, dataBlock=None):
        return self._getInputAttr(self.enabled, dataBlock).asBool()

    def isSelfEnabled(self, dataBlock=None):
        return self._getInputAttr(self.selfEnabled, dataBlock).asBool()

    def setSelfEnabled(self, value):
        if value != self.isSelfEnabled():
            # pulling isEnabled will trigger enabledChanged
            # (no matter if enable output value has changed or not)
            with undo.NotifyCtxMgr(kSet % (self.name(), 'enabled', value), self.enabledChanged):
                with undo.NotifyDecorateMgr(None, context.beforeEnabled(self), context.afterEnabled(self)):
                    cmds.setAttr(self.name()+".selfEnabled", 1 if value else 0)

    @context.applyContainer
    def apply(self):
        """ Apply all children in this container. """
        with profiler.ProfilerMgr('Container::apply'):
            # Apply all our children to the selection
            for child in nodeList.forwardListGenerator(self):
                child.apply()

    @context.applyContainer
    def postApply(self):
        '''Post applies all children in this container. This function may be called to apply a container (with contained overrides)
        after the layer was set visible. It allows inserting new overrides in the currently visible layer
        without the need to toggle visibility.'''
        with profiler.ProfilerMgr('Container::postApply'):
            # Post apply all our children
            for child in nodeList.forwardListGenerator(self):
                child.postApply()

    @context.unapplyContainer
    def unapply(self):
        """Unapply all children in this container."""
        with profiler.ProfilerMgr('Container::unapply'):
            for child in nodeList.reverseListGenerator(self):
                child.unapply()

    @context.updateContainer
    def update(self):
        with profiler.ProfilerMgr('Container::update'):
            for n in nodeList.forwardListGenerator(self):
                n.update()

    # Container interface as list of children.
    # These methods implement the list requirements for the nodeList module.
    #
    # The list front and back are destination plugs connected to the child
    # node's message plug (which is a source).
    def _getFrontAttr(self):
        return Container.childLowest

    def _getBackAttr(self):
        return Container.childHighest

    def _getListItemsAttr(self):
        return Container.children

    def _selectorChanged(self):
        """Selector of this container changed.

        Identical to _selectedNodesChanged(), except that the itemChanged()
        notification is given with selectorChanged=True."""
        layer = self.getRenderLayer()
        if layer:
            layer._selectedNodesChanged(self)
        current = self
        while not current.hasSelector():
            current = current.parent()
        current.itemChanged(selectorChanged=True)

    def _selectedNodesChanged(self):
        """ Ownership of this container or one of its children changed """
        layer = self.getRenderLayer()
        if layer:
            layer._selectedNodesChanged(self)
        self.itemChanged()

    def activate(self):
        '''
        Called when this list item is inserted into the list.
        Override this method to do any scene specific initialization.
        '''
        if self.getSelector():
            self.getSelector().activate()

    def deactivate(self):
        '''
        Called when this list item is removed from the list.
        Override this method to do any scene specific teardown.
        '''
        # Handle unknown selector type (e.g. from unavailable plugin)
        # gracefully.
        if self.getSelector() and self.getSelectorType():
            self.getSelector().deactivate()

    def overridesConnections(self):
        for n in nodeList.forwardListGenerator(self):
            if n.overridesConnections():
                return True
        return False

    def _decodeChildren(self, children, mergeType, prependToName):
        jsonTranslatorUtils.decodeObjectArray(children,
                                              jsonTranslatorUtils.MergePolicy(self.getChild,
                                                                              self._importChild,
                                                                              mergeType,
                                                                              prependToName))

    def isAcceptableChild(self, modelOrData):
        """ Check if the model could be a child"""
        if isinstance(modelOrData, clipboardData.ClipboardData):
            isOverride = modelOrData.typeName() in _overrideTypes
            parentTypeName = modelOrData.parentTypeName
        else:
            isOverride = isinstance(modelOrData, override.Override)
            parentTypeName = modelOrData.parent().typeName()

        return (isOverride and parentTypeName == self.typeName()) or \
                (modelOrData.typeName() == self.typeName() and self.isSelfAcceptableChild()) or \
                (modelOrData.typeName() == Container.kGroupTypeName) or \
                (modelOrData.typeName() == Container.kCollectionTypeName)

    def isSelfAcceptableChild(self):
        """Overridden instances that return False, prevent copy/paste of the container type to itself."""
        return True

    def isTopLevel(self):
        """Is the container's parent a render layer?"""
        # Don't have access to renderLayer.RenderLayer, type check on
        # container instead.
        return not isinstance(self.parent(), Container)

    def isEmptyRecursive(self):
        """ Return whether or not the container or any of its parents is empty """
        # Base Case 1: if the current container's selector is empty, then the
        # container is obviously empty, meaning that there is no need to look
        # at its parents.
        # Base Case 2: if the current container's parent is not a container,
        # than False will be returned since we already established that the
        # current container is not empty and it has no parent container.
        # Recursive Case: if the current container does not have an empty
        # selector and has a parent container, then we return whether or not
        # any of its parents are empty. (any one parent container with an
        # empty selector results in the current container being empty)
        return (self.getSelector() and self.getSelector().isEmpty()) or \
               (isinstance(self.parent(), Container) and self.parent().isEmptyRecursive())

    def isTraversingConnections(self):
        return self.getSelector() and self.getSelector().isTraversingConnections()

    def hasOverridesRecursive(self):
        return next(utils.getOverridesRecursive(self), None) is not None

    def _updateChildrenIsolatedAncestors(self, val, includeSelf=False):
        # Tell descendants there has been a change in their ancestors'
        # isolate select.
        for c in traverse.depthFirst(self, containers):
            if c is self and not includeSelf:
                continue
            c._updateNumIsolatedAncestors(val)

    def _connectLayerIsolatedChildren(self, layer):
        # Connect subtree to layer's isolated children attribute.
        if layer:
            for c in traverse.depthFirst(self, containers):
                c._connectSelfLayerIsolatedChildren(layer)

    def _disconnectLayerIsolatedChildren(self, layer):
        # Disconnect subtree from layer's isolated children attribute.
        if layer:
            for c in traverse.depthFirst(self, containers):
                c._disconnectSelfLayerIsolatedChildren(layer)

    def ancestorContainers(self):
        """Return this container's ancestors.

        Neither the container itself, nor the render layer, are included
        in the ancestors.  Therefore, a top-level container has no
        ancestors."""

        parent = self.parent()
        while isinstance(parent, Container):
            yield parent
            parent = parent.parent()

@undo.chunk('Create container')
@namespace.root
def create(name, nodeType, parent=None, **selArgs):
    """ Create a container.

    Returns the MPxNode object corresponding to the created
    container node.  A RuntimeError is raised in case of error.
    The selArgs keyword arguments are passed along to the selector creation.

    This function is undoable.

    """
    # container names should never contain namespace delimiter or other invalid characters
    # container belong to current namespace (i.e. root)
    name = re.sub(r'[^a-zA-Z0-9_]', '_', name)
    from sys import version_info as sys_version_info
    string_type = str if sys_version_info[0] >= 3 else basestring
    if isinstance(nodeType, string_type):
        typeName = nodeType
    else:
        typeName = cmds.objectType(typeFromTag=nodeType.id())

    # To avoid writing a command to implement container creation,
    # re-use existing name-based commands for undo / redo purposes, since
    # container creation is not performance-critical.  If the name
    # flag is specified, it cannot be an empty string.

    returnContainerName = cmds.createNode(
        typeName, name=name, skipSelect=True) if name else \
        cmds.createNode(typeName, skipSelect=True)
    container = utils.nameToUserNode(returnContainerName)

    # Groups do not have selectors
    if str(nodeType) != Container.kGroupTypeName:
        container._createSelector(parent=parent, selArgs=selArgs)

    return container

@undo.chunk('Delete container')
def delete(container):
    """Remove the argument container from the scene.

    All overrides and children in the container are removed."""

    # Inform our parent (if any) of upcoming delete.
    # This will remove the container from its parent,
    # and will trigger deactivation of the container
    # causing it and the selector to stop listening to scene and attribute changes.
    # Need to call _preChildDelete before removing children, otherwise we lose the parenting information
    # to the children which may be used by the parent (ex: renderLayers use that information
    # to determine if they need to be refreshed).

    if not container:
        return

    parent = container.parent()
    if parent:
        parent._preChildDelete(container)

    # Delete the children
    for child in container.getChildren():
        if isinstance(child, Container):
            delete(child)
        elif isinstance(child, override.Override):
            override.delete(child)

    # Deleting the selector means unhooking the selector node
    # from the collection and removing it from the scene.
    # Only collections have selectors
    if container.isCollection():
        container._deleteSelector()

    # Deleting the node will remove it from the scene.
    utils.deleteNode(container)

@undo.chunk('Unapply a container')
def unapply(container):
    ''' Command to unapply a container '''
    if isinstance(container, Container):
        for c in container.getChildren():
            unapply(c)
    else:
        # End of recursion so unapply the override
        #  using a command
        override.UnapplyCmd.execute(container)

def getAllContainerClasses():
    """ Returns the list of Container subclasses """
    return commonUtils.getSubClasses(Container)

def containers(c):
    return c.getContainers()

_overrideTypes = { o.kTypeName for o in overrideUtils.getAllOverrideClasses() }
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
