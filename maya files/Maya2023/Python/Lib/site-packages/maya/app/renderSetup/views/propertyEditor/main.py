import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import range
from functools import partial
import weakref

from maya.app.general.mayaMixin import MayaQWidgetDockableMixin

import PySide2.QtCore as QtCore
from PySide2.QtCore import QPersistentModelIndex, QSize, Slot, QItemSelection, QTimer
from PySide2.QtGui import QStandardItem
from PySide2.QtWidgets import QScrollArea, QVBoxLayout, QWidget, QWidgetItem

import maya.cmds as cmds
import maya.api.OpenMaya as OpenMaya

from maya.app.renderSetup.views.frameLayout import FrameLayout
from maya.app.renderSetup.views.propertyEditor.override import Override
from maya.app.renderSetup.views.propertyEditor.renderLayer import RenderLayer
from maya.app.renderSetup.lightEditor.views.properties import LightProperties
from maya.app.renderSetup.lightEditor.views.properties import GroupProperties

import maya.app.renderSetup.views.propertyEditor.containerFactory as containerFactory

import maya.app.renderSetup.views.proxy.renderSetup as renderSetup
import maya.app.renderSetup.views.proxy.renderSetupRoles as renderSetupRoles
import maya.app.renderSetup.views.utils as utils
import maya.app.renderSetup.lightEditor.views.proxy as lightEditor
import maya.app.renderSetup.model.renderSetup as renderSetupModel
import maya.app.renderSetup.model.plug as plug
import maya.app.renderSetup.model.typeIDs as typeIDs
import maya.app.renderSetup.common.utils as commonUtils

kWarningPropagateLightValueChange = maya.stringTable['y_maya_app_renderSetup_views_propertyEditor_main.kWarningPropagateLightValueChangeStr' ]

class PropertyEditorScrollArea(QScrollArea):
    STARTING_SIZE = QSize(450, 600)

    def sizeHint(self):
        return utils.dpiScale(self.STARTING_SIZE)

class PropertyEditor(MayaQWidgetDockableMixin, QWidget):
    """
    This class represents the property editor which displays the selected render setup item's property information.


    Note: The Qt should never called any 'deferred' actions because all the design is based on synchronous notifications
          and any asynchronous events will change the order of execution of these events.

          For example when the selection in the Render Setup Window is changed (so the Property Editor must be updated).
          The delete must be synchronous on the 'unselected' layouts otherwise they will be updated along with selected ones.
          The two main side effects are that lot of unnecessary processings are triggered (those one the deleted layouts)
          and the infamous 'C++ already deleted' issue appears because the Data Model & Qt Model objects were deleted
          but not their corresponding Layout (instance used by the Property Editor to display a render setup object).
    """

    width = cmds.optionVar(query='workspacesWidePanelInitialWidth')
    PREFERRED_SIZE = QSize(width, 600)
    MINIMUM_SIZE = QSize((width * 0.75), 0)
    MAX_INCREMENTAL_LOAD_ITEMS = 20
    MINIMUM_DISTANCE_TO_START_DYNAMIC_SCROLL = 50

    pinnedItemsLightEditor = {}

    @staticmethod
    def pinListChanged(boolVal, groupName):
        """ User may pin and unpin items in light editor's property. Pinned items are displayed even when they are not selected"""
        if boolVal:
            PropertyEditor.pinnedItemsLightEditor[groupName] = True
        else:
            PropertyEditor.pinnedItemsLightEditor.pop(groupName, None)

    def __init__(self, treeView, parent, observeRenderSetup=True):
        super(PropertyEditor, self).__init__(parent=parent)
        self.observeRenderSetup = observeRenderSetup
        self.needsRebuild = None
        self.itemsToRepopulate = None
        self.rebuildInProgress = None
        self.preferredSize = self.PREFERRED_SIZE
        PropertyEditor.pinnedItemsLightEditor = {}

        self.treeView = weakref.ref(treeView)
        self.model = weakref.ref(treeView.model())

        # Name the Property Editor according to what is being observed,
        # either Render Setup or the Light Editor.
        if observeRenderSetup:
            self.setWindowTitle(maya.stringTable['y_maya_app_renderSetup_views_propertyEditor_main.kPropertyEditorRenderSetup' ])
        else:
            self.setWindowTitle(maya.stringTable['y_maya_app_renderSetup_views_propertyEditor_main.kPropertyEditorLightEditor' ])

        self.scrollArea = PropertyEditorScrollArea(self)
        self.scrollAreaLayout = QVBoxLayout(self)
        self.scrollArea.setLayout(self.scrollAreaLayout)
        self.scrollWidget = QWidget(self)
        self.scrollArea.setWidget(self.scrollWidget)
        self.scrollArea.setWidgetResizable(True)
        self.scrollWidgetLayout = QVBoxLayout(self)
        self.scrollWidget.setLayout(self.scrollWidgetLayout)

        layout = QVBoxLayout(self)
        layout.setContentsMargins(0,0,0,0)
        layout.addWidget(self.scrollArea, 0)
        self.setLayout(layout)

        self.frameLayouts = []

        self.setAcceptDrops(True)

        self._registered = False
        self._register()

        """ Performance degrades if the user tries to display 200+ light sources on screen with multiselect.
        This method set up a dynamic Just-In-Time scroll functionality, i.e. display items dynamically. As the user scrolls down, load more items."""
        self.createScrollConnector()
        self.appendItemsInProgress = False

        self._currentItemDisplayedCount = 0
        self._maxItemToDisplay = 0
        self._sortedSelectedIndexesCache = []

        if self.observeRenderSetup:
            renderSetupModel.addObserver(self)

    def __del__(self):
        """ This is a workaround for a runtime error raised when the window is closed.
        'Internal C++ object (PropertyEditor) already deleted.
        See MAYA-82966 for details. """
        pass

    def _register(self):
        if not self._registered:
            self.model().itemChanged.connect(self.itemChanged)
            self.rebuildInProgress = False
            self.itemsToRepopulate = [] # List of items waiting to be repopulated
            self.needsRebuild = False

            selectionModel = self.treeView().selectionModel()
            selectionModel.selectionChanged.connect(self.selectionChanged)
            self._registered = True

    def _unregister(self):
        if self._registered:
            self.model().itemChanged.disconnect()
            self.rebuildInProgress = False
            self.itemsToRepopulate = [] # List of items waiting to be repopulated
            self.needsRebuild = False

            selectionModel = self.treeView().selectionModel()

            # The following more obvious implementation:
            #
            # selectionModel.selectionChanged.disconnect(self.selectionChanged)
            #
            # raises
            #
            # // Error: line 0: RuntimeError: file renderSetup\views\propertyEditor\main.py line 103: Failed to disconnect signal selectionChanged(QItemSelection,QItemSelection). //
            #
            # which comes from PySide2's CPython implementation, in file
            # pysidesignal.cpp, function signalInstanceDisconnect().  The
            # argument slot is not recognized, and the function fails.
            # Use old-style disconnection as a workaround.

            selectionModel.disconnect(
                QtCore.SIGNAL(
                    'selectionChanged(QItemSelection,QItemSelection)'),
                self, QtCore.SLOT(
                    'selectionChanged(QItemSelection,QItemSelection)'))

            self._registered = False

    def setSizeHint(self, size):
        self.preferredSize = size

    def sizeHint(self):
        return self.preferredSize

    def minimumSizeHint(self):
        return self.MINIMUM_SIZE

    def aboutToDelete(self):
        """Cleanup method to be called immediately before the object is deleted."""
        self._unregister()
        self._clearWidgets()
        # Qt object can take a long time before actually being destroyed
        # => observation of renderSetupModel may remain active (since self is not dead)
        # => explicitly remove observer to avoid receiving unwanted calls
        if self.observeRenderSetup:
            renderSetupModel.removeObserver(self)

    # Obsolete interface.
    dispose = aboutToDelete

    def renderSetupAdded(self):
        """ RenderSetup node was created """
        self._register()

    def renderSetupPreDelete(self):
        """ RenderSetup node is about to be deleted """
        # Flush the current content to avoid intermediate refreshes
        self._unregister()
        self._clearWidgets()

    def _clearWidgets(self):
        """ Clears the property editor widgets """
        while self.scrollWidgetLayout.count() > 0:
            layoutItem = self.scrollWidgetLayout.takeAt(0)
            # Note: Not obvious but to enforce the layoutItem delete, the parent should be None.
            #  I would have expected that the takeAt() call did it by default
            #  as the layoutItem is not anymore in the layout.
            if isinstance(layoutItem, QWidgetItem):
                layoutItem.widget().setParent(None)
            del layoutItem

        self.frameLayouts = []

    def _addItemEditor(self, propertyEditorItem):
        """
        Adds a property editor item type to the end of the layout, also
        keeps track of the control and frameLayout in case there is a data
        change.
        """
        frameLayout = FrameLayout(propertyEditorItem.item(), self)
        self.scrollWidgetLayout.addWidget(frameLayout)
        frameLayout.addWidget(propertyEditorItem)
        self.frameLayouts.append(frameLayout)
        return propertyEditorItem

    def _addLayer(self, currentItem):
        """ Adds a property editor layer to the end of the layout. """
        self._addItemEditor(RenderLayer(currentItem, self))

    def _addCollection(self, currentItem):
        """ Adds a property editor collection to the end of the layout. """
        self._addItemEditor(containerFactory.create(currentItem, self))

    def _addGroup(self, currentItem):
        """ Adds a property editor group to the end of the layout. """
        self._addItemEditor(containerFactory.create(currentItem, self))

    def _addOverride(self, currentItem):
        """ Adds a property editor override to the end of the layout. """
        self._addItemEditor(Override(currentItem, self))

    def _addLightEditorLight(self, currentItem):
        """ Adds a property editor light item to the end of the layout. """
        self._addItemEditor(LightProperties(currentItem, self))

    def _addLightEditorGroup(self, currentItem):
        """ Adds a property editor group item to the end of the layout. """
        self._addItemEditor(GroupProperties(currentItem, self))


    @Slot(QStandardItem)
    def itemChanged(self, item):
        """
        When an item in the model changes, update the control and
        frameLayout that make use of that item (if one exists).
        """
        if not item.isModelDirty():
            # itemChanged was not triggered due to a change to the model.
            # Nothing to do.
            # This is a workaround (see views/proxy/renderSetup.py (modelChanged() callback))
            return
        if item.data(renderSetupRoles.NODE_REBUILD_UI_WHEN_CHANGED):
            self.triggerRebuild()
        else:
            self.triggerRepopulate(item)

    def _getSortedSelectedIndexes(self):
        """ Unfortunately the selected items that are given to us from Qt are not sorted, we need to do this ourselves. """

        selectionModel = self.treeView().selectionModel()
        selectedIndexes = selectionModel.selectedIndexes()
        rootIndex = self.treeView().rootIndex()
        indexStack = []
        indexStack.append(rootIndex)
        count = 0
        # Pre-order traversal of our tree in order to get the preOrderIndex for each item in the tree.
        # Then a sort is applied by preOrderIndex on the selected items to get the sorted selected indexes.
        while(len(indexStack) > 0):
            index = indexStack.pop()
            if index != self.treeView().rootIndex():
                item = self.model().itemFromIndex(index)
                item.preOrderIndex = count
                count = count + 1
            if index is not None and (index.isValid() or index == self.treeView().rootIndex()):
                numRows = self.model().rowCount(index)
                for i in range(numRows):
                    indexStack.append(self.model().index(numRows - i - 1, 0, index))
        sortedSelectedIndices = []
        for i in range(len(selectedIndexes)):
            item = self.model().itemFromIndex(selectedIndexes[i])
            sortedSelectedIndices.append((selectedIndexes[i], item.preOrderIndex))
        sortedSelectedIndices = sorted(sortedSelectedIndices, key=lambda element: element[1]) # Sort by preOrderIndex
        return sortedSelectedIndices

    @Slot(QItemSelection, QItemSelection)
    def selectionChanged(self, selected, deselected):
        """
        On selection changed we lazily regenerate our collection/override/layer
        controls.
        """
        self.triggerRebuild()

    def triggerRebuild(self):
        self.needsRebuild = True
        if len(self.itemsToRepopulate) == 0 and not self.rebuildInProgress:
            self.rebuildInProgress = True
            QTimer.singleShot(0, lambda: self.rebuild())

    def rebuild(self):
        """ regenerate our collection/override/layer controls. """
        if not self.needsRebuild:
            # early out if we no longer need to rebuild
            # this can happen because rebuild is asynchronous
            return
        self.scrollArea.setVisible(False)
        self._clearWidgets()
        indexes = self._getSortedSelectedIndexes()
        self._sortedSelectedIndexesCache = indexes

        creators = {    renderSetup.RENDER_LAYER_TYPE                     : self._addLayer,
                        renderSetup.COLLECTION_TYPE                       : self._addCollection,
                        renderSetup.GROUP_TYPE                            : self._addGroup,
                        renderSetup.RENDER_SETTINGS_TYPE                  : self._addCollection,
                        renderSetup.RENDER_SETTINGS_CHILD_COLLECTION_TYPE : self._addCollection,
                        renderSetup.LIGHTS_TYPE                           : self._addCollection,
                        renderSetup.AOVS_TYPE                             : self._addCollection,
                        renderSetup.AOVS_CHILD_COLLECTION_TYPE            : self._addCollection,
                        renderSetup.LIGHTS_CHILD_COLLECTION_TYPE          : self._addCollection,
                        renderSetup.RENDER_OVERRIDE_TYPE                  : self._addOverride,
                        lightEditor.LIGHT_ITEM_TYPE                       : self._addLightEditorLight,
                        lightEditor.LIGHT_GROUP_TYPE                      : self._addLightEditorGroup,
                        }

        # Adding the pinned light editor items to the top of the list if observing light editor
        if not self.observeRenderSetup:
            for pinnedItemName in sorted(PropertyEditor.pinnedItemsLightEditor):
                item = commonUtils.nameToNode(pinnedItemName)
                if item and cmds.objExists(pinnedItemName):
                    fn = OpenMaya.MFnDependencyNode(item)
                    itemModel = fn.userNode()
                    currentItem = lightEditor.getProxy(itemModel)
                    creators[currentItem.type()](currentItem)

        #Only displaying MAX_INCREMENTAL_LOAD_ITEMS items at a time.
        #Dynamic scroll is used if the user wish to display more items (tricked when user scrolls to the buttom of the current item list)
        for i in range(0, min(len(indexes), self.MAX_INCREMENTAL_LOAD_ITEMS)):
            currentIndex = QPersistentModelIndex(indexes[i][0])
            currentItem = self.model().itemFromIndex(currentIndex)
            currentItemName = currentItem.model.getLightName(fullPath= True) if currentItem.type() == lightEditor.LIGHT_ITEM_TYPE else currentItem.model.name()
            if currentItemName not in PropertyEditor.pinnedItemsLightEditor:
                creators[currentItem.type()](currentItem)

        self._currentItemDisplayedCount = min(len(indexes), self.MAX_INCREMENTAL_LOAD_ITEMS)
        self._maxItemToDisplay = len(indexes)
        self.scrollWidgetLayout.addStretch(1)
        self.rebuildInProgress = False
        self.needsRebuild = False
        self.itemsToRepopulate = []
        self.scrollArea.setVisible(True)

    def triggerRepopulate(self, item):
        if not self.rebuildInProgress and not item in self.itemsToRepopulate:
            self.itemsToRepopulate.append(item)
            QTimer.singleShot(0, partial(self.populateFields, item=item))

    def populateFields(self, item):
        # If we need a rebuild while a populateFields request is made, the rebuild is the priority, so rebuild and return.
        if self.needsRebuild:
            return self.rebuild()
        # If another populateFields caused a rebuild then the item will no longer be in the list so return there is no work to do.
        elif not item in self.itemsToRepopulate:
            return

        PropertyEditor.updaters = \
            { renderSetup.RENDER_LAYER_TYPE                     : self._updateItem,
              renderSetup.COLLECTION_TYPE                       : self._updateCollection,
              renderSetup.GROUP_TYPE                            : self._updateGroup,
              renderSetup.RENDER_SETTINGS_TYPE                  : self._updateItem,
              renderSetup.RENDER_SETTINGS_CHILD_COLLECTION_TYPE : self._updateItem,
              renderSetup.LIGHTS_TYPE                           : self._updateCollection,
              renderSetup.AOVS_TYPE                             : self._updateItem,
              renderSetup.AOVS_CHILD_COLLECTION_TYPE            : self._updateItem,
              renderSetup.LIGHTS_CHILD_COLLECTION_TYPE          : self._updateItem,
              renderSetup.RENDER_OVERRIDE_TYPE                  : self._updateItem,
              lightEditor.LIGHT_ITEM_TYPE                       : self._updateItem,
              lightEditor.LIGHT_GROUP_TYPE                      : self._updateItem,
               }

        PropertyEditor.updaters[item.type()](item)
        self.itemsToRepopulate.remove(item)

    def _updateItem(self, item):
        for frameLayout in self.frameLayouts:
            if frameLayout.item() is item:
                frameLayout.update()

    def _updateCollection(self, item):
        for frameLayout in self.frameLayouts:
            if frameLayout.item() is item:
                frameLayout.getWidget(0).populateFields()
        self._updateItem(item)

    def _updateGroup(self, item):
        for frameLayout in self.frameLayouts:
            if frameLayout.item() is item:
                frameLayout.getWidget(0).populateFields()
        self._updateItem(item)

    def highlight(self, names):
        if not isinstance(names, set):
            names = set(names)
        def doHighlight():
            collections = (frameLayout.getWidget(0) for frameLayout in self.frameLayouts \
                if frameLayout.item().type() == renderSetup.COLLECTION_TYPE)
            for col in collections:
                col.highlight(names)
        # triggerRepopulate is delayed => highlight must also be delayed to apply only
        # when repopulate is complete
        QTimer.singleShot(0, doHighlight)

    def lightAttrChanged(self, attrName):
        ''' When the transform or shape attributes of lights are changed, propagate the changes to all
        selected lights.'''

        # Get the sole attribute name if this is
        # a compound "node.attr" string
        attrNameShort = attrName
        if attrName.find('.') != -1:
            attrNameShort = attrName.split('.')[-1]

        indexes = self._getSortedSelectedIndexes()
        for i in range(0, len(indexes)):
            currentIndex = QPersistentModelIndex(indexes[i][0])
            currentItem = self.model().itemFromIndex(currentIndex)

            if attrNameShort == "selfEnabled":
                plg = currentItem.model.getSelfEnabledPlug()
                newValue = cmds.getAttr(attrName)
                oldValue = plg.asBool()
                if newValue != oldValue:
                    cmds.setAttr(plg.name(), newValue)
            elif attrNameShort == "isolateSelected":
                plg = currentItem.model.getIsolatePlug()
                newValue = cmds.getAttr(attrName)
                oldValue = plg.asBool()
                if newValue != oldValue:
                    cmds.setAttr(plg.name(), newValue)
            elif currentItem.model.typeId() == typeIDs.lightItem:
                transformPlug = currentItem.model.getTransformPlug(attrName)
                shapePlug = currentItem.model.getShapePlug(attrName)
                plg = shapePlug if shapePlug else transformPlug
                if plg:
                    # Try to set the value but catch any errors
                    # since we're not guaranteed to handle all
                    # user defined attributes gracefully here.
                    try:
                        if plg.isVector or plg.type == plug.Plug.kColor:
                            newValue = cmds.getAttr(attrName)[0]
                            oldValue = cmds.getAttr(plg.name)[0]
                            if newValue != oldValue:
                                cmds.setAttr(plg.name, newValue[0], newValue[1], newValue[2], type="double3")
                        else:
                            newValue = cmds.getAttr(attrName)
                            oldValue = cmds.getAttr(plg.name)
                            if newValue != oldValue:
                                cmds.setAttr(plg.name, newValue)
                    except Exception:
                        # Just print a warning to let the execution continue.
                        cmds.warning(kWarningPropagateLightValueChangeStr % plg.name)

    def createScrollConnector(self):
        """Use to implement dynamic scroll display: Connects scrollbar value changes to method displayMoreItems"""
        self.scrollArea.verticalScrollBar().valueChanged.connect(self.displayMoreItems)

    def destroyScrollConnector(self):
        """Use to implement dynamic scroll display: turn off scrollbar connection if an instance of appenMoreItems is already running"""
        self.scrollArea.verticalScrollBar().valueChanged.disconnect(self.displayMoreItems)

    def displayMoreItems(self, e):
        """Use to implement dynamic scroll display: Method checks if the user has scroll to the bottom of the list. If yes, it tries to see if there are more items to be fetched and display on screen"""
        # If user has yet scrolled to the bottom, do nothing
        if e < self.scrollArea.verticalScrollBar().maximum() - self.MINIMUM_DISTANCE_TO_START_DYNAMIC_SCROLL:
            return
        else:
            if not self.rebuildInProgress:
                # Checks whether there are more items to display and that another instance isn't already running
                if (not self.appendItemsInProgress and self.hasMoreItemsToDisplay()):
                    self.destroyScrollConnector()
                    self.appendMoreItems()
                    self.createScrollConnector()
            return

    def hasMoreItemsToDisplay(self):
        """Use to implement dynamic scroll display: Check if more items are available to be displayed"""
        return self._maxItemToDisplay > self._currentItemDisplayedCount

    def appendMoreItems(self):
        """Use to implement dynamic scroll display: append new items at the bottom of the screen when called. Append MAX_INCREMENTAL_LOAD_ITEMS # of items at a time"""
        self.appendItemsInProgress = True
        creators = {    renderSetup.RENDER_LAYER_TYPE                     : self._addLayer,
                        renderSetup.COLLECTION_TYPE                       : self._addCollection,
                        renderSetup.RENDER_SETTINGS_TYPE                  : self._addCollection,
                        renderSetup.RENDER_SETTINGS_CHILD_COLLECTION_TYPE : self._addCollection,
                        renderSetup.LIGHTS_TYPE                           : self._addCollection,
                        renderSetup.AOVS_TYPE                             : self._addCollection,
                        renderSetup.AOVS_CHILD_COLLECTION_TYPE            : self._addCollection,
                        renderSetup.LIGHTS_CHILD_COLLECTION_TYPE          : self._addCollection,
                        renderSetup.RENDER_OVERRIDE_TYPE                  : self._addOverride,
                        lightEditor.LIGHT_ITEM_TYPE                       : self._addLightEditorLight,
                        lightEditor.LIGHT_GROUP_TYPE                      : self._addLightEditorGroup,
                        }

        indexes = self._sortedSelectedIndexesCache

        for i in range(self._currentItemDisplayedCount, min(len(indexes), self._currentItemDisplayedCount + self.MAX_INCREMENTAL_LOAD_ITEMS)):
            currentIndex = QPersistentModelIndex(indexes[i][0])
            currentItem = self.model().itemFromIndex(currentIndex)
            creators[currentItem.type()](currentItem)

        self._currentItemDisplayedCount = min(len(indexes), self._currentItemDisplayedCount+ self.MAX_INCREMENTAL_LOAD_ITEMS)
        self._maxItemToDisplay = len(indexes)

        self.appendItemsInProgress = False
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
