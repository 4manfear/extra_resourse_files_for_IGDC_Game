from builtins import int
from builtins import object
from builtins import str as futureStr
from future import standard_library
standard_library.install_aliases()
from builtins import next
from builtins import map
from maya.app.flux.commonImports import *

import json
import math
import inspect
import maya.OpenMayaUI as omui
import maya
from maya.app.general.mayaMixin import MayaQWidgetDockableMixin

import csv, codecs

dockableMixin = MayaQWidgetDockableMixin

def getFluxResourcesFolder():
    from os import path as os_path
    fluxResourcesFolder = os_path.dirname(__file__)
    fluxResourcesFolder = os_path.join(fluxResourcesFolder, 'resources')
    return fluxResourcesFolder

moduleIdentifier = 'maya.app.flux.utils'

_color_labels = ['kWhite', 'kRed', 'kBlue', 'kGrey', 'kOrange', 'kGreen', 'kYellow', 'kPurple']

def loadStringResources(module):
    try: maya.utils.loadStringResourcesForModule(module)
    except: pass

loadStringResources(moduleIdentifier)

def str_res(name):
    return getStringResource(moduleIdentifier, name)

def registerStringResources(identifier, resources):
    for key, value in list(resources.items()):
        maya.stringTable['y_%s.%s' % (identifier, key)] = value

def getStringResource(indentifier, key):
    value = key
    tableKey = 'y_%s.%s' % (indentifier, key)
    try:
        value = maya.stringTable[tableKey]
    except:
        print('Couldn\'t find string resource for: %s' % tableKey)
    return value

def getPluginStringResource(key):
    return mel.eval('getPluginResource("MASH", "%s")' % key)

def colorLabel(identifier):
    return str_res(identifier)

def allColorLabels():
    return list(map(colorLabel, _color_labels))

def getColourFromLabel(label):
    newColour = None
    if (label == colorLabel('kYellow')):
        newColour = qt.QColor(191,178,58)
    elif (label == colorLabel('kBlue')):
        newColour = qt.QColor(88,165,204)
    elif (label == colorLabel('kGrey')):
        newColour = qt.QColor(189,189,189)
    elif (label == colorLabel('kOrange')):
        newColour = qt.QColor(219,148,86)
    elif (label == colorLabel('kGreen')):
        newColour = qt.QColor(85,171,100)
    elif (label == colorLabel('kPurple')):
        newColour = qt.QColor(174,156,219)
    elif label == colorLabel('kWhite'):
        newColour = qt.QColor(255, 255, 255)
    else:
        newColour = qt.QColor(241,90,91)
    return newColour

def createColorIcon(colorName=None, qcolor=None, x=100, y=100):
    pixmap = qt.QPixmap(x,y)
    if colorName:
        pixmap.fill(getColourFromLabel(colorName))
    elif qcolor:
        pixmap.fill(qcolor)
    return qt.QIcon(pixmap)

###########################
# Utilities
###########################

## API shortcuts ##

def getMObjectFromName(nodeName):
    sel = nom.MSelectionList()
    sel.add(nodeName)
    thisNode = sel.getDependNode(0)
    return thisNode

def getAttributePlug(name, attr):
    thisNode = getMObjectFromName(name)
    fnThisNode = nom.MFnDependencyNode ( thisNode )
    fnThisNode.name()
    outAttribute = fnThisNode.attribute(attr)
    outPlug = nom.MPlug( thisNode, outAttribute )
    return outPlug

def getDagPathFromName(nodeName):
    sl = nom.MSelectionList()
    sl.add(nodeName)
    return sl.getDagPath(0)

## API shortcuts - end ##

def mayaWindow():
    mainWindowPtr = omui.MQtUtil.mainWindow()
    mainWindow = wrapInstance(int(mainWindowPtr), qt.QWidget)
    return mainWindow

def mayaViewport():
    widget = omui.M3dView.active3dView().widget()
    widget = wrapInstance(int(widget), qt.QWidget)
    return widget

def getFluxString(key):
    reskey = 'y_fluxUtils.%s' % key
    return maya.stringTable[reskey]

def getFuncFullName(func):
    if not hasattr(func, 'im_class'):
        return func.__name__
    for cls in inspect.getmro(func.__self__.__class__):
        if func.__name__ in cls.__dict__: 
            return '.'.join([x for x in str(cls).split('.') if x != '__main__'] + [func.__name__])
    return func.__name__

def printCallStack():
    frame = inspect.currentframe()
    print('Printing call stack:')
    try:
        i = 0
        while True:
            if frame is None:
                break

            frameinfo = inspect.getframeinfo(frame)
            print(i*'\t', frameinfo.filename, frameinfo.lineno)
            i += 1

            frame = frame.f_back
    except:
        print('\n# Error: Frame error #')

def getLocale():
    return cmds.about(uiLanguage=True)

def getQtWidgetAtPos(x,y):
    return qt.qApp.widgetAt(x,y)

def getWidgetNameAtPos(x,y):
    a = getQtWidgetAtPos(x, y)
    name = ''
    try:
        name = omui.MQtUtil.fullName( int(unwrapInstance(a)[0]) )
    except:
        print('Couldn\'t get widget name.')
    return name

def getMayaWidget(name):
    w = omui.MQtUtil.findControl(name)
    w = wrapInstance(int(w), qt.QWidget)
    return w

def applyRotations(rotations, origin):
    # Shorthand imports
    sin, cos, radians = math.sin, math.cos, math.radians

    class myPoint(object):
        def __init__(self, x, y, z):
            self.x = x
            self.y = y
            self.z = z

        def copy(self):
            return myPoint(self.x, self.y, self.z)

        def asList(self):
            return [self.x, self.y, self.z]

    rot = [radians(x) for x in rotations]
    rsin = [sin(x) for x in rot]
    rcos = [cos(x) for x in rot]

    psin = myPoint(*rsin)
    pcos = myPoint(*rcos)

    point = myPoint(*origin)
    p = point.copy()

    # X rotation
    point.y = pcos.x * p.y - psin.x * p.z
    point.z = psin.x * p.y + pcos.x * p.z
    # Y rotation
    p = point.copy()
    point.z = pcos.y * p.z - psin.y * p.x
    point.x = psin.y * p.z + pcos.y * p.x
    # Z rotation
    p = point.copy()
    point.x = pcos.z * p.x - psin.z * p.y
    point.y = psin.z * p.x + pcos.z * p.y

    return point.asList()

def startProgressBar(message='Loading...', length=100):
    gMainProgressBar = mel.eval('$tmp = $gMainProgressBar')
    cmds.progressBar( gMainProgressBar,
                                edit=True,
                                beginProgress=True,
                                isInterruptable=True,
                                status=message,
                                maxValue=length)

def stepProgressBar(amount=1):
    gMainProgressBar = mel.eval('$tmp = $gMainProgressBar')
    cmds.progressBar(gMainProgressBar, edit=True, step=amount)

def endProgressBar():
    gMainProgressBar = mel.eval('$tmp = $gMainProgressBar')
    cmds.progressBar(gMainProgressBar, edit=True, endProgress=True)

def getReadFileName(message, fileFilter=''):
    fileName = cmds.fileDialog2(dialogStyle=1, fm=1, fileFilter=fileFilter, caption=message)
    if not((fileName is None) or (len(fileName[0]) == 0)):
        from os import path as os_path
        fileName = fileName[0]
        fileName = fileName and os_path.normpath(fileName) #hoping this fixes the file path on PCs
        return fileName

    return None

def getWriteFileName(message, fileFilter=''):
    fileName = cmds.fileDialog2(dialogStyle=1, fm=0, fileFilter=fileFilter, caption=message)
    if not((fileName is None) or (len(fileName[0]) == 0)):
        from os import path as os_path
        fileName = fileName[0]
        fileName = fileName and os_path.normpath(fileName) #hoping this fixes the file path on PCs
        return fileName

    return None

def exportJSONFile(jsonData):
    fileName = getWriteFileName(str_res('kChooseExport'), '*.json')
    if fileName is None:
        nom.MGlobal.displayInfo(str_res('kExportCanceled'))
        return

    try:
        f = open(fileName, "w")
        try:
            f.write(jsonData) # Write the json dump to the file
            nom.MGlobal.displayInfo(str_res('kExportedTo') + fileName)
        finally:
            f.close()
    except IOError:
        pass

def importJSONFile():
    fileName = getReadFileName(str_res('kChooseImport'), '*.json')

    #did the user press cancel ?
    if fileName is None:
        nom.MGlobal.displayInfo(str_res('kImportCanceled'))
    else:
        try:
            with open(fileName, 'r') as f:
                return f.read()
        except:
            nom.MGlobal.displayInfo(str_res('kOpeningFileFailed'))

    return ''

#UTF-8 CSV

class UTF8Wrapper(object):
    def __init__(self, f, encoding):
        self.fileReader = codecs.getreader(encoding)(f)

    def __iter__(self):
        return self

    def __next__(self):
        return self.fileReader.next().encode("utf-8")

class csv_reader(object):
    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        f = UTF8Wrapper(f, encoding)
        self.reader = csv.reader(f, dialect=dialect, **kwds)

    def __next__(self):
        row = next(self.reader)
        return [futureStr(s, "utf-8") for s in row]

    def __iter__(self):
        return self

class csv_writer(object):
    def __init__(self, f, dialect=csv.excel, encoding="utf-8", **kwds):
        self.fileWriter = f
        from io import StringIO as io_StringIO
        self.queue = io_StringIO()
        self.writer = csv.writer(self.queue, dialect=dialect, **kwds)
        self.encoder = codecs.getincrementalencoder(encoding)()

    def writerow(self, row):
        self.writer.writerow([s.encode("utf-8") for s in row])
        data = self.queue.getvalue()
        data = data.decode("utf-8")
        data = self.encoder.encode(data)
        self.fileWriter.write(data)
        self.queue.truncate(0)

    def writerows(self, rows):
        for row in rows:
            self.writerow(row)

class MCallbackIdWrapper(object):
    '''Wrapper class to handle cleaning up of MCallbackIds from registered MMessage
    '''
    def __init__(self, callbackId):
        self.callbackId = callbackId

    def __del__(self):
        om.MMessage.removeCallback(self.callbackId)

    def __repr__(self):
        return 'MCallbackIdWrapper(%r)'%self.callbackId
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
