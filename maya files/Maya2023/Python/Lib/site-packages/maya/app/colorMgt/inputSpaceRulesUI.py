"""
Color management preferences input space rules UI code.
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)


from builtins import object
import maya.cmds as cmds
import maya.mel as mel
import maya.app.colorMgt.customTransformUI as customTransformUI
import maya.app.colorMgt.reapplyRules as reapplyRules

import re
import functools

vSpc = 10
hSpc = 10
buttonWidth = 60

# Parent form for the rules UI.
parentForm = ''

# Color constants
red = [1, 0, 0]
black = [0, 0, 0]

def mayaImageFileExtensions():
    """Return the list of image file extensions read by Maya."""

    # MAYA-48524 - LT: need to source the mel file containing buildImageFileFilterList.
    mel.eval('source fileDialogFilterTypes')

    # This MEL procedure returns a list of image file extensions in a file
    # dialog-friendly format, so we need to filter it.
    dialogImageFiles = mel.eval('buildImageFileFilterList')

    # Returned string has file type extensions within parentheses.
    extRe = re.compile('\((.*)\);')
    reMatch = extRe.search(dialogImageFiles)
    extensionsString = reMatch.group(1)
    extensionsList = re.split('[\W]+', extensionsString)

    # The split regexp matches at the beginning of the string, so split
    # returns an empty string match as the initial split.  Throw that away.
    extensionsList.pop(0)

    # Maya supported file extensions are case sensitive so the same file extension
    # is in lowercase and in uppercase in the list (i.e. two times). However file 
    # extensions with a mix of lower & upper cases are still not correctly handled.
    # To overcome that problem for the file rule mechanism, the list is changed to 
    # only display lowercase file extensions and the file rule evaluation is based
    # on lowercase characters.

    # Lower file extension characters & remove duplicated file extensions
    extensionsList = [element.lower() for element in extensionsList]
    extensionsList = list(set(extensionsList))

    # The '*' match all glob pattern must also be presented in the extension
    # menu.
    extensionsList.insert(0, '*')
    extensionsList.sort()

    return extensionsList
    
def nativeMode():
    return not cmds.colorManagementPrefs(query=True, cmConfigFileEnabled=True)

def ociov2Enabled():
    return cmds.colorManagementPrefs(query=True, ociov2Enabled=True)

class Rule(object):

    def __init__(self, name):
        self.name = name

    def canDelete(self):
        # A non-deletable rule cannot be deleted or moved.
        return False

class OpaqueRule(Rule):

    def __init__(self, name):
        super(OpaqueRule, self).__init__(name=name)

    def canDelete(self):
        return ociov2Enabled()

    def createUI(self):
        handlerForm = cmds.setParent(query=True)
        layout = cmds.rowLayout()
        # Surprisingly, the simpler
        # cmds.columnLayout(columnAlign='center', rowSpacing=20)
        # is not equivalent to the line below, and doesn't center horizontally.
        cmds.rowColumnLayout(numberOfColumns=1, columnAlign=[1, 'center'],
                             rowSpacing=[1, 20])
        cmds.text(label=self.name)
        cmds.text(label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kOCIORuleLabel' ],
                  wordWrap=True)
        cmds.setParent('..')
        cmds.setParent('..')
        cmds.formLayout(handlerForm, edit=True,
                        attachForm=[(layout, 'top', 0), (layout, 'bottom', 0)])

class ColorSpaceRule(Rule):

    def __init__(self, name):
        super(ColorSpaceRule, self).__init__(name=name)

        # State of color space background color.  True in case of invalid
        # color space.
        self._menuInvalidBgColor = False

    def setColorSpace(self, colorSpace):
        cmds.colorManagementFileRules(
            self.name, edit=True, colorSpace=colorSpace)

    def getColorSpace(self):
        return cmds.colorManagementFileRules(
            self.name, query=True, colorSpace=True)

    colorSpace = property(getColorSpace, setColorSpace)

    def onInputColorSpaceChangeOCIOv2(self, newInputSpace, newInputSpaceDescription, *args):
        if self._addTransformLabel == newInputSpace:
            # This entry is special i.e. add custom transform.
            returnVal = customTransformUI.addCustomTransformDialog('input')

            if returnVal != '':
                self.colorSpace = returnVal

            cmds.button(self._popupLabel, edit=True, label=self.colorSpace)

            validColorSpace = True
        else:
            cmds.button(self._popupLabel, edit=True, label=newInputSpace, annotation=newInputSpaceDescription)

            validColorSpace = self.validateColorSpace(newInputSpace)

            if validColorSpace:
                self.colorSpace = newInputSpace

        self.setMenuValidColorSpace(validColorSpace)

    def onInputColorSpaceChangeSynColor(self, *args):
        selection = cmds.optionMenuGrp(
            self._colorSpaceMenu, query=True, select=True)

        if selection == cmds.optionMenuGrp(
                self._colorSpaceMenu, query=True, numberOfItems=True):
            # Last entry is special: add custom transform.
            returnVal = customTransformUI.addCustomTransformDialog('input')

            # If user didn't cancel out, add to the menu, and change the color
            # space.  Awkward menuItem parent call taken from optionMenuGrp
            # documentation, more intuitive and direct
            # cmds.setParent(self._colorSpaceMenu, menu=True)
            # fails with object not found error.
            if returnVal != '':
                cmds.menuItem(parent=self._colorSpaceMenu + '|OptionMenu',
                              label=returnVal)
                self.colorSpace = returnVal

            cmds.optionMenuGrp(
                self._colorSpaceMenu, edit=True, value=self.colorSpace)

            validColorSpace = True
        else:
            # Not the last entry: standard processing.
            newColorSpace = cmds.optionMenuGrp(
                    self._colorSpaceMenu, query=True, value=True)

            validColorSpace = self.validateColorSpace(newColorSpace)

            if validColorSpace:
                self.colorSpace = newColorSpace

        self.setMenuValidColorSpace(validColorSpace)

    def onRemoveColorSpace(self, *args):
        # If color space is already invalid (doesn't exist), don't try to
        # remove it.
        if not self.validateColorSpace(self.colorSpace):
            return

        # Because color space removal can only be done on the selected
        # color space, it must be our own color space, so we must choose an
        # alternate one.
        removed = mel.eval('colorMgtRemoveTransform "' + self.colorSpace + '" input')
            
        if removed != '':
            # Need a mode-specific interface to retrieve a default input
            # color space.  For now, arbitrarily pick the first one.
            colorSpaces = cmds.colorManagementFileRules(query=True, colorSpaceNames=True)
            self.colorSpace = colorSpaces[0]
            if ociov2Enabled():
                cmds.button(self._popupLabel, edit=True, label=self.colorSpace)

    def validateColorSpace(self, colorSpace):
        colorSpaces = cmds.colorManagementFileRules(query=True, colorSpaceNames=True)
        return colorSpace in colorSpaces

    def setMenuValidColorSpace(self, valid):
        if valid:
            # If we were invalid, need to reset (but only if we were invalid).
            if self._menuInvalidBgColor:
                cmds.layout(self._colorSpaceLayout, edit=True,
                            backgroundColor=black, noBackground=False)
        else:
            cmds.layout(self._colorSpaceLayout, edit=True, backgroundColor=red)

        self._menuInvalidBgColor = not valid

    def createColorSpacePopupMenu(self, colorSpaces, parentMenu):
        existingFamilyItem = [] # Used to only display one menu item per family.

        for colorSpace in colorSpaces:
            currentParent = parentMenu
            colorSpaceFamilies = cmds.colorManagementFileRules(query=True, colorSpaceFamilies=colorSpace)
            colorSpaceDescription = cmds.colorManagementFileRules(query=True, colorSpaceDescription=colorSpace)

            for family in colorSpaceFamilies:
                found = False
                for familyItem in existingFamilyItem:
                    if cmds.menuItem(familyItem, query=True, exists=True) \
                        and family == cmds.menuItem(familyItem, query=True, label=True):
                        currentParent = familyItem
                        found = True
                if not found:
                    currentParent = cmds.menuItem(subMenu=True, label=family, parent=currentParent)
                    existingFamilyItem.append(currentParent)

            cmd = functools.partial(self.onInputColorSpaceChangeOCIOv2, colorSpace, colorSpaceDescription)
            cmds.menuItem(label=colorSpace, parent=currentParent, command=cmd)

    def createColorSpaceMenu(self):
        # The Input Color Space for the file rules is now an hierarchical menu for OCIOv2.
        # Unfortunately, the OptionMenu does not offer the capability so the UI is rebuilt from
        # scratch explaining all the differences in this file. 

        labelString = maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kInputColorSpaceMenuLabel' ]

        if ociov2Enabled():
            self._colorSpaceLayout = cmds.rowLayout(numberOfColumns=4)
            self._label = cmds.text(label=labelString, width=130, parent=self._colorSpaceLayout)
            self._popupLabel = cmds.button(label=self.colorSpace, height=18,
                parent=self._colorSpaceLayout)

            # Disable the input color space menu for OCIOv1 config as the file rules are new
            # to OCIOv2.
            if cmds.colorManagementFileRules(query=True, enabled=True):
                backgroundColor = [0.37109375, 0.37109375, 0.37109375]
                self._iconButton = cmds.iconTextButton(image1='popupMenuIcon.png',
                    width=18, height=18, backgroundColor=backgroundColor,
                    parent=self._colorSpaceLayout)

                self._popupMenu = cmds.popupMenu(button=1, parent=self._popupLabel)
                self._popupMenuIcon = cmds.popupMenu(button=1, parent=self._iconButton)

                colorSpaces = cmds.colorManagementFileRules(query=True, colorSpaceNames=True)

                # Fill the popup menus.
                self.createColorSpacePopupMenu(colorSpaces, self._popupMenu)
                self.createColorSpacePopupMenu(colorSpaces, self._popupMenuIcon)

                validColorSpace = self.colorSpace in colorSpaces
                if not validColorSpace:
                    cmds.menuItem(label=self.colorSpace)

                self._addTransformLabel = mel.eval(
                    'uiRes("m_colorManagementUtilities.kAddCustomTransform")')

                cmd = functools.partial(self.onInputColorSpaceChangeOCIOv2, self._addTransformLabel)
                cmds.menuItem(
                    label=self._addTransformLabel, enable=False, parent=self._popupMenu, command=cmd)

                self.setMenuValidColorSpace(validColorSpace)

                transformSettings = cmds.symbolButton(
                    enable=False, image='colorTransformSettings.png')
                cmds.popupMenu(button=1, parent=transformSettings)

                removeTransformLabel = mel.eval(
                    'uiRes("m_createPrefWndUI.kColorManagementRemoveTransform")')
                cmds.menuItem(
                    label=removeTransformLabel, enable=False, command=self.onRemoveColorSpace)

                cmds.setParent('..', menu=True)

            # End of row layout.
            cmds.setParent('..')
        else:
            self._colorSpaceLayout = cmds.rowLayout(numberOfColumns=2)

            self._colorSpaceMenu = cmds.optionMenuGrp(columnWidth=[1, 130],
                ad2=2, label=labelString, changeCommand=self.onInputColorSpaceChangeSynColor)

            # Fill in the input color spaces, and set the menu selection.
            colorSpaces = cmds.colorManagementFileRules(
                query=True, colorSpaceNames=True)

            for colorSpace in colorSpaces:
                cmds.menuItem(label=colorSpace)

            validColorSpace = self.colorSpace in colorSpaces
            if not validColorSpace:
                cmds.menuItem(label=self.colorSpace)

            addTransformLabel = mel.eval(
                'uiRes("m_colorManagementUtilities.kAddCustomTransform")')

            cmds.menuItem(enable=nativeMode(), label=addTransformLabel)

            cmds.optionMenuGrp(self._colorSpaceMenu, edit=True, value=self.colorSpace)

            self.setMenuValidColorSpace(validColorSpace)

            transformSettings = cmds.symbolButton(
                enable=nativeMode(), image='colorTransformSettings.png')

            cmds.popupMenu(button=1, parent=transformSettings)
            removeTransformLabel = mel.eval(
                'uiRes("m_createPrefWndUI.kColorManagementRemoveTransform")')
                
            cmds.menuItem(label=removeTransformLabel, command=self.onRemoveColorSpace)

            cmds.setParent('..', menu=True)

            # End of row layout.
            cmds.setParent('..')

    def fileRuleLayout(self, extWidget, patternWidget):
        """Shared layout for color space rules."""
    
        # Add in common widgets
        conditionText = cmds.text(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kRuleConditionsLabel' ])
    
        separatorWidget = cmds.separator(style='singleDash')
    
        colorSpaceText = cmds.text(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kImageInputColorSpace' ])
    
        # Get our parent form layout, and place the widgets inside it.
        handlerForm = cmds.setParent(query=True)
    
        rowSpacing = 30

        cmds.formLayout(
            handlerForm, edit=True,
            attachForm=[(conditionText,    'top',   vSpc),
                        (conditionText,    'left',  hSpc),
                        (extWidget,        'left',  hSpc),
                        (patternWidget,    'left',  hSpc),
                        (separatorWidget,  'left',  hSpc),
                        (separatorWidget,  'right', hSpc),
                        (colorSpaceText,   'left',  hSpc),
                        (self._colorSpaceLayout, 'left',  hSpc)],
            attachOppositeControl=[
                (extWidget,        'top', rowSpacing, conditionText),
                (patternWidget,    'top', rowSpacing, extWidget),
                (separatorWidget,  'top', rowSpacing, patternWidget)],
            attachControl=[
                (colorSpaceText,   'top', vSpc, separatorWidget),
                (self._colorSpaceLayout, 'top', vSpc, colorSpaceText)])


class DefaultRule(ColorSpaceRule):

    def __init__(self, name):
        super(DefaultRule, self).__init__(name=name)

    def createUI(self):

        extText = cmds.text(width=150, align='right',
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kDefaultRuleExtLabel' ])

        patternText = cmds.text(width=150, align='right',
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kDefaultRulePatternLabel' ])

        self.createColorSpaceMenu()

        # Fill in layout.
        self.fileRuleLayout(extText, patternText)

class FilePathRule(ColorSpaceRule):

    _extensionsList = mayaImageFileExtensions()

    def __init__(self, name):
        super(FilePathRule, self).__init__(name=name)
        if self.pattern == '':
            self.pattern = '*'

    def setPattern(self, pattern):
        cmds.colorManagementFileRules(
            self.name, edit=True, pattern=pattern)

    def getPattern(self):
        return cmds.colorManagementFileRules(
            self.name, query=True, pattern=True)

    pattern = property(getPattern, setPattern)

    def setExtension(self, extension):
        cmds.colorManagementFileRules(
            self.name, edit=True, extension=extension)

    def getExtension(self):
        return cmds.colorManagementFileRules(
            self.name, query=True, extension=True)

    extension = property(getExtension, setExtension)

    def canDelete(self):
        return True

    def onPatternChange(self, *args):
        self.pattern = cmds.textFieldGrp(
            self._patternWidget, query=True, text=True)
        if self.pattern == '':
            self.pattern = '*'
            cmds.textFieldGrp(self._patternWidget, edit=True, text=self.pattern)

    def onExtensionChange(self, *args):
        self.extension = cmds.optionMenuGrp(
            self._extensionsMenu, query=True, value=True)

    def createUI(self):
        self._extensionsMenu = cmds.optionMenuGrp(
            ad2=2, label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kExtensionsMenuLabel' ],
            changeCommand=self.onExtensionChange)

        # Fill in the extensions.
        for extension in FilePathRule._extensionsList:
            cmds.menuItem(label=extension)

        # Using the command, the user could select a file extension
        # which does not exist.
        try:
            cmds.optionMenuGrp(self._extensionsMenu, edit=True,
                               value=self.extension)
        except RuntimeError as err:
            cmds.optionMenuGrp(self._extensionsMenu, edit=True,
                               value=FilePathRule._extensionsList[0])
            err = maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kInvalidNode' ]
            msg = cmds.format(err, stringArg=(self.extension, FilePathRule._extensionsList[0]))
            cmds.warning( msg )

        self._patternWidget = cmds.textFieldGrp(
            ad2=2, label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kImageNamePattern' ],
            changeCommand=self.onPatternChange, text=self.pattern)

        self.createColorSpaceMenu()

        # Fill in layout.
        self.fileRuleLayout(self._extensionsMenu, self._patternWidget)

class ChainRule(Rule):            

    def __init__(self, name=''):
        super(ChainRule, self).__init__(name=name)

        # Initialize our list of rules with a default rule.  This will
        # always be the last rule.  The rule list is always appended to,
        # and is placed in the scroll list in back to front (reverse
        # iteration) order.
        self._rulesChain = []

        if ociov2Enabled():
            # Fill in UI with existing rules.
            rules = cmds.colorManagementFileRules(listRules=True)

            for rule in rules:
                if rule == "Default":
                    self._rulesChain.append(DefaultRule(rule))
                elif rule == "ColorSpaceNamePathSearch":
                    self._rulesChain.append(OpaqueRule(rule))
                else:
                    self._rulesChain.append(FilePathRule(rule))
        else:
            # Fill in UI with existing rules.
            rules = cmds.colorManagementFileRules(listRules=True)
            # Default rule already added, skip it.
            self._rulesChain.append(DefaultRule(rules[0]))
            rules.pop(0)

            self._ocioRulesEnabled = cmds.colorManagementPrefs(query=True, cmConfigFileEnabled=True) \
                                     and cmds.colorManagementPrefs(query=True, ocioRulesEnabled=True)
            if self._ocioRulesEnabled:
                self._rulesChain.append(OpaqueRule(rules.pop(0)))
            else:
                for rule in rules:
                    self._rulesChain.append(FilePathRule(rule))

        self._selectedPos = 0

    def isReadOnly(self):
        # A read-only container does not allow moving, adding, or deleting rules.
        if ociov2Enabled():
            return cmds.colorManagementPrefs(query=True, ocioRulesEnabled=True) \
                or not cmds.colorManagementFileRules(query=True, enabled=True)
        else:
            return self._ocioRulesEnabled and not nativeMode()

    def positionToIndex(self, position):
        # For SynColor, higher priority rules are at higher indices.  The
        # scroll list works in reverse (top to bottom), and its indexing 
        # is 1-based.
        return len(self._rulesChain) - position

    def indexToPosition(self, index):
        return len(self._rulesChain) - index

    def updateScrollList(self):
        # Naive, destroy everything and rebuild implementation, but should
        # not be an issue given limited size of rules list.  Note how we
        # must use reverse iteration, as rules appended to the rule list
        # must appear at the top of the scroll list.

        cmds.textScrollList(self._scrollList, edit=True, removeAll=True)

        for rule in reversed(self._rulesChain):
            cmds.textScrollList(self._scrollList, edit=True, append=rule.name)

    def appendRule(self, rule):

        self._rulesChain.append(rule)
        self.updateScrollList()
        self.selectRule(len(self._rulesChain)-1)

    def createHandlerRuleUI(self):

        # Re-create the rule UI.  First, delete existing children of the
        # handler rule form.
        children = cmds.formLayout(
            self._handlerForm, query=True, childArray=True)

        for child in children:
            cmds.deleteUI(child)

        # Next, call create UI on the selected rule.
        rule = self._rulesChain[self._selectedPos]

        oldParent = cmds.setParent(query=True)

        cmds.setParent(self._handlerForm)

        rule.createUI()

        cmds.setParent(oldParent)

    def updateHandlerRuleUI(self):

        # Update up, down, delete buttons.
        rule = self._rulesChain[self._selectedPos]

        canGoUp = not self.isReadOnly() and rule.canDelete() and (
            self._selectedPos < (len(self._rulesChain) - 1))
        canGoDown = not self.isReadOnly() and rule.canDelete() and (
            self._selectedPos > 1)
        canAdd    = not self.isReadOnly()
        canDelete = not self.isReadOnly() and rule.canDelete()

        cmds.button(self._up, edit=True, enable=canGoUp)
        cmds.button(self._down, edit=True, enable=canGoDown)
        cmds.button(self._add, edit=True, enable=canAdd)
        if ociov2Enabled():
            canAddFilePathRule = not self.isReadOnly()
            rules = cmds.colorManagementFileRules(listRules=True)
            for rule in rules:
                if rule == "ColorSpaceNamePathSearch":
                    canAddFilePathRule = False
                    break
            cmds.button(self._addFilePathRule, edit=True, enable=canAddFilePathRule)
        cmds.button(self._delete, edit=True, enable=canDelete)

        self.createHandlerRuleUI()

    def selectRule(self, position):

        self._selectedPos = position
        selectedIndex = self.positionToIndex(self._selectedPos)
        cmds.textScrollList(self._scrollList, edit=True,
                            selectIndexedItem=selectedIndex)

        self.updateHandlerRuleUI()

    def createUI(self):

        # Create a formLayout under our parent.  It will hold 3 controls,
        # the rules chain form, the separator, and the handler rule form.
        # Use 100 divisions as a convenience, so that divisions are
        # effectively a percentage.
        self._form = cmds.formLayout(numberOfDivisions=100)

        # Create a form layout for the rules chain section of the UI.
        self._chainForm = cmds.formLayout(numberOfDivisions=100)

        self._scrollList = cmds.textScrollList(
            allowMultiSelection=False, selectCommand=self.onSelect)

        self.updateScrollList()

        # Priority controls.
        self._priorityText = cmds.text(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kPriorityLabel' ])
        self._up     = cmds.button(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kUpLabel' ], width=buttonWidth, command=self.onUp)
        self._down   = cmds.button(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kDownLabel' ], width=buttonWidth,
            command=self.onDown)
        self._add    = cmds.button(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kAddLabel' ], width=buttonWidth,
            command=self.onAddRule)
        if ociov2Enabled():
            self._addFilePathRule = cmds.button(
                label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kAddFilePathRuleLabel' ],
                width=3*buttonWidth,
                annotation=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kAddFilePathRuleAnnotation' ],
                command=self.onAddFilePathRule)
        self._delete = cmds.button(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kDeleteLabel' ], width=buttonWidth,
            command=self.onDeleteRule)

        # Reapply rules.
        self._reload = cmds.button(
            label=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kReloadLabel' ],
            command=self.onReapply)

        if ociov2Enabled():
            cmds.formLayout(
                self._chainForm, edit=True,
                attachForm=[(self._priorityText,    'top',    vSpc),
                            (self._up,              'left',   hSpc),
                            (self._down,            'right',  hSpc),
                            (self._add,             'left',   hSpc),
                            (self._addFilePathRule, 'left',   2*hSpc+buttonWidth),
                            (self._delete,          'right',  hSpc),
                            (self._reload,          'left',   hSpc),
                            (self._reload,          'right',  hSpc),
                            (self._scrollList,      'left',   hSpc),
                            (self._scrollList,      'right',  hSpc)],
                attachControl=[(self._up,             'top', vSpc, self._priorityText),
                               (self._down,            'top', vSpc, self._priorityText),
                               (self._scrollList,      'top', vSpc, self._up),
                               (self._add,             'top', vSpc, self._scrollList),
                               (self._addFilePathRule, 'top', vSpc, self._scrollList),
                               (self._delete,          'top', vSpc, self._scrollList),
                               (self._reload,          'top', vSpc, self._add)])
        else:
            cmds.formLayout(
                self._chainForm, edit=True,
                attachForm=[(self._priorityText, 'top',    vSpc),
                            (self._up,           'left',   hSpc),
                            (self._down,         'right',  hSpc),
                            (self._add,          'left',   hSpc),
                            (self._delete,       'right',  hSpc),
                            (self._reload,       'left',   hSpc),
                            (self._reload,       'right',  hSpc),
                            (self._scrollList,   'left',   hSpc),
                            (self._scrollList,   'right',  hSpc)],
                attachControl=[(self._up,   'top', vSpc, self._priorityText),
                               (self._down, 'top', vSpc, self._priorityText),
                               (self._scrollList, 'top', vSpc, self._up),
                               (self._add,        'top', vSpc, self._scrollList),
                               (self._delete,     'top', vSpc, self._scrollList),
                               (self._reload,     'top', vSpc, self._add)])

        cmds.setParent('..')

        self._separator = cmds.separator(horizontal=False, style='singleDash')

        # Give our chained handler rules a form layout of their own, and
        # populate it with the selected rule.
        self._handlerForm = cmds.formLayout(numberOfDivisions=100)
        selectedRule = self._rulesChain[self._selectedPos]
        selectedRule.createUI()

        cmds.setParent('..')

        cmds.formLayout(
            self._form, edit=True,
            attachForm=[(self._chainForm,   'top',    0),
                        (self._chainForm,   'bottom', 0),
                        (self._chainForm,   'left',   0),
                        (self._separator,   'top',    vSpc),
                        (self._separator,   'bottom', vSpc),
                        (self._handlerForm, 'top',    0),
                        (self._handlerForm, 'bottom', 0),
                        (self._handlerForm, 'right',  0)],
            attachPosition=[(self._chainForm, 'right', hSpc, 50)],
            attachControl=[(self._separator,   'left', hSpc, self._chainForm),
                           (self._handlerForm, 'left', hSpc, self._separator)])

        cmds.setParent('..')

        # Select the default rule, which is considered by SynColor to be at
        # position 0.
        self.selectRule(0)

    def onAddRule(self, *args):

        # Obtain rule name.
        okStr = maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kColorMgtOK' ]
        cancelStr = maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kColorMgtCancel' ]

        result = cmds.promptDialog(
            title=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kRuleDialogTitle' ],
            message=maya.stringTable['y_maya_app_colorMgt_inputSpaceRulesUI.kRuleDialogMsg' ],
            button=[okStr, cancelStr], defaultButton=okStr,
            cancelButton=cancelStr, dismissString=cancelStr)

        if result != okStr:
            return
            
        text = cmds.promptDialog(query=True, text=True)
        
        # Create rule with match all pattern, 'exr' extension, and same color
        # space as default rule.
        rules = cmds.colorManagementFileRules(listRules=True)
        colorSpace = cmds.colorManagementFileRules(
            rules[0], query=True, colorSpace=True)

        cmds.colorManagementFileRules(add=text, pattern='*',
            extension='exr', colorSpace=colorSpace)

        self.appendRule(FilePathRule(name=text))

    def onAddFilePathRule(self, *args):
        # Add the rule if it does not exist.
        rules = cmds.colorManagementFileRules(listRules=True)
        found = False
        for rule in rules:
            if rule == "ColorSpaceNamePathSearch":
                found = True
                break
        if not found:
            cmds.colorManagementFileRules(add='ColorSpaceNamePathSearch')
            self.appendRule(OpaqueRule('ColorSpaceNamePathSearch'))

    def onDeleteRule(self, *args):

        # If selected rule is 0 (default), early out.
        if self._selectedPos == 0:
            return

        # Update data model.
        cmds.colorManagementFileRules(rm=self._rulesChain[self._selectedPos].name)

        del self._rulesChain[self._selectedPos]
        self._selectedPos = min(self._selectedPos, len(self._rulesChain)-1)

        self.updateScrollList()

        self.selectRule(self._selectedPos)

    def onUp(self, *args):

        # If last rule selected, early out.
        if self._selectedPos == (len(self._rulesChain)-1):
            return

        # Update data model.
        cmds.colorManagementFileRules(
            up=self._rulesChain[self._selectedPos].name)

        # Take the selected rule, move it up, and rebuild the scroll list.
        nextRule = self._rulesChain[self._selectedPos+1]

        self._rulesChain[self._selectedPos+1] = \
            self._rulesChain[self._selectedPos]

        self._rulesChain[self._selectedPos] = nextRule

        self.updateScrollList()

        self.selectRule(self._selectedPos+1)

    def onDown(self, *args):

        # Rule 0 can't be moved, and therefore rule 1 can't either.
        if self._selectedPos <= 1:
            return

        # Update data model.
        cmds.colorManagementFileRules(
            down=self._rulesChain[self._selectedPos].name)

        # Take the selected rule, move it down, and rebuild the scroll list.
        previousRule = self._rulesChain[self._selectedPos-1]

        self._rulesChain[self._selectedPos-1] = \
            self._rulesChain[self._selectedPos]

        self._rulesChain[self._selectedPos] = previousRule

        self.updateScrollList()

        self.selectRule(self._selectedPos-1)

    def onSelect(self, *args):

        # Contrary to documentation, selection queries returns a list of
        # indices (most likely because of multi-selection mode).  We use
        # single selection, so we know the list will have a single element.
        selectedRuleIndex = cmds.textScrollList(self._scrollList, query=True,
                                                selectIndexedItem=True)

        self._selectedPos = self.indexToPosition(selectedRuleIndex[0])

        self.updateHandlerRuleUI()

    def onReapply(self, *args):
        reapplyRules.reapply()

def build():
    global parentForm
    parentForm = cmds.setParent(query=True)
    createUI()
    cmds.scriptJob(event=['colorMgtConfigChanged', createUI])
    cmds.scriptJob(event=['colorMgtPrefsReloaded', createUI])
    cmds.scriptJob(event=['colorMgtOCIORulesEnabledChanged', createUI])

def createUI():
    if( not cmds.control(parentForm, exists=True) ):
        return

    oldParent = cmds.setParent(query=True)
    cmds.setParent(parentForm)

    # Clear out old UI by deleting existing children.  If no children, None
    # is returned, which is not iterable.
    children = cmds.layout(parentForm, query=True, childArray=True)
    if children:
        for child in children:
            cmds.deleteUI(child)

    # Always using a chain rule, as we always have at least two rules to
    # deal with.
    rule = ChainRule()
    rule.createUI()

    cmds.setParent(oldParent)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
