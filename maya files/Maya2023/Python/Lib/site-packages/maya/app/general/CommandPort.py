"""
Implementation of the commandPort command.

Input to a commandPort is handled by a subclass of TcommandHandler.
Customization of commandPort behaviour could be achieved by implementing
a custom subclass, and adding it to commandHandlersMap, with a string key
which will be passed to openCommandPort as the 'lang' parameter.
"""
import maya
maya.utils.loadStringResourcesForModule(__name__)

from errno import EINTR
import select
import threading
import time
import types
from maya import utils, cmds, mel, OpenMaya
from sys import version_info as sys_version_info
if sys_version_info[0] >= 3:
    import socketserver as SocketServer
else:
    import SocketServer


if cmds.about(windows=True):
    from . import ServerRegistryMMap

# map of command ports portName->TcommandServer
__commandPorts = {}
# map of language -> command handler class
commandHandlersMap = {}
# Transfer string encoding (used by Python 2 and 3)
encodingType = 'utf8'
# Query Maya encoding (in Python3 bindings are automatically taking care of the translation between str and the mayaEncoding)
mayaEncoding = cmds.about(codeset=True)

class TcommandHandler(SocketServer.StreamRequestHandler):
    """
    StreamRequestHandler base class for command ports, 
    handle() is called when client connects.  Subclasses must implement _languageExecute.
    """
    # the response terminator
    resp_term = '\n\x00'

    def postSecurityWarning(self):
        # Posts the security warning dialog, sets the dialog 
        # result accordingly
        message = maya.stringTable['y_maya_app_general_CommandPort.kSecurityWarningMessage' ]
        try:
            if len(self.data) > 300:
                data = self.data[0:300] + '...'
            else:
                data = self.data
            msg = message % (self.server.portName, data)
        except UnicodeDecodeError:
            msg = message % (self.server.portName, repr(self.data))
        allowButton = maya.stringTable['y_maya_app_general_CommandPort.kAllow' ]
        denyButton = maya.stringTable['y_maya_app_general_CommandPort.kDeny' ]
        allowAllButton = maya.stringTable['y_maya_app_general_CommandPort.kAllowAll' ]
        title = maya.stringTable['y_maya_app_general_CommandPort.kSecurityWarningTitle' ]
        res = cmds.confirmDialog(title = title,
                                message = msg,
                                button = (allowButton, denyButton, allowAllButton),
                                defaultButton = allowButton,
                                cancelButton = denyButton )
        if res == denyButton:
            self.dialog_result = False
        elif res == allowAllButton:
            self.dialog_result = True
        else:
            self.dialog_result = None

    def receiveData(self):
        # Called by handle() to accumulate one incoming message.
        # Returns the received message, None if the request should be terminated
        # Raises socket.timeout if no data is read

        nextdata = self.request.recv(self.server.bufferSize)

        if nextdata is None:
            return None
        data = nextdata   
        if len(data) == 0:
            return None
        oldtimeout = self.request.gettimeout()
        self.request.settimeout(1.5)
        import socket
        while len(nextdata) >= self.server.bufferSize:
            try:
                nextdata = self.request.recv(self.server.bufferSize)
                data += nextdata
            except socket.timeout:
                # no more data, go with what we have
                break
        self.request.settimeout(oldtimeout)

        # remove any string terminating character the buffer may contains
        data=data.translate(None,b'\x00')

        # Decode received utf8 string, can be done only when data is fully receive, we do not want to decode half of a multi byte character
        from sys import stderr as sys_stderr
        try :
            data = data.decode(encodingType).strip()
        except :
            warnMsg = maya.stringTable['y_maya_app_general_CommandPort.kInvalidUTF8' ]
            sys_stderr.write(warnMsg + "\n")
            return None
        # Second, for python 2 only, encode it to the local encoding back in a python2 str type
        # For Python 3, binding code invoking interpreter takes care of the conversion to Maya local
        from sys import version_info as sys_version_info
        if sys_version_info[0] < 3:
            try :
                data = data.encode(mayaEncoding)
            except :
                warnMsg = maya.stringTable['y_maya_app_general_CommandPort.kEncodeToNativeFailed' ]
                warnMsg = warnMsg % mayaEncoding
                sys_stderr.write(warnMsg + "\n")
                return None
        return data

    def handle(self):
        # Called to handle each connection request
        import socket
        try:
            # if we are echoing output, we hold on to the first request
            # and poll the socket for pending command messages.
            # Otherwise, we just block on the socket.
            if self.server.echoOutput:
                self.request.settimeout(1.5)
            while not self.server.die:
                # check for pending command messages
                if self.server.echoOutput:
                    while not self.server.commandMessageQueue.empty():
                        self.wfile.write(self.server.commandMessageQueue.get() + self.resp_term)
                # set self.data to be the incoming message
                try:
                    self.data = self.receiveData()
                except socket.timeout:
                    continue
                if self.data is None: 
                    break
                # check if we need to display the security warning
                # posting the dialog also has to be done in the gui thread
                if self.server.securityWarning:
                    utils.executeInMainThreadWithResult(self.postSecurityWarning)
                    if self.dialog_result is False:
                        self.wfile.write(maya.stringTable['y_maya_app_general_CommandPort.kExecutionDeniedByMaya' ] + self.resp_term)
                        return
                    elif self.dialog_result is True:
                        self.server.securityWarning = False

                # execute the message
                response = utils.executeInMainThreadWithResult(self._languageExecute)

                # write the command responses to the client
                self.wfile.write(response.encode(encodingType))
        except socket.error:
            # a socket exception is a normal way to terminate the connection
            pass


class TMELCommandHandler(TcommandHandler):
    """
    The StreamRequestHandler for deferred MEL execution
    """
    def _languageExecute(self):
        from sys import version_info as sys_version_info
        text_type = str if sys_version_info[0] >= 3 else unicode
        if sys_version_info[0] >= 3:
            from io import StringIO
            writer = StringIO()
        else:
            import StringIO
            writer = StringIO.StringIO()
        # if there is a prefix, add it to the start of each line
        #
        if len(self.server.prefix) > 0:
            newLines = []
            for line in self.data.split('\n'):
                newLines.append(self.server.prefix + ' "' + cmds.encodeString(line) + '";')
            self.data = '\n'.join(newLines)
        if not self.server.sendResults:
            try:
                mel.eval(self.data)
                writer.write( self.resp_term )
            except RuntimeError as ex:
                writer.write(text_type(ex) + self.resp_term)
        elif self.server.returnNbCommands:
            # send back number of commands eval'd instead of results

            try:
                mel.eval(self.data)
                writer.write( text_type(self.data.count('\n') + 1) + self.resp_term )
            except RuntimeError as ex:
                writer.write( text_type(ex) + self.resp_term )
        else:
            # eval each line and send back the results
            for line in self.data.split('\n'):
                outp = None
                try:
                    outp = mel.eval(line)
                except RuntimeError as ex:
                    outp = text_type(ex)
                else:
                    # if the result is a list, intersperse with tabs
                    if outp is not None and not isinstance(outp, (str,)):
                        if sys_version_info[0] >= 3:
                            import collections.abc
                            isSequence = isinstance(outp, collections.abc.Sequence)
                        else:
                            import operator
                            isSequence = operator.isSequenceType(outp)
                        if (isSequence):
                            tempList = []
                            for item in outp :
                                # If this item is not string type, like "int",
                                # We only need to use "text_type()"
                                if not isinstance(item, (str,)):
                                    tempList.append(text_type(item))
                                # If this item is string type, when using "text_type()"
                                # we need to specify the source encoding or it will fail
                                elif isinstance(item, str):
                                    if sys_version_info[0] >= 3:
                                       tempList.append(text_type(item))
                                    else:
                                        tempList.append(text_type(item, mayaEncoding))
                                else :
                                    # if it is already unicode
                                    tempList.append( item )
                            outp = '\t'.join( tempList )
                        else :
                            # like "int", "float".. type
                            try :
                                outp = text_type(outp)
                            except :
                                outp = None
                    # if the result is a string
                    elif isinstance(outp, str):
                        if sys_version_info[0]  < 3:
                            outp = text_type(outp, mayaEncoding)
                if outp is None:
                    outp = ""
                writer.write(outp.strip() + self.resp_term)
        try:
            return writer.getvalue()
        except:
            return self.resp_term

class TpythonCommandHandler(TcommandHandler):
    """
    The StreamRequestHandler instance for deferred python execution
    """
    def _languageExecute(self):
        lines = self.data.splitlines()
        # if there is a prefix, add it to the start of each line
        #
        if len(self.server.prefix) > 0 :
            newLines = []
            for _line in lines :
                newLines.append( self.server.prefix + ' "' + cmds.encodeString(_line) + ' "' )
            lines = newLines
            self.data = '\n'.join( newLines )

        outp = None
        if len(lines) == 1:
            try:
                # first try evaluating it as an expression so we can get the result
                outp = eval(self.data)
            except Exception:
                pass
        if outp is None:
            # more than one line, or failed to eval
            # exec everything instead
            try:
                lv= locals()
                exec(self.data, globals(), lv)
                outp= lv[self.server.outputVarName]
            except Exception as ex:
                outp = ex

        if self.server.returnNbCommands:
            outp = len(lines)
        if not self.server.sendResults:
            outp = ""
        from sys import version_info as sys_version_info
        text_type = str if sys_version_info[0] >= 3 else unicode
        if sys_version_info[0] == 2:
            # If it is a local string, we need to decode it to unicode first
            if isinstance(outp, str) :
                outp = text_type(outp, mayaEncoding)
            # If it is a list, try to deocode all local strings inside it to unicode
            if type(outp) == type([]):
                listSize = len(outp)
                for i in range(0, listSize):
                    if isinstance(outp[i], str):
                        outp[i] = text_type(outp[i], mayaEncoding)

        if self.server.pickleOutput and self.server.sendResults:
            if sys_version_info[0] >= 3:
                import pickle as PICKLE
            else:
                import cPickle as PICKLE
            try :
                # Pickle form, type of "outp" is "str"
                outp = text_type(PICKLE.dumps(outp))
            except PICKLE.PickleError as ex:
                outp = text_type(ex)
        elif not isinstance(outp, text_type):
            outp = text_type(outp)
        return (outp + self.resp_term)

def commandOutputCallback(message, msgType, qu):
    # Command callback function
    # When new output comes in, we add the output 
    # to the message queue, which the request handler will drain
    #    
    # message - the message string
    # msgType - message type enum
    # qu      - user data, which is the message queue
    qu.put(message)

class TcommandServer(threading.Thread):
    """
    Server for one command port
    
    socketServer - StreamServer instance to serve on endpoint
    """
    def __init__(self, socketServer):
        threading.Thread.__init__(self,None)
        self.daemon = True
        self.servObj = socketServer
        self.__die = False

    def run(self):
        r""" called by Thread.start """
        self.servObj.die = False
        if self.servObj.echoOutput:
            from sys import version_info as sys_version_info
            if sys_version_info[0] >= 3:
                import queue as Queue
            else:
                import Queue
            self.servObj.commandMessageQueue = Queue.Queue()
            self.callbackId = OpenMaya.MCommandMessage.addCommandOutputCallback(commandOutputCallback, self.servObj.commandMessageQueue)

        while not self.__die:
            try:
                self.servObj.handle_request()
            except select.error as ex:
                # EINTR error can be ignored
                if ex[0] == EINTR:
                    continue
                raise

    def __del__(self):
        if self.servObj.echoOutput:
            OpenMaya.MCommandMessage.removeCallback(self.callbackId)
        self.servObj.cleanup()

    def shutdown(self):
        """ tell the server to shutdown """
        self.__die = True
        import socket
        try:
            # create a socket, connect to our listening socket and poke it so that it dies
            self.servObj.die = True
            s = socket.socket(self.servObj.socket.family, self.servObj.socket.type)
            s.connect(self.servObj.endpoint)

            s.send( '\x00'.encode(encodingType) )
            s.close()
        except (socket.gaierror,socket.error):
            # several errors could happen here, 
            # most are ok as we are closing the socket anyway
            pass

# Add default command handlers
commandHandlersMap['python'] = TpythonCommandHandler
commandHandlersMap['mel'] = TMELCommandHandler

def openCommandPort(portName, lang, prefix, sendResults, returnNbCommands, echoOutput, bufferSize, securityWarning, outputVarName, pickleOutput = False):
    """
    Open a command port with the given name
    Can be INET (host:port) or Unix local format (/tmp/endpoint)
    
    On Windows, the Unix-style format will create a named binary file-mapping
    object which contains a mapping of paths to ports.
    On Mac and Linux a Unix-domain socket will be created.
    
    Environment variable MAYA_IP_TYPE can be used to override the default 
    address family by setting it to either 'ipv4' or 'ipv6'.  The default is 
    ipv4.

    portname         - name of the port, used to refer to the server, follows 
                       above format
    lang             - must be a key in commandHandlersMap eg 'mel' or 'python'
    prefix           - string prefix to prepend to every command
    sendResults      - True means send results of commands back to client
    returnNbCommands - True means return the number of commands executed
    echoOutput       - True means echo command output to the port
    bufferSize       - byte size of the socket buffer
    securityWarning  - True means issue a security warning
    pickleOutput     - True means the return string for python command would be
                       pickled, default is false
    Returns error string on failure, None on success
    """
    # make sure port name is encodable as str
    try:
        portName = str(portName)
    except UnicodeEncodeError:
        msg = maya.stringTable['y_maya_app_general_CommandPort.kCoundNotCreateCommandPortNotAscii' ]
        return(msg % portName)
        
    nameLen = len(portName)
    
    # parse out an ipv6 network resource identifier format '[2001:db8::1428:57ab]:443' -> '2001:db8::1428:57ab:443'
    if nameLen > 0 and portName[0] == '[' and portName.rfind(']') > 0:
        portNameNormal = portName[1:].replace(']', '')
    else:
        portNameNormal = portName

    portInvalidNameMsg = maya.stringTable['y_maya_app_general_CommandPort.kCouldNotCreateCommandPortInvalidName' ]
    colonIx = portNameNormal.rfind(':')
    if nameLen == 0 or colonIx == nameLen - 1:
        msg = portInvalidNameMsg
        return(msg % portName)

    # look up command handler for this language
    try:
        HdlrClass = commandHandlersMap[lang]
    except KeyError:
        msg = maya.stringTable['y_maya_app_general_CommandPort.kLanguageNotSupported' ]
        return(msg % lang)

    # check if the portName is already active
    if portName in __commandPorts:
        # edit actual command port server
        commandPortServer = __commandPorts[portName].servObj
        commandPortServer.outputVarName =    outputVarName

        commandPortServer.pickleOutput =     pickleOutput
        return

    # select default address family, defaulting to ipv4 unless we set the environment
    # variable to use IPv6
    # ultimatly, the address family is determined by the portName string, which may be
    # one or the other.
    hasIPV6 = False
    import socket
    addrFamily = socket.AF_INET
    host = '127.0.0.1'
    try:
        from os import environ as os_environ
        maya_ip_type = os_environ['MAYA_IP_TYPE'].lower()
        if 'ipv6' == maya_ip_type:
            try:
                # this call will raise if the OS doesn't support ipv6
                socket.getaddrinfo('::1',None)
                hasIPV6 = True
                host = '::1'
                addrFamily = socket.AF_INET6
            except socket.gaierror:
                # ipv6 isn't going work
                pass
    except KeyError: pass
	
    port = 0
    # parse out the endpoint
    from sys import version_info as sys_version_info
    if sys_version_info[0] >= 3:
        import socketserver as SocketServer
    else:
        import SocketServer
    if colonIx >= 0:
        defaulthost = host
        # INET port, don't know if it is ipv4 or ipv6 yet
        try:
            if colonIx == 0:
                # eg: ':65000'
                port = int(portNameNormal[1:])
            else:
                # eg: 'localhost:65000'
                host = portNameNormal[0:colonIx]
                port = int(portNameNormal[colonIx+1:])

            if port > 65535 or port < 1:
                msg = maya.stringTable['y_maya_app_general_CommandPort.kCoundNotCreateCommandPortInvalidPort' ]
                return(msg % portName)

            try:
                try:
                    # check the endpoint with the current addrFamily and host
                    endpoints = socket.getaddrinfo(host,port,addrFamily)
                except socket.gaierror:
                    if defaulthost != host:
                        # maybe the hostname is wrong, try the default hostname
                        endpoints = socket.getaddrinfo(defaulthost,port,addrFamily)
                    else:
                        raise
            except socket.gaierror:
                # try the other address family, unless there is no other
                if not hasIPV6:
                    raise
                if addrFamily is socket.AF_INET6:
                    addrFamily = socket.AF_INET
                else:
                    addrFamily = socket.AF_INET6
                endpoints = socket.getaddrinfo(host,port,addrFamily)
            if len(endpoints) == 0:
                raise ValueError
            endpoint = endpoints[0][-1]
        except (ValueError, socket.gaierror):
            msg = portInvalidNameMsg
            return(msg % portName)
        ServerClass = SocketServer.TCPServer
        ServerClass.address_family = addrFamily
        def cleanup(): pass
    else:
        # filename (no ':' in name)
        if cmds.about(windows=True):
            try:
                # We have a named mmap file wherein we keep the mappings of paths to INET ports
                endpoint = ServerRegistryMMap.registerServer(portName.encode(encodingType), addrFamily)
            except RuntimeError as ex:
                return ex.args[0]
            ServerClass = SocketServer.TCPServer
            ServerClass.address_family = addrFamily
            def cleanup(): pass
        else:
            # normal Unix domain socket
            if portNameNormal[0] == '/':
                endpoint = portNameNormal
            else:
                endpoint = '/tmp/' + portNameNormal
            from os import path as os_path
            if os_path.exists(endpoint):
                # file is already there, delete it now so that we can create it again
                try:
                    from os import remove as os_remove
                    os_remove(endpoint)
                except OSError:
                    # probably won't be able to create the socket
                    # but try anyway
                    pass
            ServerClass = SocketServer.UnixStreamServer
            def cleanup():
                try:
                    from os import remove as os_remove
                    os_remove(endpoint)
                except OSError: pass
    
    try:
        # create the server and attach preferences variables
        socketServer =                  ServerClass(endpoint, HdlrClass)
        socketServer.prefix =           prefix
        socketServer.sendResults =      sendResults
        socketServer.returnNbCommands = returnNbCommands and sendResults
        socketServer.echoOutput =       echoOutput and sendResults
        socketServer.bufferSize =       max(16, int(bufferSize))
        socketServer.securityWarning =  securityWarning
        socketServer.portName =         portNameNormal
        socketServer.endpoint =         endpoint              
        socketServer.cleanup =          cleanup
        socketServer.outputVarName =    outputVarName

        socketServer.pickleOutput =     pickleOutput

        # create the command server and start it
        cmdServer = TcommandServer(socketServer)
        __commandPorts[portName] = cmdServer
        cmdServer.start()
        time.sleep(0)
    except socket.error as ex:
        msg = maya.stringTable['y_maya_app_general_CommandPort.kSocketErrorCreatingCommandPort' ]
        return(msg % (portName, ex.args[0]))

def closeCommandPort(portName):
    """ 
    Close the specified command port  
    Returns error string on failure, None on success
    """
    try:
        portName = str(portName)
        server = __commandPorts.pop(portName)
        server.shutdown()
        if cmds.about(windows=True):
            activeServers = ServerRegistryMMap.getInstance()
            activeServers.removeServer(portName)
    except (KeyError, UnicodeEncodeError):
        return(maya.stringTable['y_maya_app_general_CommandPort.kNoSuchCommandPort' ] % repr(portName))

def listCommandPorts():
    """
    Returns the list of command port names, in the format used by openCommandPort
    """
    from sys import version_info as sys_version_info
    if sys_version_info[0] >= 3:
        return list(__commandPorts.keys())
    else:
        return __commandPorts.keys()
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
