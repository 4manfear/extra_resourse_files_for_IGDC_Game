import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Support for the Ghost items that appear in the main menus
'''
from functools import partial
import maya.cmds as cmds
from maya.app.ghosting.GhostingManager import GhostingManager, string_to_frames
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferencePreFrames, GhostingPreferencePostFrames, GhostingPreferenceGhostsStep

__all__ = [ r'create_visualize_ghosting_menu_items'
          , r'create_window_ghosting_menu_item'
          , r'create_animation_shelf_ghosting_buttons'
          , r'initialize_ghosting_runtime_commands'
          , r'layout_ghosting_attributes'
          , r'ae_check_ghosting_mode'
          ]

# List of the preferences that the preferences UI will be monitoring for changes
PREFERENCES_MONITORED = [ GhostingPreferencePreFrames()
                        , GhostingPreferencePostFrames()
                        , GhostingPreferenceGhostsStep()
                        ]

# Unique client ID for object-independent preference change callbacks
CLIENT_GHOSTING=r'GhostingMenus'

# runTimeCommand names, constants for consistency
RTC_UNGHOST_ALL=r'UnghostAll'
ANN_UNGHOST_ALL=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kUnghostAllAnno'  ]
LBL_UNGHOST_ALL=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kUnghostAllLabl'  ]
#
RTC_GHOST_SELECTED=r'GhostSelected'
ANN_GHOST_SELECTED=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kGhostSelAnno'  ]
LBL_GHOST_SELECTED=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kGhostSelLabl'  ]
#
RTC_UNGHOST_SELECTED=r'UnghostSelected'
ANN_UNGHOST_SELECTED=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kUnghostSelAnno'  ]
LBL_UNGHOST_SELECTED=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kUnghostSelLabl'  ]
#
RTC_OPEN_GHOST_EDITOR=r'OpenGhostEditor'
LBL_OPEN_GHOST_EDITOR_WINDOW_MENU=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kOpenGhostEditorLablWindowMenu'  ]
ANN_OPEN_GHOST_EDITOR=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kOpenGhostEditorAnno'  ]
LBL_OPEN_GHOST_EDITOR=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kOpenGhostEditorLabl'  ]

# Flag to allow lazy initialization of runtime commands
GHOSTING_RUNTIME_INITIALIZED=False

# Menu and operation tags, similar to what are in defaultRunTimeCommands.mel but able to initialize on demand
TAGS_GHOSTING=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kTag_Visualize' ]
KEYWORDS_GHOSTING=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kKwFormat' ].format( maya.stringTable['y_maya_app_ghosting_GhostingMenus.kKwGhosting' ], maya.stringTable['y_maya_app_ghosting_GhostingMenus.kKwPreviewAnimation' ] )

# Widget names used by the attribute editor
AE_TEMPLATE = r'attributeEditorTemplate'
AE_CUSTOM_FRAMES_WIDGET = r'customFramesText'

# Node types not allowing ghosting attributes to be shown
NODE_TYPES_HIDING_GHOSTING_ATTRIBUTES = [ r'ikHandle'
                                        , r'pointEmitter'
                                        , r'particle'
                                        , r'nParticle'
                                        , r'motionTrailShape'
                                        ]


#======================================================================
def tag_runtime_ghosting_commands():
    '''
    Tag all of the runTimeCommands used by ghosting UI.
    '''
    for command in [RTC_GHOST_SELECTED, RTC_UNGHOST_SELECTED, RTC_UNGHOST_ALL]:
        try:
            cmds.runTimeCommand( command, edit=True, tags=TAGS_GHOSTING, keywords=KEYWORDS_GHOSTING )
        except Exception:
            cmds.warning( maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kRuntimeCommandTagFailure' ].format(command) )

#======================================================================
def mel_as_python(mel_script):
    '''Return the mel_script as it would be executed directly through the Python interpreter'''
    mel_script = mel_script.replace( r'"', r'\"' )
    return r'import maya.mel ; maya.mel.eval("{}")'.format( mel_script )

#======================================================================
def initialize_ghosting_runtime_commands():
    '''
    Create all of the runTimeCommands used by ghosting UI.
    These command will be initialized at gui.py
    '''
    # The runtime commands only need to be initialized once. Use the global flag to
    # allow anyone using the commands to call here without worrying about that.
    global GHOSTING_RUNTIME_INITIALIZED
    if GHOSTING_RUNTIME_INITIALIZED:
        return
    GHOSTING_RUNTIME_INITIALIZED=True

    cmds.runTimeCommand( RTC_UNGHOST_ALL
                       , default=True
                       , label=LBL_UNGHOST_ALL
                       , annotation=ANN_UNGHOST_ALL
                       , image=r'ghostOff.png'
                       , category=r'Menu items.Animation.Visualize'
                       , command=r'from maya.app.ghosting.GhostingManager import GhostingManager ; GhostingManager().unghost_all()'
                       )

    cmds.runTimeCommand( RTC_GHOST_SELECTED
                       , default=True
                       , label=LBL_GHOST_SELECTED
                       , annotation=ANN_GHOST_SELECTED
                       , category=r'Other items.Display'
                       , command=r'from maya.app.ghosting.GhostingManager import GhostingManager ; GhostingManager().ghost_selected()'
                       , showInHotkeyEditor=False
                       )

    cmds.runTimeCommand( RTC_UNGHOST_SELECTED
                       , default=True
                       , label=LBL_UNGHOST_SELECTED
                       , annotation=ANN_UNGHOST_SELECTED
                       , category=r'Other items.Display'
                       , command=r'from maya.app.ghosting.GhostingManager import GhostingManager ; GhostingManager().unghost_selected()'
                       , showInHotkeyEditor=False
                       )

    cmds.runTimeCommand( RTC_OPEN_GHOST_EDITOR
                       , default=True
                       , label=LBL_OPEN_GHOST_EDITOR
                       , annotation=ANN_OPEN_GHOST_EDITOR
                       , image=r'ghostingEditor.png'
                       , category=r'Other items.Display'
                       , command=r'from maya.app.ghosting.GhostingEditor import GhostingEditor ; GhostingEditor().build_editor()'
                       )

    tag_runtime_ghosting_commands()

#======================================================================
def update_toggle_menu(menu_item):
    '''Update the toggle ghosting menu item state from the preference'''
    if cmds.menuItem( menu_item, exists=True ):
        cmds.menuItem( menu_item, edit=True, checkBox=GhostingManager().enabled )

def create_window_ghosting_menu_item():
    '''
    Create the Ghosting Editor menu item that apper in the main Window menu.
    '''

    cmds.menuItem( r'WindowGhostEditorItem'
                 , version=r'2022'
                 , sourceType=r'mel'
                 , label=LBL_OPEN_GHOST_EDITOR_WINDOW_MENU
                 , runTimeCommand=RTC_OPEN_GHOST_EDITOR
                 )

#======================================================================
def create_visualize_ghosting_menu_items():
    '''
    Create the Ghost menu items that appear in the main Visualize menu.
    The ifdef is put in this method so that the menu calling it can be blissfully ignorant
    of when and why the menu items are disabled.
    '''

    cmds.menuItem( divider=True
                 , dividerLabel=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kTimeGhost'  ]
                 )
    cmds.menuItem( r'GhostEditorItem'
                 , version=r'2022'
                 , sourceType=r'mel'
                 , runTimeCommand=RTC_OPEN_GHOST_EDITOR
                 )
    cmds.menuItem( r'GhostSelectedItem'
                 , sourceType=r'mel'
                 , runTimeCommand=RTC_GHOST_SELECTED
                 )
    cmds.menuItem( r'UnghostSelectedItem'
                 , sourceType=r'mel'
                 , runTimeCommand=RTC_UNGHOST_SELECTED
                 )

    cmds.menuItem( r'UnghostAllItem'
                 , sourceType=r'mel'
                 , runTimeCommand=RTC_UNGHOST_ALL
                 )

#======================================================================
def create_animation_shelf_ghosting_buttons():
    '''
    Create the Ghost items that appear in the default Animation shelf.
    The ifdef is put in this method so that the menu calling it can be blissfully ignorant
    of when and why the menu items are disabled.
    '''
    annotation_format = maya.stringTable['y_maya_app_ghosting_GhostingMenus.kRtcAnnFmt' ]

    cmds.shelfButton( sourceType=r'mel'
                    , command=RTC_GHOST_SELECTED
                    , label=LBL_GHOST_SELECTED
                    , annotation=annotation_format.format(LBL_GHOST_SELECTED, ANN_GHOST_SELECTED)
                    , image1=r'ghost.png'
                    )
    cmds.shelfButton( sourceType=r'mel'
                    , command=RTC_UNGHOST_SELECTED
                    , label=LBL_UNGHOST_SELECTED
                    , annotation=annotation_format.format(LBL_UNGHOST_SELECTED, ANN_UNGHOST_SELECTED)
                    , image1=r'ghostOff.png'
                    )
    cmds.shelfButton( version=r'2022'
                    , sourceType=r'mel'
                    , command=RTC_OPEN_GHOST_EDITOR
                    , label=LBL_OPEN_GHOST_EDITOR
                    , annotation=annotation_format.format(LBL_GHOST_SELECTED, ANN_OPEN_GHOST_EDITOR)
                    , image1=r'ghostingEditor.png'
                    )

#======================================================================
def layout_ghosting_attributes(node_name):
    '''
    Run the template commands that display the ghosting attributes in DAG nodes.
    :param node_name: Name of node for which the attributes are being shown
    '''
    node_type = cmds.objectType( node_name )
    is_field = (cmds.ls( node_name, type=r'field' ) != [])
    ghosting_enabled = (not is_field and node_type not in NODE_TYPES_HIDING_GHOSTING_ATTRIBUTES)
    if ghosting_enabled:
        cmds.editorTemplate( beginLayout=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kGhostingInformation' ] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kAttrGhosting' ],          addControl=[r'ghosting'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kAttrGhostingMode' ], addControl=[r'ghostingMode', ae_check_ghosting_mode] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kPreFrames'],            addControl=[r'ghostPreFrames'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kPostFrames'],          addControl=[r'ghostPostFrames'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kGhostsStep'],                 addControl=[r'ghostsStep'] )
        cmds.editorTemplate( r'ghostFrames', callCustom=[ae_ghost_frames_new,ae_ghost_frames_replace] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kGhostUseDriver'], addControl=[r'ghostUseDriver'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kGhostDriver'],        addControl=[r'ghostDriver'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kPreFrameColor'],   addControl=[r'ghostColorPre'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kPostFrameColor'], addControl=[r'ghostColorPost'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kNearOpacity'],        addControl=[r'ghostNearOpacity'] )
        cmds.editorTemplate( label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kFarOpacity'],          addControl=[r'ghostFarOpacity'] )
        cmds.editorTemplate( suppress=r'ghostCustomSteps' )
        cmds.editorTemplate( suppress=r'ghostOpacityRange' )
        cmds.editorTemplate( endLayout=True )
    else:
        for ghosting_attribute in [ r'ghosting'
                                  , r'ghostingMode'
                                  , r'ghostCustomSteps'
                                  , r'ghostPreFrames'
                                  , r'ghostPostFrames'
                                  , r'ghostsStep'
                                  , r'ghostFrames'
                                  , r'ghostOpacityRange'
                                  , r'ghostFarOpacity'
                                  , r'ghostNearOpacity'
                                  , r'ghostColorPre'
                                  , r'ghostColorPreR'
                                  , r'ghostColorPreG'
                                  , r'ghostColorPreB'
                                  , r'ghostColorPost'
                                  , r'ghostColorPostR'
                                  , r'ghostColorPostG'
                                  , r'ghostColorPostB'
                                  , r'ghostDriver'
                                  , r'ghostUseDriver']:
            cmds.editorTemplate( suppress=ghosting_attribute )

#======================================================================
def ae_check_ghosting_mode(node_name):
    '''
    Check the current ghosting mode in the node and upate the attribute editor template widgets to match it.
    :param node_name: The name of the node whose ghosting mode is to be checked
    '''
    try:
        ghosting_mode = cmds.getAttr( r'{}.ghostingMode'.format( cmds.ls( node_name, long=True )[0] ) )
    except IndexError:
        # This would only happen if the node were deleted before this callback
        return
    dim_pre          = False
    dim_post         = False
    dim_step         = False
    dim_frames       = False
    dim_ghost_driver = False

    if ghosting_mode == 0: # preAndPost
        dim_frames = True
        dim_ghost_driver = True
    elif ghosting_mode == 1: # pre
        dim_post = True
        dim_frames = True
        dim_ghost_driver = True
    elif ghosting_mode == 2: # post
        dim_pre = True
        dim_frames = True
        dim_ghost_driver = True
    elif ghosting_mode == 3: # custom frames
        dim_post = True
        dim_pre = True
        dim_ghost_driver = True
        dim_step = True
    elif ghosting_mode == 4: # Keyframes pre/post
        dim_frames = True
    elif ghosting_mode == 5: # Keyframes all
        dim_post = True
        dim_pre = True
        dim_frames = True
        dim_step = True

    if cmds.textFieldGrp( AE_CUSTOM_FRAMES_WIDGET, exists=True ):
        cmds.textFieldGrp( AE_CUSTOM_FRAMES_WIDGET, edit=True, enable=(not dim_frames) )

    cmds.editorTemplate( dimControl=[node_name, r'ghostPreFrames', dim_pre] )
    cmds.editorTemplate( dimControl=[node_name, r'ghostPostFrames',  dim_post] )
    cmds.editorTemplate( dimControl=[node_name, r'ghostsStep',   dim_step] )
    cmds.editorTemplate( dimControl=[node_name, r'ghostUseDriver',  dim_ghost_driver] )
    cmds.editorTemplate( dimControl=[node_name, r'ghostDriver',  dim_ghost_driver] )

#======================================================================
def ae_ghost_frames_new(plug_added):
    '''
    When a plug is added to the template this will be called to generate the UI for it
    :param plug_added: Name of plug added
    '''
    cmds.setUITemplate( AE_TEMPLATE, pushTemplate=True )
    cmds.textFieldGrp( AE_CUSTOM_FRAMES_WIDGET, label=maya.stringTable['y_maya_app_ghosting_GhostingMenus.kCustomFrames' ]
                     , annotation=maya.stringTable[ 'y_maya_app_ghosting_GhostingMenus.kEnterTheFrameNumbersSeparatedAnnot'  ] )
    ae_ghost_frames_replace( plug_added )
    cmds.setUITemplate( popTemplate=True )

#======================================================================
def ae_ghost_frames_replace(plug_replaced):
    '''
    When a plug is added to the template with existing UI this will be called to update that UI
    :param plug_replaced: Name of plug replaced
    '''
    frame_string = r','.join( [str(frame) for frame in cmds.getAttr(plug_replaced) or []] )
    cmds.textFieldGrp( AE_CUSTOM_FRAMES_WIDGET, edit=True, text=frame_string )
    cmds.textFieldGrp( AE_CUSTOM_FRAMES_WIDGET, edit=True, changeCommand=partial(ae_update_ghost_frames, plug_to_update=plug_replaced) )

#======================================================================
def ae_update_ghost_frames(plug_to_update):
    '''
    Callback for when the custom frames widget is updated
    :param plug_to_update: Name of plug being updated
    '''
    frame_string = cmds.textFieldGrp( AE_CUSTOM_FRAMES_WIDGET, query=True, text=True )
    frame_list = string_to_frames( frame_string )
    cmds.setAttr( plug_to_update, [len(frame_list)] + frame_list, type=r'Int32Array' )
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
