import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Create and manage the Ghost Editor window. Usually created through the Animation -> Visualize menu.
It can also be created manually via:
    from maya.app.ghosting.GhostingEditor import GhostingEditor
    ghost_editor = GhostingEditor()
    ghost_editor.build_editor()
'''
from functools import partial
import maya.cmds as cmds
from maya.common.utils import Singleton
from maya.common.ui import LayoutManager
from maya.common.ui import callback_tool
from maya.app.ghosting.GhostingManager import GhostingManager, string_to_frames
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceAllInRange
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceCustomFrames
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceEnabled
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceFarOpacity
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceGeometryFilter
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferencePostFrames
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferencePreFrames
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceGhostsStep
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceHierarchy
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceJointFilter
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceLocatorFilter
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceMode
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceNearOpacity
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferencePostColour
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferencePreColour
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferencePreset
from maya.app.ghosting.ghosting_optionvar_states import GhostingPreferenceUseDriver
from maya.app.ghosting.ghosting_optionvar_states import GHOSTING_MODE_PRE_AND_POST_FRAMES, GHOSTING_MODE_PRE_FRAMES, GHOSTING_MODE_POST_FRAMES, GHOSTING_MODE_CUSTOM_FRAMES, GHOSTING_MODE_KEYFRAMES
from maya.app.ghosting.ghosting_optionvar_states import GHOSTING_PRESET_CUSTOM, GHOSTING_PRESETS
from maya.app.ghosting.ghosting_optionvar_states import INDEX_ENUM_ID, INDEX_ENUM_NAME, INDEX_ENUM_INFO, INDEX_ENUM_DATA
from future.utils import with_metaclass

__all__ = [ r'GhostingEditor'
          ]

# Shared strings
GHOSTING_EDITOR_TITLE=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingEditorTitle' ]

#======================================================================

class GhostingEditor(with_metaclass(Singleton, object)):
    '''
    Class that manages creation and management of the operation of the ghosting editor.
    '''

    # The name to use for various widgets in the editor. Makes them easier to identify in UI inspectors and to find in callbacks.
    ID_ADD_FRAME       = r'GhostingAddCurrentFrame'
    ID_ALL_IN_RANGE    = r'GhostingAllInRange'
    ID_CUSTOM_FRAMES   = r'GhostingCustomFrames'
    ID_DISPLAY         = r'GhostingDisplay'
    ID_ENABLED         = r'GhostingEnabled'
    ID_FAR_OPACITY     = r'GhostingFarOpacity'
    ID_GHOSTS_STEP     = r'GhostingGhostsStep'
    ID_GHOSTS_POST     = r'GhostingGhostsPost'
    ID_GHOSTS_PRE      = r'GhostingGhostsPre'
    ID_GHOST_LIST      = r'GhostingGhostList'
    ID_HIERARCHY       = r'GhostingHierarchy'
    ID_MODES           = r'GhostingModes'
    ID_NEAR_OPACITY    = r'GhostingNearOpacity'
    ID_OBJECTS         = r'GhostingObjects'
    ID_OBJ_ALL         = r'GhostingObjectTypeAll'
    ID_GEOMETRY_FILTER = r'GhostingObjectTypeGeometry'
    ID_JOINT_FILTER    = r'GhostingObjectTypeJoint'
    ID_LOCATOR_FILTER  = r'GhostingObjectTypeLocator'
    ID_PRE_COLOUR      = r'GhostingPreColour'
    ID_PRESET_PREFIX   = r'GhostingPreset_'
    ID_PRESETS         = r'GhostingPresets'
    ID_POST_COLOUR     = r'GhostingPostColour'
    ID_SELECTED        = r'GhostingGhostSelected'
    ID_UNGHOST         = r'GhostingUnghost'
    ID_UNGHOST_ALL     = r'GhostingUnghostAll'
    ID_USE_DRIVER      = r'GhostingUseDriver'
    ID_WINDOW          = r'GhostingEditor'
    #
    ID_LAYOUT_DISPLAY          = r'GhostingLayoutDisplay'
    ID_LAYOUT_GHOSTED_OBJECTS  = r'GhostingLayoutGhostedObjects'
    ID_LAYOUT_FILTERS          = r'GhostingLayoutFilters'
    ID_LAYOUT_FRAME_PARAMETERS = r'GhostingLayoutFrameParameters'
    ID_LAYOUT_MODES            = r'GhostingLayoutModes'
    ID_LAYOUT_PRESETS          = r'GhostingLayoutPresets'
    ID_LAYOUT_ROOT             = r'GhostingEditorRoot'
    ID_LAYOUT_SELECTED         = r'GhostingLayoutSelected'
    ID_LAYOUT_SETTINGS         = r'GhostingSettings'
    ID_LAYOUT_SETTINGS_ROWS    = r'GhostingSettingsRows'
    ID_LAYOUT_UNGHOST          = r'GhostingLayoutUnghost'
    #
    ID_LABEL_GHOSTS_STEP     = r'GhostingGhostsStepLabel'
    ID_LABEL_HIERARCHY       = r'GhostingHierarchyLabel'
    ID_LABEL_LAYOUT_PRESETS  = r'GhostingLayoutPresetsLabel'
    ID_LABEL_OBJECT_TYPES    = r'GhostingObjectTypesLabel'
    #
    ID_MODE_POST_FRAMES     = r'GhostingPreFrames'
    ID_MODE_PRE_FRAMES      = r'GhostingPostFrames'
    ID_MODE_PRE_POST_FRAMES = r'GhostingPrePostFrames'
    ID_MODE_CUSTOM_FRAMES   = r'GhostingFrames'
    ID_MODE_KEYFRAMES       = r'GhostingKeyframes'
    MODE_INFO = [ [ID_MODE_PRE_POST_FRAMES, GHOSTING_MODE_PRE_AND_POST_FRAMES]
                , [ID_MODE_PRE_FRAMES,      GHOSTING_MODE_PRE_FRAMES]
                , [ID_MODE_POST_FRAMES,     GHOSTING_MODE_POST_FRAMES]
                , [ID_MODE_CUSTOM_FRAMES,   GHOSTING_MODE_CUSTOM_FRAMES]
                , [ID_MODE_KEYFRAMES,       GHOSTING_MODE_KEYFRAMES] ]

    #----------------------------------------------------------------------
    class DisableUiUpdateScope(object):
        '''
        Scope class that will disable the GhostingEditor callback operation within the scope.
        Use it to bracket changes initiated by the editor itself that would trigger its own callbacks:
            with DisableCallbacks():
                GhostingManager().change_some_value_with_a_widget()
        '''
        def __enter__(self):
            '''Enter the scope, remember the current callback enabled state for restoring on exit and disabling callbacks'''
            self.paused_callbacks = GhostingEditor().pause_preference_callback()
            self.was_enabled = GhostingEditor().update_ui_from_values
            GhostingEditor().update_ui_from_values = False
            

        def __exit__(self,exit_type,value,traceback):
            '''Exit the scope, restoring all of the state information'''
            assert self.paused_callbacks is not None # Only if the with() syntax was not used
            
            
            GhostingEditor().update_ui_from_values = self.was_enabled
            GhostingEditor().resume_preference_callback(self.paused_callbacks)

        def __init__(self):
            '''Initialize values - do not instantiate directly, use the with() syntax'''
            self.was_enabled = None
            self.paused_callbacks = None

    #----------------------------------------------------------------------
    def __init__(self):
        '''
        Set up all of the class members to their default values
        :member widgets: List of UI widgets in the editor. KEY=Widget ID, VALUE=Widget Name
        :member preference_callbacks: List of preferences for which callbacks have been added
        :member update_ui_from_values: Normally True; when False ignore callbacks for preference changes (usually because this UI initiated the changes)
        :member selection_change_job: scriptJob ID for the selection change event callback
        :member ghost_list_change: scriptJob ID for event triggered when items on the ghosted objects list are changed
        :member delayed_update_job: Temporary scriptJob ID when the UI is updated on idle. It's runOnce but the UI may be destroyed before it's fired.
        '''
        
        # Safety check for when the editor failed to open for any reason (mostly for debugging)
        if cmds.window( self.ID_WINDOW, exists=True ):
            cmds.deleteUI( self.ID_WINDOW )

        self.preference_callbacks = []
        self.update_ui_from_values = True
        self.widgets = {}
        self.selection_change_job = None
        self.ghost_list_change_job = None
        self.delayed_update_job = None

    #----------------------------------------------------------------------
    def build_editor(self):
        '''
        Populate the editor and show it. Kept separate from the __init__ function since this class is a Singleton
        but we might want to open and close the editor multiple times.
        '''
        
        # No need to rebuild if the window already exists
        if cmds.window( self.ID_WINDOW, exists=True ):
            
            cmds.showWindow( self.ID_WINDOW )
            return

        self.preference_callbacks = {}
        self.update_ui_from_values = True
        self.widgets = {}
        self.widgets[self.ID_WINDOW] = cmds.window( self.ID_WINDOW
                                                  , title=GHOSTING_EDITOR_TITLE
                                                  , iconName=GHOSTING_EDITOR_TITLE
                                                  , menuBar=True
                                                  )

        # The menus do not need a layout
        cmds.menu( label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingMenuEdit'  ] )
        cmds.menuItem( label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingMenuEditReset' ]
                     , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingMenuEditResetAnn' ]
                     , command=callback_tool(self, self.callback_reset_all)
                     )
        cmds.menu( label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingMenuHelp'  ], helpMenu=True, familyImage=r'menuIconHelp.png' )
        cmds.menuItem( label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingMenuHelpLink' ]
                     , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostMenuHelpLinkAnn' ]
                     , command=lambda tool: cmds.showHelp( r'GhostingEditor' )
                     )

        # This monitoring happens even if the values do not initially populate
        cmds.scriptJob( uiDeleted=(self.widgets[self.ID_WINDOW], callback_tool(self, self.callback_window_deleted)) )

        with LayoutManager( cmds.columnLayout( self.ID_LAYOUT_ROOT, adjustableColumn=True, rowSpacing=10 ) ):

            self.widgets[self.ID_LAYOUT_SETTINGS] = cmds.frameLayout( self.ID_LAYOUT_SETTINGS, collapsable=True, label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingSettings' ] )
            with LayoutManager( self.widgets[self.ID_LAYOUT_SETTINGS] ):

                #----------------------------------------
                with LayoutManager( cmds.rowColumnLayout( self.ID_LAYOUT_SETTINGS_ROWS
                                                        , numberOfRows=2
                                                        , adjustableColumn=2
                                                        , columnAttach=[(1,r'both',5), (2,r'both',5)]
                                                        , rowOffset=[(1,r'top',5), (2,r'both',5)]
                                                        , rowAlign=[(1,r'center'), (2,r'center')] ) ):

                    cmds.text( self.ID_LABEL_OBJECT_TYPES
                             , label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingObjTypesLbl' ]
                             , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingObjTypesAnn' ]
                             , align=r'right'
                             )
                    cmds.text( self.ID_LABEL_HIERARCHY
                             , label=GhostingPreferenceHierarchy().title
                             , annotation=GhostingPreferenceHierarchy().info
                             , align=r'right'
                             )

                    with LayoutManager( cmds.rowLayout( self.ID_LAYOUT_FILTERS
                                                      , numberOfColumns=4
                                                      , adjustableColumn=4
                                                      , columnAttach=[(1,r'left',0), (1,r'right',2), (2,r'both',2), (3,r'left',2)]
                                                      ) ):

                        control = cmds.iconTextCheckBox( self.ID_GEOMETRY_FILTER
                                                       , label=GhostingPreferenceGeometryFilter().title
                                                       , annotation=GhostingPreferenceGeometryFilter().info
                                                       , style=r'iconOnly'
                                                       , image1=r'ghostingObjectTypeGeometry.png'
                                                       , onCommand=callback_tool(self, partial(self.callback_geometry_filter_ui_changed, new_filter_value=False))
                                                       , offCommand=callback_tool(self, partial(self.callback_geometry_filter_ui_changed, new_filter_value=True))
                                                       )
                        self.widgets[self.ID_GEOMETRY_FILTER] = control
                        self.monitor_preference( GhostingPreferenceGeometryFilter(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_GEOMETRY_FILTER)) )

                        control = cmds.iconTextCheckBox( self.ID_JOINT_FILTER
                                                       , label=GhostingPreferenceJointFilter().title
                                                       , annotation=GhostingPreferenceJointFilter().info
                                                       , style=r'iconOnly'
                                                       , image1=r'ghostingObjectTypeJoint.png'
                                                       , onCommand=callback_tool(self, partial(self.callback_joint_filter_ui_changed, new_filter_value=False))
                                                       , offCommand=callback_tool(self, partial(self.callback_joint_filter_ui_changed, new_filter_value=True))
                                                       )
                        self.widgets[self.ID_JOINT_FILTER] = control
                        self.monitor_preference( GhostingPreferenceJointFilter(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_JOINT_FILTER)) )

                        control = cmds.iconTextCheckBox( self.ID_LOCATOR_FILTER
                                                       , label=GhostingPreferenceLocatorFilter().title
                                                       , annotation=GhostingPreferenceLocatorFilter().info
                                                       , style=r'iconOnly'
                                                       , image1=r'ghostingObjectTypeLocator.png'
                                                       , onCommand=callback_tool(self, partial(self.callback_locator_filter_ui_changed, new_filter_value=False))
                                                       , offCommand=callback_tool(self, partial(self.callback_locator_filter_ui_changed, new_filter_value=True))
                                                       )
                        self.widgets[self.ID_LOCATOR_FILTER] = control
                        self.monitor_preference( GhostingPreferenceLocatorFilter(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_LOCATOR_FILTER)) )

                    control = cmds.checkBox( self.ID_HIERARCHY
                                           , onCommand=callback_tool(self, partial(self.callback_hierarchy_ui_changed, new_hierarchy_value=True))
                                           , offCommand=callback_tool(self, partial(self.callback_hierarchy_ui_changed, new_hierarchy_value=False))
                                           , label=''
                                           )
                    self.widgets[self.ID_HIERARCHY] = control
                    self.monitor_preference( GhostingPreferenceHierarchy(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_HIERARCHY)) )

                #----------------------------------------
                with LayoutManager( cmds.rowLayout( self.ID_LAYOUT_SELECTED, adjustableColumn=1, columnAttach=[(1,r'both',10)]) ):
                    control = cmds.button( self.ID_SELECTED
                                         , label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostSelectedLbl']
                                         , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostSelectedAnn']
                                         , command=r'maya.app.ghosting.GhostingManager.GhostingManager().ghost_selected()'
                                         )
                    self.widgets[self.ID_SELECTED] = control

                #----------------------------------------
                # Layout form tries to space 5 buttons and 1 separator, where the button size is 3 times the separator size,
                # and the spacing between buttons/separator is the same size as the separator.
                #   ...OOO.OOO.OOO.O.OOO.OOO...
                #   000000000111111111122222222
                #   123456789012345678901234567
                form = cmds.formLayout( self.ID_LAYOUT_MODES, numberOfDivisions=27 )
                self.widgets[self.ID_LAYOUT_MODES] = form
                with LayoutManager( form ):
                    self.widgets[self.ID_MODES] = cmds.iconTextRadioCollection( self.ID_MODES )
                    button1 = cmds.iconTextRadioButton( self.ID_MODE_PRE_FRAMES
                                                    , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingPre']
                                                    , style=r'iconOnly'
                                                    , image1=r'ghostingPre.png'
                                                    , onCommand=callback_tool(self, partial(self.callback_mode_ui_changed, mode=GHOSTING_MODE_PRE_FRAMES))
                                                    )
                    self.widgets[self.ID_MODE_PRE_FRAMES] = button1

                    button2 = cmds.iconTextRadioButton( self.ID_MODE_PRE_POST_FRAMES
                                                    , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingPrePost']
                                                    , style=r'iconOnly'
                                                    , image1=r'ghostingPreAndPost.png'
                                                    , onCommand=callback_tool(self, partial(self.callback_mode_ui_changed, mode=GHOSTING_MODE_PRE_AND_POST_FRAMES))
                                                    )
                    self.widgets[self.ID_MODE_PRE_POST_FRAMES] = button2

                    button3 = cmds.iconTextRadioButton( self.ID_MODE_POST_FRAMES
                                                    , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingPost']
                                                    , style=r'iconOnly'
                                                    , image1=r'ghostingPost.png'
                                                    , onCommand=callback_tool(self, partial(self.callback_mode_ui_changed, mode=GHOSTING_MODE_POST_FRAMES))
                                                    )
                    self.widgets[self.ID_MODE_POST_FRAMES] = button3

                    separator = cmds.separator( horizontal=False, style=r'single' )

                    button4 = cmds.iconTextRadioButton( self.ID_MODE_CUSTOM_FRAMES
                                                    , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingCustom']
                                                    , style=r'iconOnly'
                                                    , image1=r'ghostingCustomFrames.png'
                                                    , onCommand=callback_tool(self, partial(self.callback_mode_ui_changed, mode=GHOSTING_MODE_CUSTOM_FRAMES))
                                                    )
                    self.widgets[self.ID_MODE_CUSTOM_FRAMES] = button4

                    button5 = cmds.iconTextRadioButton( self.ID_MODE_KEYFRAMES
                                                    , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingKeyframes']
                                                    , style=r'iconOnly'
                                                    , image1=r'ghostingKeyFrames.png'
                                                    , onCommand=callback_tool(self, partial(self.callback_mode_ui_changed, mode=GHOSTING_MODE_KEYFRAMES))
                                                    )
                    self.widgets[self.ID_MODE_KEYFRAMES] = button5
                    self.ui_update_mode_selection()
                    self.monitor_preference( GhostingPreferenceMode(), callback_tool(self, self.callback_pref_changed_mode) )


                # Evenly space the 5 buttons, with the separator at half width and a button-sized space on both ends
                cmds.formLayout( form, edit=True
                               , attachPosition=[ (button1,   r'left',  2, 3)
                                                , (button1,   r'right', 2, 5)
                                                , (button2,   r'left',  2, 7)
                                                , (button2,   r'right', 2, 9)
                                                , (button3,   r'left',  2, 11)
                                                , (button3,   r'right', 2, 13)
                                                , (separator, r'left',  2, 15)
                                                , (separator, r'right', 2, 15)
                                                , (button4,   r'left',  2, 17)
                                                , (button4,   r'right', 2, 19)
                                                , (button5,   r'left',  2, 21)
                                                , (button5,   r'right', 2, 23)
                                                ]
                               )

                #----------------------------------------
                self.ui_build_ghost_frame_parameters( False )

            #----------------------------------------
            self.widgets[self.ID_OBJECTS] = cmds.frameLayout(maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingObjectsLayout' ], collapsable=True)
            with LayoutManager( self.widgets[self.ID_OBJECTS] ):
                form = cmds.formLayout( self.ID_LAYOUT_GHOSTED_OBJECTS, numberOfDivisions=100 )
                with LayoutManager( form ):
                    ghost_list_ctrl = cmds.textScrollList( self.ID_GHOST_LIST
                                                 , numberOfRows=8
                                                 , allowMultiSelection=True
                                                 , showIndexedItem=4
                                                 , selectCommand=callback_tool(self, self.callback_node_selected_ui_changed)
                                                 )
                    enabled_ctrl = cmds.iconTextCheckBox( self.ID_ENABLED
                                                        , label=GhostingPreferenceEnabled().title
                                                        , annotation=GhostingPreferenceEnabled().info
                                                        , style=r'iconOnly'
                                                        , image1=r'ghostingVisible.png'
                                                        , onCommand=callback_tool(self, partial(self.callback_enabled_ui_changed, new_enabled_value=True))
                                                        , offCommand=callback_tool(self, partial(self.callback_enabled_ui_changed, new_enabled_value=False))
                                                        )
                    self.monitor_preference( GhostingPreferenceEnabled(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_ENABLED)) )
                self.widgets[self.ID_GHOST_LIST] = ghost_list_ctrl
                self.widgets[self.ID_ENABLED] = enabled_ctrl
                cmds.formLayout( form, edit=True
                               , attachForm=[ (ghost_list_ctrl, r'right', 10)
                                            , (ghost_list_ctrl, r'left', 10)
                                            , (ghost_list_ctrl, r'bottom', 10)
                                            , (enabled_ctrl, r'top', 10)
                                            , (enabled_ctrl, r'right', 10)
                                            ]
                               , attachControl=[ (enabled_ctrl, r'bottom', 5, ghost_list_ctrl)
                                               ]
                               )
                self.callback_ui_update_ghosted_objects( tool=self )

                form = cmds.formLayout( self.ID_LAYOUT_UNGHOST, numberOfDivisions=100 )
                self.widgets[self.ID_LAYOUT_UNGHOST] = form
                with LayoutManager( self.widgets[self.ID_LAYOUT_UNGHOST] ):
                    unghost = cmds.button( self.ID_UNGHOST
                                         , label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kUnghostSelectedLbl']
                                         , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kUnghostSelectedAnn']
                                         , command=r'maya.app.ghosting.GhostingManager.GhostingManager().unghost_selected()'
                                         )
                    self.widgets[self.ID_UNGHOST] = unghost

                    unghost_all = cmds.button( self.ID_UNGHOST_ALL
                                             , label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kClearAllGhostsLbl']
                                             , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kClearAllGhostsAnn']
                                             , command=r'maya.app.ghosting.GhostingManager.GhostingManager().unghost_all()'
                                             )
                    self.widgets[self.ID_UNGHOST_ALL] = unghost_all
                # This attaches the two buttons in a way that makes them stick to both sides and maintain even sizes
                cmds.formLayout( form, edit=True
                               , attachForm=[ (unghost, r'top', 10)
                                            , (unghost, r'left', 10)
                                            , (unghost, r'bottom', 10)
                                            , (unghost_all, r'top', 10)
                                            , (unghost_all, r'right', 10)
                                            , (unghost_all, r'bottom', 10)]
                               , attachPosition=[ (unghost, r'right', 5, 50)
                                                , (unghost_all, r'left', 5, 50)]
                               )

            #----------------------------------------
            self.widgets[self.ID_DISPLAY] = cmds.frameLayout(maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingDisplayLayout' ], collapsable=True)
            with LayoutManager( self.widgets[self.ID_DISPLAY] ):
                with LayoutManager( cmds.rowColumnLayout( self.ID_LAYOUT_DISPLAY
                                                        , numberOfColumns=2
                                                        , rowSpacing=(1,2)
                                                        , columnAlign=[(1,r'right'), (2,r'left')]
                                                        , columnAttach=[(1,r'both',10)]
                                                        ) ):

                    def add_text (preference_item) :
                        cmds.text( label=preference_item.title + r':', annotation=preference_item.info)

                    add_text(GhostingPreferencePreColour())
                    control = cmds.colorSliderGrp( self.ID_PRE_COLOUR
                                                 , annotation=GhostingPreferencePreColour().info
                                                 , changeCommand=callback_tool(self, self.callback_pre_colour_ui_changed)
                                                 )
                    self.widgets[self.ID_PRE_COLOUR] = control
                    self.monitor_preference( GhostingPreferencePreColour(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_PRE_COLOUR)) )

                    add_text(GhostingPreferencePostColour())
                    control = cmds.colorSliderGrp( self.ID_POST_COLOUR
                                                 , annotation=GhostingPreferencePostColour().info
                                                 , changeCommand=callback_tool(self, self.callback_post_colour_ui_changed)
                                                 )
                    self.widgets[self.ID_POST_COLOUR] = control
                    self.monitor_preference( GhostingPreferencePostColour(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_POST_COLOUR)) )

                    add_text(GhostingPreferenceNearOpacity())
                    control = cmds.floatSliderGrp( self.ID_NEAR_OPACITY
                                                 , annotation=GhostingPreferenceNearOpacity().info
                                                 , field=True
                                                 , minValue=0.0
                                                 , maxValue=1.0
                                                 , fieldMinValue=0.0
                                                 , fieldMaxValue=1.0
                                                 , precision = 3
                                                 , changeCommand=callback_tool(self, self.callback_near_opacity_ui_changed)
                                                 )
                    self.widgets[self.ID_NEAR_OPACITY] = control
                    self.monitor_preference( GhostingPreferenceNearOpacity(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_NEAR_OPACITY)) )

                    add_text(GhostingPreferenceFarOpacity())
                    control = cmds.floatSliderGrp( self.ID_FAR_OPACITY
                                                 , annotation=GhostingPreferenceFarOpacity().info
                                                 , field=True
                                                 , minValue=0.0
                                                 , maxValue=1.0
                                                 , fieldMinValue=0.0
                                                 , fieldMaxValue=1.0
                                                 , precision = 3
                                                 , changeCommand=callback_tool(self, self.callback_far_opacity_ui_changed)
                                                 )
                    self.widgets[self.ID_FAR_OPACITY] = control
                    self.monitor_preference( GhostingPreferenceFarOpacity(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_FAR_OPACITY)) )

        # Set all of the widgets to their current values before showing the window
        self.update_widget( self, None )
        cmds.showWindow( self.widgets[self.ID_WINDOW] )

        self.selection_change_job = cmds.scriptJob( parent=self.widgets[self.ID_WINDOW], event=(r'SelectionChanged', callback_tool(self, self.callback_ui_update_ghosted_objects)) )
        self.ghost_list_change_job = cmds.scriptJob( parent=self.widgets[self.ID_WINDOW], event=(r'GhostListChanged', callback_tool(self, self.callback_ui_update_ghosted_objects)) )

    #----------------------------------------------------------------------
    def frame_parameter_visibility(self):
        '''
        Calculate a dictionary of booleans indicating which of the frame parameters should be shown based on the current
        mode and preset selection. The key is the ID of the widget controlling the parameter, the value is the boolean.
        '''
        parameter_visibility = { self.ID_GHOSTS_PRE    : False
                               , self.ID_GHOSTS_POST   : False
                               , self.ID_GHOSTS_STEP   : False
                               , self.ID_CUSTOM_FRAMES : False
                               , self.ID_USE_DRIVER    : False
                               , self.ID_PRESETS       : True
                               , self.ID_ALL_IN_RANGE  : False
                               }
        mode = GhostingManager().mode
        preset = GhostingManager().preset
        if mode == GHOSTING_MODE_KEYFRAMES:
            parameter_visibility[self.ID_USE_DRIVER] = True
            # Relative keyframe mode is not well supported right now, hide it
            parameter_visibility[self.ID_ALL_IN_RANGE] = False 
            if GhostingManager().all_in_range:
                parameter_visibility[self.ID_PRESETS]  = False
            else:
                # Keyframe mode doesn't differentiate pre/post availability
                # parameter_visibility[self.ID_GHOSTS_PRE]    = (preset == GHOSTING_PRESET_CUSTOM)
                # parameter_visibility[self.ID_GHOSTS_POST]   = (preset == GHOSTING_PRESET_CUSTOM)
                # parameter_visibility[self.ID_GHOSTS_STEP]   = True
                parameter_visibility[self.ID_PRESETS]  = False
        elif mode == GHOSTING_MODE_CUSTOM_FRAMES:
            parameter_visibility[self.ID_CUSTOM_FRAMES]  = True
            parameter_visibility[self.ID_PRESETS]  = False
        elif preset == GHOSTING_PRESET_CUSTOM:
            parameter_visibility[self.ID_GHOSTS_PRE]    = mode in [GHOSTING_MODE_PRE_AND_POST_FRAMES, GHOSTING_MODE_PRE_FRAMES]
            parameter_visibility[self.ID_GHOSTS_POST]   = mode in [GHOSTING_MODE_PRE_AND_POST_FRAMES, GHOSTING_MODE_POST_FRAMES]
            parameter_visibility[self.ID_GHOSTS_STEP]   = mode in [GHOSTING_MODE_PRE_AND_POST_FRAMES, GHOSTING_MODE_PRE_FRAMES, GHOSTING_MODE_POST_FRAMES]
        

        return parameter_visibility

    #----------------------------------------------------------------------
    def delayed_ui_build_ghost_frame_parameters(self):
        '''
        The UI (re)build might destroy the widget that triggered the rebuild so call this when that happens so that the
        rebuild happens after the widget processing is finished.
        '''
        if not self.delayed_update_job:
            self.delayed_update_job = cmds.scriptJob( runOnce=True, idleEvent=partial( self.ui_build_ghost_frame_parameters, populate_values=True ) )

    #----------------------------------------------------------------------
    def ui_build_ghost_frame_parameters(self, populate_values):
        '''
        Based on the current mode and the current preset selected selectively display the relevant parts of the ghost frame parameter list.
        This is set up to destroy and recreate the section in order to allow for correct alignment of all of the visible pieces. Simply
        toggling the "visible" argument on the widgets does not do this.
        :param populate_values: If True then update the values in all widgets (only use False if you will do that later)
        '''
        
        self.delayed_update_job = None # Just in case
        # This section is laid out from scratch every time so delete any pre-existing children of the main layout
        if self.ID_LAYOUT_FRAME_PARAMETERS in self.widgets:
            # Conditionally remove the widgets that are currently active
            if self.ID_ALL_IN_RANGE in self.widgets:
                del self.widgets[self.ID_ALL_IN_RANGE]
            if self.ID_GHOSTS_POST in self.widgets:
                del self.widgets[self.ID_GHOSTS_POST]
            if self.ID_PRESETS in self.widgets:
                del self.widgets[self.ID_PRESETS]
            if self.ID_GHOSTS_PRE in self.widgets:
                del self.widgets[self.ID_GHOSTS_PRE]
            if self.ID_GHOSTS_STEP in self.widgets:
                del self.widgets[self.ID_GHOSTS_STEP]
            if self.ID_CUSTOM_FRAMES in self.widgets:
                del self.widgets[self.ID_CUSTOM_FRAMES]
            if self.ID_ADD_FRAME in self.widgets:
                del self.widgets[self.ID_ADD_FRAME]
            if self.ID_USE_DRIVER in self.widgets:
                del self.widgets[self.ID_USE_DRIVER]
            widgets_to_delete = [r'{}|{}'.format( self.widgets[self.ID_LAYOUT_FRAME_PARAMETERS], child ) for child in cmds.rowColumnLayout( self.widgets[self.ID_LAYOUT_FRAME_PARAMETERS], query=True, childArray=True )]
            if widgets_to_delete:
                cmds.deleteUI( widgets_to_delete )
            cmds.setParent( self.widgets[self.ID_LAYOUT_FRAME_PARAMETERS] )
        else:
            self.widgets[self.ID_LAYOUT_FRAME_PARAMETERS] = cmds.rowColumnLayout( self.ID_LAYOUT_FRAME_PARAMETERS
                                                                                , numberOfColumns=2
                                                                                , adjustableColumn=2
                                                                                , rowSpacing=(1, 2)
                                                                                , columnAttach=[(1,r'both',10), (2,r'both',10)]
                                                                                , columnAlign=[(1,r'right'), (2,r'left')]
                                                                                )

        parameter_visibility = self.frame_parameter_visibility()

        with LayoutManager( self.widgets[self.ID_LAYOUT_FRAME_PARAMETERS] ):
            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_USE_DRIVER]:
                cmds.text( label=GhostingPreferenceUseDriver().title + r':'
                         , annotation=GhostingPreferenceUseDriver().info
                         , align=r'right'
                         )
                control = cmds.checkBox( self.ID_USE_DRIVER
                                       , onCommand=r'maya.app.ghosting.GhostingManager.GhostingManager().apply_use_driver(True)'
                                       , offCommand=r'maya.app.ghosting.GhostingManager.GhostingManager().apply_use_driver(False)'
                                       )
                self.widgets[self.ID_USE_DRIVER] = control
                self.monitor_preference( GhostingPreferenceUseDriver(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_USE_DRIVER)) )

            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_PRESETS]:
                self.widgets[self.ID_LABEL_LAYOUT_PRESETS] = cmds.text( self.ID_LABEL_LAYOUT_PRESETS, align=r'right' )
                selected_preset = GhostingManager().preset
                self.widgets[self.ID_LAYOUT_PRESETS] = cmds.rowLayout( self.ID_LAYOUT_PRESETS, numberOfColumns=6 )
                
                with LayoutManager( self.widgets[self.ID_LAYOUT_PRESETS] ):
                    cmds.radioCollection()
                    buttons = []
                    for preset_index in range(0, len(GHOSTING_PRESETS)):
                        try:
                            preset_data = GhostingPreferencePreset().DATA[preset_index]
                            
                            buttons.append( cmds.radioButton( self.ID_PRESET_PREFIX + preset_data[INDEX_ENUM_NAME]
                                                            , label=preset_data[INDEX_ENUM_NAME]
                                                            , annotation=preset_data[INDEX_ENUM_INFO]
                                                            , select=(selected_preset == preset_data[INDEX_ENUM_ID])
                                                            , onCommand=callback_tool(self, partial(self.callback_preset_ui_changed, preset=preset_index) )
                                                            )
                                        )
                        except Exception as ex:
                            cmds.warning( maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingEditorPresetLoadFailure' ].format(ex) )
                    self.widgets[self.ID_PRESETS] = buttons[:]
                    self.monitor_preference( GhostingPreferencePreset(), callback_tool(self, self.callback_pref_changed_preset) )

            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_GHOSTS_STEP]:
                self.widgets[self.ID_LABEL_GHOSTS_STEP] = cmds.text( self.ID_LABEL_GHOSTS_STEP, align=r'right' )
                control = cmds.intSliderGrp( self.ID_GHOSTS_STEP
                                           , annotation=GhostingPreferenceGhostsStep().info
                                           , adjustableColumn=2
                                           , field=True
                                           , minValue=1
                                           , maxValue=120
                                           , fieldMinValue=1
                                           , fieldMaxValue=65535
                                           , changeCommand=callback_tool(self, self.callback_ghosts_step_ui_changed)
                                           )
                self.widgets[self.ID_GHOSTS_STEP] = control
                self.monitor_preference( GhostingPreferenceGhostsStep(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_GHOSTS_STEP)) )

            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_ALL_IN_RANGE]:
                cmds.text( label=GhostingPreferenceAllInRange().title + r':'
                         , annotation=GhostingPreferenceAllInRange().info
                         , align=r'right'
                         )
                control = cmds.checkBox( self.ID_ALL_IN_RANGE
                                       , changeCommand=callback_tool(self, partial(self.callback_all_in_range_ui_changed) )
                                       , label=''
                                       )
                self.widgets[self.ID_ALL_IN_RANGE] = control
                self.monitor_preference( GhostingPreferenceAllInRange(), callback_tool(self, partial(self.callback_pref_changed_all_in_range) ) )

            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_GHOSTS_PRE]:
                cmds.text( label=GhostingPreferencePreFrames().title+r':'
                         , annotation=GhostingPreferencePreFrames().info
                         , align=r'right' )
                control = cmds.intSliderGrp( self.ID_GHOSTS_PRE
                                        , annotation=GhostingPreferencePreFrames().info
                                        , adjustableColumn=2
                                        , field=True
                                        , minValue=0
                                        , maxValue=10
                                        , fieldMinValue=0
                                        , changeCommand=callback_tool(self, self.callback_pre_frames_ui_changed)
                                        )
                self.widgets[self.ID_GHOSTS_PRE] = control
                self.monitor_preference( GhostingPreferencePreFrames(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_GHOSTS_PRE)) )

            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_GHOSTS_POST]:
                cmds.text( label=GhostingPreferencePostFrames().title+r':'
                            , annotation=GhostingPreferencePostFrames().info
                            , align=r'right' )
                control = cmds.intSliderGrp( self.ID_GHOSTS_POST
                                        , annotation=GhostingPreferencePostFrames().info
                                        , adjustableColumn=2
                                        , field=True
                                        , minValue=0
                                        , maxValue=10
                                        , fieldMinValue=0
                                        , changeCommand=callback_tool(self, self.callback_post_frames_ui_changed)
                                        )
                self.widgets[self.ID_GHOSTS_POST] = control
                self.monitor_preference( GhostingPreferencePostFrames(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_GHOSTS_POST)) )

            #----------------------------------------------------------------------
            
            if parameter_visibility[self.ID_CUSTOM_FRAMES]:
                cmds.text( label=GhostingPreferenceCustomFrames().title
                            , annotation=GhostingPreferenceCustomFrames().info
                            , align=r'right' )
                with LayoutManager( cmds.rowLayout( numberOfColumns=2, adjustableColumn=1 ) ):
                    control = cmds.textFieldGrp( self.ID_CUSTOM_FRAMES
                                               , annotation=GhostingPreferenceCustomFrames().info
                                               , placeholderText=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingCustomFramesSample' ]
                                               , width=100
                                               , changeCommand=callback_tool(self, self.callback_custom_frames_ui_changed)
                                               )
                    self.widgets[self.ID_CUSTOM_FRAMES] = control
                    self.monitor_preference( GhostingPreferenceCustomFrames(), callback_tool(self, partial(self.update_widget, widget_id=self.ID_CUSTOM_FRAMES)) )

                    control = cmds.button( self.ID_ADD_FRAME
                                         , label=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingAddFrameLbl' ]
                                         , annotation=maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingAddFrameAnn' ]
                                         , command=callback_tool(self, self.callback_add_frame_pressed)
                                         )
                    self.widgets[self.ID_ADD_FRAME] = control

        if populate_values:
            self.update_widget( self, self.ID_ALL_IN_RANGE )
            self.update_widget( self, self.ID_GHOSTS_POST )
            self.update_widget( self, self.ID_GHOSTS_PRE )
            self.update_widget( self, self.ID_GHOSTS_STEP )
            self.update_widget( self, self.ID_CUSTOM_FRAMES )
            self.update_widget( self, self.ID_PRESETS )
            self.update_widget( self, self.ID_USE_DRIVER )

    #----------------------------------------------------------------------
    def ui_update_mode_selection(self):
        '''Update the selected states of all of the mode text buttons. Used when the mode changes a way other than clicking on them'''
        current_mode = GhostingManager().mode
        for mode_info in self.MODE_INFO:
            cmds.iconTextRadioButton( self.widgets[mode_info[0]], edit=True, select=(current_mode == mode_info[1]) )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_update_ghosted_objects(tool):
        '''
        Put all of the currently ghosted objects into the list control. Select any of the ghosted objects
        that are, or are below currently selected objects.
        This is called whenever the selection list of the ghosting attribute is changed.
        '''
        
        cmds.textScrollList( tool.widgets[tool.ID_GHOST_LIST], edit=True, removeAll=True )
        ghosted_objects = set(GhostingManager().ghosted_objects())
        all_selected_objects = cmds.ls( selection=True ) or []
        for selected_object in cmds.ls( selection=True ):
            all_selected_objects += cmds.listRelatives( selected_object, allDescendents=True ) or []
        cmds.textScrollList( tool.widgets[tool.ID_GHOST_LIST]
                            , edit=True
                            , append=ghosted_objects
                            , selectItem=list( ghosted_objects.intersection( set(all_selected_objects) ) )
                            )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_reset_all(tool):
        '''
        Callback to reset all of the values in this editor to their defaults
        :param tool: GhostingEditor object to be updated
        '''
        
        with tool.DisableUiUpdateScope(): # So that everything updates just once
            GhostingManager().reset_all()
        tool.update_widget( tool, None )
        tool.ui_update_mode_selection()
        tool.ui_build_ghost_frame_parameters( True )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_add_frame_pressed(tool):
        '''
        Callback to react to the button "add frame" being pressed
        :param tool: GhostingEditor object that owns the button
        '''
        
        custom_frames = GhostingManager().custom_frames
        custom_frames += [int(cmds.currentTime( query=True ))]
        custom_frames = list( set(custom_frames) ) # Avoid duplicates
        try:
            GhostingManager().apply_custom_frames( custom_frames )
            # Change the field after success so that it doesn't have to be undone on failure
            tool.update_widget( tool, tool.ID_CUSTOM_FRAMES )
        except RuntimeError as ex:
            cmds.warning( maya.stringTable[ 'y_maya_app_ghosting_GhostingEditor.kGhostingAddFrameFailure' ].format( ex ) )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_custom_frames_ui_changed(tool):
        '''
        Callback to react to a change in the "custom frames" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        if tool.update_ui_from_values: # Prevent recursive update when "fixing" a bad string
            with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
                new_custom_frames = cmds.textFieldGrp( tool.widgets[tool.ID_CUSTOM_FRAMES], query=True, text=True )
                
                try:
                    GhostingManager().apply_custom_frames( new_custom_frames )
                    sanitized_string = GhostingManager().custom_frames_as_string
                    if new_custom_frames != sanitized_string:
                        
                        cmds.textFieldGrp( tool.widgets[tool.ID_CUSTOM_FRAMES], edit=True, text=GhostingManager().custom_frames_as_string )
                except [RuntimeError, ValueError]:
                    # If the new custom frames failed then restore the previous value
                    tool.update_widget( tool, tool.ID_CUSTOM_FRAMES )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_enabled_ui_changed(tool, new_enabled_value):
        '''
        Callback to react to a change in the "enabled" state
        :param tool: GhostingEditor object that owns the widget
        :param new_enabled_value: New value for the enabled flag
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            
            GhostingManager().enabled = new_enabled_value

    #----------------------------------------------------------------------
    @staticmethod
    def callback_far_opacity_ui_changed(tool):
        '''
        Callback to react to a change in the "far opacity" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_far_opacity_value = cmds.floatSliderGrp( tool.widgets[tool.ID_FAR_OPACITY], query=True, value=True )
            
            GhostingManager().apply_far_opacity( new_far_opacity_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_geometry_filter_ui_changed(tool, new_filter_value):
        '''
        Callback to react to a change in the "geometry filter" state
        :param tool: GhostingEditor object that owns the widget
        :param new_filter_value: New value for the filter
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            
            GhostingManager().geometry_filter = new_filter_value

    #----------------------------------------------------------------------
    @staticmethod
    def callback_post_frames_ui_changed(tool):
        '''
        Callback to react to a change in the "post frames" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_post_frames_value = cmds.intSliderGrp( tool.widgets[tool.ID_GHOSTS_POST], query=True, value=True )
            
            GhostingManager().apply_post_frames( new_post_frames_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_pre_frames_ui_changed(tool):
        '''
        Callback to react to a change in the "pre frames" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_pre_frames_value = cmds.intSliderGrp( tool.widgets[tool.ID_GHOSTS_PRE], query=True, value=True )
            
            GhostingManager().apply_pre_frames( new_pre_frames_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ghosts_step_ui_changed(tool):
        '''
        Callback to react to a change in the "ghosts step" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_ghosts_step_value = cmds.intSliderGrp( tool.widgets[tool.ID_GHOSTS_STEP], query=True, value=True )
            
            GhostingManager().apply_ghosts_step( new_ghosts_step_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_hierarchy_ui_changed(tool, new_hierarchy_value):
        '''
        Callback to react to a change in the "hierarchy" state
        :param tool: GhostingEditor object that owns the widget
        :param new_hierarchy_value: New value for the hierarchy flag
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            
            GhostingManager().hierarchy = new_hierarchy_value

    #----------------------------------------------------------------------
    @staticmethod
    def callback_joint_filter_ui_changed(tool, new_filter_value):
        '''
        Callback to react to a change in the "joint filter" state
        :param tool: GhostingEditor object that owns the widget
        :param new_filter_value: New value for the filter
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            
            GhostingManager().joint_filter = new_filter_value

    #----------------------------------------------------------------------
    @staticmethod
    def callback_locator_filter_ui_changed(tool, new_filter_value):
        '''
        Callback to react to a change in the "locator filter" state
        :param tool: GhostingEditor object that owns the widget
        :param new_filter_value: New value for the filter
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            
            GhostingManager().locator_filter = new_filter_value

    #----------------------------------------------------------------------
    @staticmethod
    def callback_mode_ui_changed(tool, mode):
        '''
        Callback to react to a change in the "ghosting mode" radio selection
        :param tool: GhostingEditor object that owns the widget
        :param mode: Newly selected mode
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            
            GhostingManager().apply_mode( mode )
        tool.delayed_ui_build_ghost_frame_parameters()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_near_opacity_ui_changed(tool):
        '''
        Callback to react to a change in the "near opacity" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_near_opacity_value = cmds.floatSliderGrp( tool.widgets[tool.ID_NEAR_OPACITY], query=True, value=True )
            
            GhostingManager().apply_near_opacity( new_near_opacity_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_post_colour_ui_changed(tool):
        '''
        Callback to react to a change in the "post colour" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_post_colour_value = cmds.colorSliderGrp( tool.widgets[tool.ID_POST_COLOUR], query=True, rgbValue=True )
            
            GhostingManager().apply_post_colour( new_post_colour_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_node_selected_ui_changed(tool):
        '''Synchronize the ghosted object list with selection'''
        items = cmds.textScrollList(tool.widgets[tool.ID_GHOST_LIST], query=True, selectItem=True)
        cmds.select(items, r=True)
        # tool.callback_ui_update_ghosted_objects( tool )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_pre_colour_ui_changed(tool):
        '''
        Callback to react to a change in the "pre colour" parameter
        :param tool: GhostingEditor object that owns the widget
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_pre_colour_value = cmds.colorSliderGrp( tool.widgets[tool.ID_PRE_COLOUR], query=True, rgbValue=True )
            
            GhostingManager().apply_pre_colour( new_pre_colour_value )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_all_in_range_ui_changed(tool):
        '''
        Callback to rebuild the UI to match the new allInRange value
        :param tool: GhostingEditor object to be updated
        '''
        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            new_all_in_range_value = cmds.checkBox( tool.widgets[tool.ID_ALL_IN_RANGE], query=True, value=True )
            
            GhostingManager().apply_all_in_range( new_all_in_range_value )
        tool.delayed_ui_build_ghost_frame_parameters()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_preset_ui_changed(tool, preset):
        '''
        Callback to reset all of the values in this editor to their defaults
        :param tool: GhostingEditor object to be updated
        :param preset: Preset number to apply
        '''
        

        with tool.DisableUiUpdateScope(): # Prevent UI change from recursively updating the UI
            try:
                preset_data = GhostingPreferencePreset().DATA[preset]
                GhostingManager().preset = preset_data[INDEX_ENUM_ID]
                new_preset = preset_data[INDEX_ENUM_DATA]
                if new_preset:
                    GhostingManager().apply_ghosts_step( new_preset )
            except Exception as ex:
                cmds.error( maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingEditorPresetFailure' ].format( preset, ex ) )

            # Being a bit lazy here and always rebuilding the parameter section, even though it's only
            # really necessary when going to or from "Custom".
        tool.delayed_ui_build_ghost_frame_parameters()

    #----------------------------------------------------------------------
    def widget_should_update(self, widget_to_check, widget_id):
        '''
        :return: True if the widget_id can be updated when widget_to_check is specified
        :param widget_to_check: Widget ID passed in for checking
        :param widget_id: Widget ID to compare against
        '''
        return (not widget_to_check or widget_to_check == widget_id) and (widget_id in self.widgets)

    #----------------------------------------------------------------------
    @staticmethod
    def update_widget(tool, widget_id):
        '''
        Catch-all place for updating widget values that eliminates a lot of repeated methods.
        This is called whenever a subsection of the interface needs updating due to changes in the preferences or other parts of the interface.
        :param widget_id: ID of the widget to update. If None then update all of them.
        '''
        
        if tool.update_ui_from_values:
            if tool.widget_should_update( widget_id, tool.ID_ENABLED ):
                cmds.iconTextCheckBox( tool.widgets[tool.ID_ENABLED], edit=True, value=GhostingManager().enabled )
            if tool.widget_should_update( widget_id, tool.ID_ALL_IN_RANGE ):
                cmds.checkBox( tool.widgets[tool.ID_ALL_IN_RANGE], edit=True, value=GhostingManager().all_in_range )
            if tool.widget_should_update( widget_id, tool.ID_FAR_OPACITY ):
                cmds.floatSliderGrp( tool.widgets[tool.ID_FAR_OPACITY], edit=True, value=GhostingManager().far_opacity )
            if tool.widget_should_update( widget_id, tool.ID_GEOMETRY_FILTER ):
                cmds.iconTextCheckBox( tool.widgets[tool.ID_GEOMETRY_FILTER], edit=True, value=(not GhostingManager().geometry_filter) )
            if tool.widget_should_update( widget_id, tool.ID_GHOSTS_PRE ):
                cmds.intSliderGrp( tool.widgets[tool.ID_GHOSTS_PRE], edit=True, value=GhostingManager().pre_frames )
            if tool.widget_should_update( widget_id, tool.ID_GHOSTS_POST ):
                cmds.intSliderGrp( tool.widgets[tool.ID_GHOSTS_POST], edit=True, value=GhostingManager().post_frames )
            if tool.widget_should_update( widget_id, tool.ID_GHOSTS_STEP ):
                if GhostingManager().mode == GHOSTING_MODE_KEYFRAMES:
                    cmds.text( tool.widgets[tool.ID_LABEL_GHOSTS_STEP], edit=True, label=GhostingPreferenceGhostsStep().title_key+r':', annotation=GhostingPreferenceGhostsStep().info_key )
                else:
                    cmds.text( tool.widgets[tool.ID_LABEL_GHOSTS_STEP], edit=True, label=GhostingPreferenceGhostsStep().title+r':', annotation=GhostingPreferenceGhostsStep().info )
                cmds.intSliderGrp( tool.widgets[tool.ID_GHOSTS_STEP], edit=True, value=GhostingManager().ghosts_step )
            if tool.widget_should_update( widget_id, tool.ID_CUSTOM_FRAMES ):
                cmds.textFieldGrp( tool.widgets[tool.ID_CUSTOM_FRAMES], edit=True, text=GhostingManager().custom_frames_as_string )
            if tool.widget_should_update( widget_id, tool.ID_HIERARCHY ):
                cmds.checkBox( tool.widgets[tool.ID_HIERARCHY], edit=True, value=GhostingManager().hierarchy )
            if tool.widget_should_update( widget_id, tool.ID_JOINT_FILTER ):
                cmds.iconTextCheckBox( tool.widgets[tool.ID_JOINT_FILTER], edit=True, value=(not GhostingManager().joint_filter) )
            if tool.widget_should_update( widget_id, tool.ID_LOCATOR_FILTER ):
                cmds.iconTextCheckBox( tool.widgets[tool.ID_LOCATOR_FILTER], edit=True, value=(not GhostingManager().locator_filter) )
            if tool.widget_should_update( widget_id, tool.ID_NEAR_OPACITY ):
                cmds.floatSliderGrp( tool.widgets[tool.ID_NEAR_OPACITY], edit=True, value=GhostingManager().near_opacity )
            if tool.widget_should_update( widget_id, tool.ID_POST_COLOUR ):
                cmds.colorSliderGrp( tool.widgets[tool.ID_POST_COLOUR], edit=True, rgbValue=GhostingManager().post_colour )
            if tool.widget_should_update( widget_id, tool.ID_PRE_COLOUR ):
                cmds.colorSliderGrp( tool.widgets[tool.ID_PRE_COLOUR], edit=True, rgbValue=GhostingManager().pre_colour )
            if tool.widget_should_update( widget_id, tool.ID_PRESETS ):
                with tool.DisableUiUpdateScope():  # Prevent recursive update of the interface
                    if GhostingManager().mode == GHOSTING_MODE_KEYFRAMES:
                        cmds.text( tool.widgets[tool.ID_LABEL_LAYOUT_PRESETS], edit=True, label=GhostingPreferencePreset().title_key+r':', annotation=GhostingPreferencePreset().info_key )
                    else:
                        cmds.text( tool.widgets[tool.ID_LABEL_LAYOUT_PRESETS], edit=True, label=GhostingPreferencePreset().title+r':', annotation=GhostingPreferencePreset().info )
                    selected_preset = GhostingManager().preset
                    for preset_index in range(0, len(GHOSTING_PRESETS)):
                        try:
                            preset_data = GhostingPreferencePreset().DATA[preset_index]
                            cmds.radioButton( tool.widgets[tool.ID_PRESETS][preset_index], edit=True, select=(selected_preset == preset_data[INDEX_ENUM_ID]) )
                        except Exception as ex:
                            cmds.warning( maya.stringTable['y_maya_app_ghosting_GhostingEditor.kPresetFailure' ].format(ex) )
            if tool.widget_should_update( widget_id, tool.ID_USE_DRIVER ):
                use_driver = GhostingManager().use_driver
                label = maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingEditorGhostDriverHint'  ] if use_driver else " " 
                tooltip = maya.stringTable['y_maya_app_ghosting_GhostingEditor.kGhostingEditorGhostDriverHintLong'  ]
                cmds.checkBox( tool.widgets[tool.ID_USE_DRIVER], edit=True, value=use_driver, label=label, annotation=tooltip)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_pref_changed_mode(tool):
        '''
        Callback to update the state of the ghosts after integer value when the preference changed
        :param tool: GhostingEditor object that owns the checkbox
        '''
        
        if tool.update_ui_from_values:
            tool.ui_update_mode_selection()
            tool.ui_build_ghost_frame_parameters( True )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_pref_changed_preset(tool):
        '''
        Callback to update the state of the preset value when the preference changed
        :param tool: GhostingEditor object that owns the widget
        '''
        
        if tool.update_ui_from_values:
            tool.ui_build_ghost_frame_parameters( True )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_pref_changed_all_in_range(tool):
        '''
        Callback to update the state of the allInRange value when the preference changed. This doesn't use
        the update_widget call since it needs to reconfigure the frame parameter section.
        :param tool: GhostingEditor object that owns the widget
        '''
        
        if tool.update_ui_from_values:
            tool.ui_build_ghost_frame_parameters( True )

    #----------------------------------------------------------------------
    def monitor_preference( self, preference, callback_function ):
        '''Add a callback for when a preference value changes. Remember it so that it can be removed when the UI is destroyed'''
        if preference not in self.preference_callbacks:
            self.preference_callbacks[preference] = callback_function
            preference.add_client( self, callback_function )

    def pause_preference_callback(self):
        '''Pause the preference monitors for intentional change from UI'''
        callbacks = self.preference_callbacks
        self.preference_callbacks = {}
        for preference in callbacks.keys():
            preference.remove_client( self )
        return callbacks

    def resume_preference_callback(self, callbacks):
        '''Resume the preference monitors'''
        for preference, callback in callbacks.items():
            preference.add_client( self, callback )
        self.preference_callbacks.update(callbacks)

    #----------------------------------------------------------------------
    def close_window(self):
        '''Simple interface to closing and deleting the ghosting editor window'''
        
        if self.ID_WINDOW in self.widgets and not cmds.window( self.widgets[self.ID_WINDOW], exists=True ):
            cmds.deleteUI( self.widgets[self.ID_WINDOW] )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_window_deleted(tool):
        '''
        Invoked when the window is deleted - cleans up the class variables and client monitoring.
        :param tool: GhostingEditor window object attached to the UI that was deleted
        '''
        
        tool.widgets = {}
        tool.update_ui_from_values = True

        # The scriptJobs are automatically killed when the window is destroyed so just forget the IDs
        tool.selection_change_job = None
        tool.ghost_list_change_job = None
        tool.delayed_update_job = None

        for callback in tool.preference_callbacks.keys():
            callback.remove_client( tool )
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
