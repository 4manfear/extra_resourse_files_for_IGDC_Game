from future import standard_library
from builtins import object
from builtins import str as futureStr
standard_library.install_aliases()
from maya.app.flux.imports import *
import maya.mel as mel
import re
import maya.app.TTF.store as store

import sys
string_type = str if sys.version_info[0] >= 3 else basestring

def getAllRunTimeCommands():
    data = []
    all_rtc = cmds.runTimeCommand(defaultCommandArray=True, q=True)
    for rtc in all_rtc:
        row = [rtc]
        row.append(cmds.runTimeCommand(rtc, label=True, q=True))
        row.append(cmds.runTimeCommand(rtc, annotation=True, q=True))
        row.append(cmds.runTimeCommand(rtc, command=True, q=True))
        row.append(cmds.runTimeCommand(rtc, image=True, q=True))
        row.append(cmds.runTimeCommand(rtc, tags=True, q=True))
        row.append(cmds.runTimeCommand(rtc, keywords=True, q=True))
        row.append(cmds.runTimeCommand(rtc, category=True, q=True))
        data.append(row)
    return data

def getAllTTFItems():
    commands = store.db['ttf']['commands']
    tags = store.db['ttf']['tags']
    data = []
    for key, c in list(commands.items()):
        t = [tag for tag in tags if key in tags[tag].commands]
        row = [key, c.label, c.description, c.longAnnotation, c.optionCommand, c.imageName, ';'.join(t), ';'.join(c.keywords), ';'.join(c.categories)]
        data.append(row)
    return data

def checkInvalidNamingRTC():
    data = []
    all_rtc = set(cmds.runTimeCommand(defaultCommandArray=True, q=True))
    options = [x for x in all_rtc if x.endswith('Options')]
    invalid = [x for x in options if x[:-len('Options')] not in all_rtc]
    return invalid

class MenuCrawler(object):
    def formatIcon(self, icon, parentIcon=''):
        if not icon:
            icon = parentIcon
        if '.png' in icon:
            icon = icon[:-4]
        return icon

    def getItemScript(self, item):
        script = cmds.menuItem(item, command=True, q=True)
        if not script:
            script = ''

        lang = cmds.menuItem(item, sourceType=True, q=True)

        if not isinstance(script, string_type) and lang == 'python':
            if re.match(r'menuItem\d*', item, re.U):
                return None
            script = '''cmds.menuItem('%s', command=True, q=True)()''' % item

        script = futureStr(script)

        if lang == 'python':
            script = 'python("%s");' % script.replace('"', '\\"')

        return script

    def getSubmenus(self, menu, menuPath, lastDivider=''):
        parentIcon = cmds.menu(menu, familyImage=True, q=True)
        parentIcon = self.formatIcon(parentIcon)

        items = cmds.menu(menu, itemArray=True, q=True) or []
        if len(items) == 0:
            createCmd = cmds.menu(menu, postMenuCommand=True, q=True)
            if createCmd is not None:
                try:
                    mel.eval(createCmd)
                except:
                    try:
                        cmds.python(createCmd)
                    except:
                        pass
                items = cmds.menu(menu, itemArray=True, q=True) or []

        lastItem = None

        if items:
            self.commandMenuLabels.append(['# Starting Menu: ' + '->'.join(menuPath), len(self.commandsList)])
            if len(menuPath) == 1:
                self.tagsMenuLabels.append(['# Starting Main Menu: ' + menuPath[0], len(self.tagsList)])

        for index, item in enumerate(items):
            itemName = cmds.menuItem(item, label=True, q=True)
            itemName = itemName.strip()
            isRadio = cmds.menuItem(item, isRadioButton=True, q=True)
            isCheckbox = cmds.menuItem(item, isCheckBox=True, q=True)
            isDivider = cmds.menuItem(item, divider=True, q=True)
            isOptionBox = cmds.menuItem(item, isOptionBox=True, q=True)

            if isDivider:
                dividerName = cmds.menuItem(item, dividerLabel=True, q=True)
                if len(dividerName.strip()) > 0:
                    lastDivider = dividerName.strip()

            if isRadio or isDivider: 
                continue
            elif isOptionBox:
                if not lastItem: continue

                script = self.getItemScript(item)
                if not script: continue

                script = '/*TTF_option_script*/' + script
                self.commands[lastItem]['script'] += script
                self.commandsList[self.commandKeys[lastItem]][1] += script

            elif itemName:            
                if cmds.menu(item, exists=True, q=True):
                    self.getSubmenus(item, menuPath + [itemName], lastDivider)
                else:
                    icon = cmds.menuItem(item, image=True, q=True)
                    icon = self.formatIcon(icon)

                    script = self.getItemScript(item)
                    if not script: continue

                    description = futureStr(cmds.menuItem(item, annotation=True, q=True) or '')
                    if len(description) > 0:
                        description += '\n'
                    description += '<menuLocation>' + '->'.join(menuPath + [itemName]) + '</menuLocation>'

                    if itemName in self.paths:

                        if itemName in self.commands:
                            temp = self.commands[itemName]
                            del self.commands[itemName]
                            name = itemName + ' (%s)' % self.paths[itemName][-1]
                            self.commands[name] = temp

                        if itemName in self.commandKeys:
                            name = itemName + ' (%s)' % self.paths[itemName][-1]
                            self.commandsList[self.commandKeys[itemName]][0] = name

                            temp = self.commandKeys[itemName]
                            del self.commandKeys[itemName]
                            self.commandKeys[name] = temp

                            temp = self.commandDividers[itemName]
                            del self.commandDividers[itemName]
                            self.commandDividers[name] = temp

                        itemName += ' (%s)' % menuPath[-1]                            
                    else:
                        self.paths[itemName] = menuPath

                    if itemName in self.commandKeys:
                        prev = self.commandsList[self.commandKeys[itemName]]
                        if script.strip() == prev[1].strip() or script.strip() in prev[1].strip():

                            if (len(description) > len(prev[2]) or (len(description) == len(prev[2]) and len(icon) > len(prev[3]))):
                                self.commandsList[self.commandKeys[itemName]] = []
                                del self.commandKeys[itemName]
                                del self.commandDividers[itemName]
                            else:
                                lastItem = None
                                continue
                        else:
                            name = itemName[:-1] + ':' + self.commandDividers[itemName] + ')'

                            self.commandsList[self.commandKeys[itemName]][0] = name

                            temp = self.commandKeys[itemName]
                            del self.commandKeys[itemName]
                            self.commandKeys[name] = temp

                            temp = self.commandDividers[itemName]
                            del self.commandDividers[itemName]
                            self.commandDividers[name] = temp

                            itemName = itemName[:-1] + ':' + lastDivider + ')'

                    self.commands[itemName] = {'script': script, 'description': description, 'icon':icon, 'tags':menuPath}

                    self.commandsList.append([itemName, script, description, icon, menuPath])
                    self.commandKeys[itemName] = len(self.commandsList) - 1
                    self.commandDividers[itemName] = lastDivider

                    for tag in menuPath:
                        if tag not in self.tagKeys:
                            self.tagsList.append([tag, []])
                            self.tagKeys[tag] = len(self.tagsList) - 1

                    lastItem = itemName

            
    # Gets all menus that begin with 'main'
    def getMenus(self):
        self.tagsList = []
        self.commandsList = []
        self.commandDividers = {}
        self.commandKeys = {}
        self.tagKeys = {}

        self.tags = {}
        self.commands = {}
        self.paths = {}

        self.commandMenuLabels = []
        self.tagsMenuLabels = []

        seenMenus = set()

        cmds.menuSetPref(loadAll=True)
        menuSets = cmds.menuSet(allMenuSets=True)

        for mset in menuSets:
            msetName = cmds.menuSet(mset, label=True, q=True)
            self.commandMenuLabels.append(['# Starting Menu Set: ' + msetName, len(self.commandsList)])
            self.tagsMenuLabels.append(['# Starting Menu Set: ' + msetName, len(self.tagsList)])
            menus = cmds.menuSet(mset, query=True, menuArray=True)

            for m in menus:
                name = None

                try:
                    name = cmds.menu(m, label=True, q=True)
                except:
                    pass

                if name:
                    name = name.strip()

                    if name in seenMenus: continue
                    seenMenus.add(name)

                    self.getSubmenus(m, [name])

        self.commandMenuLabels.append(['# Starting Menus without a Menu Set', len(self.commandsList)])
        self.tagsMenuLabels.append(['# Starting Menus without a Menu Set', len(self.tagsList)])
        menus = cmds.lsUI(menus=True)

        for m in menus:
            name = None
            
            try:
                name = cmds.menu(m, label=True, q=True)
            except:
                pass

            if name and (m.lower().startswith('main') or m == 'ArnoldMenu'):
                name = name.strip()

                if name in seenMenus: continue
                seenMenus.add(name)

                self.getSubmenus(m, [name])

        for k, v in list(self.commands.items()):
            tags = v['tags']
            del v['tags']
            for t in tags:
                if t not in self.tags:
                    self.tags[t] = []
                self.tags[t].append(k)

        for i, row in enumerate(self.commandsList):
            if len(row) == 0:
                self.commandsList[i] = []
                continue

            name = row[0]
            tags = row[4]
            for t in tags:
                self.tagsList[self.tagKeys[t]][1].append(name)
            self.commandsList[i] = ['addCommand']+ row[:-1]

        for i, row in enumerate(self.tagsList):
            self.tagsList[i] = ['setTag', row[0], ';'.join(row[1])]

        commands = []
        tags = []

        index = 0
        for i, row in enumerate(self.commandsList):
            labelToInsert = None
            while index < len(self.commandMenuLabels) and self.commandMenuLabels[index][1] == i:
                labelToInsert = [self.commandMenuLabels[index][0]]
                index += 1

            if labelToInsert:
                commands.append(labelToInsert)
            
            if len(self.commandsList[i]) > 0:
                commands.append(self.commandsList[i])

        index = 0
        for i, row in enumerate(self.tagsList):
            labelToInsert = None
            while index < len(self.tagsMenuLabels) and self.tagsMenuLabels[index][1] == i:
                labelToInsert = [self.tagsMenuLabels[index][0]]
                index += 1

            if labelToInsert:
                tags.append(labelToInsert)

            tags.append(self.tagsList[i])

        rows = commands + tags
        self.tags = dict((x, {'commands': ';'.join(self.tags[x])}) for x in self.tags)
        data = {'addCommand':self.commands, 'setTag':self.tags}
        return (data, rows)

def getTopLevelMenus(asCSV=False):
    print('getTopLevelMenus', asCSV)
    crawler = MenuCrawler()
    if asCSV:
        return crawler.getMenus()[1]
    else:
        return crawler.getMenus()[0]
        
def writeCSV(inputList):
    import csv
    filePath = cmds.fileDialog2(fileFilter='*.csv', dialogStyle=1, fm=0)[0]
    with open(filePath, 'w+') as f:
        writer = csv.writer(f)
        for row in inputList:
            writer.writerow(row)

def getMenuInfo():
    import json
    menus = getTopLevelMenus()
    commands = menus['addCommand']
    tags = menus['setTag']

    data = []
    for key, value in list(commands.items()):
        menuPath = value['description'].split('<menuLocation>')[1].split('</menuLocation>')[0]
        row = [menuPath] + value['script'].split('/*TTF_option_script*/')
        if len(row) == 2: row.append('')
        data.append(row)
    
    data = sorted(data, key=lambda x: x[0])
    all_rtc = cmds.runTimeCommand(defaultCommandArray=True, q=True)
    all_ttf = store.db['ttf']['commands']
    for row in data:
        has_rtc = (row[1] in all_rtc)
        has_ttf = (row[1] in all_ttf)
        row += [has_rtc, has_ttf]
    data = [['Menu path', 'Command', 'Option Command', 'Is runTimeCommand', 'Is in TTF']] + data
    writeCSV(data)

def exportRTC():
    data = getAllRunTimeCommands()
    data = [['Id', 'label', 'annotation', 'command', 'image', 'tags', 'keywords', 'category']] + data
    writeCSV(data)

def exportTTF():
    data = getAllTTFItems()
    data = [['command', 'label', 'annotation', 'long annotation', 'option command', 'image', 'tags', 'keywords', 'categories']] + data
    writeCSV(data)

def exportMenus():
    data = getTopLevelMenus(True)
    writeCSV(data)# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
