from builtins import range
from builtins import zip
from builtins import filter
from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix
import json
import os
import re
from copy import deepcopy

import maya.app.TTF.ui as tUI

import maya.app.TTF.utils as dUtils
import maya.app.TTF.prefsWindow
from maya.app.TTF.tagPopup import TagPopup, MainTagPopup
from maya.app.TTF.uiElements import TTFField, DropDownPopup, ClickableWidget, TTFListWidget, TTFTag, TTFListDelegate

from maya.app.TTF.hotkeys import HotkeyFilter

import maya.app.TTF.api
dm = lambda: maya.app.TTF.api.dataManager()

import maya.app.TTF.dataUtils as tDU

CONTEXT_ICONS = ['TTF_Search', 'TTF_Select', 'TTF_Mel', 'TTF_Python']
toggleOn = False

if not 'ttfWindow' in globals():
    ttfWindow = None

#load window
def showWindow(launchInCenter=False):
    global ttfWindow
    ttfWindow = TTFUI(parent=fx.mayaWindow())

def toggleSearchWindow():
    global toggleOn
    if toggleOn:
        toggleOn = False
        cmds.iconTextCheckBox( "mayaSearchToolBoxIcon", edit=True, value=False)
    else:
        toggleOn = True
        cmds.iconTextCheckBox( "mayaSearchToolBoxIcon", edit=True, value=True)
        showWindow()

class TTFListItem(qt.QListWidgetItem):
    def __init__(self, label='', itemId=None):
        qt.QListWidgetItem.__init__(self, label)
        self.label = label
        self.itemId = itemId
        self.hasOptionBox = False

class TTFFieldGroup(qt.QFrame):
    # Signals
    contextUpdated = qt.Signal()

    def __init__(self, parent=None):
        qt.QFrame.__init__(self, parent)
        fx.setWidgetBackgroundColor(self, tUI.colors['dark'])
        self.setAutoFillBackground(True)
        self.setMaximumHeight(pix(tUI.dimensions['ttf_window_height']))
        fx.setHLayout(self)

        # Create the icon and create a button to spawn drop down for mode selection
        icon = tUI.getDropDownIcon()
        self.searchDropDown = fx.ImageButton(icon)
        self.searchDropDown.setObjectName("TTF_search_dd")
        self.searchDropDown.clicked.connect(self.searchSwitchClicked)
        self.searchDropDown.setToolTip(fx.res('kSearchModeSwitch'))
        self.searchDropDown.setStatusTip(fx.res('kSearchModeSwitch'))

        # Mode selection drop down dialog
        pos = qt.QPoint(0,0)
        self.dialog = DropDownPopup(self, pos, CONTEXT_ICONS)
        self.layout().addWidget(self.searchDropDown)

        self.tagList = qt.QWidget()
        self.tagList.setLayout(qt.QHBoxLayout())
        self.tagList.layout().setContentsMargins(pix(3),pix(3),pix(3),pix(3))
        self.tagList.layout().setSpacing(pix(3))
        self.tagList.setFixedHeight(pix(tUI.dimensions['ttf_window_height']))
        self.tagList.hide()
        self.layout().addWidget(self.tagList)

        self.lineEdit = TTFField([])
        self.lineEdit.setPlaceholderText(fx.res('kLoading'))
        self.lineEdit.setStyleSheet(tUI.lineEditStyleSheet())
        self.layout().setMargin(pix(0))
        self.layout().setSpacing(pix(0))
        self.lineEdit.openPreferences.connect(maya.app.TTF.prefsWindow.openPrefsWindow)
        self.lineEdit.setFixedHeight(pix(tUI.dimensions['ttf_window_height']))
        self.lineEdit.setFocusPolicy(qt.Qt.StrongFocus)
        self.layout().addWidget(self.lineEdit)

        self.clearTextBtn = fx.ImageButton('TTF_Clear')
        self.clearTextBtn.clicked.connect(self.clearText)
        self.layout().addWidget(self.clearTextBtn)
        self.clearTextBtn.hide()
        self.layout().addSpacing(pix(2))

        self.activeTags = []

    def updateContextUI(self):
        self.clearText()
        self.searchDropDown.setImage(tUI.getDropDownIcon(CONTEXT_ICONS[dm().getContextId()], self.dialog.isVisible()))
        self.lineEdit.setPlaceholderText(tUI.PLACEHOLDERS[dm().getContextId()])

        isSearchMode = (dm().getContext() == 'ttf')

    def searchSwitchClicked(self):
        pos = self.searchDropDown.mapToGlobal(self.searchDropDown.pos())
        #Spawn the dropdown below the TFFFieldGroup
        pos.setY(pos.y() + pix(tUI.dimensions['ttf_window_height']))
        self.dialog.setGeometry(pos.x(), pos.y(), pix(tUI.dimensions['ttf_dropDown_width']), len(CONTEXT_ICONS)*pix(tUI.dimensions['ttf_window_height']))
        if not self.dialog.isVisible() and not self.dialog.ignoreDropDownButtonPress():
            self.dialog.show()
        elif self.dialog.isVisible():
            self.dialog.close()

    def setDropDownIcon(self, open):
        self.searchDropDown.setImage(tUI.getDropDownIcon(CONTEXT_ICONS[dm().getContextId()], open))

    def clearText(self):
        self.removeAllTags()
        self.lineEdit.setText('')

    def removeAllTags(self):
        while self.tagList.layout().count() > 0:
            item = self.tagList.layout().takeAt(self.tagList.layout().count()-1)
            item.widget().close()
            del self.activeTags[-1]

    def addTag(self, tag):
        self.activeTags.append(tag)
        self.tagList.layout().addWidget(tag)
        self.tagList.show()
        self.tagList.repaint()
        self.layout().activate()

    def deleteTag(self, index=None):
        layout = self.tagList.layout()
        if layout.count() == 0:
            return -1
        else:
            if index == None:
                index = layout.count()-1

            del self.activeTags[index]

            layout.itemAt(index).widget().hide()
            layout.activate()
            item = layout.takeAt(index)
            item.widget().deleteLater()

            if len(self.activeTags) == 0:
                self.tagList.hide()
                self.layout().activate()

            return index

class TTFHelpView(qt.QFrame):
    hideClicked = qt.Signal()

    def __init__(self, parent=None):
        qt.QFrame.__init__(self, parent)
        fx.setVLayout(self)
        self.setFixedWidth(pix(tUI.dimensions['ttf_window_without_tag']))

        helpHeader = qt.QWidget()
        helpHeader.setFixedHeight(pix(40))
        fx.setVLayout(helpHeader)
        self.layout().addWidget(helpHeader)
        
        header = qt.QWidget()
        header.setLayout(qt.QHBoxLayout())
        header.layout().setContentsMargins(pix(0),pix(0),pix(2),pix(0))
        header.layout().setSpacing(pix(0))
        header.setAutoFillBackground(True)
        header.setFixedHeight(pix(tUI.dimensions['ttf_window_height']))
        fx.setWidgetBackgroundColor(header, [51,115,153,230])
        helpHeader.layout().addWidget(header)

        self.helpHeaderIcon = qt.QLabel()
        self.helpHeaderIcon.setAlignment(qt.Qt.AlignCenter)
        self.helpHeaderIcon.setFixedHeight(pix(tUI.dimensions['ttf_window_height']))
        self.helpHeaderIcon.setFixedWidth(pix(22))

        header.layout().addWidget(self.helpHeaderIcon)
        header.layout().addSpacing(pix(2))

        self.helpHeaderTitle = qt.QLabel()
        self.helpHeaderTitle.setStyleSheet('QLabel{font-size: %dpx;}' % pix(12))
        header.layout().addWidget(self.helpHeaderTitle,1)

        backIcon = fx.ImageButton('TTF_Collapse')
        backIcon.clicked.connect(lambda: self.hideClicked.emit())
        header.layout().addWidget(backIcon)

        helpSubHeader = ClickableWidget()
        helpSubHeader.clicked.connect(self.openOnlineHelp)
        helpSubHeader.setLayout(qt.QHBoxLayout())
        helpSubHeader.layout().setContentsMargins(pix(24),pix(0),pix(2),pix(0))
        helpSubHeader.layout().setSpacing(pix(0))
        helpSubHeader.setAutoFillBackground(True)
        helpSubHeader.setFixedHeight(pix(18))
        fx.setWidgetBackgroundColor(helpSubHeader, [68,68,68, 217])
        helpHeader.layout().addWidget(helpSubHeader)

        helpHeaderSubtitle = qt.QLabel()
        helpHeaderSubtitle.setStyleSheet('QLabel{font-size: %dpx;}' % pix(12))
        helpHeaderSubtitle.setText('<i>%s</i>' % fx.res('kOnlineDocumentation'))
        helpSubHeader.layout().addWidget(helpHeaderSubtitle, 1)

        helpIcon = qt.QLabel()
        helpIcon.setPixmap(fx.scalePixmap(fx.getPixmap('menuIconHelp'), 16, 16))
        helpSubHeader.layout().addWidget(helpIcon)

        self.helpView = qt.QTextEdit()
        self.layout().addWidget(self.helpView)
        self.helpView.setReadOnly(True)
        self.helpView.setStyleSheet('QTextEdit{border: none; font-size: %dpx;}' % pix(12))

        dUtils.loadInconsolata()

        self.normalFont = self.helpView.font()
        self.monospaceFont = qt.QFont('Inconsolata')

        fx.setWidgetBaseColor(self.helpView, [55,55,55,217])

    def setHelpViewFocus(self):
        self.helpView.setFocus()

    def setHelpViewText(self, text):
        self.helpView.setText(text)

    def updateFont(self):
        font = self.normalFont
        if dm().getContext() in ('mel','python'):
            font = self.monospaceFont
        self.helpView.setFont(font)

    def setItemPixmap(self, pixmap):
        self.helpHeaderIcon.setPixmap(pixmap)

    def setItemTitle(self, title):
        self.helpHeaderTitle.setText(title)

    def openOnlineHelp(self):
        cmd = dm().getCommand(self.helpCommand)
        tDU.showDocsForCommand(cmd)

    def getDetailInfoForCommand(self, command):
        quickhelp = dm().getCommand(command).description # short annotation
        quickhelp += "\r\n"
        quickhelp += "\r\n"
        quickhelp += dm().getCommand(command).longAnnotation # long annotation
        
        moreInfo = []

        if dm().getContext() in ['mel','python']:
            toolAnnotation = dm().getAnnotationForCommand(command)
            if toolAnnotation:
                moreInfo.append(toolAnnotation)

            try:
                cmdsHelp = cmds.help(command)
                moreInfo.append("".join([s for s in cmdsHelp.splitlines(True) if s.strip("\r\n")]))
            except:
                pass

        # if len(menuLocation) > 0:
        #     moreInfo.append(fx.res('kTTF_Menu') + menuLocation.replace('->', u"\u2192"))

        tags = dm().getTagsForCommand(command)
        if len(tags) > 0:
            moreInfo.append(fx.res('kTTF_Tags') + ', '.join(tags))

        if len(quickhelp) > 0:
            quickhelp += '\r\n'
            quickhelp += '\r\n'
            quickhelp += '\r\n'.join(moreInfo)

        # if dm().getContextId() == 0:
        #     quickhelp += '\n' + 'Menu path(s): ' + '\n'.join(dm().getMenuPaths(command))

        return quickhelp

    def setCommand(self, command):
        self.helpCommand = command

        quickhelp = self.getDetailInfoForCommand(command)
        self.setHelpViewText(quickhelp)

        pixmap = tDU.getPixmapForCommand(command)
        pixmap = tUI.fixTTFIconScaling(pixmap)

        self.setItemPixmap(pixmap)
        self.updateFont()
        self.setItemTitle(dm().getCommand(command).label)

class TTFUI(qt.QDialog):

    def __init__(self, parent=None):
        qt.QDialog.__init__(self, parent)
        
        self.setProperty("saveWindowPref", True )
        self.setWindowFlags(qt.Qt.Window|qt.Qt.FramelessWindowHint|qt.Qt.NoDropShadowWindowHint)
        self.setAttribute(qt.Qt.WA_DeleteOnClose)
        self.setAttribute(qt.Qt.WA_NoSystemBackground)
        self.setAttribute(qt.Qt.WA_TranslucentBackground)

        self.hotkeyFilter = HotkeyFilter(self)

        self.setupEnvs()
        maya.app.TTF.api.initTTF()
        self.setupUI()
        self.lineEdit.setFocus()
        
        # Create a shortcut for the search hotkey and connect it to cycleToNextContext.
        self.shortcut = qt.QShortcut(qt.QKeySequence(dm().getHotkeyForCommand("SearchEngine")), self)
        self.shortcut.activated.connect(self.cycleToNextContext)
        
        self.updateContext()
        self.fillLastCommand()
        self.show()

    def setupEnvs(self):
        self.isHelpVisible = False
        self.activeTags = []
        self.navigationIndex = 0
        self._results = []
        self.selectData = []
        self.selectIndexData = []
        self.searchModeMsg = ''

    def fillLastCommand(self):
        hist = dm().getHistory()
        if cmds.optionVar( q='autoFillLastCommand' ) and len(hist)>0:
            if dm().getContext() == 'ttf':
                self.lineEdit.setText(dm().getCommand(hist[-1]).label)
            else:
                self.lineEdit.setText(hist[-1])
            self.lineEdit.selectAll()
        
    def changeEvent(self, e):
        if e.type() == qt.QEvent.ActivationChange:
            if not self.isActiveWindow():
                self.close()

    def closeEvent(self, event=None):
        global toggleOn
        dm().save()

        # If the window was toggled on from Maya toolbar icon we need to keep track
        # of the toggle state and update the icon accordingly.
        if toggleOn:
            if not self.mayaToolBoxSearchIcon.underMouse():
                toggleOn = False
            cmds.iconTextCheckBox( "mayaSearchToolBoxIcon", edit=True, value=False)


    #all layout code goes here
    def setupUI(self):
        self.setStyleSheet(tUI.windowStyleSheet())
        self.setFixedWidth(pix(tUI.dimensions['ttf_window_total_width']))
        self.resize(self.width(), pix(22))

        # Calling this function is expensive, so keep a handle to the search icon
        # instead of calling this function multiple times.
        self.mayaToolBoxSearchIcon = fx.getMayaWidget("mayaSearchToolBoxIcon")

        if toggleOn:
            tUI.showNextToSearchIcon(self)
        else:
            tUI.adjustPosition(self)

        fx.setVLayout(self)

        self.topBar = qt.QWidget()
        fx.setHLayout(self.topBar)
        self.layout().addWidget(self.topBar)

        self.fieldGroup = TTFFieldGroup()
        self.fieldGroup.contextUpdated.connect(self.updateContext)
        self.topBar.layout().addWidget(self.fieldGroup, 0)

        self.lineEdit = self.fieldGroup.lineEdit
        self.lineEdit.installEventFilter(self.hotkeyFilter)
        self.lineEdit.textChanged.connect(self.textChanged)

        self.tagBtn = fx.ImageButton('TTF_Filter')
        self.tagBtn.setFixedWidth(pix(22))
        self.tagBtn.clicked.connect(self.tagBtnClicked)
        self.tagBtn.rightClicked.connect(self.tagBtnRightClicked)
        self.tagBtn.setCursor(qt.QCursor(fx.getPixmap('rmbMenu.png'), pix(7), pix(5)))
        self.tagBtn.hoverBackgroundColor = qt.QColor(*tUI.colors['gray'])
        self.tagBtn.setConstantBackground(True)
        self.tagBtn.setBackgroundColor(qt.QColor(*tUI.colors['blue']))
        self.tagBtn.setToolTip(fx.res('kFilter'))
        self.tagBtn.setStatusTip(fx.res('kFilter'))
        self.topBar.layout().addWidget(self.tagBtn)

        self.slider = qt.QWidget()
        self.slider.setFixedWidth(pix(tUI.dimensions['ttf_window_without_tag']))

        self.resultsWrapper = qt.QWidget(self.slider)
        self.resultsWrapper.setFixedWidth(2*pix(tUI.dimensions['ttf_window_without_tag']))

        self.results = TTFListWidget(self, self.resultsWrapper)
        self.results.setFixedWidth(pix(tUI.dimensions['ttf_window_without_tag']))
        self.results.setStyleSheet(tUI.resultsListStyleSheet())

        self.results.transition.connect(self.transition)
        self.results.rightClicked.connect(self.rightClickedRow)
        self.results.rowClicked.connect(self.rowClicked)
        self.results.optionBoxClicked.connect(self.optionBoxClicked)
        self.results.favClicked.connect(self.favClicked)
        self.results.itemSelectionChanged.connect(self.resultsSelectionChanged)

        self.newHelpView = TTFHelpView(self.resultsWrapper)
        self.newHelpView.hideClicked.connect(self.hideHelp)
        self.newHelpView.move(pix(tUI.dimensions['ttf_window_without_tag']), self.newHelpView.pos().y())
        
        self.layout().addWidget(self.slider, 0)
        self.layout().addStretch()

        self.newHelpView.helpView.installEventFilter(self.hotkeyFilter)

# Events

    def optionBoxClicked(self, row):
        if row < len(self._results):
            self.openOptionBox(self._results[row])

    def tagBtnClicked(self):
        self.showTagList()

    def tagBtnRightClicked(self):
        menu = qt.QMenu(self)
        menu.setFocusPolicy(qt.Qt.NoFocus)
        menu.setFixedWidth(pix(170))
        menu.addAction(fx.getIconFromName('out_MASH_Options'), fx.res('kManageFilterTags'), maya.app.TTF.prefsWindow.openPrefsWindow)
        menu.move(qt.QCursor.pos())
        menu.show()

    def resultsSelectionChanged(self):
        selectedIndexes = self.results.selectionModel().selectedRows()
        if selectedIndexes:
            self.updateNavIndex(selectedIndexes[0].row())

    def transition(self, row):
        self.showHelp()

    def favClicked(self):
        self.toggleFavorite()

    def updateContext(self):
        self.updateContextUI()
        self.updateResults()

    def cycleToNextContext(self):
        newContext = (dm().getContextId()+1) % 4

        dm().setContextId(newContext)
        self.updateContext()

    def textChanged(self):
        text = self.lineEdit.text()

        # Open tag list on ':' press
        if text.endswith(':') and dm().getContext() != 'select':
            self.lineEdit.setText(text[:-1])
            self.showTagList()
            return

        if not text or dm().getContext() == 'ttf':
            self.hideHelp()

        if len(text) == 0:
            self.fieldGroup.clearTextBtn.hide()
        else:
            self.fieldGroup.clearTextBtn.show()

        self.updateResults()

    def rightClickedRow(self, row):
        if dm().getContext() != 'select': 
            self.showTagPopup(row)

    def rowClicked(self, row):
        self.executeCommand()

# Utilities

    def openSelectedOptionBox(self):
        '''Opens the option box for the selected item in TTF mode, else does nothing'''
        if dm().getContext() == 'ttf':
            cmd = self.getSelectedCommand()
            if cmd:
                self.openOptionBox(cmd)

    def openOptionBox(self, command):
        info = dm().getCommand(command)
        if info:
            mel.eval(info.optionCommand)

    def getSuggestionTags(self):
        suggestionTags = []

        if not self.lineEdit.text():
            suggestionTags = dm().getAllTags() 
        elif self._results:
            suggestionTags = dm().getSuggestionTags(self._results)

        return suggestionTags
        
    def showTagPopup(self, row):
        pos = qt.QCursor.pos()
        pos.setY(pos.y()-pix(15))
        pos.setX(pos.x()-pix(115))

        command = self.getSelectedCommand()

        tags = dm().getTagsForCommand(command)
        newTags, ok = TagPopup.getChoice(self, pos, tags)

        # Update the data model if any user changes
        if tags != newTags:
            for tag in (x for x in tags if x not in newTags):
                dm().removeTagForCommand(command, tag)
            for tag in (x for x in newTags if x not in tags):
                if tag not in dm().getAllTags():
                    dm().addTag(tag)
                dm().addTagForCommand(command, tag)
            self.setCompleterTags()
            
    def setCompleterTags(self):
        return
        tags = [':'+x for x in dm().getAllTags()]
        self.lineEdit._completer.model().setStringList(tags)

    def updateContextUI(self):
        self.fieldGroup.updateContextUI()
        self.tagBtn.setEnabled(dm().getContext() != 'select')

    def getCurrentRowHeight(self):
        return (TTFListDelegate.getCurrentRowHeight())

    def getCommandsForActiveTags(self):
        # Returns commands that have all the active tags assigned
        data = set()
        for i, tag in enumerate(self.activeTags):
            if i == 0:
                data = set(dm().getAllCommandsForTag(tag))
            else:
                # intersect for narrowing down, union for adding up
                data = data.intersection(set(dm().getAllCommandsForTag(tag)))

        return sorted(data, key=lambda item: (len(item), item))

    def updateResults(self):            
        self.clearSelectKeepHistory()

        text = self.lineEdit.text()

        if dm().getContext() == 'select':
            # Search mode
            self.updateResultsForSearchMode(text)
        elif len(text) == 0:
            self.doEmptyQuery()
        else:
            self.doCommandQuery(text)

    def doEmptyQuery(self):
        if len(self.activeTags) > 0:
            # show commands which have the active tags
            data = self.getCommandsForActiveTags()
            self.setResults(data)
        elif dm().getContext() == 'ttf' and cmds.optionVar( q='showHistoryOnEmptySearchField' ):
            # show most recently used commands in ttf mode
            hist = dm().getHistory()[::-1]
            hist = [x for x in hist if dm().commandExists(x)]
            self.setResults(hist)
        else:
            self.setResults([])

    def doCommandQuery(self, text):
        shortestFirst = True
        allFavorites = dm().getAllFavorites(text, shortestFirst)
        
        cmd = dm().getCommandNames(text, shortestFirst, self.activeTags)
        cmdLookup = set(cmd)

        favorites = [x for x in allFavorites if x in cmdLookup]
        favLookup = set(favorites)

        results = favorites + [x for x in cmd if x not in favLookup]
        
        self.setResults(results)

    def setResults(self, results):
        self._results = results[:100]

        self.results.clear()
        for i in self._results:
            item = TTFListItem()
            item.contextId = dm().getContextId()

            # For TTF_Select at index 1 we don't need a command
            if dm().getContext() != 'select':
                item.label = dm().getCommand(i).label
                item.command = i
            else:
                item.label = i

            item.hasOptionBox = False

            if dm().getContext() == 'ttf':
                cmdInfo = dm().getCommand(i)
                item.hasOptionBox = len(cmdInfo.optionCommand) > 0

            item.hotkey = dm().getHotkeyForCommand(i)

            self.results.addItem(item)
        self.fixUI()
        
    def fixUI(self):
        maxVisibleRows = 10

        if len(self._results) > 0:
            if not self.results.isVisible():
                self.results.show()
        else:
            if self.results.isVisible():
                self.results.hide()

        rowCount = min(self.results.count(), maxVisibleRows)
        if self.isHelpVisible:
            rowCount = maxVisibleRows

        height = rowCount * self.getCurrentRowHeight()

        self.results.setFixedHeight(height)
        self.slider.setFixedHeight(height)
        self.resultsWrapper.setFixedHeight(height)
        self.setFixedHeight(height + pix(22))

    def resizeToFitText(self):
        return #TODO: auto expand field as user is typing
        fm = qt.QFontMetrics(self.lineEdit.font())
        w = fm.horizontalAdvance(self.lineEdit.text())
        self.lineEdit.setMinimumWidth(w+pix(6))
        self.fieldGroup.setMinimumWidth(self.fieldGroup.sizeHint().width())
        self.topBar.setMinimumWidth(self.topBar.sizeHint().width())
        self.setMinimumWidth(max(self.sizeHint().width(), pix(362)))

    def getSelectedCommand(self):
        selectedIndexes = self.results.selectionModel().selectedRows()
        if len(selectedIndexes) > 0 and len(self._results) > 0:
            return self._results[selectedIndexes[0].row()]
        else:
            row = self.results.rowUnderMouse()
            if row >= 0 and row < len(self._results):
                return self._results[row]
        
        return None

    def clearSelection(self):
        self.results.selectionModel().clearSelection()

    def selectRow(self, row):
        self.clearSelection()

        # loop result rows
        if row == self.results.count(): 
            row = 0

        self.results.setCurrentRow(row)
        self.results.item(row).setSelected(True)
        self.updateNavIndex(row)

    def updateNavIndex(self, selectedRow):
        self.navigationIndex = selectedRow + 1

    def clearSelectKeepHistory(self):
        self.clearSelection()

        if self.navigationIndex > 0:
            self.navigationIndex = 0
            
    def animateHelpView(self, toValue):
        start = deepcopy(self.resultsWrapper.geometry())
        end = deepcopy(start)
        end.setX(toValue)

        self.animation = qt.QPropertyAnimation(self.resultsWrapper, qt.QByteArray(b'geometry'))
        self.animation.setDuration(150)
        self.animation.setStartValue(start)
        self.animation.setEndValue(end)
        self.animation.start()

        self.newHelpView.setHelpViewFocus()
        self.fixUI()

    def showHelp(self):
        if not self.isHelpVisible:
            command = self.getSelectedCommand()
            if command is None:
                command = self._results[0]

            self.newHelpView.setCommand(command)

            self.isHelpVisible = True
            self.animateHelpView(-pix(tUI.dimensions['ttf_window_without_tag']))
        
    def hideHelp(self):
        if self.isHelpVisible:
            self.isHelpVisible = False
            self.animateHelpView(pix(0))
            self.focusTTFInput()

    def enterPressed(self):
        modifiers = qt.QGuiApplication.keyboardModifiers()
        if not modifiers & qt.Qt.ControlModifier:
            self.close()

### Actions

    def showDocs(self):
        c = self.getSelectedCommand()
        if not c: return

        c = dm().getCommand(c)
        tDU.showDocsForCommand(c)

    def switchHelp(self):
        if self.isHelpVisible:
            self.hideHelp()
        elif self.getSelectedCommand():
            self.showHelp()
        elif self.results.count() > 0:
            self.selectRow(0)
            self.showHelp()

    def focusTTFInput(self):
        self.lineEdit.setFocus()

    def forwardEventToInput(self, event):
        self.lineEdit.keyPressEvent(event)

    def executeCommand(self):
        if dm().getContext() == 'select':
            self.executeCommandForSearchMode()
            return

        command = self.lineEdit.text()

        c = self.getSelectedCommand()
        if c:
            command = dm().getCommand(c).command
        elif dm().getContext() == 'ttf':
            if len(self._results) > 0:
                c = self._results[0]
                command = dm().getCommand(c).command
            else:
                return

        if dm().getContext() == 'ttf':
            dm().addHistory(c)
        else:
            dm().addHistory(command)

        self.enterPressed()

        try:
            if dm().getContext() == 'python':
                maya.OpenMaya.MGlobal.executePythonCommand(command, True, True)
            else:
                maya.OpenMaya.MGlobal.executeCommand(command, True, True)
        except Exception as e:
            print(str(e))

    def autocomplete(self):
        command = self.getSelectedCommand()
        if command is None and self.results.count() > 0:
            command = self.results.item(0).text()

        if not command: return

        if dm().getContext() == 'select':
            command = self.autocompleteSearchMode(command)

        if dm().getContext() in ['mel','python']:
            c = dm().getCommand(command)
            command = c.command

        if command:
            self.lineEdit.setText(command)

    def navigateUpDown(self, nav):
        self.clearSelection()

        hist = []
        if dm().getContext() != 'select':
            hist = dm().getHistory()

        # navigation safeguards
        if self.navigationIndex == 0:
            if nav == -1 and len(hist) == 0:
                # history query, but no history
                return
            elif nav == 1 and (self.results.count() == 0 or self.isHelpVisible):
                # can't navigate rows if no results or help is visible
                return

        if self.navigationIndex == 0 and nav == -1:
            # save the field text when navigating history
            self.lastEdit = self.lineEdit.text()

        self.navigationIndex += nav

        if self.navigationIndex == 0:
            if nav == 1:
                # restore the field text
                self.lineEdit.setText(self.lastEdit)
        elif self.navigationIndex < 0:
            # navigate history
            if -self.navigationIndex > len(hist):
                self.navigationIndex = -len(hist)
            if dm().getContextId() > 0:
                self.lineEdit.setText(hist[self.navigationIndex])
            else:
                cmdKey = hist[self.navigationIndex]
                cmd = dm().getCommand(cmdKey)
                self.lineEdit.setText(cmd.label)
        else:
            # navigate rows
            self.selectRow(self.navigationIndex - 1)

    def addTag(self, tag):
        if tag not in self.activeTags:
            self.activeTags.append(tag)
            color = dm().getColorForTag(tag)

            # A tag has been added. Highlight the filter button to ON state.
            self.tagBtn.setHighlighted(True)

            dtag = TTFTag(tag, color=color)
            dtag.clicked.connect(self.deleteTag)
            self.fieldGroup.addTag(dtag)

            self.updateResults()

        self.resizeToFitText()

    def deleteTag(self, specificTag=None):
        index = None
        if specificTag in self.activeTags:
            index = self.activeTags.index(specificTag)

        index = self.fieldGroup.deleteTag(index)
        if index >= 0:
            del self.activeTags[index]
            self.updateResults()

        # If there are no active tags set filter button highlight to False.
        if len(self.activeTags) == 0:
            self.tagBtn.setHighlighted(False)

        self.resizeToFitText()

    def toggleFavorite(self):
        cmd = self.getSelectedCommand()

        exists = dm().isFavorite(cmd)
        if exists:
            dm().unfavorite(cmd)
        else:
            dm().favorite(cmd)
            
    def showTagList(self):
        suggestionTags = self.getSuggestionTags()
        tags = [x for x in suggestionTags if x not in self.activeTags]
        self.tagPopup = MainTagPopup(tags)
        self.tagPopup.addTag.connect(self.addTag)
        pos = self.mapToGlobal(self.tagBtn.pos())
        self.tagPopup.setGeometry(pos.x(), pos.y(), pix(150), pix(20))
        self.tagPopup.show()

###
### Search mode
###

    def autocompleteSearchMode(self, command):
        i = len(self.selectData) - 1
        i = self.selectIndexData[i]
        if self.searchModeMsg in ['1', '4']:
            command = '/%s/' % command
        elif command == self.lineEdit.text()[i:] and self.searchModeMsg in ['2', '5']:
            command = '=%s$' % command
        command = self.lineEdit.text()[:i] + command

        return command

    def executeCommandForSearchMode(self):
        if len(self.selectData) in [3, 6]:
            self.autocomplete()
        if len(self.selectData) == 6:
            dm().addHistory(self.lineEdit.text())

            leftNodes = self.selectData[1]
            rightNodes = self.selectData[4]
            leftAttr = self.selectData[2]
            rightAttr = self.selectData[5]

            if len(leftNodes) == 1: #one to many
                left = leftNodes[0]
                for node in rightNodes:
                    try:
                        first = '%s.%s' % (left, leftAttr)
                        second = '%s.%s' % (node, rightAttr)
                        cmds.connectAttr(first, second, f=True)
                        print('Connected %s to %s' % (first, second))
                    except Exception as e:
                        print(str(e))
            else: #many to many
                nodes = list(zip(leftNodes, rightNodes))
                for nPair in nodes:
                    try:
                        first = '%s.%s' % (nPair[0], leftAttr)
                        second = '%s.%s' % (nPair[1], rightAttr)
                        cmds.connectAttr(first, second, f=True)
                        print('Connected %s to %s' % (first, second))
                    except Exception as e:
                        print(str(e))

            self.enterPressed()
        elif self.searchModeMsg == '2':
            dm().addHistory(self.lineEdit.text())
            toSelect = self._results
            c = self.getSelectedCommand()
            if c:
                toSelect = [c]
            cmds.select(clear=True)
            cmds.select(*toSelect, r=True, ne=True)
            self.enterPressed()

    def updateResultsForSearchMode(self, text):
        results = cmds.ls(dep=True)
        if len(text) > 0:
            exp = text.split('>')
            res = []
            ires = []

            attributes= []

            p = re.compile(u'(^/[^/]*)?/?([^/]*)/?(.*)', re.U)
            for index, e in enumerate(exp):
                m = p.match(e)
                typeFilter = m.group(1)
                if typeFilter and len(typeFilter) > 0:
                    typeFilter = typeFilter[1:]
                    if m.end(1) >= 0 and m.end(1)==m.end(2):
                        p2 = re.compile(u'.*%s.*' % re.escape(typeFilter), re.I | re.U)
                        r = list(filter(p2.match, cmds.allNodeTypes()))
                        res.append(r)
                    else:
                        res.append(cmds.ls(typ=typeFilter))
                else:
                    res.append(results)

                if m.end(2) > m.end(1):
                    if m.group(2):
                        p2 = None
                        r = None
                        try:
                            if m.group(2)[0] == '=':
                                p2 = re.compile(m.group(2)[1:])
                            else:
                                p2 = re.compile(u'.*%s.*' % re.escape(m.group(2)), re.I | re.U)
                            r = list(filter(p2.match, res[-1]))
                            res.append(r)
                        except Exception as e:
                            print(str(e))
                            return
                    else:
                        res.append(res[-1])

                if m.end(3) > m.end(2):
                    attrMatch = []

                    if res[-1]:
                        nodes = res[-1]
                        attr = set(cmds.listAttr(nodes[0], c=True))
                        for n in nodes[1:]:
                            attr = attr.intersection(set(cmds.listAttr(n, c=True)))
                        attrMatch = list(attr)

                    if m.group(3):
                        attributes.append(m.group(3))
                        p2 = None
                        try:
                            p2 = re.compile(u'.*%s.*' % re.escape(m.group(3)), re.I | re.U)
                            r = list(filter(p2.match, attrMatch))
                            res.append(r)
                        except Exception as e:
                            print(str(e))
                            return
                    else:
                        res.append(attrMatch)

                if len(res) != 3 and len(exp)>1 and index==0:
                    break

                offset = len(exp[0]) + 1 if index == 1 else 0
                ires += [m.start(x) + offset for x in range(1, 4)]

            results = res[-1]
            self.selectData = res

            if attributes:
                for i in range(len(attributes)):
                    j = [2, 5][i]
                    if len(self.selectData) > j:
                        self.selectData[j] = attributes[i]

            self.selectIndexData = ires
            self.searchModeMsg = str(len(res))
            if len(res) == 3 and len(res[1]) > 0:
                self.searchModeMsg += ',' + res[1][0]
        else:
            self.searchModeMsg = '2'
            self.selectData = [results]
            self.selectIndexData = [0]

        results = sorted(results, key=lambda item: (len(item), item))
        self.setResults(results)# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
