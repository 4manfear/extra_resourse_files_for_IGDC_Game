from builtins import range
from builtins import object
from future import standard_library
standard_library.install_aliases()
from builtins import filter
from past.builtins import cmp
from maya.app.flux.imports import *
import maya.app.TTF.store as store
from maya.app.TTF.search import TTFSearch
import maya.app.TTF.utils as dUtils
import os
import json
import re
from functools import reduce, cmp_to_key

class DataManager(object):
    def __init__(self):
        self.contexts = ['ttf', 'select', 'mel', 'python']
        self.defaults = {
            'context': 'ttf',
            'history':[[] for x in self.contexts],
            'version': '0.21'
        }

        self.db = store.db

        for c in self.contexts:
            if c not in self.db and c != 'select':
                self.db[c] = {'commands':{}, 'tags':{}}
        if 'search' not in self.db['ttf']:
            self.db['ttf']['search'] = TTFSearch()
        self.ttf = self.db['ttf']

        self.userEdits = [[],[],[]]

        self.loadPaths()
        self.loadPrefs()
        self.needsToFinishLoading = True
        
        self.callback = dUtils.onMayaQuitCallback(self.save)

    def finishLoading(self):
        self.loadPaths()
        self.loadToolsPackage()
        self.loadCmdsPackage()
        self.loadUserAudit()
        self.needsToFinishLoading = False

    def save(self):
        self.savePrefs()
        self.saveUserEdits()

    ### API

    def addItem(self, item, tags=[]):
        if item.command.endswith('Options'):
            mainCommand = item.command[:-len('Options')]
            if mainCommand in self.ttf['commands']:
                self.ttf['commands'][mainCommand].optionCommand = item.command
            else:
                # If option command is received before main command we add the main command to the command
                # dictionary, and add options command as placeholder. When main command is added later,
                # command dictionary is updated.
                self.ttf['commands'][mainCommand] = item
                self.ttf['commands'][mainCommand].optionCommand = item.command
            return

        # Ensure that if item already exists we read the optionCommand and add it to current item.
        # There might be instances when option command is received before main command. This logic
        # keeps track of optioncommand.
        if item.command in self.ttf['commands']:
            item.optionCommand = self.ttf['commands'][item.command].optionCommand

        for category in item.categories:
            subpaths = self.categoryToList(category)
            tags += subpaths

        for tag in tags:
            tag = tag.strip()
            if not len(tag): continue
            if tag not in self.ttf['tags']:
                self.ttf['tags'][tag] = TTFTag(tag)
            self.ttf['tags'][tag].commands.add(item.command)

        self.ttf['search'].addItem(item)
        self.ttf['commands'][item.command] = item

    ### Prefs

    def loadPaths(self):
        ''' Loads all paths needed by TTF '''

        # Preferences folder
        self.prefsFolder = reduce(os.path.join, (dUtils.mayaPrefsFolder(), 'prefs', 'search'))
        if not os.path.exists(self.prefsFolder):
            os.makedirs(self.prefsFolder)

        # Preferences file
        self.prefsFile = os.path.join(self.prefsFolder, 'user_prefs.json')
        self.auditFile = os.path.join(self.prefsFolder, 'user_audit.json')

    def loadPrefs(self):
        ''' Loads the user preferences '''
        if not os.path.exists(self.prefsFile):
            self.prefs = dict(self.defaults)
            self.savePrefs()
            
        else:
            prefs = {}
            with open(self.prefsFile, 'r') as f:
                prefs = json.load(f)

            if prefs['version'] != self.defaults['version']:
                self.prefs = dict(self.defaults)
                self.savePrefs()
            else:
                self.prefs = prefs

    def savePrefs(self):
        ''' Saves the user preferences '''
        with open(self.prefsFile, 'w') as f:
            json.dump(self.prefs, f, sort_keys=True,
                indent=4, separators=(',', ': '), cls=SetEncoder)

    ### Context

    def getContext(self):
        return self.prefs['context']

    def setContext(self, ctx):
        self.prefs['context'] = ctx

    def getContextId(self):
        return self.contexts.index(self.getContext())

    def setContextId(self, ctxId):
        self.setContext(self.contexts[ctxId])

    ### History

    def getHistory(self):
        return self.prefs['history'][self.getContextId()]

    def addHistory(self, script):
        history = self.getHistory()
        if script in history:
            history.remove(script)
        history.append(script)

    ### Data setup

    def loadToolsPackage(self):
        self.toolsPackage = dUtils.getAssignCommandsMap()

    def loadCmdsPackage(self):
        '''Loads cmds commands for python and mel dynamically'''
        items = [x for x in dir(cmds) if not 'Ctx' in x and not x.startswith('__')]
        self.cmdsPackage = items
        for item in items:
            self.db['python']['commands'][item] = TTFItem(item, 'maya.cmds.' + item + '()', item, imageName=item)
            self.db['mel']['commands'][item] = TTFItem(item, item, item, imageName=item)

    ### Data access

    def getHotkeyForCommand(self, command):
        p = re.match(r'[^a-zA-Z_0-9]*([a-zA-Z_0-9]*).*', command, re.U)
        if p.group(1):
            index = self.toolsPackage.get(p.group(1), None)
            if index:
                return dUtils.getAssignCommandHotkey(index)
        
        return ''

    def data(self, field):
        ''' Returns the field data for the current context '''
        return self.db[self.getContext()][field]

    def categoryToList(self, category):
        parts = category.split('.')
        subpaths = []
        for i in range(len(parts)):
            subpath = '.'.join(parts if i==0 else parts[:-i])
            if subpath in store.ttfCategories:
                subpaths.append(store.ttfCategories[subpath])
        return subpaths[::-1]

    def getMenuPaths(self, cmd):
        command = self.getCommand(cmd)
        cats = command.categories
        menus = []
        for cat in cats:
            subpaths = self.categoryToList(cat)
            if len(subpaths):
                menus.append('->'.join(subpaths + [command.label]))
        return menus

    def getUserEdits(self):
        # For python context the index needs to be specified as 1. This is because
        # select and python's context ids were swapped recently. This is a by product 
        # of that change. (TODO - Fix useredits to index by context name)
        if self.getContext() == 'python':
            return self.userEdits[1]
        else:        
            return self.userEdits[self.getContextId()]

    def getCMDSCommands(self):
        return self.cmdsPackage

    def getToolCommands(self):
        return list(self.toolsPackage.keys())

    def getDocLinkCommand(self, script):
        commands = re.findall(r'\w+', script, re.U)
        if len(commands) == 1 and (commands[0] in self.getToolCommands() or 
            commands[0] in self.getCMDSCommands()):
            return commands[0]

        return None

    def getAnnotationForCommand(self, command):
        if self.getContext() == 'ttf':
            return self.getCommand(command).description

        index = self.toolsPackage.get(command, None)
        if index:
            return dUtils.getAssignCommandAnnotation(index)

    def getImageForCommand(self, command):
        c = self.getCommand(command)
        imageName = c.imageName
        if len(imageName) == 0:
            for cat in c.categories:
                catPath = cat.split('.')
                for i in range(len(catPath), 0, -1):
                    catImg = 'img:' + ".".join(catPath[:i])
                    if catImg in store.ttfCategories:
                        return store.ttfCategories[catImg]

        return imageName

    ### Tags

    def getAllTags(self):
        return list(self.data('tags').keys())

    def getColorForTag(self, tagName):
        tag = self.data('tags').get(tagName, TTFTag(''))
        return tag.color

    def setColorForTag(self, tagName, color):
        self.user_setTagColor(tagName, color)

    def getTagsForCommand(self, name):
        tags = [tag for tag in self.data('tags') if name in self.data('tags')[tag].commands]
        return tags

    def removeTagForCommand(self, name, tag):
        self.user_unsetTag(tag, name)

    def addTagForCommand(self, name, tag):
        if tag not in self.data('tags'):
            self.user_addTag(tag)
        self.user_setTag(tag, name)

    def getAllCommandsForTag(self, tag):
        tag = self.data('tags').get(tag, None)
        if tag:
            return [x for x in tag.commands if x in self.data('commands')]

        return []

    def addTag(self, tag):
        self.user_addTag(tag)

    def deleteTag(self, tag):
        self.user_delTag(tag)

    def renameTag(self, old, new):
        self.user_renameTag(old, new)

    def getSuggestionTags(self, commands):
        tags = []
        for tag in self.data('tags'):
            if any(c in self.data('tags')[tag].commands for c in commands):
                tags.append(tag)
        return tags

    ### Favorites

    def compareRankedCommands(self, lhs, rhs):
        rankCmp = cmp(lhs[1], rhs[1])
        if rankCmp != 0:
            return -rankCmp

        len1 = len(self.getCommand(lhs[0]).label)
        len2 = len(self.getCommand(rhs[0]).label)
        return cmp(len1, len2)

    def getAllFavorites(self, searchString='', shortFirst=True):
        favorites = self.getFavorites()

        p = re.compile(u'.*%s.*' % re.escape(searchString), re.I | re.U)
        results = sorted(filter(p.match, favorites), key=lambda item: len(self.getCommand(item).label))

        if self.getContext() == 'ttf':
            lookup = set(favorites)
            closestResults = self.ttf['search'].find(searchString)
            closestResults = sorted(closestResults, key=cmp_to_key(self.compareRankedCommands))
            closestResults = [x for x in closestResults if x in lookup]
            lookup2 = set(closestResults)
            results = closestResults + [x for x in results if x not in lookup2]

        return results

    def commandExists(self, name):
        return name in self.data('commands')

    def favorite(self, command):
        if not self.commandExists(command):
            return #TODO
        self.addTagForCommand(command, 'Favorites')

    def unfavorite(self, command):
        self.removeTagForCommand(command, 'Favorites')

    def isFavorite(self, command):
        return command in self.getFavorites()

    def getFavorites(self):
        return self.getAllCommandsForTag('Favorites')

    ### Commands

    def filterAndSort(self, names, filterStr, shortFirst):
        p = re.compile(u'.*%s.*' % re.escape(filterStr), re.I | re.U)
        def matches(name):
            return p.match(self.getCommand(name).label)
        names = list(filter(matches, names))
        if shortFirst:
            names = sorted(names, key=lambda item: len(self.getCommand(item).label))
        else:
            names = sorted(names)
        return names

    def getCommandNames(self, searchString, shortFirst=True, tags=[]):
        names = None
        if len(tags) == 0:
            names = list(self.data('commands').keys())
        else:
            names = set()
            for i, t in enumerate(tags):
                tCommands = set(self.getAllCommandsForTag(t))
                if i == 0:
                    names = tCommands
                else:
                    names = names.intersection(tCommands)
            names = list(names)

        results = self.filterAndSort(names, searchString, shortFirst)

        if self.getContext() == 'ttf':
            lookup = set(names)
            lookup2 = set(results)
            closestResults = self.ttf['search'].find(searchString)            
            closestResults = sorted(closestResults, key=cmp_to_key(self.compareRankedCommands))
            closestResults = (x[0] for x in closestResults)
            closestResults = [x for x in closestResults if x in lookup]
            lookup2 = set(closestResults)
            results = closestResults + [x for x in results if x not in lookup2]

        return results

    def getCommand(self, name):
        c = self.data('commands').get(name, None)
        if c is None:
            return TTFItem(name, name, name)
        return c

    def getAvailableTagName(self, text):
        if len(text) == 0:
            text = 'Untitled'   
        allTags = self.getAllTags()
        while text in allTags:
            match = re.match(u'(.*?)([0-9]+)$', text, re.U)
            if match:
                text = match.group(1)
                num = match.group(2)
                num = int(num)
                text = text + str(num+1)
            else:
                text = text + '1'
        return text

    def getDefaultUserAudit(self):
        version = 0.01
        default_user_audit = {'ttf':[], 'py':[], 'mel':[], 'version': version}
        return default_user_audit

    ### User edits
    def loadUserAudit(self):
        '''Apply all the actions that the user has taken, ex: addTag, delTag, etc'''
        default_user_audit = self.getDefaultUserAudit()
        user_audit = dict(default_user_audit)
        if not os.path.exists(self.auditFile):
            with open(self.auditFile, 'w') as f:
                json.dump(default_user_audit, f, cls=SetEncoder)
        else:
            with open(self.auditFile, 'r') as f:
                user_audit = json.load(f)

        if 'version' not in user_audit or user_audit['version'] < default_user_audit['version']:
            with open(self.auditFile, 'w') as f:
                json.dump(default_user_audit, f, cls=SetEncoder)
            user_audit = dict(default_user_audit)

        oldCtxId = self.getContextId()

        for ctx in range(3):
            if 0 == ctx:
                self.setContext('ttf')
            elif 1 == ctx:
                self.setContext('python')
            else:
                self.setContext('mel')

            prefix = ['ttf', 'py', 'mel'][ctx]
            self.userEdits[ctx] = user_audit[prefix]

            for row in self.userEdits[ctx]:
                key = row[0]

                if key == 'addTag':
                    self._addTag(row[1])

                elif key == 'setTag':
                    self._setTag(row[1], row[2])

                elif key == 'unsetTag':
                    self._unsetTag(row[1], row[2])

                elif key == 'delTag':
                    self._delTag(row[1])

                elif key == 'setTagColor':
                    self._setTagColor(row[1], row[2])

                elif key == 'renameTag':
                    self._renameTag(row[1], row[2])

        self.setContextId(oldCtxId)

    # Internal setters

    def _addTag(self, name):
        if name not in self.data('tags'):
            self.data('tags')[name] = TTFTag(name)

    def _setTag(self, name, command):
        if name not in self.data('tags'): return

        commands = self.data('tags')[name].commands
        if command not in commands:
            commands.add(command)

    def _unsetTag(self, name, command):
        if name not in self.data('tags'): return

        commands = self.data('tags')[name].commands
        if command in commands:
            commands.remove(command)

    def _delTag(self, name):
        if name in self.data('tags'):
            del self.data('tags')[name]

    def _setTagColor(self, name, color):
        if name in self.data('tags'):
            self.data('tags')[name].color = color

    def _renameTag(self, old, new):
        if old in self.data('tags'):
            self._addTag(new)
            oldTag = self.data('tags')[old]
            newTag = self.data('tags')[new]
            for cmd in oldTag.commands:
                if cmd not in newTag.commands:
                    newTag.commands.add(cmd)

            newTag.color = oldTag.color
            self._delTag(old)

    # User setters

    def user_addTag(self, name):
        self.getUserEdits().append(['addTag', name])
        self._addTag(name)

    def user_setTag(self, name, command):
        self.getUserEdits().append(['setTag', name, command])
        self._setTag(name, command)

    def user_unsetTag(self, name, command):
        self.getUserEdits().append(['unsetTag', name, command])
        self._unsetTag(name, command)

    def user_delTag(self, name):
        self.getUserEdits().append(['delTag', name])
        self._delTag(name)

    def user_setTagColor(self, name, color):
        self.getUserEdits().append(['setTagColor', name, color])
        self._setTagColor(name, color)

    def user_renameTag(self, old, new):
        self.getUserEdits().append(['renameTag', old, new])
        self._renameTag(old, new)        

    def saveUserEdits(self):
        user_audit = self.getDefaultUserAudit()

        for ctx in range(3):
            prefix = ['ttf', 'py', 'mel'][ctx]
            user_audit[prefix] = self.userEdits[ctx]

        with open(self.auditFile, 'w') as f:
            json.dump(user_audit, f, cls=SetEncoder)

class TTFItem(object):
    def __init__(self, rtc, command, label, 
                    description='Command',
                    longAnnotation='',
                    categories=[],
                    imageName='out_MASH_Utilities', 
                    keywords=[], 
                    plugin="",
                    helpUrl=""):

        self.rtc = rtc
        self.command = command
        self.optionCommand = ''
        self.label = label
        self.description = description
        self.longAnnotation = longAnnotation
        self.imageName = imageName
        self.keywords = keywords
        self.plugin = plugin
        self.categories = categories
        self.helpUrl = helpUrl

    def getCmdNameAsKeys(self, regex):
        keys = regex.findall(self.command.lower())
        return keys

    def getLabelAsKeys(self, regex):
        keys = regex.findall(self.label.lower())
        return keys

    def getKeywordAsKeys(self, regex):
        keys = []
        for x in self.keywords:
            keys += regex.findall(x.lower())
        return keys

    def getDescriptionAsKeys(self, regex):
        keys = regex.findall(self.description.lower())
        return keys

class TTFTag(object):
    def __init__(self, name, commands=[], color='#48AAB5'):
        self.name = name
        self.commands = set(commands)
        self.color = color

def searchItemFunc(item):
    return (len(item), item)

class SetEncoder(json.JSONEncoder):
    def default(self, obj):
        if isinstance(obj, set):
            return list(obj)
        return json.JSONEncoder.default(self, obj)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
