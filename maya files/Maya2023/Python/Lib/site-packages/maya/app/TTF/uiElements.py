from __future__ import division
from builtins import range
from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix
from maya.app.flux.core import dpi
from copy import deepcopy

import maya.app.TTF.api
dm = lambda: maya.app.TTF.api.dataManager()

import maya.app.TTF.ui as tUI
import maya.app.TTF.dataUtils as tDU

class DropDownPopup(qt.QWidget):
    def __init__(self, parent, pos, icons):
        super(DropDownPopup, self).__init__(parent=parent)

        self.setWindowFlags(qt.Qt.Popup|qt.Qt.FramelessWindowHint|qt.Qt.NoDropShadowWindowHint)
        self.setGeometry(pos.x(), pos.y(), pix(tUI.dimensions['ttf_dropDown_width']), len(icons)*pix(tUI.dimensions['ttf_window_height']))
        fx.setWidgetBackgroundColor(self, tUI.colors['dark'])
        self.setFixedHeight(len(icons)*pix(tUI.dimensions['ttf_window_height']))
        self.choice = -1
        self.setLayout(qt.QVBoxLayout())
        self.layout().setMargin(pix(0))
        self.layout().setSpacing(pix(0))

        # This member keeps track of the case when we press the searchDropDown to
        # close this dropDown. If the user clicks anywhere outside of this widget
        # this widget gets the mousepress event. We would like to close the dialogue
        # in that case. But the parent also gets the same event which ends up opening
        # the dialog again which produces a flashing affect. We solve this by setting
        # this member when we hide the dialog. This member is set to false state when
        # a timer for 100ms times out. We filter the mouse press events to search drop
        # down button if the member is set to True.
        self.ignoreButtonPressFromsearchDropDown = False
        
        # Create mode labels and add them to the layout
        choices = list(range(len(icons)))
        for i in range(len(icons)):
            btn = DropDownImageButton(icons[choices[i]], tUI.MODES[i])
            btn.clicked.connect(lambda a=choices[i]: self.setChoice(a))
            btn.setFixedHeight(pix(tUI.dimensions['ttf_window_height']))
            self.layout().addWidget(btn)
        
    def setChoice(self,choice):
        self.choice = choice
        self.close()

    # At show event ensure we highlight the current selected mode
    def showEvent(self, event):
        for i in range(self.layout().count()):
            item = self.layout().itemAt(i).widget()
            item.highLight(item.getLabel() == tUI.MODES[dm().getContextId()])

        self.parent().setDropDownIcon(True)

    def timedOut(self):
        self.ignoreButtonPressFromsearchDropDown = False

    def ignoreDropDownButtonPress(self):
        return self.ignoreButtonPressFromsearchDropDown

    # On mouse press event hide the drop down and start a timer to ignore events.
    def mousePressEvent(self, event):
        if self.isVisible() and not self.underMouse():
            self.close()
            event.accept()
            self.ignoreButtonPressFromsearchDropDown = True
            qt.QTimer.singleShot(100, self.timedOut)

    # At hide event we ensure that choice is updated in dm
    def hideEvent(self, event):
        if self.choice != -1:
            dm().setContextId(self.choice)
            self.parent().contextUpdated.emit()
        self.parent().setDropDownIcon(False)

class TagListWidget(qt.QListWidget):
    clicked = qt.Signal(int)
    def __init__(self, parent=None):
        super(TagListWidget, self).__init__(parent=parent)
        self.setMouseTracking(True)

    def mouseMoveEvent(self, e):
        super(TagListWidget, self).mousePressEvent(e)
        pos = e.pos()
        index = self.indexAt(e.pos())
        if index.isValid():
            row = index.row()
            self.selectionModel().clearSelection()
            self.setCurrentRow(row)
            self.item(row).setSelected(True)

    def mousePressEvent(self, e):
        super(TagListWidget, self).mousePressEvent(e)
        pos = e.pos()
        index = self.indexAt(e.pos())
        if index.isValid():
            row = index.row()
            self.clicked.emit(row)

class ClickableWidget(qt.QWidget):
    clicked = qt.Signal()

    def __init__(self, parent=None):
        super(ClickableWidget, self).__init__(parent)

    def mousePressEvent(self, e):
        super(ClickableWidget, self).mousePressEvent(e)
        self.clicked.emit()

class TTFListDelegate(qt.QItemDelegate):
    ACTION_ICON_WIDTH = 20
    ACTION_ICON_MARGIN = 8
    
    def __init__(self, window, parent=None):
        qt.QItemDelegate.__init__(self, parent)
        self.setClipping(False)
        self.window = window

    def getBackgroundColor(self, option, selected):
        if selected:
            return qt.QColor(51,115,153,230)
        else:
            return qt.QColor(55,55,55,217)

    def _drawBackground(self, color):
        self._painter.fillRect(self._rect, color)

    def _drawIcon(self, offset, icon, highlighted, size):
        p = qt.QPoint(self._rect.left() + offset, self._rect.top())

        if icon.height() / dpi() > size:
            newsize = (icon.height() / dpi()) / 2
            icon = fx.scalePixmap(icon, newsize, newsize)

        off = (size - icon.height() / dpi()) / 2
        p.setX(p.x() + pix(off))
        p.setY(p.y() + pix(off))

        if highlighted: icon = fx.highlightPixmap(icon)
        self._painter.drawPixmap(p, icon)

    def _drawText(self, offset, text, color, yoffset = 0, align = qt.Qt.AlignVCenter):
        newRect = deepcopy(self._rect)
        oldPen = self._painter.pen()
        newRect.setLeft(self._rect.left() + offset)
        if yoffset != 0:
            newRect.setTop(self._rect.top() + yoffset)
            newRect.setBottom(self._rect.bottom() + yoffset)
        self._painter.setPen(color)
        self._painter.drawText(newRect, align | qt.Qt.AlignLeft | qt.Qt.TextSingleLine, text)

        self._painter.setPen(oldPen)

    def setPainterFont(self):
        f = self._painter.font()
        f.setPixelSize(pix(12))
        self._painter.setFont(f)

    def updateHotkeyForSelectMode(self, item):
        message = self.window.searchModeMsg.split(',')
        additional = '' if len(message)==1 else message[1]
        message = message[0]

        try:
            if message == '1':
                item.hotkey = 'Type'
            elif message == '2':
                item.hotkey = str(cmds.nodeType(item.label) or '')
            elif message == '3':
                if len(additional) > 0:
                    item.hotkey = str(cmds.getAttr('%s.%s' % (additional, item.label), typ=True) or '')
        except:
            pass

    def getPixmapForSelectMode(self, node):
        pixmap = None
        if cmds.objExists(node):

            typ = cmds.nodeType(node)

            if typ == 'transform':
                shapes = cmds.listRelatives(node, shapes=True, fullPath=True)
                if shapes:
                    typ = cmds.nodeType(shapes[0])

            iconName = 'out_' + typ
            pixmap = fx.getPixmap(iconName)

        if self.window.searchModeMsg == '1':
            iconName = 'out_' + node
            pixmap = fx.getPixmap(iconName)
            
        if pixmap is None:
            pixmap = fx.getPixmap('out_default')

        return pixmap

    def getSubtitle(self, cmd, w, textWidth):
        text = ''

        toolAnnotation = dm().getAnnotationForCommand(cmd)
        if toolAnnotation:
            text += toolAnnotation + '\n'

        text = "".join([s for s in text.splitlines(True) if s.strip("\r\n")])

        savedRect = deepcopy(self._rect)
        self._rect.setWidth(w-textWidth-pix(2)-pix(24))

        metrics = self._painter.fontMetrics()
        text = metrics.elidedText(text, qt.Qt.ElideRight, self._rect.width()-pix(24))
        return text

    def paint(self, painter, option, index):
        """ Main entry point of drawing the cell """
        if not index.isValid(): 
            return

        # fake selection on mouse over if the user hasn't used
        # the keyboard to select something
        if self.parent().currentRow() == -1:
            selected = option.state & qt.QStyle.State_MouseOver
        else:
            selected = option.state & qt.QStyle.State_Selected
        
        item = self.parent().itemFromIndex(index)
        self._rect = option.rect
        self._painter = painter

        self.setPainterFont()
        self._drawBackground(self.getBackgroundColor(option, selected))

        self._rect.setHeight(pix(20))

        savedRect = deepcopy(self._rect)
        w = self._rect.width()

        pixmap = None
        # For TTF_Select we don't need a command
        if dm().getContext() == 'select':
            pixmap = self.getPixmapForSelectMode(item.label)
        else:
            pixmap = tDU.getPixmapForCommand(item.command)

        if dm().getContext()=='ttf':
            iconMargin = pix(8)
            iconHeight = 24
            textMargin = pix(4)
        else:
            iconMargin =  pix(4)
            iconHeight = 20
            textMargin = pix(6)

        self._rect.setY(self._rect.y()+iconMargin)
        self._drawIcon(iconMargin, pixmap, False, iconHeight)
        self._rect.setY(self._rect.y()-iconMargin)
        iconHeight = pix(iconHeight) # for the rest of the code

        offsetRight = 16 if item.hasOptionBox else 20
        if dm().getContext() == 'select': 
            offsetRight = 15
            self.updateHotkeyForSelectMode(item)
        
        metrics = self._painter.fontMetrics()

        textWidth = metrics.horizontalAdvance(item.hotkey)
        self._rect.setWidth(w-textWidth-pix(2)-pix(offsetRight))

        if dm().getContext()=='ttf':
            subTitle = self.getSubtitle(item.command, w, textWidth)
            # if no subtitle, center text in the middle of the rectangle
            if not subTitle: 
              textMargin = pix(12)
              self._rect.setHeight(self.getCurrentRowHeight())
              savedRect.setHeight(self.getCurrentRowHeight())
        else:
            subTitle = ""

        text = metrics.elidedText(item.label, qt.Qt.ElideRight, self._rect.width()-pix(24))
        self._drawText(iconHeight + iconMargin*2, text, self.parent().palette().text().color(), textMargin, qt.Qt.AlignTop)

        self._rect = deepcopy(savedRect)
        self._rect.setLeft(self._rect.right()-textWidth-pix(offsetRight))

        # in selection mode, the item.hotkey contains the dg node type, so we'll show it
        # since it won't be obscured by the action icons
        if not selected or dm().getContext() =='select':
            self._drawText(pix(0), item.hotkey, qt.QColor(163,163,163), textMargin, qt.Qt.AlignTop)

        self._rect = savedRect

        self._rect.setHeight(self.getCurrentRowHeight())

        if selected:
            iconWidth = TTFListDelegate.ACTION_ICON_WIDTH
            infoPos   = iconWidth*1 + TTFListDelegate.ACTION_ICON_MARGIN
            favePos   = iconWidth*2 + TTFListDelegate.ACTION_ICON_MARGIN
            optPos    = iconWidth*3 + TTFListDelegate.ACTION_ICON_MARGIN
            
            oldTop = self._rect.top()
            self._rect.setTop(oldTop + pix(10 if dm().getContext()=='ttf' else pix(4)))

            if item.hasOptionBox:
                self._drawIcon(self._rect.width()-pix(optPos), fx.getPixmap('TTF_Option'), False, iconWidth)        

            if dm().getContext() != 'select':
                isFav = dm().isFavorite(item.command)
                self._drawIcon(self._rect.width()-pix(favePos), fx.getPixmap('TTF_Fav' if isFav else 'TTF_FavBlank'), False, iconWidth)
                self._drawIcon(self._rect.width()-pix(infoPos), fx.getPixmap('TTF_Info'), False, iconWidth)
            self._rect.setTop(oldTop)
        
        # Draw subtitle in TTF mode
        if subTitle:
            savedRect = deepcopy(self._rect)
            self._rect.setTop(self._rect.top()+pix(14))
            
            self._painter.save()
            f = self._painter.font()
            f.setItalic(True)
            f.setPixelSize(pix(10))
            self._painter.setFont(f)

            self._drawText(iconHeight + iconMargin*2, subTitle, qt.QColor(163,163,163), -textMargin-pix(2), qt.Qt.AlignBottom)

            self._painter.restore()
            self._rect = savedRect

        # Draw separator
        self._rect.setTop(self._rect.top()+self._rect.height()-pix(1))
        self._drawBackground(qt.QColor(93,93,93,204))

        self._rect = None
        self._painter = None

    @staticmethod
    def getCurrentRowHeight():
        return pix(28) if dm().getContextId()>0 else pix(40)

    def sizeHint(self, option, index):
        hint = qt.QItemDelegate.sizeHint(self, option, index)
        if self.parent().count() < 10:
            hint.setWidth(pix(tUI.dimensions['ttf_window_without_tag']))
        else:
            hint.setWidth(pix(tUI.dimensions['ttf_window_without_tag']-5))
        
        hint.setHeight(self.getCurrentRowHeight())
        return hint

class TTFListWidget(qt.QListWidget):
    transition = qt.Signal(int)
    optionBoxClicked = qt.Signal(int)
    rightClicked = qt.Signal(int)
    rowClicked = qt.Signal(int)
    favClicked = qt.Signal()

    def __init__(self, window, parent=None):
        qt.QListWidget.__init__(self, parent)
        delegate = TTFListDelegate(window, self)
        self.setItemDelegate(delegate)
        self.setMouseTracking(True)

        self.setSelectionMode(qt.QAbstractItemView.SingleSelection)
        self.setFocusPolicy(qt.Qt.NoFocus)
        self.setFixedHeight(pix(0))
        self.setSpacing(pix(0))
        self.setContentsMargins(pix(0),pix(0),pix(0),pix(0))
        self._rowUnderMouse = -1

    def mouseMoveEvent(self, e):
        qt.QListWidget.mouseMoveEvent(self, e)
        self._rowUnderMouse  = -1

        if dm().getContext() == 'select': return

        pos = e.pos()
        index = self.indexAt(e.pos())

        if not index.isValid(): return

        self._rowUnderMouse  = index.row()
        item = self.item(index.row())

        iconWidth = TTFListDelegate.ACTION_ICON_WIDTH
        offsetRight = iconWidth*3 if item.hasOptionBox else iconWidth*3
        offsetRight += TTFListDelegate.ACTION_ICON_MARGIN

    def mousePressEvent(self, e):
        qt.QListWidget.mousePressEvent(self, e)
        pass

    def mouseReleaseEvent(self,e):
        qt.QListWidget.mouseReleaseEvent(self, e)
        if e.button() == qt.Qt.RightButton:
            pos = e.pos()
            index = self.indexAt(e.pos())
            if index.isValid():
                row = index.row()
                self.rightClicked.emit(row)
        elif e.button() == qt.Qt.LeftButton:
            pos = e.pos()
            index = self.indexAt(e.pos())

            if not index.isValid(): return

            item = self.item(index.row())

            iconWidth = TTFListDelegate.ACTION_ICON_WIDTH
            infoPos   = iconWidth*1 + TTFListDelegate.ACTION_ICON_MARGIN
            favePos   = iconWidth*2 + TTFListDelegate.ACTION_ICON_MARGIN
            optPos    = iconWidth*3 + TTFListDelegate.ACTION_ICON_MARGIN

            if e.pos().x()>self.rect().width()-pix(infoPos):
                row = index.row()
                self.transition.emit(row)
            elif e.pos().x()>self.rect().width()-pix(favePos):
                self.favClicked.emit()
                self.update()
            elif item.hasOptionBox and e.pos().x()>self.rect().width()-pix(optPos):
                row = index.row()
                self.optionBoxClicked.emit(row)
            else:
                row = index.row()
                self.rowClicked.emit(row)

    def rowUnderMouse(self):
        return self._rowUnderMouse if self._rowUnderMouse < self.count() else -1


class TTFCompleterDelegate(qt.QItemDelegate):
    def __init__(self, parent=None):
        qt.QItemDelegate.__init__(self, parent)
        self.setClipping(False)

    def _drawBackground(self, index, color):
        self._painter.fillRect(self._rect, color)

    def _drawIcon(self, offset, icon, highlighted, size):
        newRect = deepcopy(self._rect)
        newRect.setLeft(self._rect.left() + offset)
        newRect.setTop(self._rect.top() + pix(1))
        newRect.setWidth(size)
        newRect.setHeight(size)
        if highlighted: icon = fx.highlightPixmap(icon)
        self._painter.drawPixmap(newRect, icon)

    def _drawText(self, offset, text, color):
        newRect = deepcopy(self._rect)
        oldPen = self._painter.pen()
        newRect.setLeft(self._rect.left() + offset)
        self._painter.setPen(color)
        self._painter.drawText(newRect, qt.Qt.AlignVCenter | qt.Qt.AlignLeft | qt.Qt.TextSingleLine, text)

        self._painter.setPen(oldPen)

    def paint(self, painter, option, index):
        """ Main entry point of drawing the cell """
        if not index.isValid(): 
            return
        #item = self.parent().itemFromIndex(index)
        text = index.data(qt.Qt.DisplayRole)
        self._rect = option.rect
        self._painter = painter

        selected = option.state & qt.QStyle.State_Selected
        bgcolor = None
        if selected:
            bgcolor = qt.QColor(51,115,153,204)
            self._drawBackground(index.row(), bgcolor)        

        tag = text[1:]
        color = dm().getColorForTag(tag)

        self._drawIcon(pix(1), maya.app.TTF.ui.getColoredCircle(color), False, pix(15))

        metrics = self._painter.fontMetrics()
        text = metrics.elidedText(text, qt.Qt.ElideRight, self._rect.width()-pix(22))
        self._drawText(pix(15), text, self.parent().palette().text().color())

        self._rect = None
        self._painter = None

    def sizeHint(self, option, index):
        hint = qt.QItemDelegate.sizeHint(self, option, index)
        hint.setHeight(pix(15))
        return hint

def createCompleter(model):
    completer = qt.QCompleter(model)
    completer.popup().setFocusPolicy(qt.Qt.NoFocus)
    completer.popup().setWindowFlags(qt.Qt.Popup|qt.Qt.FramelessWindowHint|qt.Qt.NoDropShadowWindowHint)
    completer.popup().setStyleSheet('''
        QWidget{background-color: rgba(109,109,109,204); border: none; margin:0; padding:0;}
        QListView {
outline: 0;
}
        QScrollBar {
            border: none;
            margin: 0;
            width: %dpx;
            background:transparent;
        }
        QScrollBar::handle {
            border:none;
            background: rgba(68,68,68,191);
        }
        QScrollBar::add-page, QScrollBar::sub-page {
            border:none;
            background: rgb(109,109,109,0);
        }
        QScrollBar::add-line {
            width: 0;
            height: 0;
            border: none;
            background: none;
        }

        QScrollBar::sub-line {
            width: 0;
            height: 0;
            border: none;
            background: none;
        }
    ''' % pix(5) )
    completer.setCaseSensitivity(qt.Qt.CaseInsensitive)

    delegate = TTFCompleterDelegate(completer.popup())
    completer.popup().setItemDelegate(delegate)
    return completer

class TTFField(qt.QLineEdit):
    openPreferences = qt.Signal()
    def __init__(self, model):
        qt.QLineEdit.__init__(self)

        self.setPlaceholderText(tUI.PLACEHOLDERS[0])
        self.setStyleSheet("QLineEdit{border: none }")
        self.shortcut = dm().getHotkeyForCommand("SearchEngine")
        palette = self.palette()
        palette.setColor(qt.QPalette.Base, qt.Qt.transparent)
        self.setPalette(palette)

        self._completer = createCompleter(model)
        self._completer.setWidget(self)
        self._completer.activated.connect(self._insertCompletion)

        self.installEventFilter(self)

    def _insertCompletion(self, completion):
        alreadyTyped = len(self._completer.completionPrefix())
        text = self.text()[:-alreadyTyped]

        self.setText(text + completion + ' ')

    def keyPressEvent(self, event):
        if self._completer.popup().isVisible():
            if event.key()==qt.Qt.Key_Space:
                index = self._completer.popup().currentIndex()
                model = self._completer.popup().model()
                text = model.itemData(index)[0]
                self._insertCompletion(text)
                self._completer.popup().hide()
                return

        qt.QLineEdit.keyPressEvent(self, event)

        completionPrefix = self.text()[self.text().rfind(':'):]

        if completionPrefix != self._completer.completionPrefix():
            self._updateCompleterPopupItems(completionPrefix)

        if len(event.text()) > 0 and len(completionPrefix) > 0:
            self._completer.complete()

        if len(completionPrefix) == 0:
            self._completer.popup().hide()

    def _updateCompleterPopupItems(self, completionPrefix):
        self._completer.setCompletionPrefix(completionPrefix)
        self._completer.popup().setCurrentIndex(
                self._completer.completionModel().index(0,0))

    def contextMenuEvent(self, event):
        import maya.app.TTF.debug as tDebug
        import maya.app.TTF.exporterWindow as exporterWindow
        menu = self.createStandardContextMenu()

        menu.setFocusPolicy(qt.Qt.NoFocus)
        menu.addAction(fx.getIconFromName('out_MASH_Options'), fx.res('kSearchPreferences'), self.openSearchPrefs)
        menu.addAction(fx.getIconFromName('out_MASH_Options'), fx.res('kManageFilterTags'), self.openPrefs)
        # Extract window(a hidden option) should be shown only if Ctrl was pressed.(MAYA-110087) 
        if  qt.QGuiApplication.keyboardModifiers() & qt.Qt.ControlModifier:
            menu.addAction(fx.getIconFromName('out_MASH_Options'), fx.res('kOpenExtractWindow'), exporterWindow.openLauncher)

        menu.exec_(event.globalPos())
        del menu

        #fixes bug with the viewport getting the focus if the 
        #user clicks outside the field
        self.clearFocus()
        self.setFocus()

    # Open the main pref window with search panel selected.
    def openSearchPrefs(self):
        mel.eval('preferencesWnd search')

    def openPrefs(self):
        self.openPreferences.emit()

    def paintEvent(self,e):
        qt.QLineEdit.paintEvent(self, e)
        
        # We need to print hotkey for TTF(SearchEngine) command on the right side of the TTFField.
        # We do this by drawing text on right after paint event is called. (MAYA-110080)
        if not self.text():
            painter = qt.QPainter(self)
            pal = self.palette()
            oldPen = painter.pen()
            painter.setPen(pal.placeholderText().color())
            rect = self.rect()
            # Design requires padding of 6px on right. TTField has 2px already so we
            # need to add 4px more.
            rect.setRight(rect.right() - pix(4))
            painter.drawText(rect, qt.Qt.AlignRight|qt.Qt.AlignVCenter, self.shortcut)
            painter.setPen(oldPen)


class TTFTag(qt.QWidget):
    clicked = qt.Signal(str)
    def __init__(self, text=None, parent=None, color=[75,153,165]):
        qt.QWidget.__init__(self, parent)

        self.setStyleSheet('QLabel{font-size:%dpx}' % pix(10))
        fx.setHLayout(self, pix(0),pix(1),pix(0),pix(3),pix(0))
        self.setMaximumHeight(pix(14))
        
        self.circle = maya.app.TTF.ui.getColoredCircle(color)
        self.xshape = maya.app.TTF.ui.getColoredXshape(color)
        self.deletable = True

        self.dot = qt.QLabel('')
        self.dot.setFixedWidth(pix(14))
        self.dot.setFixedHeight(pix(14))
        self.dot.setPixmap(self.circle)
        self.layout().addWidget(self.dot)

        self.label = qt.QLabel(text)
        self.layout().addWidget(self.label)

        self.installEventFilter(self)

    def eventFilter(self, widget, event):
        if self.deletable:
            if event.type() == qt.QEvent.Type.Enter:
                self.dot.setPixmap(self.xshape)
                self.update()
                return True

            elif event.type() == qt.QEvent.Type.Leave:
                self.dot.setPixmap(self.circle)
                self.update()
                return True

            elif event.type() == qt.QEvent.Type.MouseButtonRelease:
                self.clicked.emit(self.label.text())
                return True

        return False

    def paintEvent(self,e):
        qt.QWidget.paintEvent(self, e)

        p = qt.QPainter(self)
        p.setRenderHint(qt.QPainter.Antialiasing)
        p.setPen(qt.Qt.transparent)
        p.setBrush(qt.QColor(93,93,93))
        p.drawRoundedRect(e.rect(), pix(2), pix(2))
        p.end()

# Buttons in the drop down dialog.
class DropDownImageButton(qt.QWidget):
    clicked = qt.Signal()
    rightClicked = qt.Signal()

    def __init__(self, imageName, text='', hover=False, parent=None):
        qt.QWidget.__init__(self,parent)

        self.setFocusPolicy(qt.Qt.NoFocus)

        self.hover = hover
        
        #Create icon
        self.buttonPixmap = fx.getPixmap(imageName)
        self.hoverPixmap = fx.highlightPixmap(self.buttonPixmap)
        self.button = qt.QLabel()
        self.button.setAlignment(qt.Qt.AlignCenter)
        self.button.setSizePolicy(qt.QSizePolicy.Preferred, qt.QSizePolicy.Minimum)
        self.button.setPixmap(self.buttonPixmap)
        self.button.setFixedWidth(pix(tUI.dimensions['ttf_window_height']))
        self.button.setStyleSheet('background-color : rgb(64,64,64);')

        #Create text
        self.label = qt.QLabel(text)
        self.label.setAlignment(qt.Qt.AlignLeft | qt.Qt.AlignVCenter)
        self.label.setWordWrap(True)
        self.label.setStyleSheet('''color: rgb(238, 238, 238); 
                background-color: rgb(82, 82, 82);
                padding: %d;''' % pix(4))

        self.setLayout(qt.QHBoxLayout())
        self.layout().setContentsMargins(0,0,0,0)
        self.layout().setSpacing(0)
        self.layout().addWidget(self.button, 0)
        self.layout().addWidget(self.label, 0)

        self.highLight(self.hover)
        self.label.setVisible(len(text) > 0)

    def highLight(self, highlight):
        if highlight:
            self.button.setPixmap(self.hoverPixmap)
            self.label.setStyleSheet('''color: rgb(238, 238, 238); 
                background-color: rgb(82,133,166);
                padding: %d;''' % pix(3))
        else:
            self.button.setPixmap(self.buttonPixmap)
            self.label.setStyleSheet('''color: rgb(238, 238, 238); 
                background-color: rgb(82, 82, 82);
                padding: %d;''' % pix(3))

    def getLabel(self):
        return self.label.text()

    #########
    # Events
    #########

    def enterEvent(self, e):
        if self.isEnabled():
            self.hover = True
            self.highLight(self.hover)
        return qt.QWidget.enterEvent(self,e)

    def leaveEvent(self, e):
        if self.hover:
            self.hover = False
            self.highLight(self.hover)
        return qt.QWidget.leaveEvent(self,e)

    def mouseReleaseEvent(self, e):
        qt.QWidget.mouseReleaseEvent(self,e)
        if e.button() == qt.Qt.LeftButton:
            self.clicked.emit()# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
