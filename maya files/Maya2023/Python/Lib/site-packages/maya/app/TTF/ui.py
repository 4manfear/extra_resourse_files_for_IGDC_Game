from __future__ import division
from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix, qt_dpi
from maya.app.flux.core import dpi

colors = {
    'dark': [43,43,43],
    'gray': [55,55,55],
    'blue': [82,133,166]
}

dimensions = {
    'ttf_window_height': 22,
    'ttf_window_total_width':  362,
    'ttf_window_without_tag' : 340,
    'ttf_search_mode_width': 30,
    'ttf_dropDown_width': 148
}

PLACEHOLDERS = [fx.res('kSearchModeHint'),
                fx.res('kSelectModeHint'),
                fx.res('kMELModeHint'),
                fx.res('kPythonModeHint')]

MODES = [fx.res('kSearchMode'), fx.res('kSelectMode'), 'MEL', 'Python']

def fixTTFIconScaling(pixmap):
    if pixmap.height() / fx.dpi() > 20:
        newsize = (pixmap.height() / fx.dpi()) / 2
        pixmap = fx.scalePixmap(pixmap, newsize, newsize)
    return pixmap

def getColoredXshape(color):
    pixmap = fx.getPixmap('TTF_DeleteTag')
    painter = qt.QPainter(pixmap)
    painter.setRenderHint(qt.QPainter.Antialiasing)
    painter.setCompositionMode(qt.QPainter.CompositionMode_SourceIn)
    painter.fillRect(pixmap.rect(), qt.QColor(color))
    painter.end()

    pixmap2 = qt.QPixmap(dpi(pix(14)),dpi(pix(14)))
    pixmap2.fill(qt.QColor(0,0,0,0))
    painter = qt.QPainter(pixmap2)
    painter.setRenderHint(qt.QPainter.Antialiasing)
    painter.drawPixmap(qt.QRectF(dpi(pix(4)),dpi(pix(4)),dpi(pix(6)),dpi(pix(6))), pixmap, pixmap.rect())
    painter.end()

    pixmap2.setDevicePixelRatio(fx.dpi())
    return pixmap2

def getColoredCircle(color, width=14, height=14):
    pixmap = qt.QPixmap (pix(100),pix(100))
    pixmap.fill(qt.QColor(0,0,0,0))
    painter = qt.QPainter()
    painter.begin(pixmap)
    painter.setRenderHint(qt.QPainter.Antialiasing)
    painter.setPen(qt.QColor(0,0,0,0))
    painter.setBrush(qt.QColor(color))
    painter.drawEllipse(qt.QPointF(pix(50),pix(50)),pix(25),pix(25))
    painter.end()
    p = qt.QPixmap(pixmap)
    del pixmap
    return qt.QIcon(p).pixmap(pix(width),pix(height))

def getDropDownIcon(selectedPixMap = 'TTF_Search', caretUp = False):
    # Create a pixelMap big enough to hold two pixMaps

    # on mac and on mac only we need to set the device pixel ratio
    # to 2x and create a pixmap twice the size. pix(1.0) is 1.0 on mac
    pmPixelRatio = 1.0
    if cmds.about(mac=True):
        pmPixelRatio = fx.dpi()
    
    dropDownButtonPM = qt.QPixmap(pix(dimensions['ttf_search_mode_width'])*pmPixelRatio, pix(dimensions['ttf_window_height'])*pmPixelRatio)
    dropDownButtonPM.setDevicePixelRatio(pmPixelRatio)
    dropDownButtonPM.fill(qt.QColor(0,0,0,0))

    searchPixMap = fx.getPixmap(selectedPixMap)
    caretPixMap = getDropDownCaret(caretUp)

    painter = qt.QPainter(dropDownButtonPM)
    painter.setRenderHint(qt.QPainter.Antialiasing)

    searchAnchor = qt.QPoint(pix(1), pix(1))
    caretXPos = searchAnchor.x() + searchPixMap.width() / pmPixelRatio # back in logical coordinates
    caretAnchor =  qt.QPoint(caretXPos, pix(dimensions['ttf_window_height']/2 - 2))

    painter.drawPixmap( searchAnchor,  searchPixMap)
    painter.drawPixmap( caretAnchor,  caretPixMap)
    painter.end()

    return dropDownButtonPM


def getDropDownCaret(caretUp):
    path = qt.QPainterPath()

    pmPixelRatio = 1.0
    if cmds.about(mac=True):
        pmPixelRatio = fx.dpi()

    # Set the stroke path
    if (not caretUp):
        path.moveTo(pix(0),pix(0))
        path.lineTo(pix(6),pix(0))
        path.lineTo(pix(3),pix(4))
        path.lineTo(pix(0),pix(0))
    else:
        path.moveTo(pix(3),pix(0))
        path.lineTo(pix(6),pix(4))
        path.lineTo(pix(0),pix(4))
        path.lineTo(pix(3),pix(0))


    # Create pixMap to draw in and paint
    pixmap = qt.QPixmap(pix(6)*pmPixelRatio,pix(4)*pmPixelRatio)
    pixmap.fill(qt.QColor(0,0,0,0))
    painter = qt.QPainter()
    painter.begin(pixmap)
    painter.scale(pmPixelRatio, pmPixelRatio)
    painter.setRenderHint(qt.QPainter.Antialiasing)
    painter.setPen(qt.Qt.NoPen)
    brushColor = qt.QColor(189,189,189)
    brush = qt.QBrush(brushColor)
    painter.fillPath(path, brush)
    painter.end()

    pixmap.setDevicePixelRatio(pmPixelRatio)
    return pixmap

    
def adjustPosition(window):
    pos = qt.QCursor.pos()
    screen = qt.qApp.desktop().screenGeometry(pos).size()
    topLeft = qt.qApp.desktop().screenGeometry(pos).topLeft()
    pos = pos - topLeft

    x = pos.x() - pix(65)
    y = pos.y() - pix(11)

    if x + window.width() > screen.width() - pix(130):
        x = screen.width() - window.width() - pix(130)

    if y + window.height() > screen.height() - pix(320):
        y = screen.height() - window.height() - pix(320)

    if x < 0:
        x = 0
    if y < 0:
        y = 0

    pt = qt.QPoint(x, y) + topLeft

    window.move(pt)

def showNextToSearchIcon(window):    
    pt = qt.QPoint(0,0)
    pt = window.mayaToolBoxSearchIcon.mapToGlobal(pt)
    # When Search window is activated from toolbar we show it on the right
    # of the icon.
    xOffset = window.mayaToolBoxSearchIcon.width() + pix(4) #Space of 4 pix between icon and window
    yOffset = (window.mayaToolBoxSearchIcon.height() - dimensions['ttf_window_height'])/2 #Vertically centered
    pt.setX(pt.x() + xOffset)
    pt.setY(pt.y() + yOffset)
    window.move(pt)

def windowStyleSheet():
    styleSheet = ('''
            QDialog{
                border:none;
            }
            QScrollBar {
                border: none;
                margin: 0;
                width: %dpx;
                background: rgba(55,55,55,217);
                padding-left: %dpx;
                padding-right: %dpx;
                margin-bottom:%dpx;
            }
            QScrollBar::handle {
                background: rgba(255, 255, 255, 0.2);
                border-radius: %dpx;
            }
            QScrollBar::handle:hover {
                background: rgba(255, 255, 255, 0.5);
            }
            QScrollBar::add-page, QScrollBar::sub-page {
                border:none;
                background: rgba(0,0,0,0);;
            }
            QScrollBar::add-line {
                width: 0;
                height: 0;
                border: none;
                background: none;
            }

            QScrollBar::sub-line {
                width: 0;
                height: 0;
                border: none;
                background: none;
            }
        ''' % (pix(14), pix(4), pix(4), pix(1), pix(3)))
    return styleSheet

def lineEditStyleSheet():
    return 'QLineEdit{background-color: rgba(0,0,0,0); border: none; font-size: %dpx;}' % pix(12)

def resultsListStyleSheet():
    return 'QListWidget{background-color: rgba(56,56,56,0); border: none; margin:0; padding:0;}'# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
