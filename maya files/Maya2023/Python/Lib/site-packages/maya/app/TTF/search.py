from builtins import object
from builtins import range
import re
import maya.cmds as cmds

class ClosestMatchNode(object):
    def __init__(self):
        self.text = None
        self.subnodes = {}

    def add(self, text):
        node = self
        for x in text:
            if x not in node.subnodes: 
                node.subnodes[x] = ClosestMatchNode()

            node = node.subnodes[x]

        node.text = text

class ClosestMatch(object):
    def __init__(self, values, maxErr=2):
        self.maxErr = maxErr
        self.root = ClosestMatchNode()

        for v in values:
            self.root.add(v)

    def search(self, text):
        self.results = []
        self.searchStr = text
        errors = list(range(len(self.searchStr) + 1))
        self.searchChildren(self.root, errors)

        for i in range(self.maxErr + 1):
            results = [x[0] for x in self.results if x[1] == i]
            if results:
                return results
        return []

    def searchRecursive(self, node, x, prevErrors):
        errors = [prevErrors[0] + 1]

        for i in range(1, len(self.searchStr) + 1):
            insertErr = errors[i - 1] + 1
            deleteErr = prevErrors[i] + 1
            replaceErr = prevErrors[i - 1]

            if self.searchStr[i - 1] != x:
                replaceErr += 1

            errors.append(min(insertErr, deleteErr, replaceErr))

        if errors[-1] <= self.maxErr and node.text:
            self.results.append((node.text, errors[-1]))

        if min(errors) <= self.maxErr:
            self.searchChildren(node, errors)

    def searchChildren(self, node, errors):
        for x, subnode in list(node.subnodes.items()):
            self.searchRecursive(subnode, x, errors)

class TTFSearch(object):
    def __init__(self):
        self.wordSplitter = re.compile(r'\w+', re.U)

        # Items have four main criteras on which they can be grouped i.e. item label,
        # keywords associated with the item(refer to defaultRunTimeCommands.mel), 
        # item description, and command associated with the item. We keep track of
        # the command for these categories separately.
        self.labelLookupTable = {}
        self.labelRankingTable = {}
        self.labelClosestTable = ClosestMatch([])

        self.descriptionLookupTable = {}
        self.descriptionRankingTable = {}
        self.descriptionClosestTable = ClosestMatch([])

        self.keywordLookupTable = {}
        self.keywordRankingTable = {}
        self.keywordClosestTable = ClosestMatch([])

        self.commandLookupTable = {}
        self.commandRankingTable = {}
        self.commandClosestMatch = ClosestMatch([])

        # Keep track of last search result. Search is called multiple times for the same
        # query. We save some time with this optimization.
        self.lastSearchStringWords = []
        self.lastSearchResults = []

    def addItem(self, item):
        #Add the ranking of this item to the respective four categories
        labelItemRanking = {}
        if item.command not in self.labelRankingTable:
            self.labelRankingTable[item.command] = labelItemRanking
        else:
            labelItemRanking = self.labelRankingTable[item.command]

        descriptionItemRanking = {}
        if item.command not in self.descriptionRankingTable:
            self.descriptionRankingTable[item.command] = descriptionItemRanking
        else:
            descriptionItemRanking = self.descriptionRankingTable[item.command]

        keywordItemRanking = {}
        if item.command not in self.keywordRankingTable:
            self.keywordRankingTable[item.command] = keywordItemRanking
        else:
            keywordItemRanking = self.keywordRankingTable[item.command]

        commandItemRanking = {}
        if item.command not in self.commandRankingTable:
            self.commandRankingTable[item.command] = commandItemRanking
        else:
            commandItemRanking = self.commandRankingTable[item.command]

        
        # Get the command keys and update the ranking and lookup table.
        commandKeys = item.getCmdNameAsKeys(self.wordSplitter)
        for key in commandKeys:
            self.addKeyToLookupTable(key, item, self.commandLookupTable)
            commandItemRanking[key] = 1
            self.commandClosestMatch.root.add(key)

        labelKeys = item.getLabelAsKeys(self.wordSplitter)
        for key in labelKeys:
            self.addKeyToLookupTable(key, item, self.labelLookupTable)
            labelItemRanking[key] = 1
            self.labelClosestTable.root.add(key)

        keywordKeys = item.getKeywordAsKeys(self.wordSplitter)
        for key in keywordKeys:
            self.addKeyToLookupTable(key, item, self.keywordLookupTable)
            keywordItemRanking[key] = 1
            self.keywordClosestTable.root.add(key)
        
        descriptionKeys = item.getDescriptionAsKeys(self.wordSplitter)
        for key in descriptionKeys:
            self.addKeyToLookupTable(key, item, self.descriptionLookupTable)
            if key not in descriptionItemRanking:
                descriptionItemRanking[key] = 0
            else:
                if isinstance(key, str) or key < 0:
                    descriptionItemRanking[key] = 0
            self.descriptionClosestTable.root.add(key)

    # Add keys and asscoated item to a lookup table
    def addKeyToLookupTable(self, key, item, lookupTable):
        if key not in lookupTable:
            lookupTable[key] = []
        lookupTable[key].append(item.command)

    def find(self, searchString):
        words = re.findall(r'\w+', searchString.lower(), re.U)

        # Check the words against last searched words ignoring whitespace.
        # If last word consists of single letter and rest of the query is same as before no results are updated.
        if (self.lastSearchStringWords == words or 
                    (len(words[-1]) == 1 and self.lastSearchStringWords == words[:-1])):
            return self.lastSearchResults

        self.lastSearchStringWords = words
        # List to aggregate all the results.
        aggregatedResults = []
        # Temporary list to hold the results for each type of keyword.
        results = []
        
        # Search for the commands and include them in results if option is set 
        if cmds.optionVar( q='includeCommandsInSearch' ):
            self._getResults(results, words, self.commandLookupTable, 
                    self.commandRankingTable, self.commandClosestMatch)
            aggregatedResults.extend(results)
            results[:] = []

        # Search for the keywords and include them in results if option is set
        if cmds.optionVar( q='includeKeywordsInResult' ):
            self._getResults(results, words, self.keywordLookupTable, 
                    self.keywordRankingTable, self.keywordClosestTable)
            aggregatedResults.extend(results)
            results[:] = []
        # Search for matching command labels
        self._getResults(results, words, self.labelLookupTable, 
                    self.labelRankingTable, self.labelClosestTable)
        aggregatedResults.extend(results)
        results[:] = []
        # Search for matching command descriptions
        self._getResults(results, words, self.descriptionLookupTable, 
                    self.descriptionRankingTable, self.descriptionClosestTable)
        aggregatedResults.extend(results)
        results[:] = []

        mergedResults = {}
        for r in aggregatedResults:
            for cmd in r:
                if cmd not in mergedResults:
                    mergedResults[cmd] = 0
                mergedResults[cmd] += r[cmd]
        self.lastSearchResults = list(mergedResults.items())
        return self.lastSearchResults

    # Given the lookup and ranking table get the commands that match the words in ranked order.
    def _getResults(self, results, words, lookupTable, rankingTable, closestMatch, depth=0):
        dictionary = lookupTable.keys()

        # If we have iterated over all searchable words or we have no results for the first word; return.
        if (len(words) == depth or (len(results) == 0 and depth > 0)):
            return

        # Skip if we encounter a reapeating word, or if words has less than 2 characters.
        if words[depth] in words[:depth] or len(words[depth]) < 2:
            self._getResults(results, words, lookupTable, rankingTable, closestMatch, depth+1)
            return

        # For the first word depth is 0.
        if depth == 0:
            x = words[depth]
            # Get the keys from the lookup table that match the word entered
            keys = set([y for y in dictionary if re.match(u'%s.*' % x, y, re.I | re.U)])
            # Iff there are no keys in the lookup table, we try to find a closest match. This should not be
            # a common case if user knows what they are looking for.
            if len(keys) == 0:
                keys = set(closestMatch.search(x))

            # Iterate over all the keys, and get the commands associated with it from lookuptable. Check ranking table for that particular
            # commnad and key and append them to the results.
            for key in keys:
                rankedResults = {}
                for cmd in set(lookupTable[key]):
                    rankedResults[cmd] = rankingTable[cmd][key]
                results.append(rankedResults)
        else:
            # Current word is not the first word and we should already have some results. We copy the old results and use them to
            # rank the results of the current word.
            oldResults = results[:]
            # Clear the results list, so it can be used for the new results.
            results[:] = []

            x = words[depth]
            keys = set([y for y in dictionary if re.match(u'%s.*' % x, y, re.I | re.U)])
            if len(keys) == 0:
                keys = set(closestMatch.search(x))

            # Iterate over all the keys, and get the commands associated with it from lookuptable. For the commands that are already
            # in the old results, we increase the rank accorrding to the ranking table and add it to the results.
            # NOTE: Following algorithm ensures that the subset of the old results appear in the final result based on rank.
            for key in keys:
                rankedResults = {}
                for cmd in set(lookupTable[key]):
                    for r in oldResults:
                        if cmd in r:
                            rankedResults[cmd] = rankingTable[cmd][key] + r[cmd]
                if rankedResults:
                    results.append(rankedResults)
            
            # If no new results were found, we use the old results.
            if not results:
                results[:] = oldResults[:]
        
        self._getResults(results, words, lookupTable, rankingTable, closestMatch, depth+1)# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
