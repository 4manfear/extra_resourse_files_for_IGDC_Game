import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Module containing helper class for managing scriptJobs that are dependent on the plug-in load state.
'''
import maya.cmds as cmds
from maya.common.ui import callback_tool
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager, CACHE_PLUGIN_NAME
from maya.plugin.evaluator.cache_debugging import CP_DBG
from maya.common.utils import Singleton
from future.utils import with_metaclass

__all__ = [ r'CacheScriptJobHelper'
          , r'EVENT_SAFE_MODE'
          , r'EVENT_LIMIT_CHANGE'
          , r'EVENT_EM_DISABLED'
          , r'EVENT_CACHE_DESTROYED'
          ]

# IDs for scriptJob events
EVENT_SAFE_MODE        = r'cachingSafeModeChanged'
EVENT_LIMIT_CHANGE     = r'resourceLimitStateChange'
EVENT_EM_DISABLED      = r'cachingEvaluationModeChanged'
EVENT_CACHE_DESTROYED  = r'cacheDestroyed'

#======================================================================
class CacheScriptJobHelper(with_metaclass(Singleton, object)):
    '''Class to manage the lifespan of scriptJobs so that they come and go when the plug-in is unloaded and loaded'''

    def __init__(self):
        '''Start monitoring the plug-in so that the state information is known'''
        super(CacheScriptJobHelper,self).__init__()
        self.clients = []
        self.monitoring = False

        # Monitor both loads and unloads. Only one at a time will be of interest
        # but doing both simplifies the code.
        cmds.loadPlugin( addCallback=self.callback_plugin_loaded )
        cmds.unloadPlugin( addCallback=self.callback_plugin_unloaded )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_plugin_loaded(plugin_name):
        '''
        Callback invoked whenever a plug-in is loaded.
        :param plugin_name: Name of the plug-in that was loaded. Only 'cache' is of interest.
        '''
        if plugin_name == CACHE_PLUGIN_NAME:
            helper = CacheScriptJobHelper()
            script_job_events = cmds.scriptJob( listEvents=True ) or []
            
            for index, [event_name, client, callback_function, _] in enumerate(helper.clients):
                if event_name in script_job_events:
                    
                    helper.clients[index][-1] = cmds.scriptJob( event=(event_name, callback_tool(client, callback_function)) )
                    # Run the callback to match the state since it will have missed this one
                    callback_function( tool=client )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_plugin_unloaded(plugin_name):
        '''
        Callback invoked whenever a plug-in is unloaded.
        :param plugin_name: Name of the plug-in that was unloaded. Only 'cache' is of interest.
        '''
        if plugin_name == CACHE_PLUGIN_NAME:
            helper = CacheScriptJobHelper()
            
            for index, [event_name, client, callback_function, script_job_id] in enumerate(helper.clients):
                if script_job_id is not None:
                    
                    cmds.scriptJob( kill=script_job_id )
                    helper.clients[index][-1] = None

    #----------------------------------------------------------------------
    def add_client(self, client, event_name, callback_function):
        '''
        Add a new scriptJob client function to an event relying on the cacheEvaluator plug-in being loaded.
        :param client: The "self" pointer of the class calling this
        :param event_name: Name of the scriptJob event to monitor
        :param callback_function: Function to call when the event fires
        '''
        
        self.clients.append( [event_name, client, callback_function, None] )
        if CacheEvaluatorManager().plugin_loaded:
            script_job_events = cmds.scriptJob( listEvents=True ) or []
            if event_name in script_job_events:
                self.clients[-1][-1] = cmds.scriptJob( event=(event_name, callback_tool(client, callback_function)) )
                # Do an initial callback to match the current plug-in state
                callback_function( tool=client )
            elif not cmds.about( batch=True ): # No scriptJobs exist in batch mode so not finding the events is not an error
                cmds.warning( maya.stringTable['y_maya_plugin_evaluator_CacheScriptJobHelper.kNoEvent' ].format(event_name) )
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
