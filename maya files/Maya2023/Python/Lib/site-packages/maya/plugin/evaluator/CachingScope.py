'''
Classes that manage caching states by a "with" scope object
'''
from builtins import object
from builtins import zip
import re
import maya.cmds as cmds
from maya.debug.emModeManager import emModeManager
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager, CACHE_STANDARD_MODE_EVAL

__all__ = [ 'CachingScope'
          , 'NonCachingScope'
          ]

# ======================================================================

class NonCachingScope(object):
    '''
    Scope object responsible for setting up non cached mode and restoring default settings after
    '''
    def __enter__(self):
        '''Enter the scope, setting up the evaluator managers and initial states'''
        self.em_mgr = emModeManager()
        self.em_mgr.setMode('emp')
        self.em_mgr.setMode('-cache')

        return self

    def __init__(self):
        '''Initialize everything to be empty - only use the "with" syntax with this object'''
        self.em_mgr = None

    def __exit__(self,exit_type,value,traceback):
        '''Exit the scope, restoring all of the state information'''
        if self.em_mgr:
            self.em_mgr.restore_state()
            self.em_mgr = None

    @staticmethod
    def verify_scope_setup(unit_test):
        '''
        Meta-test to check that the scope was defined correctly
        :param unit_test: The test object from which this method was called
        '''
        unit_test.assertTrue( cmds.evaluationManager( mode=True, query=True )[0] == 'parallel' )
        if cmds.pluginInfo('cacheEvaluator', loaded=True, query=True):
            unit_test.assertFalse( cmds.evaluator( query=True, en=True, name='cache' ) )

    @staticmethod
    def is_caching_scope():
        '''
        Method to determine whether caching is on or off in this object's scope
        :return: False, since this is the non-caching scope
        '''
        return False

# ======================================================================

class CachingScope(object):
    '''
    Scope object responsible for setting up caching and restoring original setup after
    '''
    def __enter__(self):
        '''Enter the scope, setting up the evaluator managers and initial states'''
        self.em_mgr = emModeManager()
        self.em_mgr.setMode('emp')
        self.em_mgr.setMode('+cache')
        # Enable idle build to make sure we can rebuild the graph when waiting.
        self.em_mgr.idle_action = emModeManager.idle_action_build

        # Setup caching options
        self.cache_mgr = CacheEvaluatorManager()
        self.cache_mgr.save_state()
        self.cache_mgr.plugin_loaded = True
        self.cache_mgr.enabled = True
        self.cache_mgr.cache_mode = CACHE_STANDARD_MODE_EVAL
        self.cache_mgr.resource_guard = False
        self.cache_mgr.fill_mode = 'syncAsync'

        # Setup autokey options
        self.auto_key_state = cmds.autoKeyframe(q=True, state=True)
        self.auto_key_chars = cmds.autoKeyframe(q=True, characterOption=True)
        cmds.autoKeyframe(e=True, state=False)

        return self

    def __init__(self):
        '''Initialize everything to be empty - only use the "with" syntax with this object'''
        self.em_mgr = None
        self.cache_mgr = None
        self.auto_key_state = None
        self.auto_key_chars = None

    def __exit__(self,exit_type,value,traceback):
        '''Exit the scope, restoring all of the state information'''
        if self.cache_mgr:
            self.cache_mgr.restore_state()
        if self.em_mgr:
            self.em_mgr.restore_state()
        cmds.autoKeyframe(e=True, state=self.auto_key_state, characterOption=self.auto_key_chars)

    @staticmethod
    def verify_scope_setup(unit_test):
        '''
        Meta-test to check that the scope was defined correctly
        :param unit_test: The test object from which this method was called
        '''
        unit_test.assertTrue( cmds.evaluationManager( mode=True, query=True )[0] == 'parallel' )
        unit_test.assertTrue( cmds.pluginInfo('cacheEvaluator', loaded=True, query=True) )
        unit_test.assertTrue( cmds.evaluator( query=True, en=True, name='cache' ) )

    def check_valid_frames(self, unit_test, expected_valid_frames, layers_mask = 0b01):
        '''
        :param unit_test: The test object from which this method was called
        :param expected_valid_frames: The list of frames the text expected to be cached
        :return: True if the cached frame list matches the expected frame list
        '''
        current_valid_frames = list(self.cache_mgr.get_valid_frames(layers_mask))
        if len(expected_valid_frames) == len(current_valid_frames):
            for current, expected in zip(current_valid_frames,expected_valid_frames):
                if current[0] != expected[0] or current[1] != expected[1]:
                    unit_test.fail( "{} != {} (current,expected)".format( current_valid_frames, expected_valid_frames) )
                    return False

            return True
        unit_test.fail( "{} != {} (current,expected)".format( current_valid_frames, expected_valid_frames) )
        return False

    @staticmethod
    def check_nodes_cached(unit_test, expected_nodes_cached):
        '''
        Verify that the list of nodes currently cached matches the expected list
        :param unit_test: The test object from which this method was called
        :param expected_nodes_cached: A dictionary of NODE_TYPE:NODE_TYPE_COUNT for all node types that should have cached
        :return: True if the cached node list matches the expected cached node list
        Note that the list of nodes cached is different from the list of nodes claimed by the cache evaluator, as
        the cache evaluator can claim invisible nodes yet never cache their values.
        '''
        re_extract_nodes = re.compile(r'([^,]+),(\d+),(\d+)')
        current_nodes_cached = {}

        # Extract the list of node types and their counts in the cache from the cache info string
        last = None
        for cache_info_line in cmds.evaluator( name='cache', q=True, info=True ).split('\n'):
            match = re_extract_nodes.match( cache_info_line )
            if match:
                current_nodes_cached[match.group(1)] = int(match.group(2))
                last = match.group(1)

        # The last line is a total and can be ignored, however the total string is localized so
        # remove it based on its position rather than trying to exactly match the string.
        if last is not None:
            del current_nodes_cached[last]

        # If the lengths do not match the dictionaries certainly do not
        failed_test = len(expected_nodes_cached) != len(current_nodes_cached)
        if not failed_test:
            for node_type, node_type_count in list(current_nodes_cached.items()):
                if node_type not in expected_nodes_cached or expected_nodes_cached[node_type] != node_type_count:
                    failed_test = True
                    break

        if failed_test:
            unit_test.fail( "{} != {} (current,expected)".format( current_nodes_cached, expected_nodes_cached) )

        return failed_test

    @staticmethod
    def wait_for_cache(unit_test, wait_time=5):
        '''
        Fill the cache in the background, waiting for a maximum time
        :param unit_test: The test object from which this method was called
        :param wait_time: Time the test is willing to wait for cache completion (in seconds)
        '''
        cmds.currentTime( cmds.currentTime(q=True) )
        cmds.currentTime( cmds.currentTime(q=True) )
        cache_is_ready = cmds.cacheEvaluator( waitForCache=wait_time )
        unit_test.assertTrue( cache_is_ready )

    @staticmethod
    def is_caching_scope():
        '''
        Method to determine whether caching is on or off in this object's scope
        :return: True, since this is the caching scope
        '''
        return True
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
