from __future__ import division
import maya
maya.utils.loadStringResourcesForModule(__name__)

'''
Implementation of the cached playback portions of the evaluation toolkit.
Manages the UI creation, destruction, and synchronization of the cached playback
preferences with the state information.

These sections are managed, appearing in different places in the toolkit:
    Cache HUD
    Cache Correctness and Cache Performance tests
    Caching playback preferences section
'''
import maya.cmds as cmds
from maya.common.ui import LayoutManager, callback_tool
from maya.debug.DeformerEvaluatorManager import DeformerEvaluatorManager
from maya.plugin.evaluator.CacheUiBase import CacheUiBase
from maya.plugin.evaluator.CacheEvaluatorManager import CacheEvaluatorManager
from maya.plugin.evaluator.CacheEvaluatorManager import CACHE_STANDARD_MODE_EVAL_SHAPES, CACHE_STANDARD_MODE_VP2_SW_NO_FALLBACK, CACHE_STANDARD_MODE_VP2_HW_NO_FALLBACK
from maya.plugin.evaluator.cache_preferences import CachePreferenceHud, CachePreferenceEnabled, CachePreferenceMode, CachePreferenceFillType, CachePreferenceDynamicsSupportEnabled, CachePreferenceDynamicsAsyncRefresh
from maya.plugin.evaluator.cache_preferences import cache_ui_enabled
from maya.plugin.evaluator.cache_ui import cache_ui_full_layout_create, cache_ui_full_layout_update
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import BUTTON_WIDTH, COLUMN_SPACING, ROW_SPACING, section_layout
from maya.app.evaluationToolkit.evaluation_toolkit_utilities import EvaluationToolkitSection

__all__ = [r'EvaluationToolkitSectionCaching']

#======================================================================
# Supported caching setups.
# Each setup in the list is a tuple with the following elements:
# - The string that should be displayed for this mode.
# - The creation parameters of the rules defining this mode
# - The description of this mode.
#
# If the description is an empty list, it means that caching is disabled.
# If the description is None, it means that caching has custom
# caching configuration, i.e. it was tweaked manually and does not match one
# of the presets.
DEBUG_CACHE_MODES = [
    (maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kApplyDebugCache' ],
     None,
     maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kApplyDebugCacheAnnotation' ]
     ),
    (maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCachePreference' ],
     [],
     maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCachePreferenceAnnotation' ]
     ),
    (maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheDBShapes' ],
     CACHE_STANDARD_MODE_EVAL_SHAPES,
     maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheDBShapesAnnotation' ]
     ),
    (maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheVP2AllNoFallback' ],
     CACHE_STANDARD_MODE_VP2_SW_NO_FALLBACK,
     maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheVP2AllNoFallbackAnnotation' ]
     ),
    (maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheVP2AllHWNoFallback' ],
     CACHE_STANDARD_MODE_VP2_HW_NO_FALLBACK,
     maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheVP2AllHWNoFallbackAnnotation' ]
     ),
    (maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheUnsupported' ],
     None,
     maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheUnsupportedAnnotation' ]
     ),
    ]

#======================================================================
def _menu(menu_grp_widget):
    '''Helper to convert a menu group widget name to its child menu name'''
    return menu_grp_widget + r'|OptionMenu'

#======================================================================
class EvaluationToolkitSectionCaching(EvaluationToolkitSection, CacheUiBase):
    '''
    Class providing support for UI and functionality of the evaluation toolkit cachign section.

    :member ui_key: Unique identifier for this UI object. Used for client notification in CachePreferences()
    :member deformer_mgr: Local DeformerEvaluatorManager for easy access to evaluator parameters
    :member cache_mgr: Local CacheEvaluatorManager for easy access to evaluator parameters

    :member layout_root: Root control for everything in this section
    :member layout_actions: Layout control for the section containing action buttons
    :member layout_memory: Layout control for the memory management section
    :member layout_safe_mode: Layout control for the safe mode section
    :member menu_debug_cache_mode_list: Menu widget for debugging cache mode list
    :member checkbox_flush_sync: Checkbox widget for whether flushing is synchronous
    :member widget_memory_usage: Text widget showing memory used
    :member widget_memory_available: Text widget showing memory available
    :member mode_change_job: scriptJob ID for the customEvaluatorChanged callback
    '''
    #----------------------------------------------------------------------
    def __init__(self, title, start_closed):
        '''
        Set up the framework for the caching tools
        :param title: Name of the main caching section
        :param start_closed: True means the section should be initially closed when the UI window is created
        '''
        EvaluationToolkitSection.__init__(self)
        CacheUiBase.__init__(self)
        

        # Unique ID used for client notifications from CachePreferences()
        self.ui_key = r'cache_section_in_toolkit'
        # Preference Item widgets
        self.widgets = {}
        # Get a few managers so that evaluator states can be easily manipulated
        self.deformer_mgr = DeformerEvaluatorManager()
        self.cache_mgr = CacheEvaluatorManager()

        self.layout_root = cmds.frameLayout( label=title, **section_layout(start_closed) )

        with LayoutManager( self.layout_root ):
            # Values driving preferences
            cache_ui_full_layout_create( r'evaluationToolkit' )

            # Custom caching modes (not supported in preferences)
            self.menu_debug_cache_mode_list = cmds.optionMenuGrp( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kCacheMode' ]
                                                                  , changeCommand=callback_tool(self, self.callback_apply_debug_cache_mode)
                                                                  )
            for i,mode in enumerate(DEBUG_CACHE_MODES):
                label = mode[0]
                if i == 0:
                    label = label.format('') # Starts with no prior selection
                else:
                    label = u'{}. {}'.format(i, label) # Others are numbered
                menuItem = cmds.menuItem(parent=_menu(self.menu_debug_cache_mode_list), label=label, annotation=mode[2])
                if i == 0:
                    self.widget_last_debug_cache_mode = menuItem

            # Flush synchronization
            self.checkbox_flush_sync = cmds.checkBoxGrp( label=''
                                                       , label1=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kFlushCacheSynchronously' ]
                                                       , annotation=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kFlushCacheSynchronouslyAnnotation' ]
                                                       , changeCommand=callback_tool(self, self.callback_update_flush_cache_synchronously)
                                                       )

            # Buttons to perform one-shot operations on the cache
            self.layout_actions = cmds.rowLayout( numberOfColumns=5
                                                , columnWidth5=(COLUMN_SPACING,BUTTON_WIDTH+COLUMN_SPACING,BUTTON_WIDTH+COLUMN_SPACING,BUTTON_WIDTH+COLUMN_SPACING,COLUMN_SPACING)
                                                )
            with LayoutManager( self.layout_actions ):
                cmds.separator( style=r'none', width=COLUMN_SPACING )
                cmds.button( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kInvalidateCache' ], width=BUTTON_WIDTH, command=callback_tool(self, self.callback_invalidate_cache) )
                cmds.button( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kFlushCache' ],           width=BUTTON_WIDTH, command=callback_tool(self, self.callback_flush_cache) )
                self.button_trigger_rebuild = cmds.button( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kRebuildCache' ], width=BUTTON_WIDTH, command=callback_tool(self, self.callback_rebuild_cache) )
                cmds.separator( style=r'none', width=COLUMN_SPACING )


            self.layout_fx = cmds.frameLayout( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kDynamicsSection' ], **section_layout(False) )
            with LayoutManager( self.layout_fx ):

                #----------------------------------------
                control = cmds.checkBoxGrp( label=''
                                        , label1=CachePreferenceDynamicsAsyncRefresh().title
                                        , annotation=CachePreferenceDynamicsAsyncRefresh().info
                                        , changeCommand=callback_tool(self, self.callback_change_dynamics_async_refresh)
                                        )
                self.widgets[CachePreferenceDynamicsAsyncRefresh().ov_id] = control

            self.layout_memory = cmds.frameLayout( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kMemoryManagement' ], **section_layout(False) )
            with LayoutManager( self.layout_memory ):

                with LayoutManager( cmds.rowLayout( numberOfColumns=2
                                                  , adjustableColumn=2
                                                  , columnAlign=[(1, r'center'), (2, r'left')]
                                                  , columnWidth=[(1, BUTTON_WIDTH + COLUMN_SPACING*2)]
                                                  ) ):

                    cmds.button(label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kUpdateMemory' ], width=BUTTON_WIDTH, command=callback_tool(self, self.callback_update_memory))

                    with LayoutManager( cmds.rowColumnLayout( numberOfColumns=2
                                                            , adjustableColumn=2
                                                            , columnAlign=[(1, r'right'), (2, r'left')]
                                                            , columnSpacing=[(1, COLUMN_SPACING), (2, COLUMN_SPACING)]
                                                            , rowSpacing=[(1, ROW_SPACING), (2, ROW_SPACING)]
                                                            ) ):
                        cmds.text( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kMemoryUsage' ] )
                        self.widget_memory_usage = cmds.text(label='')
                        cmds.text( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kMemoryAvailable' ] )
                        self.widget_memory_available = cmds.text(label='')

            self.layout_safe_mode = cmds.frameLayout( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.SafeMode' ], **section_layout(False) )
            with LayoutManager( self.layout_safe_mode ):
                with LayoutManager( cmds.rowColumnLayout( numberOfColumns=2
                                                        , columnAlign=[(1, r'right'), (2, r'center')]
                                                        , columnAttach=[(1, r'right', 0), (2, r'both', 0)]
                                                        , columnSpacing=[(1,COLUMN_SPACING), (2,COLUMN_SPACING)] ) ):
                    cmds.text(label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kSafeModeMessages' ])
                    cmds.button( label=maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kLabelPrint' ] , width=BUTTON_WIDTH , command=callback_tool(self, self.callback_print_safe_mode_messages) )

        CachePreferenceEnabled().add_client( self, callback_tool(self, self.callback_update_enabled) )
        CachePreferenceFillType().add_client( self, callback_tool(self, self.callback_update_fill_type) )
        CachePreferenceDynamicsSupportEnabled().add_client( self, callback_tool(self, self.callback_update_enabled) )
        CachePreferenceDynamicsAsyncRefresh().add_client( self, callback_tool(self, self.callback_change_dynamics_async_refresh) )

        self.monitor_window()
        self.plugin_state_change( new_state=self.cache_mgr.plugin_loaded )
        self.mode_change_job = cmds.scriptJob(event=(r'customEvaluatorChanged', callback_tool(self, self.callback_update_enabled)))

        cmds.scriptJob( uiDeleted=(self.layout_root, callback_tool(self, self.callback_ui_deleted)) )

        # Make sure the state information reflects the current values
        self.update_ui()

    #----------------------------------------------------------------------
    def is_ui_active(self):
        '''
        :return: True if the layout UI is still active. This is needed to avoid timing problems caused by the
        fact that the UI deletion callback is put onto the idle queue and may occur after idle update events.
        '''
        return self.layout_root is not None and cmds.frameLayout( self.layout_root, query=True, exists=True )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_change_dynamics_async_refresh(tool):
        '''
        Callback invoked when the dynamics-async-refresh state changes.
        Read the new value for the optionVar and set the new state.
        '''
        
        dynamics_async_refresh = bool(cmds.checkBoxGrp( tool.widgets[CachePreferenceDynamicsAsyncRefresh().ov_id], query=True, value1=True ))

        CachePreferenceDynamicsAsyncRefresh().set_value_directly( tool, dynamics_async_refresh )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_apply_debug_cache_mode(tool):
        '''
        Callback invoked when one of the custom cache modes was selected. This does not
        affect the mode preferences, it just changes the current caching mode.
        '''
        
        selected_index = cmds.optionMenu(_menu(tool.menu_debug_cache_mode_list), query=True, select=True) - 1
        values_to_set = DEBUG_CACHE_MODES[selected_index][1]
        if values_to_set is not None:
            if values_to_set == []:
                CachePreferenceMode().set_state_from_preference()
            else:
                tool.cache_mgr.cache_mode = (values_to_set)
            # Select the "information" item again to let the user know they can choose again
            cmds.optionMenu(_menu(tool.menu_debug_cache_mode_list), edit=True, select=1)
            # Add the previous choice to the menu, for reference
            new_label = DEBUG_CACHE_MODES[0][0].format( maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kLastDebugModeChoice'].format(selected_index) )
            cmds.menuItem(tool.widget_last_debug_cache_mode, edit=True, label=new_label)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_flush_cache_synchronously(tool):
        '''Invoked when the checkbox for how to flush the cache is pressed'''
        

        tool.cache_mgr.flush_sync = cmds.checkBoxGrp(tool.checkbox_flush_sync, query=True, value1=True)

    #----------------------------------------------------------------------
    @staticmethod
    def callback_invalidate_cache(tool):
        '''Invoked when the "invalidate cache" button is pressed'''
        
        tool.cache_mgr.invalidate_cache()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_flush_cache(tool):
        '''Invoked when the "flush cache" button is pressed'''
        
        tool.cache_mgr.flush_cache()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_rebuild_cache(tool):
        '''Invoked when the "trigger rebuild" button is pressed'''
        
        # We should not wait for cache when triggering a rebuild
        # since we should be in async mode.
        if CachePreferenceFillType().get_value() != r'syncOnly':
            tool.cache_mgr.rebuild_cache( False )
        else:
            cmds.warning( maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kNoRebuildInSync' ] )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_memory(tool):
        '''Invoked when the "update memory" button is pressed.  Recalculates and displays current memory usage.'''
        

        physical_memory = cmds.memory(asFloat=True, gigaByte=True, physicalMemory=True)
        virtual_memory = cmds.memory(asFloat=True, gigaByte=True, heapMemory=True)
        # this needs to get updated to include the heap offset value, right now the evaluation toolkit value is substantially different from what we see in the HUD
        percent = virtual_memory / physical_memory * 100

        cmds.text( tool.widget_memory_usage, edit=True, label=r'{0:5.1f} GB ({1:5.1f}%)'.format(virtual_memory,percent) )
        cmds.text( tool.widget_memory_available, edit=True, label=r'{0:5.1f} GB'.format(physical_memory) )

        print( maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kVirtualLine' ].format( virtual_memory ) )
        print( maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kPhysicalLine'].format( physical_memory ) )
        print( maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kSeparator'   ] )
        print( maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kTotalLine'   ].format( percent ) )

        if CachePreferenceHud().get_value():
            # Trigger viewport refresh to refresh the HUD.
            cmds.refresh()

    #----------------------------------------------------------------------
    @staticmethod
    def callback_print_safe_mode_messages(tool):
        '''Invoked when the "print safe mode messages" button is pressed'''
        

        messages = tool.cache_mgr.safe_mode_messages
        if messages is not None:
            print(maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kSafeModeMessagesAre' ])
            print(messages)
        else:
            print(maya.stringTable['y_maya_plugin_evaluator_EvaluationToolkitSectionCaching.kSafeModeNotTriggered' ])

    #----------------------------------------------------------------------
    def plugin_state_change(self, new_state):
        '''
        Called when the plug-in state changed to loaded or unloaded. Updates the UI appearance to
        reflect the new state.
        :param new_state: True if the plug-in was just loaded, False if just unloaded
        '''
        

        assert self.layout_root is not None
        cmds.frameLayout( self.layout_root, edit=True, visible=new_state )

    #----------------------------------------------------------------------
    def update_ui(self):
        '''Update the UI values to match the current external states'''
        

        # If the plug-in wasn't loaded then no state information can be retrieved so disable everything
        if not self.cache_mgr.plugin_loaded:
            return

        cache_ui_full_layout_update( r'evaluationToolkit' )

        cmds.checkBoxGrp( self.checkbox_flush_sync, edit=True, value1=self.cache_mgr.flush_sync )

        self.callback_update_fill_type( tool=self )
        self.callback_update_enabled( tool=self )

        cmds.checkBoxGrp( self.widgets[CachePreferenceDynamicsAsyncRefresh().ov_id], edit=True, value1=CachePreferenceDynamicsAsyncRefresh().get_value() )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_enabled(tool):
        '''
        Callback to refresh the enabled state of the UI to match the cache evaluator state.
        '''
        
        if not tool.is_ui_active():
            return

        # If the evaluator is disabled then the buttons that perform operations on it should also be disabled
        ui_enabled = cache_ui_enabled()
        cmds.frameLayout( tool.layout_memory, edit=True, enable=ui_enabled )
        cmds.frameLayout( tool.layout_fx, edit=True, enable=ui_enabled )
        cmds.frameLayout( tool.layout_safe_mode, edit=True, enable=ui_enabled )
        cmds.rowLayout( tool.layout_actions, edit=True, enable=ui_enabled )
        cmds.optionMenuGrp( tool.menu_debug_cache_mode_list, edit=True, enable=ui_enabled )
        cmds.checkBoxGrp( tool.checkbox_flush_sync, edit=True, enable=ui_enabled )

        # If the evaluator 's dynamics support is disabled, then all the dynamics button should be disabled
        dynamics_support_enabled = CachePreferenceDynamicsSupportEnabled().get_value()

        cmds.checkBoxGrp( tool.widgets[CachePreferenceDynamicsAsyncRefresh().ov_id],  edit=True, enable=(ui_enabled and dynamics_support_enabled), value1=CachePreferenceDynamicsAsyncRefresh().get_value() )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_update_fill_type(tool):
        '''
        Callback to refresh the enabled state of the "Rebuild Cache" button to match the cache evaluator fill type.
        '''
        

        cmds.button( tool.button_trigger_rebuild, edit=True, enable=CachePreferenceFillType().get_value() != r'syncOnly' )

    #----------------------------------------------------------------------
    @staticmethod
    def callback_ui_deleted(tool):
        '''Callback invoked when the UI was deleted. Clear out all of the local data.'''
        

        CachePreferenceFillType().remove_client( tool )
        CachePreferenceEnabled().remove_client( tool )
        CachePreferenceDynamicsSupportEnabled().remove_client( tool )
        CachePreferenceDynamicsAsyncRefresh().remove_client( tool )

        tool.layout_root = None
        tool.layout_actions = None
        tool.layout_memory = None
        tool.layout_safe_mode = None
        tool.deformer_mgr = None
        tool.cache_mgr = None
        tool.menu_debug_cache_mode_list = None
        tool.checkbox_flush_sync = None
        tool.widget_memory_usage = None
        tool.widget_memory_available = None
        tool.widgets[CachePreferenceDynamicsAsyncRefresh().ov_id] = None

        tool.deformer_mgr = None
        tool.cache_mgr = None

        if tool.mode_change_job is not None:
            cmds.scriptJob( kill=tool.mode_change_job )
            tool.mode_change_job = None
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
