### See the file "LICENSE.txt" for the full license governing this code.
import maya
maya.utils.loadStringResourcesForModule(__name__)

from maya.app.flux.ae.Template import Template
from maya.app.flux.ae.Custom import Custom

from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix

from copy import deepcopy
from imp import reload
import maya.plugin.polyBoolean.booltoolUI as btui
import maya.plugin.polyBoolean.booltoolAPI as btapi
reload(btui)
reload(btapi)

from contextlib import contextmanager

@contextmanager
def skippable(sLock):
    try:
        yield
    except Exception as e:
        if str(e) != 'skippable':
            if sLock.locked():
                sLock.unlock()
            raise
            
def skipContext():
    raise Exception('skippable')

@contextmanager
def runLocked(sLock):
    if sLock.locked():
        skipContext()
    sLock.lock()
    yield
    sLock.unlock()

class SimpleLock(object):
    def __init__(self):
        self.isLocked = False

    def locked(self):
        return self.isLocked

    def lock(self):
        self.isLocked = True

    def unlock(self):
        self.isLocked = False

class AEboolToolTemplate(Template):
    def buildUI(self, nodeName):
        self.addCustom(MyCustom(nodeName))

class MyCustom(Custom):
    def buildUI(self, nodeName):
        self.toolbar = fx.widgetWithLayout('H', pix(2), pix(5),pix(2),pix(5),pix(2))
        self.toolbar.setAutoFillBackground(True)
        self.toolbar.setFixedHeight(pix(30))
        fx.setWidgetBackgroundColor(self.toolbar, [73,73,73])
        #self.mainIcon = qt.QLabel()
        #self.mainIcon.setPixmap(fx.getPixmap('Bool_Logo'))
        #self.toolbar.layout().addSpacing(pix(2))
        #self.toolbar.layout().addWidget(self.mainIcon)
        self.toolbar.layout().addSpacing(pix(8))
        self.titleLabel = qt.QLabel('Bool')
        self.toolbar.layout().addWidget(self.titleLabel)

        self.toolbar.layout().addStretch()

        '''self.boolModeSwitch = fx.ImageButton('Bool_Mode1')
        self.boolModeSwitch.setToolTip('Bool mode')
        self.boolModeSwitch.clicked.connect(self.uiBoolModeChanged)
        self.toolbar.layout().addWidget(self.boolModeSwitch)'''
        #1 - Per Layer mode; 0 - Global mode
        self.boolModeValue = 1

        self.toolbar.layout().addSpacing(pix(3))

        self.addWidget(self.toolbar)
        self.addSpacing(pix(5))

        self.dropWidget = btui.DropListWidget(self.name)
        self.dropWidget.dropped.connect(self.uiDroppedNode)
        self.dropWidget.reorder.connect(self.uiReorderNodes)
        self.dropWidget.deleted.connect(self.uiDeleteNode)
        self.dropWidget.outMeshChanged.connect(self.uiMeshChangeNode)
        self.dropWidget.buttonClicked.connect(self.uiButtonClicked)
        self.dropWidget.selected.connect(self.uiSelected)
        self.addWidget(self.dropWidget)

        self.addSpacing(pix(5))

        self.supportLabel = qt.QLabel('')
        self.supportLabel.setAlignment(qt.Qt.AlignCenter)
        self.addWidget(self.supportLabel)

        self.addSpacing(pix(10))

        self.createAttributeListener('operation', self.attrBooleanTypeChange)
        self.createAttributeListener('booleanMode', self.attrBooleanModeChange)
        self.createAttributeListener('elementEnabled', self.attrElementEnabledChange)
        self.createAttributeListener('inputPoly', self.attrInputPolyChange)

        self.uiLock = SimpleLock()
        self.visJobs = []

        self.m_lockRepaint = False
        self.prevName = 0
        self.nodeChanged()

    def clearVisJobs(self):
        for v in self.visJobs:
            if cmds.scriptJob(exists=v):
                cmds.scriptJob(kill=v)
        self.visJobs = []

    def setupScriptJobs(self, nodes):
        self.clearVisJobs()
        for n in nodes:
            job = cmds.scriptJob(attributeChange=[n + '.visibility', self.attrVisibilityChange])
            self.visJobs.append(job)
        
        colorChangedJob = cmds.scriptJob(event=("DisplayRGBColorChanged", self.wireframeColorChange))
        self.visJobs.append(colorChangedJob)

    def getCustomKey(self, name):
        return self.instanceKey + '_' + name

    def attrVisibilityChange(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            self.updateShadeState()
            
    def wireframeColorChange(self):
        if self.name and cmds.objExists(self.name):
            nodes = cmds.listConnections(self.name + '.inputPoly')
            if not nodes: return
        else:
            return
        
        rgba = mel.eval('displayRGBColor -q -a %s' %('polyBoolean'))
        
        for i, n in enumerate(nodes):
            btapi.setBoolColor(n, rgba)
                    
    def nodeChanged(self):
        if self.prevName != cmds.ls(self.name, uuid=True):
            self.prevName = cmds.ls(self.name, uuid=True)
            self.resetView()

        shape = cmds.listConnections(self.name + '.output') or []
        if shape:
            self.titleLabel.setText(shape[0])

        nodes = cmds.listConnections(self.name + '.inputMat') or []

        if len(nodes) != self.itemCount():
            self.resetView()

        for i in range(self.itemCount()):
            item = self.itemAt(i)
            item.setText(nodes[i])

    def resetView(self):
        self.m_lockRepaint = True
        self.updateNodes()
        self.updateShadeState()
        self.attrBooleanModeChange()
        self.attrElementEnabledChange()
        self.updateRowButtons()
        self.m_lockRepaint = False

    def uiSelected(self):
        items = self.dropWidget.listWidget.selectedItems()
        if items:
            selnames='"'+self.name+'" '
            for item in items:
                selnames+='"'+item.text()+'" '
            mel.eval('select -r '+selnames)

    @fx.undoChunk('attrBooleanTypeChange')
    def attrBooleanTypeChange(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            checked = cmds.getAttr(self.name + '.booleanMode')
            types = cmds.getAttr(self.name + '.operation')

            for i in range(self.itemCount()):
                enabled = self.isRowBoolEnabled(i, checked)
                self.setIndividualMode(i, types[i])
            self.repaintList()

    @fx.undoChunk('attrBooleanModeChange')
    def attrBooleanModeChange(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            state = cmds.getAttr(self.name + '.booleanMode')
            self.boolModeValue = state

            self.updateRowButtons()
            self.updateBoolMode()

    @fx.undoChunk('attrElementEnabledChange')
    def attrElementEnabledChange(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            enabled = cmds.getAttr(self.name + '.elementEnabled') or []
            for i in range(self.itemCount()):
                item = self.itemAt(i)
                item.isOn = enabled[i] if i < len(enabled) else True
            self.repaintList()

    @fx.undoChunk('attrInputPolyChange')
    def attrInputPolyChange(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            conns = cmds.listConnections(self.name + '.inputPoly') or []
            items = [self.itemAt(i).text() for i in range(self.itemCount())]
            if conns == items:
                return
            self.resetView()

# Attr utilities    
    def updateBoolTypes(self):
        boolTypes = cmds.getAttr(self.name + '.operation')
        for i in range(self.itemCount()):
            self.setIndividualMode(i, boolTypes[i])
        self.repaintList()

    def updateRowButtons(self):
        checked = cmds.getAttr(self.name + '.booleanMode')
        types = cmds.getAttr(self.name + '.operation')
        
        for i in range(self.itemCount()):
            enabled = self.isRowBoolEnabled(i, checked)
            item = self.itemAt(i)
            item.setBoolType(types[i])
            item.setBoolButtonsEnabled(enabled)

        self.repaintList()

    def updateShadeState(self):
        for i in range(self.itemCount()):
            item = self.itemAt(i)
            item.setVisibility(btapi.nodeVisibility(item.text()))
        self.repaintList()

    def parentRow(self):
        enabled = cmds.getAttr(self.name + '.elementEnabled') or []
        for i in range(len(enabled)):
            if enabled[i]:
                return i
        return -1

    def isRowBoolEnabled(self, row, boolMode):
        pRow=self.parentRow()
        item = self.itemAt(row)
        if boolMode:
            return ((row > pRow) and item.isOn)
        else:
            return ((row == pRow) and item.isOn)

    def updateBoolMode(self):
        checked = cmds.getAttr(self.name + '.booleanMode')
        self.boolModeValue = checked
        # if self.boolModeValue:
        #     self.boolModeSwitch.setImage(fx.getPixmap('Bool_Mode2'))
        # else:
        #     self.boolModeSwitch.setImage(fx.getPixmap('Bool_Mode1'))
        self.updateRowButtons()
        self.repaintList()

    def setIndividualMode(self, row, mode):
        item = self.itemAt(row)
        item.setBoolType(mode)

# Utilities
    def repaintList(self):
        if self.m_lockRepaint: return
        self.dropWidget.listWidget.viewport().repaint()

    def itemAt(self, index):
        return self.dropWidget.listWidget.item(index)

    def itemCount(self):
        return self.dropWidget.listWidget.count()

    def clearItems(self):
        self.dropWidget.listWidget.clear()

    def addItem(self, item):
        self.dropWidget.listWidget.addItem(item)

    def draggedNode(self):
        return self.dropWidget.listWidget.drag_node
        
    def dragStartIndex(self):
        return self.dropWidget.listWidget.drag_row

# UI Events
    @fx.undoChunk('bool mode')
    def uiBoolModeChanged(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            self.boolModeValue = not self.boolModeValue
            btapi.setBoolMode(self.name, self.boolModeValue)
        
    @fx.undoChunk('bool edit')
    def uiButtonClicked(self, row, btnName):
        with skippable(self.uiLock), runLocked(self.uiLock):
            if btnName == btui.cs.dDBtnNameBoolType:
                checked = cmds.getAttr(self.name + '.booleanMode')
                boolEnabled = self.isRowBoolEnabled(row, checked)
                if (not boolEnabled) and (self.parentRow()==row):
                    return

                parent = self.dropWidget.listWidget
                pos = qt.QCursor.pos()
                pos = qt.QPoint(parent.width() - (btui.cs.dropdownIconWidth+4)*2 - 8-4, 30 * row + 8)
                pos = parent.mapToGlobal(pos)
                selected = 0
                icons = [fx.getPixmap(x) for x in ['Bool_Union', 'Bool_Subtract', 'Bool_BMinusA_AE', 'Bool_Intersect', 'Bool_Slice', 'Bool_HolePunch_AE', 'Bool_CutOut_AE', 'Bool_SplitEdges']]

                unionLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kUnionBtnLbl' ]
                diffABLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kDiffABBtnLbl' ]
                intersectionLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kInterBtnLbl' ]
                diffBALbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kDiffBABtnLbl' ]
                sliceLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kSliceBtnLbl' ]

                holePunchLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kHolePunchBtnLbl' ]
                cutOutLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kCutOutBtnLbl' ]
                splitEdgesLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kSplitEdgesBtnLbl' ]
                btnlabels = [unionLbl, diffABLbl, diffBALbl, intersectionLbl, sliceLbl, holePunchLbl, cutOutLbl, splitEdgesLbl]

                unionAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanUnion")'))
                diffABAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanDifference")'))
                intersectionAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanIntersection")'))
                diffBAAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanDifferenceBA")'))
                sliceAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanSlice")'))
                holePunchAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanHolePunch")'))
                cutOutAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanCutOut")'))
                splitEdgesAnn = (mel.eval('getRunTimeCommandAnnotation ("PolygonBooleanSplitEdges")'))
                btnAnns = [unionAnn, diffABAnn, diffBAAnn, intersectionAnn, sliceAnn, holePunchAnn, cutOutAnn, splitEdgesAnn]
                
                btn = self.itemAt(row).getButton(btui.cs.dDBtnNameBoolType)
                highlightable = btn.highlightable
                original = btn.icons[0]

                btn.icons = [btui.depressPixmap(original)]
                btn.highlightable = False
                self.repaintList()

                def choiceSelected(choice):
                    btn.icons = [original]
                    btn.highlightable = highlightable
                    self.repaintList()

                    if choice != -1:
                        checked = cmds.getAttr(self.name + '.booleanMode')
                        boolEnabled = self.isRowBoolEnabled(row, checked)
                        if (not boolEnabled) and (self.parentRow()==row): return

                        boolTypes = cmds.getAttr(self.name + '.operation')
                        
                        if self.itemAt(row).isSelected():
                            for item in self.dropWidget.listWidget.selectedIndexes():
                                boolTypes[item.row()] = choice
                                self.setIndividualMode(item.row(), choice)
                        else:
                            boolTypes[row] = choice
                            self.setIndividualMode(row, choice)
                        btapi.setBoolType(self.name, boolTypes)
                        self.repaintList()

                def choiceUnionSelected():
                    choiceSelected(btui.cs.kBoolOpUnion)

                def choiceSubtractSelected():
                    choiceSelected(btui.cs.kBoolOpDifference)

                def choiceIntersectSelected():
                    choiceSelected(btui.cs.kBoolOpIntersection)

                def choiceBMinusASelected():
                    choiceSelected(btui.cs.kBoolOpBMinusADifference)

                def choiceSplitSelected():
                    choiceSelected(btui.cs.kBoolOpSlice)

                def choiceSplitEdgesSelected():
                    choiceSelected(btui.cs.kBoolOpHolePunch)

                def choiceHolePunchSelected():
                    choiceSelected(btui.cs.kBoolOpCutOut)

                def choiceCutOutSelected():
                    choiceSelected(btui.cs.kBoolOpSplitEdges)

                def menuAboutToHide():
                    btn.icons = [original]
                    btn.highlightable = highlightable
                    self.repaintList()

                contextMenu = qt.QMenu("")
                contextMenu.aboutToHide.connect(menuAboutToHide)
                for idx,icon in enumerate(icons):
                    item = contextMenu.addAction(btnlabels[idx])
                    item.setStatusTip(btnAnns[idx])
                    item.setIcon(qt.QIcon(icon))
                    item.triggered.connect(
                        [choiceUnionSelected, choiceSubtractSelected, choiceBMinusASelected, choiceIntersectSelected, choiceSplitSelected, choiceSplitEdgesSelected, choiceHolePunchSelected, choiceCutOutSelected][idx]
                        )
                #popup position at bottom
                pos.setX(pos.x()-btui.cs.dropdownIconWidth-3)
                pos.setY(pos.y()+btui.cs.dropdownIconHeight+2)
                action = contextMenu.exec_(pos)
                #btui.ChoiceDropdown.getChoice(parent, pos, 0, icons, choiceSelected,['Union','Difference','Intersection'])

            elif btnName == btui.cs.dDBtnNameVisibility:
                parent = self.dropWidget.listWidget
                pos = qt.QCursor.pos()
                pos = qt.QPoint(parent.width() - btui.cs.dropdownIconWidth - 4 - 8, 30 * row + 8)
                pos = parent.mapToGlobal(pos)
                selected = 0
                icons = [fx.getPixmap(x) for x in ['Bool_Wireframe', 'Bool_Shaded', 'Bool_bBox_M', 'Bool_xRay_M', 'Bool_Hidden']]

                wireLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kWireBtnLbl' ]
                shadedLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kShadedBtnLbl' ]
                bboxLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kBBoxBtnLbl' ]
                xrayLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kXrayBtnLbl' ]
                hiddenLbl = maya.stringTable['y_maya_plugin_polyBoolean_AEbooltoolTemplate.kHiddenBtnLbl' ]
                btnlabels = [wireLbl, shadedLbl, bboxLbl, xrayLbl, hiddenLbl]

                btn = self.itemAt(row).getButton(btui.cs.dDBtnNameVisibility)
                highlightable = btn.highlightable
                original = btn.icons[0]

                btn.icons = [btui.depressPixmap(original)]
                btn.highlightable = False
                self.repaintList()

                @QtCore.Slot(int)
                def choiceSelected(choice):
                    btn.icons = [original]
                    btn.highlightable = highlightable
                    self.repaintList()

                    if choice != -1:
                        item = self.itemAt(row)
                        if item.isSelected():
                            for item in (self.dropWidget.listWidget.selectedItems()):
                                item.setVisibility(choice)
                                btapi.setNodeVisibility(item.text(), choice)
                        else:
                            item.setVisibility(choice)
                            btapi.setNodeVisibility(item.text(), choice)
                        self.repaintList()

                def choiceWfSelected():
                    choiceSelected(btui.cs.visibilityWireframe)

                def choiceShadedSelected():
                    choiceSelected(btui.cs.visibilityShaded)

                def choicebBoxSelected():
                    choiceSelected(btui.cs.visibilityBoundingBox)

                def choicexRaySelected():
                    choiceSelected(btui.cs.visibilityXRay)

                def choiceHiddenSelected():
                    choiceSelected(btui.cs.visibilityHidden)
                    
                def menuAboutToHide():
                    btn.icons = [original]
                    btn.highlightable = highlightable
                    self.repaintList()

                contextMenu = qt.QMenu("")
                contextMenu.aboutToHide.connect(menuAboutToHide)
                for idx,icon in enumerate(icons):
                    item = contextMenu.addAction(btnlabels[idx])
                    item.setData(idx)
                    item.setIcon(qt.QIcon(icon))
                    item.triggered.connect([choiceWfSelected, choiceShadedSelected,choicebBoxSelected,choicexRaySelected, choiceHiddenSelected][idx]
                    # menuChoiceSelected
                    #lambda checked, index=idx: choiceSelected(index)
                    )
                #at bottom
                pos.setX(pos.x()-btui.cs.dropdownIconWidth-3)
                pos.setY(pos.y()+btui.cs.dropdownIconHeight+2)
                action = contextMenu.exec_(pos)
                #btui.ChoiceDropdown.getChoice(parent, pos, 0, icons, choiceSelected, ['Wireframe','Shaded','Hidden'])

            elif btnName == 'toggleButton':
                checked = cmds.getAttr(self.name + '.booleanMode')
                rowEnabled = self.isRowBoolEnabled(row, checked)
                boolTypes = cmds.getAttr(self.name + '.operation')

                item = self.itemAt(row)
                enabled = cmds.getAttr(self.name + '.elementEnabled')
                if item.isSelected():
                    for selitem in self.dropWidget.listWidget.selectedIndexes():
                        enabled[selitem.row()] = item.isOn
                        curitem=self.itemAt(selitem.row())
                        if item.isOn:
                            if rowEnabled:
                                curitem.setBoolType(boolTypes[selitem.row()])
                                curitem.setBoolButtonsEnabled(True)
                        else:
                            curitem.setBoolType(boolTypes[selitem.row()])
                            curitem.setBoolButtonsEnabled(False)
                else:
                    enabled[row] = item.isOn
                    if item.isOn:
                        if rowEnabled:
                            item.setBoolType(boolTypes[row])
                            item.setBoolButtonsEnabled(True)
                    else:
                        item.setBoolType(boolTypes[row])
                        item.setBoolButtonsEnabled(False)
                btapi.setElementEnabled(self.name, enabled)
                self.resetView()         

    @fx.undoChunk('mesh bool')
    def uiMeshChangeNode(self, currentNode, meshNodes):
        #TODO: optimize this function by only process selected nodes.
        with skippable(self.uiLock), runLocked(self.uiLock):
            #Turn smooth mesh on/off.
            nodes = []
            count = self.itemCount()
            for i in range(count):
                nodes.append(self.itemAt(i))
                
            meshesSmoothed = []
            for i, n in enumerate(nodes):
                meshesSmoothed.append(False)
                smoothMesh = MyCustom.isOutSmoothMeshAttr(n.text())
                if smoothMesh: meshesSmoothed[i] = True

            leadNodeSmoothMesh = MyCustom.isOutSmoothMeshAttr(currentNode.text())

            conns = cmds.listConnections(self.name + '.inputPoly', p=True, c=True)
            if not conns: return
            MyCustom.DisconnectAllConns(conns)

            for i, n in enumerate(nodes):
                if (n in meshNodes):
                    meshAttrName = '.outSmoothMesh'
                    if leadNodeSmoothMesh: meshAttrName = '.outMesh'
                else:
                    meshAttrName = '.outMesh'
                    if meshesSmoothed[i]: meshAttrName = '.outSmoothMesh'
                    
                j = mel.eval('getNextFreeMultiIndex %s 0;' % (self.name + '.inputPoly'))    
                
                cmds.connectAttr(n.text() + meshAttrName, self.name + '.inputPoly[%d]' % j)
                
            self.resetView()
    
    @staticmethod
    def safeConnectAttr(attr1,attr2):
        if(not cmds.isConnected(attr1, attr2)):
            cmds.connectAttr(attr1, attr2, force=True)

    @staticmethod
    def DisconnectAllConns(conns):
        for i in range(int(len(conns) / 2)):
            outconn = conns[i*2 + 1]
            inconn = conns[i*2]

            cmds.disconnectAttr(outconn, inconn)

    @fx.undoChunk('remove bool')
    def uiDeleteNode(self, delnodes, delnode_idxs):
        with skippable(self.uiLock), runLocked(self.uiLock):
            cmds.select(self.name)
            nodes = []
            delnode_iidxs = []
            for item in delnode_idxs:
                delnode_iidxs.append(item.row())

            count = self.itemCount()
            for i in range(count):
                nodes.append(self.itemAt(i).text())

            for delnode in delnodes:
                nodes.remove(delnode.text())
                btapi.setNodeVisibility(delnode.text(), 1)

            boolTypes = cmds.getAttr(self.name + '.operation') or []
            for ele in sorted(delnode_iidxs, reverse = True):
                if len(boolTypes)>ele:
                    del boolTypes[ele]
            #numpy method of deletion.
            #boolTypes = np.delete(boolTypes, delnode_iidxs).tolist()
            btapi.setBoolType(self.name, boolTypes)

            meshType = []
            for i, n in enumerate(nodes):
                meshType.append(0)
                smoothMesh = cmds.listConnections(n + '.outSmoothMesh')
                if smoothMesh: meshType[i] = 1
            
            conns = cmds.listConnections(self.name + '.inputPoly', p=True, c=True)
            if not conns: return
            MyCustom.DisconnectAllConns(conns)
            for i, n in enumerate(nodes):           
                mesh = '.outMesh'
                if meshType[i] == 1: mesh = '.outSmoothMesh'
                    
                j = mel.eval('getNextFreeMultiIndex %s 0;' % (self.name + '.inputPoly'))    
                MyCustom.safeConnectAttr(n + mesh, self.name + '.inputPoly[%d]' % j)
            
            conns = cmds.listConnections(self.name + '.inputMat', p=True, c=True)
            if not conns: return
            MyCustom.DisconnectAllConns(conns)
            for n in nodes:
                i = mel.eval('getNextFreeMultiIndex %s 0;' % (self.name + '.inputMat'))
                MyCustom.safeConnectAttr(n + '.worldMatrix', self.name + '.inputMat[%d]' % i)
  
            self.resetView()
                

    @fx.undoChunk('reorder bool')
    def uiReorderNodes(self):
        with skippable(self.uiLock), runLocked(self.uiLock):
            dragNode = self.draggedNode()
            dragStartIndex = self.dragStartIndex()

            nodes = [self.itemAt(i).text() for i in range(self.itemCount())]
            newRow = nodes.index(dragNode)

            #If drag item been drop to same position, skip all position swap code below 
            if(newRow==dragStartIndex):
                self.resetView()
                return

            oldTypes = cmds.getAttr(self.name + '.operation')

            oldTypes.insert(newRow, oldTypes.pop(dragStartIndex))
            btapi.setBoolType(self.name, oldTypes)

            oldEnabled = cmds.getAttr(self.name + '.elementEnabled')
            oldEnabled.insert(newRow, oldEnabled.pop(dragStartIndex))
            btapi.setElementEnabled(self.name, oldEnabled)

            meshType = []
            for i, n in enumerate(nodes):
                meshType.append(0)
                smoothMesh = cmds.listConnections(n + '.outSmoothMesh')
                if smoothMesh: meshType[i] = 1;
            
            conns = cmds.listConnections(self.name + '.inputPoly', p=True, c=True)
            if not conns: return
            
            for i in range(int(len(conns) / 2)):
                outconn = conns[i*2 + 1]
                inconn = conns[i*2]

                cmds.disconnectAttr(outconn, inconn)
                    
            for i, n in enumerate(nodes):           
                mesh = '.outMesh'
                if meshType[i] == 1: mesh = '.outSmoothMesh'
                    
                j = mel.eval('getNextFreeMultiIndex %s 0;' % (self.name + '.inputPoly'))    
                cmds.connectAttr(n + mesh, self.name + '.inputPoly[%d]' % j)

            conns = cmds.listConnections(self.name + '.inputMat', p=True, c=True)
            if not conns: return

            for i in range(int(len(conns) / 2)):
                outconn = conns[i*2 + 1]
                inconn = conns[i*2]

                cmds.disconnectAttr(outconn, inconn)

            for n in nodes:
                i = mel.eval('getNextFreeMultiIndex %s 0;' % (self.name + '.inputMat'))
                cmds.connectAttr(n + '.worldMatrix', self.name + '.inputMat[%d]' % i)
 
            self.resetView()

    @fx.undoChunk('add bool')
    def uiDroppedNode(self, data):
        with skippable(self.uiLock), runLocked(self.uiLock):
            nodes = [x.strip() for x in data.split('\n')]
            if not nodes: return

            for node in nodes:
                btapi.addMeshToBool(self.name, node)

            self.resetView()

    def fixElementEnabled(self, count):
        '''Update elementEnabled to match number of connected nodes
        '''
        elementEnabled = cmds.getAttr(self.name + '.elementEnabled') or []
        if len(elementEnabled) == count:
            return elementEnabled

        if len(elementEnabled) > count:
            elementEnabled = elementEnabled[:count]
        else:
            elementEnabled += [1 for x in range(count - len(elementEnabled))]

        btapi.setElementEnabled(self.name, elementEnabled)
        return elementEnabled

    @staticmethod
    def isOutSmoothMeshAttr(node):
        smoothConnections = cmds.listConnections(node + '.outSmoothMesh') or []
        return len(smoothConnections) > 0
    
    # Force truncate number of operation attributes to count
    def fixBooleanTypes(self, count):
        '''Update booleanTypes to match number of connected nodes
        '''
        boolTypes = cmds.getAttr(self.name + '.operation') or []
        if len(boolTypes) == count:
            return boolTypes

        if len(boolTypes) > count:
            boolTypes = boolTypes[:count]
        else:
            boolTypes += [0 for x in range(count - len(boolTypes))]

        btapi.setBoolType(self.name, boolTypes)
        return boolTypes

    def updateNodes(self):
        nodes = cmds.listConnections(self.name + '.inputMat')
        self.clearItems()

        if not nodes: return

        count = len(nodes)
        elementEnabled = self.fixElementEnabled(count)
        self.fixBooleanTypes(count)
        
        rgba = mel.eval('displayRGBColor -q -a %s' %('polyBoolean'))
        
        # Fill widget with items
        for i, n in enumerate(nodes):
            item = btui.BoolItem(n, self.dropWidget.listWidget)
            nodeColor = None
            rowColor = None

            item.isSmoothMesh = MyCustom.isOutSmoothMeshAttr(n)

            if not elementEnabled[i]:
                nodeColor = [89, 89, 89]
                rowColor = self.dropWidget.listWidget.rowBGColor
            elif i == self.parentRow():
                nodeColor = [219,148,86]#[241, 90, 91]
                rowColor = self.dropWidget.listWidget.rowBGColor#qt.QColor(94, 94, 94)
            else:
                nodeColor = [189, 189, 189]
                rowColor = self.dropWidget.listWidget.rowBGColor

            item.color = qt.QColor(*nodeColor)
            item.rowBGColor = rowColor
            btapi.setNodeOverrideColor(n, nodeColor)

            btapi.setBoolColor(n, rgba)
            self.addItem(item)       
                        
        self.setupScriptJobs(nodes)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
