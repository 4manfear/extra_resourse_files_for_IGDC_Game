### See the file "LICENSE.txt" for the full license governing this code.
import maya
maya.utils.loadStringResourcesForModule(__name__)

from maya.app.flux.imports import *
import maya.app.flux.core as fx
from maya.app.flux.core import pix

import maya.plugin.polyBoolean.booltoolAPI as btapi
import maya.plugin.polyBoolean.AEbooltoolTemplate as bttemplate
import maya.cmds as cmds

from copy import deepcopy

def ConstantSpace(**args):
    args['__slots__'] = ()
    cls = type('ConstantSpace', (), args)
    return cls()

cs = ConstantSpace(
    dropdownIconWidth = 26,  #used to be 20
    dropdownIconHeight = 16,  #used to be 20

    dDBtnNameBoolType   = 'boolType',
    dDBtnNameVisibility = 'visibility',

    #BoolItem right side button index constants
    dDBtnNameBoolTypeIdx   = 0,
    dDBtnNameVisibilityIdx = 1,

    visibilityWireframe = 0,
    visibilityShaded    = 1,
    visibilityBoundingBox = 2,
    visibilityXRay      = 3,
    visibilityHidden    = 4,

    # Values should match the boolean factory enum
	kBoolOpNoop = 0,
	kBoolOpUnion = 1,
	kBoolOpDifference = 2,
	kBoolOpIntersection = 3,
    kBoolOpBMinusADifference = 4,
    kBoolOpSlice = 5,
    kBoolOpHolePunch = 6,
    kBoolOpCutOut = 7,
    kBoolOpSplitEdges  = 8
)

class ListWidget(fx.ListButtonWidget):
    def __init__(self, _boolNode, parent=None):
        fx.ListButtonWidget.__init__(self,parent,cs.dropdownIconWidth)

        self.bgpixmap = fx.getPixmap('Bool_drop_box')
        self.bgNoItemsHelpLine = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kNoItemHelpAnn' ]
        self.bgOneItemHelpLine = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kOneItemHelpAnn' ]
        self.bgGeneralToolTip = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kGeneralTooltipAnn' ]

        self.booleanOpAnn = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kBoolOpAnn' ]
        self.visibilityAnn = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kVisibilityAnn' ]
        self.enabledAnn = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kEnabledAnn' ]

        self.margins_out = pix(2) #normal margin
        #self.margins_in = pix(8) #margin between items
        self.colorBarWidth = pix(5)
        self.iconHeight = pix(20)
        #self.iconWidth = pix(26)
        #self.padding = pix(8)

        self.margins_toright = pix(8)
        self.margins_rightbtns = pix(8)

        self.boolNode = _boolNode

    def paintEvent(self, e):
        qt.QListWidget.paintEvent(self,e)
        if self.model().rowCount() < 2 and self.showDropIndicator:
            painter = qt.QPainter(self.viewport())
            iconTopLeft = self.contentsRect().center()
            iconWidth = self.bgpixmap.size().width()
            iconTopLeft.setX(iconTopLeft.x() - iconWidth/(2 * self.bgpixmap.devicePixelRatio()))
            iconTopLeft.setY(iconTopLeft.y() - self.bgpixmap.size().height())
            painter.drawPixmap(iconTopLeft, self.bgpixmap)

            helpRect = self.contentsRect()
            helpRect.setTop(iconTopLeft.y() + self.bgpixmap.size().height() + pix(5))
            helpRect.setWidth(helpRect.width() - (2 * iconWidth))
            helpRect.moveLeft(iconWidth)

            pal = self.palette()
            oldPen = painter.pen()
            painter.setPen(pal.placeholderText().color())

            if self.model().rowCount() == 1:
                painter.drawText(helpRect, qt.Qt.AlignHCenter | qt.Qt.TextWordWrap, self.bgOneItemHelpLine)
            else:
                painter.drawText(helpRect, qt.Qt.AlignHCenter | qt.Qt.TextWordWrap, self.bgNoItemsHelpLine)
            painter.setPen(oldPen)

    def canDrop(self, _nodes):
        #with bttemplate.skippable(), bttemplate.runLocked(self.uiLock):
        nodes = [x.strip() for x in _nodes.split('\n')]
        if not nodes: return False

        for meshNode in nodes:
            #Using same if judgement as in addMeshToBool function
            if cmds.objExists(meshNode) and cmds.nodeType(meshNode) in ['transform', 'mesh']:
                existingConns = cmds.listConnections(meshNode + '.outMesh') or cmds.listConnections(meshNode + '.outSmoothMesh') or []
                if cmds.ls(self.boolNode, uuid=True) in [cmds.ls(x, uuid=True) for x in existingConns]:
                    continue
                if btapi.isSelfMeshNode(self.boolNode,meshNode):
                    continue

                return True

        return False

    def dragMoveEvent(self, event):
        qt.QListWidget.dragMoveEvent(self, event)
        if event.mimeData().hasFormat('text/plain'):
            canDrop = self.canDrop(event.mimeData().text())
            if canDrop:
                #self.setCursor(qt.Qt.ForbiddenCursor)#qt.Qt.ArrowCursor
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()
            #fx.ListButtonWidget.dragMoveEvent(self, event)

        self.viewport().update()

    def dropEvent(self, event):
        index = self.indexAt(event.pos())
        item = self.itemFromIndex(index)
        #Do not call fx.ListButtonWidget.dropEvent, which will cause double drop implementation. 
        qt.QListWidget.dropEvent(self, event)
        self.dataDelegate.dropEvent(event)

    def startDrag(self, supportedActions):
        self.drag_node = self.currentItem().text()
        self.drag_row = self.row(self.currentItem())
        fx.ListButtonWidget.startDrag(self, supportedActions)

    def keyPressEvent(self, event):
        # We want the parent to handle the delete key because it's the one
        # that has the "remove item" functionality.  We ignore all other key
        # events to just let Maya handle those as hotkeys, but for some reason
        # if we don't ignore them here than we don't get the key events in our
        # parent.  e.g. if we don't ignore the 'w' key here, then that event 
        # doesn't end up with our parent, and even if our parent is just going
        # to ignore it anyways, it never ends up with Maya and we don't switch
        # to the Move tool.  Delete key and others are different for some reason.
        # Those key events DO go to the parent even if we don't ignore here.  
        event.ignore()
        return
 
    def mousePressEvent(self, event):
        index = self.indexAt(event.pos())

        if event.button() == qt.Qt.RightButton:
            self.actionButtonPressed = False
            qt.QListWidget.mousePressEvent(self,event)
            return

        row = index.row()
        if row < 0:
            self.actionButtonPressed = False
            qt.QListWidget.mousePressEvent(self, event)
            for i in range(self.count()):
                item = self.item(i)
                self.setItemSelected(item, False)
            return

        item = self.itemFromIndex(index)
        button = self.getButtonPressed(item, event.pos().x())

        if button is None or button=='dragIndicator' or button=='textField':
            self.actionButtonPressed = False
            qt.QListWidget.mousePressEvent(self,event)
            return

        self.actionButtonPressed = True

        if button=='toggleButton':
            item.setEnabled(not item.isOn)
            self.viewport().update()
            self.dataDelegate.buttonPressed(index, button)
        else:
            self.dataDelegate.buttonPressed(index, button)

    def mouseMoveEvent(self, event):
        fx.ListButtonWidget.mouseMoveEvent(self, event)
        self.setToolTip('')
        self.setStatusTip('')
        if self.hoverOver:
            if self.hoverOver[1] == 'boolType':
                self.setToolTip(self.booleanOpAnn)
                self.setStatusTip(self.booleanOpAnn)
            elif self.hoverOver[1] == 'visibility':
                self.setToolTip(self.visibilityAnn)
                self.setStatusTip(self.visibilityAnn)
            elif self.hoverOver[1] == 'toggleButton':
                self.setToolTip(self.enabledAnn)
                self.setStatusTip(self.enabledAnn)
        else:
            self.setToolTip(self.bgGeneralToolTip)
            self.setStatusTip(self.bgGeneralToolTip)

    def dragEnterEvent(self, event):
        qt.QListWidget.dragEnterEvent(self, event)
        fx.ListButtonWidget.dragEnterEvent(self, event)

class BoolItem(fx.ListButtonItem):
    def __init__(self, text, parent, index=None):
        fx.ListButtonItem.__init__(self,text,parent,index)

        # The order of these icons need to match the enum value of the operations
        self.boolTypeDDIcons = ['Bool_uniond', 'Bool_dif', 'Bool_inter', 'Bool_bminusad', 'Bool_sliced', 'Bool_holepunchd', 'Bool_cutoutd', 'Bool_splitedgesd']
        self.wireframeDDIcons = ['Bool_wireF', 'Bool_shade', "Bool_bBox", "Bool_xRay", 'Bool_hide']

        icons = decoratedPixmap('Bool_Union')
        self.addButton(icons, cs.dDBtnNameBoolType, alignRight=True)

        icons = decoratedPixmap('Bool_Wireframe')
        self.addButton(icons, cs.dDBtnNameVisibility, alignRight=True)

        self.boolType = -1
        self.visibility = 0
        self.boolButtonsDisabled = False
        self.isSmoothMesh = False

        self.updateVisibility()

    def updateVisibility(self):
        import maya.plugin.polyBoolean.booltoolAPI as btapi
        self.setVisibility(btapi.nodeVisibility(self.text()))

    def setBoolType(self, boolType):
        self.boolType = boolType
        btn = self.getButton(cs.dDBtnNameBoolType)
        btn.icons = decoratedPixmap(self.boolTypeDDIcons[self.boolType-1])
        if self.boolButtonsDisabled:
            btn.icons = [dimPixmap(p) for p in btn.icons]

    def setVisibility(self, visibility):
        self.visibility = visibility
        btn = self.getButton(cs.dDBtnNameVisibility)
        btn.icons = decoratedPixmap(self.wireframeDDIcons[self.visibility])

    def setBoolButtonsEnabled(self, enabled):
        self.boolButtonsDisabled = not enabled
        btn = self.getButton(cs.dDBtnNameBoolType)
        icons = decoratedPixmap(self.boolTypeDDIcons[self.boolType-1])
        if not enabled:
            icons = [dimPixmap(p) for p in icons]
        btn.icons = icons
        btn.highlightable = enabled            

    def setEnabled(self, enabled):
        self.isOn = enabled

class DropListDelegate(fx.ListButtonDelegate):
    def _drawIcon(self, offset, icon, highlighted):
        w = icon.width() / icon.devicePixelRatio()
        h = icon.height() / icon.devicePixelRatio()

        newRect = deepcopy(self._rect)
        newRect.setLeft(self._rect.left() + offset)
        newRect.setTop(self._rect.top() + (newRect.height() - h) / 2.0)
        newRect.setWidth(w)
        newRect.setHeight(h)
        if highlighted: icon = fx.highlightPixmap(icon)
        self._painter.drawPixmap(newRect, icon)

    def paint(self, painter, option, index):
        """ Main entry point of drawing the cell """
        if not index.isValid(): return

        item = self.parent().itemFromIndex(index)
        self._rect = deepcopy(option.rect)
        self._painter = painter

        selected = option.state & qt.QStyle.State_Selected
        bgcolor = None
        if selected:
            bgcolor = option.palette.color(qt.QPalette.Highlight)
        else:
            bgcolor = item.rowBGColor

        self._drawBackground(index.row(), bgcolor, selected, item.isOn)
        self._drawColorBar(item.color)

        buttonName = ''
        if self.parent().hoverOver:
            row, button = self.parent().hoverOver
            if index.row()==row and button is not None:
                buttonName = button

        offset = self.parent().colorBarWidth
        self._drawIcon(offset, fx.fluxIcons['OutlinerDrag'], buttonName=='dragIndicator')
        
        for i, button in enumerate(item._leftButtons):
            btn_icon = button.icons[button.state]
            #if not item.isOn:
            #    btn_icon = dimPixmap(btn_icon)
            self._drawIcon(offset, btn_icon, (buttonName==button.name and button.highlightable))
            offset += self.parent().iconWidth
        
        offset += self.parent().iconWidth
        offset += pix(5)
        
        itemText = item.text()
        if item.isSmoothMesh: 
            itemText += ' (smooth)'
        
        self._drawText(offset, itemText, self.parent().palette().text().color())

        toggleOffset = pix(20)+self.parent().margins_toright if self.parent().showToggleButton else self.parent().margins_toright


        offset = self._rect.width() -toggleOffset -len(item._rightButtons) * (self.parent().rightIconWidth+self.parent().margins_rightbtns)
        for i, button in enumerate(item._rightButtons):
            btn_icon = button.icons[button.state]
            highlighted = (buttonName==button.name and button.highlightable)
            self._drawIcon(offset, btn_icon, highlighted)
            offset += self.parent().rightIconWidth+self.parent().margins_rightbtns

        if self.parent().showToggleButton:
            icon = None
            if item.isOn and selected:
                icon = fx.fluxIcons['Enable_Selected']
            elif item.isOn:
                icon = fx.fluxIcons['Enable']
            else:
                icon = fx.fluxIcons['Disable']
            self._drawIcon(offset
                #self._rect.width()-pix(20)-self.parent().margins_toright
                , icon, buttonName=='toggleButton')

        self._rect = None

class DropListWidget(qt.QWidget):
    dropped = qt.Signal(str)
    reorder = qt.Signal()
    deleted = qt.Signal(list,list)
    buttonClicked = qt.Signal(int, str)
    selected = qt.Signal()
    outMeshChanged = qt.Signal(qt.QListWidgetItem, list)
    
    def __init__(self, boolNode):
        qt.QWidget.__init__(self)
        fx.setVLayout(self)
        self.listWidget = ListWidget(boolNode)
        self.listWidget.objectName = "MASH_ListWidget"
        self.listWidget.dataDelegate = self
        self.listWidget.setFixedHeight(pix(250))
        self.listWidget.setDefaultDropAction(qt.Qt.MoveAction)
        self.listWidget.setDropIndicatorShown(True)
        self.listWidget.showDropIndicator = True
        self.listWidget.setSelectionMode(qt.QAbstractItemView.ExtendedSelection)
        self.listWidget.setItemDelegate(DropListDelegate(self.listWidget))
        self.listWidget.iconWidth = pix(24)
        self.layout().addWidget(self.listWidget)

    def keyPressEvent(self, event):
        if event.key() == qt.Qt.Key_Delete or event.key() == qt.Qt.Key_Backspace :
            event.accept()
            self.deleteNode()
            return
        event.ignore()

    def dropEvent(self, e):
        if e.mimeData().hasFormat('text/plain'): #Drop item from outside list widget
            self.dropped.emit(e.mimeData().text())
        else: #Drop list widget item(s)
            self.reorder.emit()

    def setupTreeMenu(self, treeMenu, position):
        if self.listWidget.currentItem():
            smoothMeshMenu = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kUseSMOutput' ]
            smoothMeshMenuToolTip = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kUseSMOutputTip' ]
            removeMenu = maya.stringTable['y_maya_plugin_polyBoolean_booltoolUI.kRemoveMenu' ]
            removeMenuItem = qt.QAction(removeMenu, self)
            removeMenuItem.triggered.connect(self.deleteNode)
            meshMenuItem = qt.QAction(smoothMeshMenu, self)
            meshMenuItem.triggered.connect(self.updateNodeMesh)
            meshMenuItem.setCheckable(True)
            meshMenuItem.setToolTip(smoothMeshMenuToolTip)
            meshMenuItem.setStatusTip(smoothMeshMenuToolTip)
            meshMenuItem.setChecked(self.listWidget.currentItem().isSmoothMesh)
            
            treeMenu.setToolTipsVisible(True)
            treeMenu.addAction(meshMenuItem)
            treeMenu.addAction(removeMenuItem)
                        
    def updateNodeMesh(self):
        if self.listWidget.selectedItems():   
            self.outMeshChanged.emit(self.listWidget.currentItem(), self.listWidget.selectedItems())
        
    def deleteNode(self):
        if self.listWidget.selectedItems():
           self.deleted.emit(self.listWidget.selectedItems(),self.listWidget.selectedIndexes())

    def selectionChanged(self):
        self.selected.emit()

    def buttonPressed(self, index, buttonName):
        self.buttonClicked.emit(index.row(), buttonName)

    def doubleClick(self, index, buttonName):
        self.buttonClicked.emit(index.row(), buttonName)

    def itemTextChangedAtIndex(self, index, oldValue, newValue):
        return newName

class ToggleButton(fx.ImageButton):
    def __init__(self, imageName, text=''):
        fx.ImageButton.__init__(self, imageName, text, 'right', False)
        self.hasHoverBackground = True
        self.layout().setContentsMargins(0,0,0,0)
        self.hoverBackgroundColor = qt.QColor(90,90,90,255)
        pixmap = fx.getPixmap(imageName)
        self.setImage(pixmap)
        self.setFixedHeight(pix(20))
        self.setFixedWidth(pix(20))
        self.isBtnOn = False

    def setBtnOn(self):
        self.isBtnOn = True
        p = self.palette()
        p.setColor(self.backgroundRole(), qt.QColor(51, 114, 152))
        self.setPalette(p)
        self.hoverBackgroundColor = qt.QColor(qt.QColor(51, 114, 152))

    def setBtnOff(self):
        self.isBtnOn = False
        p = self.palette()
        p.setColor(self.backgroundRole(), qt.QColor(0, 0, 0, 0))
        self.setPalette(p)
        self.hoverBackgroundColor = qt.QColor(90,90,90,255)

    def enterEvent(self, e):
        result = fx.ImageButton.enterEvent(self,e)
        if self.isBtnOn:
            self.setBtnOn()
        else:
            self.setBtnOff()

        return result

    def leaveEvent(self, e):
        result = fx.ImageButton.leaveEvent(self,e)
        if self.isBtnOn:
            self.setBtnOn()
        else:
            self.setBtnOff()
        return result

class ChoiceDropdown(qt.QDialog):
    choiceSelected = qt.Signal(int)
    def __init__(self, parent, pos, selected, icons, callback, texts):
        qt.QDialog.__init__(self, parent=parent)
        self.setWindowFlags(self.windowFlags() | qt.Qt.FramelessWindowHint)
        self.resize(fx.pix(130), fx.pix(60))
        self.setFixedHeight(self.height())
        self.choice = -1
        fx.setVLayout(self, 0,0,0,0,0)
        choices = range(len(icons))
        self.choiceSelected.connect(callback)

        for i in range(len(icons)):
            btn = fx.ImageButton(icons[choices[i]],texts[choices[i]],'right')
            btn.clicked.connect(lambda a=choices[i]: self.setChoice(a))
            btn.setFixedHeight(pix(20))
            #btn.setFixedWidth(pix(20))
            self.layout().addWidget(btn)

    def showEvent(self, e):
        qt.QDialog.showEvent(self, e)

    def closeWindow(self):
        self.choiceSelected.emit(self.choice)
        self.close()

    def setChoice(self,choice):
        self.choice = choice
        self.closeWindow()

    def focusOutEvent(self, event):
        self.closeWindow()

    @staticmethod
    def getChoice(parent, pos,selected,icons,callback, texts=[]):
        dialog = ChoiceDropdown(parent, pos, selected, icons,callback, texts)
        dialog.move(pos)
        result = dialog.show()
        dialog.setFocus()

def dimPixmap(pixmap):
    opt = qt.QStyleOption(0)
    opt.palette = qt.QGuiApplication.palette()
    return qt.QApplication.style().generatedIconPixmap(qt.QIcon.Disabled,pixmap,opt)

def decoratePixmap(original):
    pixmap2 = qt.QPixmap(fx.dpi(cs.dropdownIconWidth), fx.dpi(cs.dropdownIconHeight))
    pixmap2.setDevicePixelRatio(original.devicePixelRatio())
    pixmap2.fill(qt.QColor(0, 0, 0, 0))
    painter = qt.QPainter(pixmap2)
    painter.setRenderHint(qt.QPainter.Antialiasing, True)
    painter.setPen(qt.QColor(0, 0, 0, 0))
    painter.setBrush(qt.QColor(0,0,0,0))

    w = original.width() / original.devicePixelRatio()
    h = original.height() / original.devicePixelRatio()

    painter.drawPixmap(0, 0, original)
    #Disable overlay icon drawing
    #painter.drawPixmap(0, 0, fx.getPixmap('Bool_Dropdown'))

    painter.end()

    return pixmap2

def depressPixmap(original):
    pixmap = qt.QPixmap(fx.dpi(cs.dropdownIconWidth), fx.dpi(cs.dropdownIconHeight))
    pixmap.setDevicePixelRatio(original.devicePixelRatio())
    #pixmap.fill(qt.QColor(42, 42, 42))
    pixmap.fill(qt.QColor(32,133,177))

    painter = qt.QPainter(pixmap)
    painter.setRenderHint(qt.QPainter.Antialiasing, True)
    painter.setPen(qt.QColor(0, 0, 0, 0))
    painter.setBrush(qt.QColor(0,0,0,0))

    w = original.width() / original.devicePixelRatio()
    h = original.height() / original.devicePixelRatio()

    painter.drawPixmap(0, 0, original)
    painter.end()
    return pixmap

def decoratedPixmap(name):
    original = fx.getPixmap(name)
    original = decoratePixmap(original)

    return [original]

def makeCircle(color):
    pixmap = qt.QPixmap(pix(100),pix(100))
    pixmap.fill(qt.QColor(0,0,0,0))
    painter = qt.QPainter(pixmap)
    painter.setPen(qt.QColor(0,0,0,0))
    painter.setBrush(color)
    painter.drawEllipse(pix(35),pix(35),pix(30),pix(30))
    painter.end()
    return qt.QIcon(pixmap).pixmap(pix(20),pix(20))
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
