from __future__ import division
import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
from builtins import range
from maya.app.general.mayaMixin import MayaQWidgetBaseMixin, MayaQWidgetDockableMixin
from PySide2.QtWidgets import QFrame, QWidget, QDialog, QVBoxLayout, QHBoxLayout, QLabel,QToolButton,QLineEdit, QSizePolicy, QPushButton, QScrollArea, QGridLayout, QSizePolicy, QLayout
from PySide2.QtGui import  QIcon, QColor, QPainter, QPixmap, QBrush, QPen, QIntValidator, QPalette, QPainterPath, QConicalGradient, QPainterPath
from PySide2.QtCore import Qt, QRectF
import maya.cmds as cmds
import maya.api.OpenMaya as om2
import maya.utils as utils
import maya.mel as mel
import maya.plugin.timeSliderBookmark.timeSliderBookmark as timeSliderBookmark
from maya.common.ui import highlight_colour
import maya.OpenMayaUI as mui
from shiboken2 import wrapInstance
import maya.OpenMayaUI as omui

CREATE_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/createBookmark.png")), QIcon)
FRAME_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/frameBookmark.png")), QIcon)
UPDATE_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/updateBookmark.png")), QIcon)
DELETE_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/delete.png")), QIcon)
LEFT_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/previousBookmark.png")), QIcon)
CURRENT_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/frameCBookmark.png")), QIcon)
RIGHT_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/nextBookmark.png")), QIcon)
VISIBLE_ICON = wrapInstance(int(mui.MQtUtil.createIcon(":/visible.png")), QIcon)
HIDDEN_ICON =  wrapInstance(int(mui.MQtUtil.createIcon(":/hidden.png")), QIcon)


RUNTIME_FRAME_BOOKMARK_CMD = "FrameTimeSliderBookmark"
RUNTIME_FRAME_BOOKMARK_NEXT_CMD = "FrameNextTimeSliderBookmark"
RUNTIME_FRAME_BOOKMARK_PREVIOUS_CMD = "FramePreviousTimeSliderBookmark"
DELETE_BOOKMARK_AT_CURRENT_TIME_CMD = "DeleteCurrentBookmark"
DELETE_ALL_BOOKMARK_CMD = "DeleteAllBookmarks"
BOOKMARK_TOGGLE_VISIBILITY_CMD = "ToggleBookmarkVisibility"
BOOKMARK_UPDATE_CMD = "UpdateBookmarkWithSelection"


def get_rounded_frame(frame):
    frame = round(frame, 2)
    if int (frame * 10) % 10 == 0:
        frame = int(frame)
    return str(frame)


class MayaScriptJobhandler(object):
    """
        Utility class to handle the unregistration of callback and script job
    """
    def __init__(self, **kwargs):
        super(MayaScriptJobhandler,self).__init__(**kwargs)
        self.jobs = []
        self.callbacks = []

    def addJob(self, job):
        self.jobs.append(job)

    def addDGMessageCallback(self, callbackId):
        self.callbacks.append(callbackId)

    def tearDown(self):
        [cmds.scriptJob(k=j) for j in self.jobs]
        self.jobs = []
        [om2.MMessage.removeCallback(c) for c in self.callbacks]
        self.callbacks = []

class Separator(QFrame):
    """Simple Widget that shows as a line either horizontal or vertical"""
    def __init__(self,parent=None, horizontal=True):
        super(Separator, self).__init__(parent=parent)
        if horizontal:
            self.setFrameShape(QFrame.HLine)
        else:
            self.setFrameShape(QFrame.VLine)
        self.setFrameShadow(QFrame.Sunken)


class ColorButton(QToolButton):
    """
        Tool Button that display a color
    """
    def __init__(self, color, parent=None):
        super(ColorButton, self).__init__(parent=parent)
        self.color = color
        self.highlight = False

    def updateColor(self, color):
        """
            change the current color and force an update to redraw itself
        """
        self.color = color
        self.update(self.visibleRegion())

    def heightForWidth(self, w):
        return w

    def setHilight(self, hi):
        self.highlight = hi
        self.update()

    def getBrush(self):
        return QBrush(self.color)

    def fillRoundRect(self, painter, rect, radius):
        painter.setRenderHint(QPainter.Antialiasing, True)
        rounded_rect = QPainterPath()
        rounded_rect.addRoundRect(rect, radius, radius)
        painter.setClipPath(rounded_rect)

        painter.fillPath(rounded_rect, painter.brush())
        painter.drawPath(rounded_rect)

    def drawRoundedRect(self):
        # We don't use simple drawRoundedRect because of some pixel artifacts
        # Workaround taken from https://stackoverflow.com/questions/6507511/qt-round-rectangle-why-corners-are-different
        borderSize = mui.MQtUtil.dpiScale(3)
        borderRadius = mui.MQtUtil.dpiScale(2)

        if self.highlight:
            hicolor = [x *255 for x in highlight_colour()]
            borderColor = QColor(*hicolor)
        else:
            borderColor = self.getBrush()
            borderSize = mui.MQtUtil.dpiScale(1)

        pen = QPen(borderColor, borderSize)

        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing, True)
        painter.setPen(pen)

        rect = QRectF(self.rect().x() + borderSize / 2.0,
                      self.rect().y() + borderSize / 2.0,
                      self.rect().width() - borderSize,
                      self.rect().height() - borderSize)

        if borderSize % 2 == 0:
            painter.drawRoundedRect(rect, borderSize, borderSize)
        else:
            painter.drawRoundedRect(rect.translated(0.5, 0.5), borderRadius, borderRadius)

        brush = self.getBrush()
        pen.setBrush(brush)
        painter.setBrush(brush)

        if borderSize  % 2 == 0:
            painter.drawRoundedRect(rect, borderRadius, borderRadius)
        else:
            painter.drawRoundedRect(rect.translated(0.5, 0.5), borderRadius, borderRadius)

        painter.end()


    def paintEvent(self, event):
        """
        Override paintEvent from QWidget to draw the desired color
        """
        self.drawRoundedRect()


class RainbowButton(ColorButton):
    def getBrush(self):
        if self.color == None:
            gradient =  QConicalGradient(self.width()/2.0,self.height()/2, 0)
            gradient.setColorAt(0,Qt.red)
            gradient.setColorAt(0.33,Qt.green)
            gradient.setColorAt(0.66,Qt.blue)
            gradient.setColorAt(1,Qt.red)
            return QBrush(gradient)
        else:
            return super(RainbowButton,self).getBrush()

def makeBookmarkLineControl(layout):
    """
        Utility function that create a Color Button, and 3 line edit (name, start, end)
    """
    rndColor = timeSliderBookmark.pickColor()
    color = ColorButton(QColor(*rndColor))
    layout.addWidget(color)
    name = QLineEdit()
    layout.addWidget(name, stretch=1)
    start = QLineEdit()
    startValidator = QIntValidator(start)
    start.setValidator(startValidator)
    stop  = QLineEdit()
    stopValidator = QIntValidator(stop)
    stop.setValidator(stopValidator)
    layout.addWidget(start)
    layout.addWidget(stop)
    return (color, name, start, stop)



class BookmarkCreateLine(QWidget):
    """
        Control that deals with creation of bookmark
    """
    def __init__(self, parent=None):
        super(BookmarkCreateLine, self).__init__(parent=parent)

        layout = QHBoxLayout()
        self.color, self.name, self.start, self.stop = makeBookmarkLineControl(layout)
        self.name.setPlaceholderText(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkName' ])
        self.start.setPlaceholderText(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkStart' ])
        self.stop.setPlaceholderText(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkEnd'])

        add =  QPushButton()
        add.setText(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkAdd' ])
        layout.addWidget(add)
        self.setLayout(layout)
        layout.setContentsMargins(0,0,0,0)
        add.clicked.connect(self.onAdd)
        self.color.clicked.connect(self.onColor)

    def onColor(self):
        """Color button has been clicked on.
           Pop out the colorEditor to let user choose a new color.
        """
        cmds.colorEditor(rgb=[1,0,0])
        if cmds.colorEditor(q=True, r=True): #if we got something selected (not cancelled)
            color = cmds.colorEditor(q=True, rgb=True)
            color = [x*255 for x in color]
            self.color.updateColor(QColor(*color))


    def onAdd(self):
        """
            On Add button pressed, create a bookmark with information given on this control
        """
        start = self.start.text()
        stop = self.stop.text()
        start = start if start != "" else None
        stop = stop if stop != "" else None
        color = self.color.color.red(), self.color.color.green(), self.color.color.blue()
        color = [x/255.0 for x in color]
        cmds.undoInfo(openChunk=True)
        try:
            timeSliderBookmark.createBookmark(name=self.name.text(), start=start, stop=stop, color=color)
        finally:
            cmds.undoInfo(closeChunk=True)

def createRuntimeButton(icon, command_name=None, annotation=None):
    button = QToolButton()

    if command_name and annotation is None:
        annotation = cmds.runTimeCommand(command_name, query=True, annotation=True)

    button.setToolTip(annotation)
    button.setStatusTip(annotation)
    button.setIcon(icon)
    button.setAutoRaise(True)
    return button

class BookmarkLine(MayaScriptJobhandler, QWidget):
    """
        Widget that display bookmark to allow user to edit the color, name, start and end
    """
    def __init__(self, bookmarkObject, parent=None):
        super(BookmarkLine, self).__init__(parent=parent)

        self.bookmarkObject = bookmarkObject
        layout = QHBoxLayout()
        self.color, self.name, self.start, self.stop =  makeBookmarkLineControl(layout)

        self.name.editingFinished.connect(self.nameChanged)
        self.start.editingFinished.connect(self.startChanged)
        self.stop.editingFinished.connect(self.stopChanged)

        self.connectScriptJob()

        frame = createRuntimeButton(FRAME_ICON, RUNTIME_FRAME_BOOKMARK_CMD)
        frame.clicked.connect(self.onFrame)

        update = createRuntimeButton(UPDATE_ICON, BOOKMARK_UPDATE_CMD)
        update.clicked.connect(self.onUpdate)

        deletebm = createRuntimeButton(DELETE_ICON, DELETE_BOOKMARK_AT_CURRENT_TIME_CMD)
        deletebm.clicked.connect(self.onDelete)

        self.color.clicked.connect(self.onColor)

        layout.addWidget(update)
        layout.addWidget(frame)
        layout.addWidget(deletebm)

        self.setLayout(layout)
        m = layout.contentsMargins()
        layout.setContentsMargins(0,0,0,0) #remove space around the frame, to get icon aligned properly
        self.update()
        self.destroyed.connect(lambda : self.tearDown())




    def onColor(self):
        """
            color clicked, trigger color editor to edit the bookmark color attribute
        """
        #editAttributeColor will trigger a attributeChange event which will redraw the color button
        mel.eval('editAttributeColor("%s.color")'%(self.bookmarkObject))

    def onUpdate(self):
        """
            on update clicked, update the bookmark from the current timeslider range selection
        """
        timeSliderBookmark.updateBookmark(self.bookmarkObject)

    def onFrame(self):
        """
        When frame button clicked, frame the playrange min/max to the bookmark
        """
        timeSliderBookmark.frameBookmark(self.bookmarkObject)

    def onDelete(self):
        """
            On delete button pressed, delete the associated bookmark
        """
        timeSliderBookmark.deleteBookmark(self.bookmarkObject)

    def connectScriptJob(self):
        """
            listen to attribute change event on information about this self.bookmarkObject
        """
        self.addJob(cmds.scriptJob(attributeChange=[self.bookmarkObject + ".color", self.update] ))
        self.addJob(cmds.scriptJob(attributeChange=[self.bookmarkObject + ".name", self.update] ))
        self.addJob(cmds.scriptJob(attributeChange=[self.bookmarkObject + ".timeRangeStart", self.update] ))
        self.addJob(cmds.scriptJob(attributeChange=[self.bookmarkObject + ".timeRangeStop", self.update] ))


    def nodeRenamed(args, newName):
        """
            Upon event received on name change of the bookmark object,
            update its internal value to allows requested user command to be sent with proper name
        """
        self.bookmarkObject = newName

    def nameChanged(self):
        """
            Name widget changed set the name attribute on self.bookmarkObject
        """
        cmds.setAttr(self.bookmarkObject + ".name", self.name.text(), type="string")

    def startChanged(self):
        """
            Start time changed, update self.bookmarkObject
        """
        cmds.setAttr(self.bookmarkObject + ".timeRangeStart", self.start.text())

    def stopChanged(self):
        """
            Stop time changed, update self.bookmarkObject
        """
        cmds.setAttr(self.bookmarkObject + ".timeRangeStop", self.stop.text())

    def update(self):
        """
            update all control, get all useful attribute and set it on widget
        """
        mayacolor = (cmds.getAttr(self.bookmarkObject + ".color")[0])
        self.color.updateColor(QColor(*[x*255 for x in mayacolor]))

        lbl = cmds.getAttr(self.bookmarkObject + ".name")
        start = cmds.getAttr(self.bookmarkObject + ".timeRangeStart")
        stop = cmds.getAttr(self.bookmarkObject + ".timeRangeStop")
        self.name.setText(lbl)
        self.start.setText(get_rounded_frame(start))
        self.stop.setText(get_rounded_frame(stop))


class TopBarBookmarkManager(QWidget):
    """
        Toolbar containing previous, current and next framing.
        Also visibility, frame all and delete all.
    """

    def __init__(self, parent=None):
        super(TopBarBookmarkManager, self).__init__(parent=parent)
        layout = QHBoxLayout()

        self.visible = QPushButton()
        visible_annotation = cmds.runTimeCommand(BOOKMARK_TOGGLE_VISIBILITY_CMD, query=True, annotation=True)
        self.visible.setToolTip(visible_annotation)
        self.visible.setStatusTip(visible_annotation)

        left = createRuntimeButton(LEFT_ICON, RUNTIME_FRAME_BOOKMARK_PREVIOUS_CMD)
        right = createRuntimeButton(RIGHT_ICON, RUNTIME_FRAME_BOOKMARK_NEXT_CMD)
        current = createRuntimeButton(CURRENT_ICON, RUNTIME_FRAME_BOOKMARK_CMD)

        layout.addWidget(left)
        layout.addWidget(current)
        layout.addWidget(right)
        layout.addWidget(Separator(horizontal=False))
        layout.addWidget(self.visible)

        layout.addStretch()

        frame = createRuntimeButton(FRAME_ICON, annotation=maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkFrameAllBookmarks'])
        deletebm = createRuntimeButton(DELETE_ICON, DELETE_ALL_BOOKMARK_CMD)

        layout.addWidget(frame)
        layout.addWidget(deletebm)

        self.setLayout(layout)
        layout.setContentsMargins(0,0,0,0)
        left.clicked.connect(lambda : timeSliderBookmark.framePreviousBookmarkAtCurrentTime())
        right.clicked.connect(lambda : timeSliderBookmark.frameNextBookmarkAtCurrentTime())
        current.clicked.connect(lambda : timeSliderBookmark.frameBookmarkAtCurrentTime())
        self.visible.clicked.connect(lambda : self.onVisible())
        deletebm.clicked.connect(lambda : timeSliderBookmark.deleteAllBookmark())
        frame.clicked.connect(lambda : timeSliderBookmark.frameAllBookmark())
        self.updateVisibilityIcon()


    def onVisible(self):
        """
            when visibility got clicked toggle the bookmark visibility
        """
        timeSliderBookmark.setBookmarkVisibility(not timeSliderBookmark.getBookmarkVisibility())
        self.updateVisibilityIcon()


    def updateVisibilityIcon(self):
        """
            Synchronize the icon status with the option var state
        """
        if timeSliderBookmark.getBookmarkVisibility():
            self.visible.setIcon(VISIBLE_ICON)
            color = [x *255 for x in highlight_colour()]
            pal = self.visible.palette()
            pal.setColor(QPalette.Button, QColor(*color))
            self.visible.setPalette(pal)
        else:
            self.visible.setIcon(HIDDEN_ICON)
            self.visible.setPalette(self.palette())



class BookmarkManager(MayaQWidgetDockableMixin,MayaScriptJobhandler, QDialog):
    """
    Bookmark manage aggregate all widget abbove to be able to create/edit and navigate bookmark
    """
    def __init__(self, parent=None, onClose=None):
        super(BookmarkManager, self).__init__(parent=parent)

        self.updateId = 0
        self.setObjectName('Bookmark Manager')
        self.setWindowTitle(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkManagerTitle' ])
        self.bmlines = []
        self.onClose = onClose
        layout = QVBoxLayout()

        topBar = TopBarBookmarkManager()
        layout.addWidget(topBar)
        layout.addWidget(Separator())

        self.arealines = QScrollArea()
        self.arealines.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
        self.arealines.setVerticalScrollBarPolicy(Qt.ScrollBarAsNeeded)
        self.arealines.setFrameShape(QFrame.NoFrame)
        self.arealines.setWidgetResizable(True)
        #Build UI

        layout.addWidget(self.arealines)

        sep = Separator()
        layout.addWidget(sep)

        create = BookmarkCreateLine()
        layout.addWidget(create)

        self.updateUI()

        self.setLayout(layout)

        self.destroyed.connect(lambda : self.tearDown())

        self.addDGMessageCallback(om2.MDGMessage.addNodeAddedCallback( self.onNodeBookmarkNodeAdded, 'timeSliderBookmark'))
        self.addDGMessageCallback(om2.MDGMessage.addNodeRemovedCallback( self.onNodeBookmarkNodeRemoved, 'timeSliderBookmark'))


    def done(self, status):
        """dialog is done, tear down widget to unregister all callbacks"""
        self.tearDown()
        if self.onClose:
            self.onClose()
        return super(BookmarkManager, self).done(status)

    def onNodeBookmarkNodeAdded(self, *args):
        """
            When bookmark node gets added, it update the current UI.
            the event are sent at improper time befor the object
            was created so we need to defer the UI creation.
            the UpdateId are needed to avoid updating multiple time upon multiple bookmark creation
            (happen often in undo/redo)
        """
        self.updateId = self.updateId + 1
        updateId = self.updateId
        utils.executeDeferred(lambda : self.updateUI(updateId = updateId))

    def onNodeBookmarkNodeRemoved(self, *args):
        """
            Before  bookmark get removed we defer an update
            so that at next Idle the scene will contain proper information
        """
        #important to defer to Idle since 'removed' node is still in the current scene
        self.updateId = self.updateId + 1
        updateId = self.updateId
        utils.executeDeferred(lambda : self.updateUI(updateId = updateId))

    def updateUI(self, updateId=None):
        """
            Fill up the bookmark manager from the scene
        """
        if updateId != None and updateId != self.updateId:
            return
        [(bmline.tearDown(), bmline.setParent(None)) for bmline in self.bmlines]
        tsbs = cmds.ls(type="timeSliderBookmark")
        sorted_bookmarks = sorted(tsbs, key=lambda bookmark: (cmds.getAttr(bookmark + ".timeRangeStart"), cmds.getAttr(bookmark + ".timeRangeStop")))

        lines = QWidget()
        bmlineLayout = QVBoxLayout()
        lines.setLayout(bmlineLayout)

        for tsb in sorted_bookmarks:
            bmline = BookmarkLine(tsb)
            self.addJob(cmds.scriptJob(nodeNameChanged=[tsb, self.updateUI] ))
            bmlineLayout.addWidget(bmline)
            self.bmlines.append(bmline)

        bmlineLayout.addStretch()
        bmlineLayout.setContentsMargins(0,0,0,0) #remove space around the frame, to get icon aligned properly
        self.arealines.setWidget(lines)
        lines.show()


    def run(self):
        self.show(dockable = True)

globalBookmarkManager = None

def showBookmarkManager():
    global globalBookmarkManager
    if not globalBookmarkManager:
        globalBookmarkManager = BookmarkManager()
    globalBookmarkManager.show(dockable = True)

class ColorPalette(QWidget):
    Colors = [ QColor(x,y,z) for x,y,z in timeSliderBookmark.DefaultColors]
    Colors =  Colors + [
        QColor(255, 255, 255),
        QColor(153, 153, 153),
        QColor(102, 102, 102),
        QColor(60,60,60),
        QColor(0,0,0),
        QColor() #custom color placholder
    ]
    def __init__(self):
        super(ColorPalette, self).__init__()
        self.selectedWidget = None
        self.colorWidgets = []
        layout = QGridLayout()
        for i in range(4):#lines
            for j in range(6): #column
                idx = i*6 + j
                if idx ==  len(ColorPalette.Colors) -1:
                    cb = RainbowButton(None)
                else:
                    cb = ColorButton(ColorPalette.Colors[idx])
                self.colorWidgets.append(cb)
                if  self.selectedWidget == None:
                    self.onColorSelected(idx, cb)
                cb.clicked.connect(lambda idx=idx, cb=cb: self.onColorSelected(idx, cb))
                sp = QSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
                sp.setHeightForWidth(True)
                cb.setSizePolicy(sp)
                layout.addWidget(cb,i,j)
        self.setLayout(layout)


    def onColorSelected(self, idx, widget):
        if self.selectedWidget != None:
            self.selectedWidget.setHilight(False)
        self.selected = idx
        self.selectedWidget = widget
        widget.setHilight(True)
        if idx == len(ColorPalette.Colors) -1 :
            cmds.colorEditor(rgb=[1,0,0])
            if cmds.colorEditor(q=True, r=True): #if we got something selected (not cancelled)
                color = cmds.colorEditor(q=True, rgb=True)
                color = [x*255 for x in color]
                widget.updateColor(QColor(*color))

    def setCustomColor(self, color):
        if self.selectedWidget != None:
            self.selectedWidget.setHilight(False)
            self.selected =  len(ColorPalette.Colors) -1
            self.selectedWidget = self.colorWidgets[self.selected]
            self.colorWidgets[self.selected].setHilight(True)
            self.colorWidgets[self.selected].updateColor(color)

    def color(self):
        return self.selectedWidget.color if self.selectedWidget != None else QColor(0,0,0)

def getMainWindowWidget():
    mainWindowPtr = omui.MQtUtil.mainWindow()
    return wrapInstance(int(mainWindowPtr), QWidget)

class CreateBookmarkDialog(MayaQWidgetBaseMixin, QDialog):
    DIALOG_WIDTH = mui.MQtUtil.dpiScale(274)
    DIALOG_HEIGHT = mui.MQtUtil.dpiScale(316)
    def __init__(self, parent=None, **kwargs):
        if parent is None:
            parent = getMainWindowWidget()

        super(CreateBookmarkDialog, self).__init__(parent=parent, **kwargs)
        self.setWindowTitle(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkCreateBookmark' ])

        layout = QVBoxLayout()
        name = QLabel(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkNameLabel' ])
        layout.addWidget(name)
        self.nameEdit = QLineEdit()
        layout.addWidget(self.nameEdit)
        color = QLabel(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkColorLabel' ])
        layout.addWidget(color)

        self.cp = ColorPalette()
        hbox = QHBoxLayout()
        hbox.addWidget(self.cp)
        layout.addLayout(hbox)

        hbox = QHBoxLayout()
        hbox.addWidget(QLabel(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkStartLabel' ]))
        self.start = QLineEdit()
        hbox.addWidget(self.start)
        hbox.addWidget(QLabel(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkEndLabel' ]))
        self.end = QLineEdit()
        hbox.addWidget(self.end)
        layout.addLayout(hbox)

        hbox = QHBoxLayout()
        self.ok = QPushButton(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkCreate' ])
        self.ok.setDefault(True);
        self.ok.clicked.connect(self.onOk)

        cancel = QPushButton(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkCancel' ])
        cancel.clicked.connect(self.onCancel)

        hbox.addWidget(self.ok)
        hbox.addWidget(cancel)
        layout.addLayout(hbox)

        layout.setSizeConstraint(QLayout.SetFixedSize)
        self.setLayout(layout)
        self.resize(self.DIALOG_WIDTH, self.DIALOG_HEIGHT)

        rng = timeSliderBookmark.getCurrentPlayRange()
        self.start.setText(get_rounded_frame(rng[0]))
        self.end.setText(get_rounded_frame(rng[1]))

    def onOk(self):
        c = self.cp.color()
        name = self.nameEdit.text()
        start = self.start.text()
        end = self.end.text()
        color = [c.redF(), c.greenF(), c.blueF()]
        #undo chunk since we are in a modal dialog
        cmds.undoInfo(openChunk=True)
        try:
            timeSliderBookmark.createBookmark(name=name, start=start, stop=end, color=color)
        finally:
            cmds.undoInfo(closeChunk=True)
        self.accept()

    def onCancel(self):
        self.reject()

class EditBookmarkDialog(CreateBookmarkDialog):
    def __init__(self, bookmark=None, **kwargs):
         super(EditBookmarkDialog, self).__init__(**kwargs)
         self.setWindowTitle('Edit bookmark')
         self.bookmark = bookmark
         self.ok.setText(maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kBookmarkEdit' ])
         if bookmark != None:
            start = cmds.getAttr(bookmark + ".timeRangeStart")
            stop = cmds.getAttr(bookmark + ".timeRangeStop")
            color = cmds.getAttr(bookmark + ".color")[0]
            name = cmds.getAttr(bookmark + ".name")
            self.start.setText(get_rounded_frame(start))
            self.end.setText(get_rounded_frame(stop))
            c = [x*255.0 for x in color]
            self.cp.setCustomColor(QColor(*c))
            self.nameEdit.setText(name)


    def onOk(self):
        c = self.cp.color()
        name = self.nameEdit.text()
        start = self.start.text()
        end = self.end.text()
        color = [c.redF(), c.greenF(), c.blueF()]
        #undo chunk since we are in a modal dialog
        cmds.undoInfo(openChunk=True)
        try:
            cmds.setAttr(self.bookmark + ".timeRangeStart ", start)
            cmds.setAttr(self.bookmark + ".timeRangeStop ",  end)
            cmds.setAttr(self.bookmark + ".color", *color)
            cmds.setAttr(self.bookmark + ".name", name, type="string")
        finally:
            cmds.undoInfo(closeChunk=True)
        self.accept()

STR_NOBOOKMARK = maya.stringTable['y_maya_plugin_timeSliderBookmark_bookmarkManager.kNoBookmarkAtTime' ]

def editCurrentBookmark():
    bm = timeSliderBookmark.getBookmarkAtCurrentTime()
    if bm != None:
        EditBookmarkDialog(bookmark=bm).show()
    else:
        cmds.error(STR_NOBOOKMARK)

def editBookmarkAtTime(value, time):
    bm = timeSliderBookmark.getBookmarkAtTime(time)
    if bm != None:
        EditBookmarkDialog(bookmark=bm).show()
    else:
        cmds.error(STR_NOBOOKMARK)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
