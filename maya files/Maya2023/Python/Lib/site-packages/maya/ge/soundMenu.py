import maya
maya.utils.loadStringResourcesForModule(__name__)

from builtins import object
import maya
from future.utils import with_metaclass
maya.utils.loadStringResourcesForModule(__name__)

import maya.cmds as cmds
import maya.mel

from maya.common.utils import Singleton
from maya.common.ui import callback_tool
from functools import partial
from maya.app.prefs.OptionVar import option_var_set_value, OPTION_VAR_TYPE_STRING
from maya.ge.sound_preferences import SoundPreferenceVolume, SoundPreferenceVolumeBeforeMute, SoundPreferencesWaveformDisplayType


WAVEFORM_MENUS = [
    ( maya.stringTable['y_maya_ge_soundMenu.kTop' ], "top",
     maya.stringTable['y_maya_ge_soundMenu.kWaveformTopAnnot' ]),
    (maya.stringTable['y_maya_ge_soundMenu.kBottom'], "bottom",
     maya.stringTable['y_maya_ge_soundMenu.kWaveformBottomAnnot'  ]),
    (maya.stringTable['y_maya_ge_soundMenu.kCentered' ],
     "both", maya.stringTable['y_maya_ge_soundMenu.kWaveformCenteredAnnot' ])
]
MAX_SOUNDS_COUNT = 30

DELETE_SOUND_ANNOTATION = maya.stringTable['y_maya_ge_soundMenu.kDeleteSoundAnnot' ]
SELECT_SOUND_ANNOTATION = maya.stringTable['y_maya_ge_soundMenu.kSelectSoundAnnot' ]

MULTIPLE_TRACKS_LABEL = maya.stringTable['y_maya_ge_soundMenu.kUseTraxSounds' ]
MULTIPLE_TRACKS_ANNOTATION = maya.stringTable['y_maya_ge_soundMenu.kUseTraxSoundsAnnot' ]


def is_sound_on():
    return SoundPreferenceVolume().get_value() != 0


def on_mute_click_callback(is_sound_enabled):
    if not is_sound_enabled:
        saved_volume = SoundPreferenceVolumeBeforeMute().get_value()
        SoundPreferenceVolume().set_value(saved_volume)
    else:
        current_volume = SoundPreferenceVolume().get_value()
        SoundPreferenceVolumeBeforeMute().set_value(current_volume)
        SoundPreferenceVolume().set_value(0)


def playback_slider_id():
    return maya.mel.eval('$tmpVar=$gPlayBackSlider')


def show_sound_slider():
    cmds.soundPopup(parent=SoundMenu().get_button_layout())


def set_sound_display(node, state=1):
    playback_slider = playback_slider_id()
    cmds.timeControl(playback_slider, edit=True, ds=state, s=node)

    is_played = cmds.play(query=True, state=True)
    if is_played:
        direction = cmds.play(query=True, forward=True)
        if state:
            cmds.play(sound=node, forward=direction)
        else:
            cmds.play(forward=direction)


def off_sound_callback(value):
    current_audio = cmds.timeControl(playback_slider_id(), query=True, sound=True)
    set_sound_display(current_audio, 0)


def off_sound_item():
    return cmds.menuItem(label=maya.stringTable['y_maya_ge_soundMenu.kOff' ]
                        ,annotation=maya.stringTable['y_maya_ge_soundMenu.kOffAnnot' ]
                         , radioButton=True

                         , command=off_sound_callback
                         )


def options_box_callback(tool, sound_name):
    maya.mel.eval('showEditor {}'.format(sound_name))


def use_trax_sound_item():
    is_active_sound = cmds.timeControl(playback_slider_id(), displaySound=True, query=True)

    return cmds.menuItem(label=MULTIPLE_TRACKS_LABEL
                         , annotation=MULTIPLE_TRACKS_ANNOTATION
                         , radioButton=is_active_sound
                         , command=callback_tool(None, partial(on_select_sound, sound_name=""))
                         )


def on_select_sound(tool, sound_name):
    set_sound_display(sound_name)

def on_delete_sound(tool, sound_name):
    cmds.delete(sound_name)

WID_NO_SOUND_ID = "no_sound"
WID_OFF_SOUND_ID = "off"
WID_TRAX_SOUND_ID = "trax"
WID_AUDIO_OPT_TEMPLATE = "{}_opt"

def create_sound_submenu(sound_list, is_delete_mode=False, use_radio=False, show_off_button=False, show_option_box=False):
    widgets = {}

    if len(sound_list) == 0:
        widgets[WID_NO_SOUND_ID] = cmds.menuItem(label=maya.stringTable['y_maya_ge_soundMenu.kNoSounds' ], enable=False)

    else:
        if use_radio and show_off_button:
            cmds.radioMenuItemCollection()
            widgets[WID_OFF_SOUND_ID] = off_sound_item()
            widgets[WID_TRAX_SOUND_ID] = use_trax_sound_item()

        current_audio = cmds.timeControl(playback_slider_id(), query=True, sound=True)
        for audio in sound_list[:MAX_SOUNDS_COUNT]:
            annotation = DELETE_SOUND_ANNOTATION if is_delete_mode else SELECT_SOUND_ANNOTATION
            on_select_callback = on_delete_sound if is_delete_mode else on_select_sound
            is_current_sound = audio == current_audio

            if use_radio:
                widgets[audio] = cmds.menuItem(label=audio, radioButton=is_current_sound, annotation=annotation,
                              command=callback_tool(None, partial(on_select_callback, sound_name=audio)))
            else:
                widgets[audio] = cmds.menuItem(label=audio, annotation=annotation,
                              command=callback_tool(None, partial(on_select_callback, sound_name=audio)))

            if show_option_box:
                annotation = maya.stringTable['y_maya_ge_soundMenu.kOpenAttrEd' ].format(audio)
                widgets[WID_AUDIO_OPT_TEMPLATE.format(audio)] = cmds.menuItem(enableCommandRepeat=True, optionBox=True, annotation=annotation,
                              command=callback_tool(None, partial(options_box_callback, sound_name=audio)))
    return widgets





def callback_update_ui(tool):
    """
    :param SoundMenu tool: tool to update UI
    """
    tool.update_ui()


class SoundPopupMenu(object):
    WID_DELETE_SOUND = 1
    WID_MUTE_SOUND = 2
    WID_WAVEFORM_DISPLAY = 3
    WID_IMPORT_AUDIO = 4
    WID_SLIDER = 5
    WID_TOP_MENU = 6
    WID_IMPORT_AUDIO_TO_TE = 7

    @staticmethod
    def on_waveform_display_changed(value, display_type):
        SoundPreferencesWaveformDisplayType().set_value(display_type)
        cmds.timeControl(playback_slider_id(), edit=True, waveform=display_type)

    @staticmethod
    def on_import_audio_callback(value):
        option_var_set_value("defaultFileImportType", OPTION_VAR_TYPE_STRING, "audio")
        cmds.Import()

    @staticmethod
    def on_import_audio_clip_to_te(value):
        cmds.TimeEditorWindow()
        cmds.TimeEditorCreateAudioClip()

    @staticmethod
    def on_adjust_volume_callback(value):
        show_sound_slider()

    def create_waveform_display_menu(self):
        cmds.radioMenuItemCollection()
        current_waveform = SoundPreferencesWaveformDisplayType().get_value()
        for menu_label, opt_name, annotation in WAVEFORM_MENUS:
            self.widgets[opt_name] = cmds.menuItem(label=menu_label, radioButton=opt_name==current_waveform, annotation=annotation,
                        command=partial(self.on_waveform_display_changed, display_type=opt_name) )

    def __init__(self, parent):
        self.parent = parent
        self.widgets = {}

        SoundPreferenceVolume().add_client(self, callback_tool(self, callback_update_ui))
        SoundPreferencesWaveformDisplayType().add_client(self, callback_tool(self, callback_update_ui))
        cmds.scriptJob(uiDeleted=(self.parent, self.callback_ui_deleted))
        self.script_jobs = []
        self.current_sound_list = []

    def build(self, with_adjust_volume=True):
        if not self.script_jobs:
            self.script_jobs = [
                cmds.scriptJob(event=("currentSoundNodeChanged", self.on_sound_selection_changed))
            ]
            SoundListHandler().add_sound_list_changed_callback(self.on_sound_list_changed)

        self.widgets[self.WID_IMPORT_AUDIO] = cmds.menuItem(label=maya.stringTable[ 'y_maya_ge_soundMenu.kImportAudio'  ]
                                                            ,annotation=maya.stringTable[ 'y_maya_ge_soundMenu.kImportAudioAnnot'  ]
                                                            ,command=self.on_import_audio_callback)

        self.widgets[self.WID_IMPORT_AUDIO_TO_TE] = cmds.menuItem(label=maya.stringTable[ 'y_maya_ge_soundMenu.kImportAudioClip'  ]
                                                                 ,annotation=maya.stringTable[ 'y_maya_ge_soundMenu.kImportAudioClipAnnot'  ]
                                                                 ,command=self.on_import_audio_clip_to_te)

        self.current_sound_list = SoundListHandler().get_sound_names()
        self.widgets["sound_divider"] = cmds.menuItem(divider=True, label=maya.stringTable['y_maya_ge_soundMenu.kSoundsDivider' ])
        self.widgets.update(create_sound_submenu(self.current_sound_list, use_radio=True, show_option_box=True, show_off_button=True))

        self.widgets["mute_divider"] = cmds.menuItem(divider=True)
        self.widgets[self.WID_MUTE_SOUND] = cmds.menuItem(label=maya.stringTable['y_maya_ge_soundMenu.kMute' ], checkBox=not is_sound_on(), command=on_mute_click_callback)

        if with_adjust_volume:
            self.widgets["adjust_volume"] = cmds.menuItem(label=maya.stringTable['y_maya_ge_soundMenu.kAdjustVolume' ], command=self.on_adjust_volume_callback)

        self.widgets[self.WID_DELETE_SOUND] = cmds.menuItem(label=maya.stringTable['y_maya_ge_soundMenu.kDeleteSound' ], subMenu=True)
        create_sound_submenu(self.current_sound_list, is_delete_mode=True)

        cmds.setParent('..', menu=True)

        self.widgets[self.WID_WAVEFORM_DISPLAY] = cmds.menuItem(label=maya.stringTable['y_maya_ge_soundMenu.kWaveformDisplay' ], subMenu=True)
        self.create_waveform_display_menu()
        cmds.setParent('..', menu=True)

        return self.widgets

    def update_waveform_menu(self):
        current_waveform = SoundPreferencesWaveformDisplayType().get_value()
        cmds.menuItem(self.widgets[current_waveform], edit=True, radioButton=True)

    def update_sound_list_selection(self):
        is_sound_on_te = cmds.timeControl(playback_slider_id(), query=True, displaySound=True)
        current_audio = cmds.timeControl(playback_slider_id(), query=True, sound=True)

        sound_name = WID_OFF_SOUND_ID
        if is_sound_on_te:
            sound_name = current_audio if current_audio else WID_TRAX_SOUND_ID

        if sound_name in self.widgets:
            cmds.menuItem(self.widgets[sound_name], edit=True, radioButton=True)

    def update_ui(self):
        cmds.menuItem(self.widgets[self.WID_MUTE_SOUND], edit=True, checkBox=not is_sound_on())
        self.update_waveform_menu()


    def update_sound_list(self):
        cmds.setParent(self.parent, menu=True)
        for widget in list(self.widgets.values()):
            cmds.deleteUI(widget)
        self.widgets = {}

        self.build()

    def callback_ui_deleted(self):
        SoundPreferenceVolume().remove_client(self)
        SoundPreferencesWaveformDisplayType().remove_client(self)

        for job in self.script_jobs:
            cmds.scriptJob( kill=job )
        self.script_jobs = []

    def on_sound_selection_changed(self):
        self.update_sound_list_selection()

    def on_sound_list_changed(self, new_sound_list):
        if new_sound_list == self.current_sound_list:
            return

        self.current_sound_list = new_sound_list
        self.update_sound_list()
        self.update_sound_list_selection()


class SoundListHandler(with_metaclass(Singleton, object)):
    @staticmethod
    def _get_all_sounds():
        # return the uuids of all the sound nodes
        return cmds.ls(cmds.ls(type="audio"), uuid=True)

    def __init__(self):
        self.uuid_sound_list = self._get_all_sounds()
        self.sound_list_changed_callbacks = []
        self.script_jobs = [
            cmds.scriptJob(event=("currentSoundNodeChanged", self.on_sound_node_changed)),
            cmds.scriptJob(event=('SoundNodeAdded', self.on_sound_node_was_added)),
            cmds.scriptJob(event=('SoundNodeRemoved', self.on_sound_node_was_deleted)),
            cmds.scriptJob(event=('NameChanged', self.on_node_renamed))
        ]


    def add_sound_list_changed_callback(self, callback):
        self.sound_list_changed_callbacks.append(callback)

    def on_sound_node_changed(self):
        is_sound_on_te = cmds.timeControl(playback_slider_id(), query=True, displaySound=True)
        current_audio = cmds.timeControl(playback_slider_id(), query=True, sound=True)

        if is_sound_on_te and current_audio:
            current_audio_uuid = cmds.ls(current_audio, uuid=True)[0]
            self.uuid_sound_list.remove(current_audio_uuid)
            self.uuid_sound_list = [current_audio_uuid] + self.uuid_sound_list
            self.sound_list_changed()

    def on_sound_node_was_added(self):
        all_sounds = self._get_all_sounds()
        sounds_diff = [sound for sound in all_sounds if sound not in self.uuid_sound_list]
        self.uuid_sound_list = sounds_diff + self.uuid_sound_list
        self.sound_list_changed()

    def on_sound_node_was_deleted(self):
        all_sounds = self._get_all_sounds()
        self.uuid_sound_list = [sound for sound in self.uuid_sound_list if sound in all_sounds]
        self.sound_list_changed()

    def on_node_renamed(self):
        all_sounds = self._get_all_sounds()
        self.uuid_sound_list = [sound for sound in self.uuid_sound_list if sound in all_sounds]
        self.sound_list_changed()

    def sound_list_changed(self):
        names = self.get_sound_names()
        for callback in self.sound_list_changed_callbacks:
            callback(names)

    def get_sound_names(self):
        return cmds.ls(self.uuid_sound_list)

class SoundMenu(with_metaclass(Singleton, object)):
    WID_BUTTON = 0
    WID_POPUP = 1

    VOLUME_ON_ICON = "volumeON.png"
    VOLUME_OFF_ICON = "volumeMuted.png"
    VOLUME_ANNOTATION = maya.stringTable['y_maya_ge_soundMenu.kVolumeAnnot' ]

    def __init__(self):
        self.widgets = {}
        self.sound_menu_popup = None
        self.sounds_list = []

    def get_sounds_list(self):
        return self.sounds_list

    @staticmethod
    def on_double_click_button_callback():
        on_mute_click_callback(is_sound_on())

    @staticmethod
    def on_press_button_callback():
        show_sound_slider()

    def create_button(self):
        self.widgets[self.WID_BUTTON] = cmds.iconTextButton(image1=self.VOLUME_ON_ICON, annotation="sound settings", enable=True,
                                                            visible=True, command=self.on_press_button_callback, version="2020",
                                                            doubleClickCommand=self.on_double_click_button_callback)

        self.widgets[self.WID_POPUP] = cmds.popupMenu(self.widgets[self.WID_BUTTON])
        self.sound_menu_popup = SoundPopupMenu(self.widgets[self.WID_POPUP])
        self.sound_menu_popup.build(with_adjust_volume=False)

        self.update_ui()

        SoundPreferenceVolume().add_client(self, callback_tool(self, callback_update_ui))

        cmds.scriptJob(uiDeleted=(cmds.setParent(query=True), callback_tool(self, self.callback_ui_deleted)))
        cmds.scriptJob(event=("currentSoundNodeChanged", self.update_ui))

        return self.widgets[self.WID_BUTTON]

    def update_ui(self):
        current_volume = SoundPreferenceVolume().get_value()
        icon = self.VOLUME_ON_ICON if is_sound_on() else self.VOLUME_OFF_ICON

        cmds.iconTextButton(self.widgets[self.WID_BUTTON], edit=True, image1=icon,
                            annotation=self.VOLUME_ANNOTATION.format(int(current_volume * 100)))

    @staticmethod
    def callback_ui_deleted(tool):
        SoundPreferenceVolume().remove_client(tool)

    def get_button_layout(self):
        return cmds.iconTextButton(self.widgets[self.WID_BUTTON], query=True, parent=True)
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
