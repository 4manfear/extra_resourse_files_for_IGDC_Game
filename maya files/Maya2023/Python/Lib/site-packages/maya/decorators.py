'''
Simple decorator definitions that are generally useful.

    @private     : Make a method really private
    @debugmethod : The single function or method following it
    @debugclass  : Every method in a class, including @staticmethod and @classmethod

The static class DebugDecorator can be used to enable and disable output by setting DebugDecorator.ENABLED to True or False

Examples:
    # Dumps debug call sequence for the function
    @debugmethod
    def free_method():
        pass

    # Dumps debug call sequence for all class methods
    @debugclass
    class Debuggable(object):
        def __init__(self):
            pass
        def method1(self):
            pass
        def method2(self):
            pass

    # Only dumps debug call sequence for method1
    class PartiallyDebuggable(object):
        def __init__(self):
            pass
        @debugmethod
        def method1(self):
            pass
        def method2(self):
            pass
'''
from builtins import object
from future import standard_library
standard_library.install_aliases()
import re
import types
import inspect
import functools
import unittest


__all__ = ['private', 'debugmethod', 'debugclass', 'DebugDecorator']

def private (method) :
    '''
    Use this decorator to force a class method to be really private
    (i.e. raises an exception if you try to access it from outside the class).

        @private
        def myPrivateClass(self):
            doSomeInternalWork()

    You can still use the double-underscore name mangling trick to hide the
    actual name of the method if you want to as well:

        @private
        def __myPrivateClass(self):
            doSomeInternalWork()
    '''
    class_name = inspect.stack()[1][3]

    def privatized_method (*args, **kwargs) :
        '''Method proxy to only allow calls the decorated method from its own class'''
        call_frame = inspect.stack()[1][0]

        # Only methods of same class should be able to call
        # private methods of the class, and no one else.
        if 'self' in call_frame.f_locals :
            caller_class_name = call_frame.f_locals ['self'].__class__.__name__
            if caller_class_name == class_name :
                return method (*args, **kwargs)
        raise RuntimeError('Cannot call private method %s from outside the class' % str(method))

    return privatized_method

#======================================================================

class DebugDecorator(object):
    '''
    High level controls for what debugging information is dumped by the decorators, as well
    as providing direct access to inject further class or method debug information into the stream.
    :member INDENT_LEVEL: How many levels deep to indent the next message
    :member INDENTATION: Indentation string at the current level
    :member ENABLED: If True then output is printed, else it is discarded
    '''
    INDENT_LEVEL = 0
    INDENTATION = ''
    ENABLED = False
    from sys import stdout as sys_stdout
    OUTPUT = sys_stdout

    @staticmethod
    def output(message):
        '''
        Print a debugging message, if enabled
        :param message: Message to be printed
        '''
        if DebugDecorator.ENABLED:
            DebugDecorator.OUTPUT.write( 'DBG: {}{}\n'.format( DebugDecorator.INDENTATION, message ) )

    @staticmethod
    def begin(title):
        '''
        Start a new debugging section, with header
        :param title: String representation of the section being started
        '''
        DebugDecorator.output( title )
        DebugDecorator.INDENT_LEVEL += 1
        DebugDecorator.INDENTATION += '    '

    @staticmethod
    def end(result=None):
        '''
        Complete a debugging section, showing the result of the block
        :param result: Return value for the section, ignored if None
        '''
        DebugDecorator.INDENT_LEVEL -= 1
        DebugDecorator.INDENTATION = DebugDecorator.INDENTATION[:-4]
        if result is not None:
            DebugDecorator.output( result )

#======================================================================
def arguments_as_string(*args, **kwargs):
    '''Convert the function argument list to a representative string'''
    args_repr = [repr(a) for a in args] if args else []
    kwargs_repr = ["{}={}".format(k, v) for k, v in list(kwargs.items())] if kwargs else []

    signature = ", ".join(args_repr + kwargs_repr)
    return signature

#======================================================================
def debugmethod(func):
    '''
    Decorator that will print the function signature and return value of a function when DebugDecorator is enabled.
    :param func: Function to be decorated with debug output.
    '''
    @functools.wraps(func)
    def wrapper_debug(*args, **kwargs):
        '''
        Decorator wrapper to call the decorated function with debug information added.
        '''
        # Optimization to skip all formatting when the debugging is off
        if DebugDecorator.ENABLED:
            try:
                name = '{}.{}'.format( func.__self__.__class__.__name__, func.__name__ )
                if func.__self__.__class__.__name__ == 'type':
                    raise AttributeError
            except AttributeError:
                calling_args = inspect.getcallargs(func, *args, **kwargs)
                try:
                    name = '{}.{}'.format( calling_args['self'].__class__.__name__, func.__name__ )
                except KeyError:
                    try:
                        name = '{}.{}'.format( calling_args['cls'].__name__, func.__name__ )
                    except KeyError:
                        name = '.{}'.format( func.__name__ )
            DebugDecorator.begin( "{}({})".format(name,arguments_as_string(*args, **kwargs)) )
            # This handles the difference between static, class, and normal methods
            value = func(*args, **kwargs)
            DebugDecorator.end( "{} returned {}".format( name, value ) )
            return value

        return func(*args, **kwargs)

    return wrapper_debug

#======================================================================
def debugclass(cls):
    '''
    Decorator that attaches to a class in order to attach the debugmethod decorator to all methods in that class.
    Note that static methods will not have class identification information on the debug output since they are
    essentially not members of that class.

    This decorator has an advantage over using individual debugmethod decoration on every method in that since it
    knows it is part of a class decoration it can ignore the "self" parameter in output.
    '''
    class NewCls(cls):
        '''Decorator class, providing decorated overrides to all of the base class methods'''
        def __init__(self,*args,**kwargs):
            signature = arguments_as_string(*args, **kwargs)
            DebugDecorator.begin( "{}.__init__({})".format(cls.__name__,signature) )
            self.object_instance = cls(*args,**kwargs)
            DebugDecorator.end()

        def __getattribute__(self,attribute_name):
            """
            this is called whenever any attribute of a NewCls object is accessed. This function first tries to
            get the attribute off NewCls. If it fails then it tries to fetch the attribute from self.object_instance (an
            instance of the decorated class). If it manages to fetch the attribute from self.object_instance, and
            the attribute is an instance method then `debugmethod` is applied.
            """
            try:
                potential_method = super(NewCls,self).__getattribute__(attribute_name)
            except AttributeError:
                pass
            else:
                # The method belongs to a parent class, let it handle possible debugging
                if attribute_name != '__init__':
                    return potential_method

            potential_method = self.object_instance.__getattribute__(attribute_name)

            # Attribute is a method; decorate it
            #if type(potential_method) == type(self.__init__): # it is an instance method
            if isinstance(potential_method,types.FunctionType) or (hasattr(potential_method, 'im_self') and potential_method.__self__ is not None):
                return debugmethod(potential_method)          # this is equivalent of just decorating the method with debugmethod

            return potential_method
    return NewCls

######################################################################
class TestDecorators(unittest.TestCase):
    '''Test operation of the debug decorators'''
    @debugclass
    class ClassDecoration(object):
        '''Class decorated with debug information at the class level'''
        def __init__(self):
            '''Decorated init'''
            pass

        def addOne(self, initial_value):
            '''Decorated method modifying a value'''
            self.sAddOne()
            return initial_value+1

        @staticmethod
        def sAddOne():
            '''Decorated static method'''
            return 10

        @classmethod
        def sClassMethod(cls):
            '''Decorated class method'''
            return 100

    class MethodDecoration(object):
        '''Class decorated with debug information at the method level'''
        @debugmethod
        def __init__(self):
            '''Decorated init'''
            pass

        @debugmethod
        def addOne(self, initial_value):
            '''Decorated method modifying a value'''
            self.sAddOne()
            return initial_value+1

        @staticmethod
        @debugmethod
        def sAddOne():
            '''Decorated static method'''
            return 10

        @classmethod
        @debugmethod
        def sClassMethod(cls):
            '''Decorated class method'''
            return 100

    def test_class_decoration(self):
        '''Test for use of the debugclass decorator'''
        DebugDecorator.ENABLED = True
        from io import StringIO as io_StringIO
        DebugDecorator.OUTPUT = io_StringIO()
        class_decorated = TestDecorators.ClassDecoration()
        class_decorated.addOne( initial_value=3 )
        class_decorated.addOne( 3 )
        class_decorated.sAddOne()
        class_decorated.sClassMethod()
        self.assertEqual( DebugDecorator.OUTPUT.getvalue(),
"""DBG: ClassDecoration.__init__()
DBG: ClassDecoration.addOne(initial_value=3)
DBG: ClassDecoration.addOne returned 4
DBG: ClassDecoration.addOne(3)
DBG: ClassDecoration.addOne returned 4
DBG: .sAddOne()
DBG: .sAddOne returned 10
DBG: ClassDecoration.sClassMethod()
DBG: ClassDecoration.sClassMethod returned 100
""" )
        DebugDecorator.OUTPUT.close()

    def test_method_decoration(self):
        '''Test for use of the debugmethod decorator'''
        DebugDecorator.ENABLED = True
        from io import StringIO as io_StringIO
        DebugDecorator.OUTPUT = io_StringIO()
        method_decorated = TestDecorators.MethodDecoration()
        method_decorated.addOne( 3 )
        method_decorated.addOne( initial_value=3 )
        method_decorated.sAddOne()
        method_decorated.sClassMethod()
        sanitized_result = re.sub( r'<[^>]*>', '<>', DebugDecorator.OUTPUT.getvalue() )
        self.assertEqual( sanitized_result,
"""DBG: MethodDecoration.__init__(<>)
DBG: MethodDecoration.__init__ returned None
DBG: MethodDecoration.addOne(<>, 3)
DBG:     .sAddOne()
DBG:     .sAddOne returned 10
DBG: MethodDecoration.addOne returned 4
DBG: MethodDecoration.addOne(<>, initial_value=3)
DBG:     .sAddOne()
DBG:     .sAddOne returned 10
DBG: MethodDecoration.addOne returned 4
DBG: .sAddOne()
DBG: .sAddOne returned 10
DBG: MethodDecoration.sClassMethod(<>)
DBG: MethodDecoration.sClassMethod returned 100
""" )
        DebugDecorator.OUTPUT.close()

    def test_private(self):
        '''Test for private method decorator'''
        class Privatized(object):
            '''Example class with private method'''
            @private
            def you_cannot_call_me(self):
                '''Method that can only be called from the class'''
                return self.__class__.__name__
            def you_can_call_me(self):
                '''Method that is allowed to call the class private method'''
                return self.you_cannot_call_me()
        class Generalized(Privatized):
            '''Example derived class attempting to call a private method'''
            def you_should_not_call_me(self):
                '''Method that attempts to call the parent class private method'''
                return self.you_cannot_call_me()
        pyle = Privatized()
        with self.assertRaises( RuntimeError ):
            pyle.you_cannot_call_me()
        self.assertEqual( 'Privatized', pyle.you_can_call_me() )
        hale = Generalized()
        with self.assertRaises( RuntimeError ):
            hale.you_should_not_call_me()

if __name__ == '__main__':
    unittest.main()
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
