"""
Implementation of ProgressStepper which is a progress bar with random-access to steps
"""

from typing import Dict
from PySide2 import QtWidgets
from PySide2.QtCore import Qt, QPoint, QRect, QSize, Signal
from PySide2.QtGui import QPainter, QBrush, QColor, QPen, QFont, QFontMetrics, QMouseEvent
from .utils import DPIScale

CIRCLE_WIDTH = DPIScale(16)
SPACING = DPIScale(8)


class ProgressStepper(QtWidgets.QWidget):
    """
    A progress stepper is a user interface that displays for every step of a progrees a circle
    the user can click to move back and forth
    """
    # called when the user clicks a circle
    stepClicked = Signal(int)

    def __init__(self, parent=None):
        super(ProgressStepper, self).__init__(parent)
        self._currentStep = 2
        self._maxSteps = 5
        self._hitTest = dict()
        self._mouseHover = -1
        self.setMouseTracking(True)

        self.setFont(QFont("Artifakt Element", DPIScale(12)))
        self.setFixedHeight(DPIScale(24))

    def _getText(self):
        text = "{cur} of {max}".format(
            cur=self._currentStep+1, max=self._maxSteps)
        return text

    def _getTextSize(self):
        metrics = QFontMetrics(self.font())
        return QSize(metrics.horizontalAdvance(self._getText()), DPIScale(24))

    def paintEvent(self, _):
        """ draw the progess bar """
        painter = QPainter(self)
        painter.save()
        painter.setRenderHint(QPainter.Antialiasing)

        grayPen = QPen(QColor("#B0B0B0"))
        grayPen.setWidth(DPIScale(1))
        grayPenHighlighed = QPen(grayPen)
        grayPenHighlighed.setWidth(DPIScale(2))
        blueBrush = QBrush(QColor("#38abdf"))
        nullBrush = QBrush()
        nullPen = QPen(Qt.NoPen)

        painter.setPen(grayPen)
        painter.setBrush(nullBrush)

        x = SPACING/2
        y = SPACING/2

        self._hitTest.clear()

        for index in range(0, self._maxSteps):

            if index == self._currentStep:
                painter.setBrush(blueBrush)
                painter.setPen(nullPen)

            if index == self._mouseHover:
                painter.setPen(grayPenHighlighed)

            rect = QRect(x, y, CIRCLE_WIDTH, CIRCLE_WIDTH)
            painter.drawEllipse(rect)
            self._hitTest[index] = rect

            if index == self._currentStep:
                painter.setBrush(nullBrush)
                painter.setPen(grayPen)
            if index == self._mouseHover:
                painter.setPen(grayPen)

            x += CIRCLE_WIDTH + SPACING

        x += SPACING
        textSize = self._getTextSize()
        painter.drawText(QRect(QPoint(x, 0), textSize), Qt.AlignVCenter,
                         self._getText())

        painter.restore()

    def setCurrentStep(self, newCurrentStep):
        self._currentStep = newCurrentStep
        self.update()

    def increment(self):
        """ increment the current step """
        if self._currentStep < self._maxSteps-1:
            self.setCurrentStep(self._currentStep + 1)

    def decrement(self):
        """ increment the current step """
        if self._currentStep > 0:
            self.setCurrentStep(self._currentStep - 1)

    def currentStep(self):
        return self._currentStep

    def resetSteps(self, currentStep, maxsteps):
        """ sets maxmium number of steps and the current step  """
        self._maxSteps = maxsteps
        if maxsteps:
            self.setCurrentStep(currentStep)
            self.show()
            self.adjustSize()
        else:
            self.hide()
            self.adjustSize()

    def clear(self):
        """ clear the progress bar, which will result in hiding it """
        self.resetSteps(0, 0)

    def sizeHint(self):
        width = SPACING/2 + self._maxSteps * (CIRCLE_WIDTH+SPACING)
        width += SPACING + self._getTextSize().width() + SPACING/2
        return QSize(width, DPIScale(24))

    def mouseMoveEvent(self, event):
        # type: (QMouseEvent) -> None
        self._mouseHover = -1
        pos = event.pos()
        for key, rect in self._hitTest.items():
            if rect.contains(pos):
                self._mouseHover = key
                break
        self.update()

    def mouseReleaseEvent(self, event):
        # type: (QMouseEvent) -> None
        pos = event.pos()
        for key, rect in self._hitTest.items():
            if rect.contains(pos):
                self.stepClicked.emit(key)
                break
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
