"""
    implementation of windows that are overlayed on top of an application
"""
# Qt
from PySide2 import QtWidgets, QtGui, QtCore
from PySide2.QtCore import Qt, QSize, QPropertyAnimation, QEasingCurve, Property
from PySide2.QtGui import QPainter, QBrush, QColor

# internal
from .enums import RelTo, OverlayStyle, Direction
from . import utils
from . import drawStyles
from .overlayDef import OverlayDef, OverlayRectList
from .utils import DPIScale

# pylint: disable=useless-super-delegation
import copy
import weakref
from typing import List, Dict, Any


class RuntimeDrawParams(object):
    """" parameters used internally for drawing """

    def __init__(self):
        self.alpha = 1.0
        self.undarkenRects = list()


class OverlayImpl(QtWidgets.QWidget):

    """ private implementation of ovelays """

    def __init__(self, parent, parentOverlay, overlayDef):
        # type: (QtWidgets.QWidget, Any, OverlayDef) -> None
        super(OverlayImpl, self).__init__(parent)
        self.parentOverlay = weakref.ref(parentOverlay)
        windowFlags = Qt.Tool | Qt.FramelessWindowHint
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        self.createParams = copy.deepcopy(overlayDef)
        self.undarkenRects = list()  # type: OverlayRectList

        self.drawParams = RuntimeDrawParams()
        self.drawParams.alpha = self.createParams.getDefaultAlpha()
        self.mouseClickCallback = None

        if self.createParams.style == OverlayStyle.Darkening:
            windowFlags |= Qt.WindowTransparentForInput
            self.blurEffect = QtWidgets.QGraphicsBlurEffect(self)
            self.blurEffect.setBlurRadius(25)
            self.setGraphicsEffect(self.blurEffect)

        self.setWindowFlags(windowFlags)
        self._repositionOnParent()

        self.speechBubbleTails = dict()  # type: Dict[Direction, List[float]]
        self._animation = None  # type: QPropertyAnimation
        self._endCallBack = None

    def destroy(self):
        self.hide()
        self.deleteLater()

    def setSize(self, width, height):
        """ set the size of the overlay """
        self.setFixedSize(width, height)

    def attachToWindow(self, attachment, offset=QSize(0, 0)):
        # type : (int, QSize) -> None
        """ attach this overlay to a border of the parent window """
        self.createParams.attachment = attachment
        self.createParams.offset = offset
        self._repositionOnParent()

    def size(self):
        """ returns QSize of the overlay """
        return super(OverlayImpl, self).size()

    def onWindowMoved(self, qwindow):
        # type: (QtGui.QWindow) -> None
        """ callback from manager to update the window position """
        if self.parent():
            parentAsWindow = self.parent().windowHandle()
            if parentAsWindow == qwindow:
                self._repositionOnParent()

    def _repositionOnParent(self):
        if self.createParams.style == OverlayStyle.Darkening:
            parent = self.parent()
            parentRect = parent.frameGeometry()
            self.move(parentRect.topLeft())
            self.resize(parentRect.size())

            thisRect = self.rect()
            self.drawParams.undarkenRects = []
            for rectDef in self.undarkenRects:
                resultRect = rectDef.rect
                if rectDef.attachment != RelTo.Screen:
                    offset = DPIScale(rectDef.offset)
                    utils.placeRectInParent(
                        thisRect, rectDef.attachment, resultRect, offset)
                self.drawParams.undarkenRects.append(resultRect)

        elif self.createParams.attachment != RelTo.Screen:
            thisRect = self.rect()
            parent = self.parent()
            parentRect = parent.frameGeometry()
            utils.placeRectInParent(
                parentRect, self.createParams.attachment, thisRect, self.createParams.offset)
            self.move(thisRect.topLeft())
            self.resize(thisRect.size())

    def showEvent(self, event):
        self._repositionOnParent()
        return super(OverlayImpl, self).showEvent(event)

    def paintEvent(self, _):
        """ Draws the render setup button """
        painter = QPainter(self)
        if self.createParams.style == OverlayStyle.ToolTip:
            drawStyles.drawToolTip(self, painter)
        elif self.createParams.style == OverlayStyle.SpeechBubble:
            drawStyles.drawSpeechBubble(self, painter)
        elif self.createParams.style == OverlayStyle.Darkening:
            rect = self.rect()
            brush = QBrush(QColor(0, 0, 0, 192))
            painter.fillRect(rect, brush)
            painter.setCompositionMode(QPainter.CompositionMode_Source)
            for rect in self.drawParams.undarkenRects:
                painter.fillRect(rect, QColor(255, 255, 255, 0))

    def enterEvent(self, event):
        # type : (QtCore.QEvent) -> None:
        if self.createParams.mouseEnterAlphaEnabled:
            self.drawParams.alpha = self.createParams.mouseInsideAlpha
            self.update()
        return super(OverlayImpl, self).enterEvent(event)

    def leaveEvent(self, event):
        # type : (QtCore.QEvent) -> None:
        if self.createParams.mouseEnterAlphaEnabled:
            self.drawParams.alpha = self.createParams.mouseOutsideAlpha
            self.update()
        return super(OverlayImpl, self).leaveEvent(event)

    def mousePressEvent(self, event):
        # type : (QtCore.QMouseEvent) -> None:
        if self.mouseClickCallback:
            self.mouseClickCallback(self.parentOverlay(), event)
        super(OverlayImpl, self).mousePressEvent(event)

    def setClickCallback(self, callback):
        """ set a function to be called on mouse click """
        self.mouseClickCallback = callback
        self.createParams.mouseEnterAlphaEnabled = True

    def setUndarkenRects(self, rects):
        # type : (OverlayRectList) -> None
        """ when overlayer is Darkening mode, set rectangles which are not dark """
        self.undarkenRects = rects
        self.update()

    def setAsLabel(self, text):
        # type : (str) -> QtWidgets.QLabel
        """ set the overlay to contain a single QLabel """
        layout = QtWidgets.QVBoxLayout()
        margin = DPIScale(16 if self.createParams.style ==
                          OverlayStyle.SpeechBubble else 12)
        layout.setContentsMargins(margin, margin, margin, margin)
        label = QtWidgets.QLabel(text)
        label.setStyleSheet("color: black; font: bold;")
        label.setOpenExternalLinks(True)
        label.setWordWrap(True)
        label.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding,
                            QtWidgets.QSizePolicy.MinimumExpanding)
        self.setSizePolicy(QtWidgets.QSizePolicy.MinimumExpanding,
                           QtWidgets.QSizePolicy.MinimumExpanding)
        layout.addWidget(label)
        self.setLayout(layout)
        return label

    def setAsWidget(self, widget):
        # type: (QtWidgets.QWidget) -> QtWidgets.QWidget
        """ sets a custom widget to take the entire area """
        layout = QtWidgets.QVBoxLayout()
        layout.setContentsMargins(0, 0, 0, 0)
        layout.addWidget(widget)
        self.setLayout(layout)

    def getBgColor(self):
        # type: () -> QColor
        bgColor = copy.copy(self.createParams.bgColor)
        bgColor.setAlphaF(self.drawParams.alpha)
        return bgColor

    def addSpeechBubbleTail(self, direction, ratio):
        # direction type is "Direction" enum
        if not direction in self.speechBubbleTails:
            self.speechBubbleTails[direction] = []
        self.speechBubbleTails[direction].append(ratio)

    def getSubWidget(self):
        layout = self.layout()
        return layout.itemAt(0).widget()

    def overlayOffset_getter(self):
        return self.createParams.offset

    def overlayOffset_setter(self, value):
        self.createParams.offset = value
        self._repositionOnParent()
        self.parentOverlay().offsetChanged.emit(
            self.parentOverlay(), self.createParams.offset)

    overlayOffset = Property(QSize, overlayOffset_getter, overlayOffset_setter)

    def animationDone(self):
        if self._endCallBack:
            self._endCallBack(self.parentOverlay())
            self._endCallBack = None

    def animateOffset(self, endPosition, endCallBack=None):
        # type: (QSize, Any) -> None
        if self._animation:
            self._animation.stop()
            self._animation.deleteLater()

        self._animation = QPropertyAnimation(self, b"overlayOffset")

        self._animation.setStartValue(self.overlayOffset)
        self._animation.setEndValue(endPosition)
        self._animation.setDuration(1000)
        curve = QEasingCurve()
        curve.setType(QEasingCurve.OutQuad)
        self._animation.setEasingCurve(curve)

        self._endCallBack = endCallBack
        self._animation.finished.connect(self.animationDone)

        self._animation.start()
# ===========================================================================
# Copyright 2022 Autodesk, Inc. All rights reserved.
#
# Use of this software is subject to the terms of the Autodesk license
# agreement provided at the time of installation or download, or which
# otherwise accompanies this software in either electronic or hard copy form.
# ===========================================================================
