// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================


proc int isShapeNode( string $node )
{ 
	string $selNodeType = `nodeType $node`;
	if ( $selNodeType == "mesh" ) {
		if (`getAttr ($node + ".intermediateObject")` == false) 
            return 1; 
    } 
    else 
	{	
		string $shapesResult[] = `listRelatives -children -shapes -fullPath -ni $node`;
		if ( size($shapesResult) > 0 )
		{
			return 1;
		} 
	}
	return 0;
} 

proc int baseIndex( string $bsn, string $shapeName )
{
    string $bases[] = `blendShape -query -geometry $bsn`;
    for ($ii = 0; $ii < size($bases); ++ $ii)
    {
        if ($bases[$ii] == $shapeName)
            return $ii;
        $parent = `listRelatives -parent -path $bases[$ii]`;
        if ($parent[0] == $shapeName)
            return $ii; 
    }
            
	return -1;
}  

global proc doBlendShapeAddTargetPostDeformer(
	string	$bsn, 
	int		$top,
	int		$bsPostDeformer,
	string  $transformName
	)
{  	
	if ($bsn == "" || $bsn == "\"\"")
	{
		error ( (uiRes("m_doBlendShapeAddTargetPostDeformer.kMustSpecifyNode")));
		return; 
	}

	// to get the base shape 
	// 
	string $sel[]=`ls -sl`;
	int $cnt = size($sel); 

	if ( $bsPostDeformer == 1 )
	{
		if(`objExists $transformName` == 0)
		{
			error( (uiRes("m_doBlendShapeAddTargetPostDeformer.kInvalidTransformName")) );
			return;
		}
	}
		
	if ($cnt != 1 || isShapeNode($sel[0]) == 0 )
	{
		// if target is transform space, and transform node is a joint, we can get base shape by transform name.
		if ( $bsPostDeformer == 1 )
		{
			// get base shape by transform name.		
			if(`objectType $transformName` == "joint")
			{
				string $transformPlug = $transformName + ".worldMatrix";
				string $skinClusterName[] = `listConnections -type "skinCluster" -source on $transformPlug`;
				if(size($skinClusterName) == 0)
					error( (uiRes("m_doBlendShapeAddTargetPostDeformer.kMustSelectBaseShape")));

				string $geo[] = `skinCluster -q -geometry $skinClusterName[0]`;
				if(size($geo) == 1)
					$sel[0] = $geo[0];
				else
				{
					// joint bind to multiple shapes.
					error( uiRes("m_doBlendShapeAddTargetPostDeformer.kMustSelectBaseShape") );
					return;
				}
			}
		}
		else
		{
			// at a minimum the base shape on the blendShape must be selected
			//
			error( uiRes("m_doBlendShapeAddTargetPostDeformer.kMustSelectBaseShape") );
			return;
		}
	}

	int $wc=`blendShape -q -wc $bsn`;
	// find the multiIndex of the next available target
	//			
	if ($wc > 0) {
		int $mi = bsMultiIndexForTarget($bsn,$wc-1);
		if (-1 != $mi) {
			$wc = $mi+1;
		}
	} 

	// duplicate the base shape as target, to make sure the target has the exact geometry as the base shape.
	string $tgt[] = `duplicate $sel[0]`;  
	
	$cmd = "blendShape -e ";

	// check topology 
	//
	if (!$top)
	{
		$cmd += (" -tc " + $top);
	}

	$cmd += " -t " + $sel[0] + " " + $wc + " " + $tgt[0] + " 1";
	if ( $bsPostDeformer == 0 )
		$cmd += " -tangentSpace";
	else if ( $bsPostDeformer == 1 )
		$cmd += " -transform " + $transformName;
	$cmd += " -w "+ $wc + " 1 " + $bsn;

	evalEcho $cmd;

	// do not need the shape in scene for tangent space target
	delete $tgt;		
	
	// zero out all of the deltas
	$bIdx = baseIndex($bsn, $sel[0]);
	if ($bIdx != -1) {
		$cmd = "blendShape -e -rtd " + $bIdx + " " + $wc + " " + $bsn; 
		evalEcho $cmd;
	}

	// select the base shape in case user apply adding target again,
	// otherwise user need to select the base manually.
	select $sel[0]; 
}

// Add normal target without target shape.
global proc doBlendShapeAddNormalTarget(string $bsn)
{
    // get the base shape
    string $sel[]=`ls -sl`;
    if (size($sel) != 1 || isShapeNode($sel[0]) == 0 )
    {
        error( uiRes("m_doBlendShapeAddTargetPostDeformer.kMustSelectBaseShape") );
		return;
    }
    else
    {   
        string $tgt[] = `duplicate $sel[0]`;
        int $wc=`blendShape -q -wc $bsn`;
        blendShape -e -t $sel[0] $wc $tgt[0] 1 -w $wc 1 $bsn;
        delete $tgt;
		select $sel[0];

    }
}

global proc postDeformerModeCB()
{
    int $selectItem = `optionMenuGrp -q -select bsPostDeformerModeList`;
    if($selectItem == 1)
        textFieldButtonGrp -e -enable 0 bsTransformNameFBGrp;
    else if($selectItem == 2)
        textFieldButtonGrp -e -enable 1 bsTransformNameFBGrp;
}

global proc transformNameButtonCB(string $textFieldName)
{
    string $selection[] = `ls -sl -type "transform"`;
	if(size($selection))
		textFieldButtonGrp -e -text $selection[0] -forceChangeCommand $textFieldName;
	else
		warning (uiRes("m_doBlendShapeAddTargetPostDeformer.kNoTransformSelected")) ;
}

global proc AddTransformNameWindow(string $bsNodeName)
{
	if(`window -exists transformWindow`) 
		showWindow transformWindow;
	else
	{
		window -title (uiRes("m_doBlendShapeAddTargetPostDeformer.kBSTransformTitle")) transformWindow;
		setUITemplate -pushTemplate DefaultTemplate;
		columnLayout -adjustableColumn true -rowSpacing 0;
		text -label  (uiRes("m_doBlendShapeAddTargetPostDeformer.kBSAddTransformTarget")) -h 35 -align "center" -fn "boldLabelFont";
		text -label (uiRes("m_doBlendShapeAddTargetPostDeformer.kBSAddTransformAnnotation")) -align "center";
		text -label "" -h 20;
		setParent ..;

		textFieldButtonGrp -label "" -text ""
			-editable true -buttonLabel (uiRes("m_doBlendShapeAddTargetPostDeformer.kBSUseSelected"))
			-adjustableColumn 2
			-w 400
			-cw 1 50 -cw 2 150 -cw 3 100
			-textChangedCommand("button -e -enable true selectButton")
			-buttonCommand("transformNameButtonCB(\"bsEditorTransformNameFBGrp\")") bsEditorTransformNameFBGrp;

		string $transformButtonForm = `formLayout -width 430 transformButtons`;
		button -label (uiRes("m_doBlendShapeAddTargetPostDeformer.kBSTransformSelect"))
			-p $transformButtonForm
			-enable false
			-command ("string $transformName = `textFieldButtonGrp -q -text bsEditorTransformNameFBGrp`; doBlendShapeAddTargetPostDeformer " + $bsNodeName +" 1 1 $transformName;deleteUI transformWindow") selectButton;

		button -label (uiRes("m_doBlendShapeAddTargetPostDeformer.kBSTTransformCancle"))
			-p $transformButtonForm
			-command ("deleteUI transformWindow") cancleButton;
		setParent ..;

		formLayout -edit
			-attachForm        selectButton     "top"       10
			-attachForm        selectButton     "left"      3
			-attachPosition	   selectButton     "right"     1    50
			-attachForm  	   selectButton     "bottom"    0

			-attachForm       cancleButton       "top"	    10
			-attachPosition	  cancleButton       "left"     1    50
			-attachForm	      cancleButton	     "right"	3
			-attachForm  	  cancleButton       "bottom"   0

			$transformButtonForm;   

		setUITemplate -popTemplate;
		showWindow;
	}
}
