// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  20 Feb 2002
//
//  Description:
//      Create Hairs Playback + Render cache
//		
//
global proc setupActiveHairPBCaches()
{
	string $hairSystemShapes[] = `getSelectedHairSystems`;	
	for( $hair in $hairSystemShapes ) {
		setupHairPBCache( $hair );
	}
}

global proc setupHairPBCache( string $hair)
//
// Description:
//	 If there's not already a cache connected to the diskCache IC
//	 create it, else clear the existing cache
//	 make the cache writeable, save the hair, and reset the
//	 writeableness to its former state
//	
{
	if( `connectionInfo -id ($hair + ".diskCache")` == 0 ) {
		string $sel[] =`ls -sl`;
		string $cacheName = uniqueCacheName($hair, ".mchp"); 
		string $dskC = `createNode -n ("cache_"+$hair) diskCache`; 

		setAttr -type "string" ($dskC + ".hiddenCacheName") $cacheName;
		setAttr -type "string" ($dskC + ".cacheType") "mchp";
		connectAttr ($dskC + ".diskCache") ($hair + ".diskCache");
		select -r $sel;
	}
}

global proc doHairDiskCache( int $version, string $args[] )
//
// Description:
//	
//	
{
	if(( $version < 1 ) || ( size( $args ) < 5 )) {
		error(uiRes("m_doAppendHairCache.kIncorrectVersion") );
		return;
	}

	string 	$cacheType 			= "mchp";
	int 	$rangeMode 			= $args[0];
	int 	$sampling  			= $args[1];
	float  	$diskCacheStartTime = $args[2];
	float  	$diskCacheEndTime   = $args[3];
	int    	$samplingRate       = $args[4];

	// Make sure that we have a hair selected
	// or warn the user and fail
	//
	string $hairSystemShapes[] = getSelectedHairSystems();
	if (size($hairSystemShapes) == 0)
	{
		warning(uiRes("m_doDeleteHairPB.kNoHairSystemSelected"));
		return;
	}

	float  $startTime = $diskCacheStartTime;
	float  $endTime = $diskCacheEndTime;

	if( $rangeMode == 1 ) {
        $startTime = `getAttr defaultRenderGlobals.startFrame`; 
        $endTime = `getAttr defaultRenderGlobals.endFrame`; 
	} else if( $rangeMode == 2 ) {
		$startTime = `playbackOptions -q -min`;
		$endTime = `playbackOptions -q -max`;
	}							   

	// If there is already a diskCache node for one of the
	// hairs, we really can't go about creating another
	// one until the user deletes the existing one.  We'll
	// call this an error condition...
	//
	int $foundDiskCache = false;
	for( $f in $hairSystemShapes ) {
		if( !$foundDiskCache ) {
			string $connections[] = eval( "listConnections -destination true " +
										  $f + ".diskCache" );
			
			for( $connectedNode in $connections ) {
				if( `nodeType $connectedNode` == "diskCache" ) {
					string $fmt = (uiRes("m_doHairDiskCache.kAlreadyHasCache"));
					error( `format -s $f $fmt` );
					$foundDiskCache = true;
					break;
				}
			}
		}

/*
		int $numFrames = $endTime - $startTime + 1;
		int	$cacheSize = hairCacheSize( $f, $numFrames );
		if( !hairCacheSizeConfirm( $cacheSize ) ) {
			return;
		}
*/
	}


	// make sure that we know where the Hairs Cache goes
	//
	verifyWorkspaceFileRule( "diskCache", "data" );

	setupActiveHairPBCaches; 

	if( !`exists hairPlaybackCaches_disableUnselected` ) {
		source "hairPlaybackCaches.mel";
	}
	string $changedCaches[] = hairPlaybackCaches_disableUnselected();
	// do nothing if there is no diskCache
	string $allDiskCaches[] = `ls -type "diskCache"`;
	if( size($allDiskCaches) < 1 ) {
		string $msg = (uiRes("m_doHairDiskCache.kNoDiskCache"));
		warning $msg;
		return;
	}

	// Verify all diskCache files have unique names
	int $n, $m;
	for($n = 1; $n < size($allDiskCaches); $n++) {
		string $cacheName = `getAttr ($allDiskCaches[$n] + ".cacheName")`;
		if( size($cacheName) == 0 )
			$cacheName = `getAttr ($allDiskCaches[$n] + ".hiddenCacheName")`;
		for( $m = 0; $m < $n; $m++) {
			string $preCacheName = `getAttr ($allDiskCaches[$m] + ".cacheName")`;
			if( size($preCacheName) == 0 )
				$prevCacheName = `getAttr ($allDiskCaches[$m] + ".hiddenCacheName")`;
			if( $cacheName == $preCacheName ) {
				string $msg = (uiRes("m_doHairDiskCache.kDiskCacheConflict"));
				error `format -s $allDiskCaches[$m] -s $allDiskCaches[$n] $msg`;
				return;
			}
		}
	}

	verifyWorkspaceFileRule( "diskCache", "data" );

	string $samplingType   = "";
	if( $sampling == 1 ) {
		$samplingType = "-os";
	}

	string $cmd = ( "diskCache" +
					" -st " + $startTime +
					" -et " + $endTime +
					" "     + $samplingType + 
					" -ct " + $cacheType + 
					" -sr  " + $samplingRate );

	// Make sure the hairSystemShapes have their "what-to-cache" attrs
	// updated with the settings in the option vars.  And then, make
	// sure we ony affect enabled cache nodes.
	//
/*
	applyHairDiskCacheOptions( "Create Cache", 
								"Add to Cache" ); 
*/
	eval( $cmd + " -enabledCachesOnly " );
	hairPlaybackCaches_enable( $changedCaches );

	// Since it's the actual reading of the diskCache header
	// that sets the startTime and endTime attrs on the diskCache
	// node, we'll do a cacheInfo query for each hair.
	// 
	// This will force the initial attribute editor start/end
	// values to display correctly.
	// 
/*
	for( $f in $hairSystemShapes ) {
		if( `hairCacheInfo -hasData -playback $f` ) {
			hairCacheInfo -playback -startFrame $f;
		}
	}
*/
}
