// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

//<doc>
//<name nClothConvertOutput>
//<owner "Autodesk">
//
//<synopsis>
//		nClothConvertOutput( int $toLocal )
//
//<returns>
//		None.	
//
//<description>
//		Given selected nCloth nodes, convert the output from world space
//	to local space, if $toLocal is true, or vice versa otherwise.
//
//
//<flags>
//	int $toLocal  if true then set the cloth to localSpace otherwise set to worldspace
//
//<examples>
//  nClothConvertOutput false;
//</doc>

global proc nClothConvertOutput( int $toLocal )
{
	// First, find the nCloths directly selected
	//
	string $converted;
	string $pruneTypes[] = { "nucleus", "dynamicConstraint", "nComponent", "nCloth", "nRigid" };
	string $nCloths[] = getSelectedNObjs( "nCloth" );

	int $numCloths = size($nCloths);
	int $index = 0;
	while( $index < $numCloths ){
		string $nCloth = $nCloths[$index];
		$index++;
		if( `getAttr ($nCloth + ".localSpaceOutput")` == $toLocal ){
			// Skip any nCloth already in the right space
			//
			continue;
		}
			

		// Find the output mesh
		//
		int $doFuture = 0;
		string $meshes[];
		string $parents[];
		while( $doFuture <= 1 ){
			string $nodes[] = pruneSearch( $nCloth, $doFuture, $pruneTypes );
			string $allMeshes[] = `ls -type "mesh" $nodes`;
			if( size($allMeshes) > 0 ){
				$meshes[$doFuture] = $allMeshes[0];
				string $allParents[] = `listRelatives -parent $meshes[$doFuture]`;
				if( size($allParents) > 0 ){
					$parents[$doFuture] = $allParents[0];
				}
			}
			$doFuture++;
		}
		if( ($meshes[0] == "") || ($meshes[1] == "") ){
			string $fmt = (uiRes("m_nClothConvertOutput.kMissingMesh"));
			warning(`format -s $nCloth $fmt`);
		} else if( ($parents[0] == "") || ($parents[1] == "") ){
			string $fmt = (uiRes("m_nClothConvertOutput.kMissingParent"));
			warning(`format -s $nCloth $fmt`);
		} else {
			if( $converted == "" ){
				$converted = $nCloth;
			} else {
				$converted = $converted + ", " + $nCloth;
			}
			if( $toLocal ){
				parent -s -r $meshes[1] $parents[0];
				delete $parents[1];
			} else {
				// Create a new parent & copy the old parent's values
				//
				string $worldParent = `createNode "transform" -n "polySurface1"`;
				copyNode $parents[0] $worldParent;
				parent -s -r $meshes[1] $worldParent;
			}
			setAttr ($nCloth + ".localSpaceOutput") $toLocal;
		}
	}
	if( $converted != "" ){
		string $fmt =  (uiRes("m_nClothConvertOutput.kWrongSpaceCache"));
		warning( `format -s $converted $fmt`);
	} else {
		warning( (uiRes("m_nClothConvertOutput.kNothingConverted")) );
	}
}
