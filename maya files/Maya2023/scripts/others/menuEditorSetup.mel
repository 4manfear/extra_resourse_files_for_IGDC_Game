// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Description:
//	This file contains procedures associated with
//	the drag-n-drop Marking Menus editor.
//

// ========= These routines are used internally by the MM Editor. =============

global proc string generateMarkingMenuEditorFilenameFromAnnotation(string $annotation) {

	return ("menu_" + $annotation);
}

global proc int isMenuRegisteredWithMenuEditor(string $annotation) {

	if (`optionVar -exists markingMenuEditorAnnotations`) {
		string $annotationArray[] = `optionVar -q markingMenuEditorAnnotations`;
		int $j;
		for ($j = size($annotationArray) - 1; $j >= 0; --$j)
			if ($annotationArray[$j] == $annotation)
				return true;
	}

	return false;
}

global proc int registerMenuWithMenuEditor(string $fileName, string $annotation) {

	// Ensure that the user respects the
	// naming convention used in this file.
	//
	string $fullName;
	
	$fullName = `internalVar -userMarkingMenuDir` + $fileName;

	if (
		// Don't register the menu if it doesn't respect the naming conventions.
		//
		$fileName != generateMarkingMenuEditorFilenameFromAnnotation($annotation)

		// Don't register the menu if the script to create it doesn't exist.
		//
	||	(!`exists $fullName` && !`exists $fileName`)

		// Don't register the menu if another menu is already registered with the same annotation.
		//
	||	isMenuRegisteredWithMenuEditor($annotation)
	) {
		return 0;   // failure
	}


	optionVar -category "Marking Menus"
		-sva markingMenuEditorFilenames $fileName
		-sva markingMenuEditorAnnotations $annotation
		-iva markingMenuEditorDisplayAsMMFlags 1
		-iva markingMenuEditorIsNamedCommandFlags 0;

	return 1;   // success
}

// $region is one of "N", "S", "E", "W", or "C" ("C" for center)
// $button is one of 1, 2, 3, for Left, Middle, Right - respectively
//
global proc string generateNameOfHotBoxOptionVar(string $region, int $button) {

	return ("nameOfHotBox" + $region + $button + "MarkingMenu");
}

// ========= routines are a public interface to the hotBox scripts. ==========
global proc int isHotBoxMenuDefined(string $region, int $button) {

	string $nameOfOptionVar = generateNameOfHotBoxOptionVar($region,$button);

	return (`optionVar -exists $nameOfOptionVar`);
}

global proc string getScriptNameForHotBoxMenu(string $region, int $button) {

	string $nameOfOptionVar = generateNameOfHotBoxOptionVar($region,$button);

	if (`optionVar -exists $nameOfOptionVar`) {
		string $annotation = `optionVar -q $nameOfOptionVar`;
		if ($annotation == "")
			return "";   // The menu is "empty".
		else {
			string $filename = generateMarkingMenuEditorFilenameFromAnnotation($annotation);

			string $filename2 = `internalVar -userMarkingMenuDir` + $filename;

			// Check if the file exists.
			//
			if (`exists $filename2`)
				return $filename2;
			else if (`exists $filename`)
				return $filename;
			else
				return "";
		}
	}
	else
		return "";
}

global proc registerHotBoxMenuWithMenuEditor(string $fileName, string $annotation, string $region, int $isLeft, int $isMiddle, int $isRight) {

	if (registerMenuWithMenuEditor($fileName, $annotation) == 0)
		return;   // failure

	string $category = "Hotbox";
	string $nameOfOptionVar;

	if ($isLeft) {
		$nameOfOptionVar = generateNameOfHotBoxOptionVar($region,1);
		optionVar -category $category -sv $nameOfOptionVar $annotation;
	}
	if ($isMiddle) {
		$nameOfOptionVar = generateNameOfHotBoxOptionVar($region,2);
		optionVar -category $category -sv $nameOfOptionVar $annotation;
	}
	if ($isRight) {
		$nameOfOptionVar = generateNameOfHotBoxOptionVar($region,3);
		optionVar -category $category -sv $nameOfOptionVar $annotation;
	}
}
