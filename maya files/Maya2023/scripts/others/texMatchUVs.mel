// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// ===========================================================================
//
//  Creation Date: January 3, 2017
//
//  Procedure Name:
//      texMatchUVs
//
//  Description:
//      Move selected UV components to their nearest neighbors.
//
//  Input Arguments
//      tolerance            - Float - Tolerance to match UVs
//
//  Return Value:
//      None.
//
// ===========================================================================

global proc texMatchUVs(float $tolerance)
{
	// Vars
	string $clusterList[];
	float $clusterBaseU[], $clusterBaseV[];
	float $tolerance2 = $tolerance * $tolerance;

	// Validate selection
	texCheckSelection("faceUV");

	// Get original selection
	string $selection[] = `ls -selection`;
	string $selectedItems[] = `filterExpand -ex false -sm 35`;
	if (size($selectedItems) == 0)
	{
		// If Convert Selection is ON, try to convert the current selection to uvs.
		int $val = `optionVar -q polyAutoConvertAction`;
		if ( 1 == $val )
			$selectedItems = `polyListComponentConversion -toUV`;

		// Check if the set of uvs is still empty.
		if (size($selectedItems) == 0) {
			error((uiRes("m_texMatchUVs.kNoUVsSelected")));
			return;
		}
	}
	$selection = `polyPinUV -q -unpinned $selectedItems`;
	$selection = `ls -flatten $selection`;
	if (size($selection) == 0)
		return;

	// Progress window
	global string $gMainProgressBar;
	progressBar -e
		-beginProgress
		-isInterruptable true
		-minValue 0
		-maxValue (size($selection) * 2)
		-status (uiRes("m_texMatchUVs.kUvEditorMatchUVsMsg"))
		$gMainProgressBar;

	// Generate list of point clusters
	for ($uv in $selection)
	{
		// Break if cancelled by user
		if (`progressBar -q -isCancelled $gMainProgressBar`)
		{
			warning((uiRes("m_texMatchUVs.kUvEditorMatchUVsInteruptMsg")));
			return;
		}

		float $coords[] = `polyEditUV -q $uv`;

		int $found = 0;
		for ($i = 0; $i < size($clusterList); $i++)
		{
			float $distanceU = $coords[0] - $clusterBaseU[$i];
			float $distanceV = $coords[1] - $clusterBaseV[$i];
			if ($distanceU * $distanceU + $distanceV * $distanceV <= $tolerance2)
			{
				$found = 1;
				$clusterList[$i] = $clusterList[$i] + " " + $uv;
				break;
			}
		}

		if (!$found)
		{
			$clusterList[size($clusterList)] = $uv;
			$clusterBaseU[size($clusterBaseU)] = $coords[0];
			$clusterBaseV[size($clusterBaseV)] = $coords[1];
		}

		// Update the progress window
		progressBar -edit -step 1 $gMainProgressBar;
	}

	// Merge clusters into singularities
	for ($cluster in $clusterList)
	{
		string $temp[] = stringToStringArray($cluster, " ");

		// Update the progress window
		progressBar -edit -step `size($temp)` $gMainProgressBar;

		if (size($temp) <= 1) continue;
		float $uvBox[] = `polyEvaluate -boundingBoxComponent2d $temp`;
		float $centerU = 0.5 * ( $uvBox[0] + $uvBox[1] );
		float $centerV = 0.5 * ( $uvBox[2] + $uvBox[3] );
		polyEditUV 
			-relative false
			-uValue $centerU
			-vValue $centerV
			$temp
		;
	}

	// Close the progress window
	progressBar -e -endProgress $gMainProgressBar;
}