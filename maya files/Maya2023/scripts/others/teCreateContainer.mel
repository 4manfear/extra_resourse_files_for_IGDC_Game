// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
source teClipExportsDir.mel;

global float $gCCanimStart = 0;         // stored animation start
global float $gCCanimDuration = 0;      // stored animation duration
global int $gTECreateContainerSaveOptionAsDefault = false; // by default don't create as default

proc string filepart( string $path )
// Extracts the path portion of an absolute filepath.
// Input: e.g. "D:/projects/default/scenes/myScene.mb"
// Result: e.g. "myScene.mb"
//
// Filepath can be delimited with
// either slash ("/" or "\")
{
  string $filepart = match( "[^/\\]*$", $path );

  return $filepart;
}

// From a full path like "N:Node.attr", extract path to the node only (until the last dot, like "N:Node")
proc string getNodePath(string $path) {
    return match( "^[^\.]*", $path );
}

// From a track path like "Group_track:3", extract the track index only (after the last ':'.  ie: "3")
proc string getTrackIndex(string $path) {
    return match( "[^:]*$", $path );
}

// From a track path like "Group_track:3", extract the track only (until the last ':'.  ie: "Group_track")
proc string getTrackName(string $path) {
    return match( "^[^:]*", $path );
}


//  Description:
//      Helper Function to teCreateContainerAction
//
//  Input Arguments:
//      $useCheckBox - Whether we should use the value of the UI checkboxes
//
//  Return Value:
//      None.
//
proc string teGetAllowedSourceTypes(int $useCheckBox)
{
    int $checkboxUseConstantValues = 0;
    int $checkboxUseAnimCurve = 0;
    int $checkboxUseNonCurve = 0;

    if ($useCheckBox == true) 
    {
        $checkboxUseConstantValues = `checkBoxGrp -q -value2 tePopulateAttribChkBox`;
        $checkboxUseAnimCurve      = `checkBoxGrp -q -value1 tePopulateAttribChkBox`;
        $checkboxUseNonCurve       = `checkBoxGrp -q -value3 tePopulateAttribChkBox`;
    }
    else
    {
        $checkboxUseConstantValues = `optionVar -q ctePopulateUseNonAnimAttrib`;
        $checkboxUseAnimCurve      = `optionVar -q ctePopulateUseCurveAnim`;
        $checkboxUseNonCurve       = `optionVar -q ctePopulateUseNonCurveAnim`;
    }

    string $animCurveType = "-type animCurveTL -type animCurveTA -type animCurveTT -type animCurveTU ";
    string $constValueType = "-type \"\" ";
    string $populateType = "";

    if ( $checkboxUseAnimCurve == true && $checkboxUseNonCurve == true && $checkboxUseConstantValues == true) {
        // Everything
		// Special case, No filters means everything
    }
    else if ( $checkboxUseAnimCurve == false && $checkboxUseNonCurve == false && $checkboxUseConstantValues == false) {
        // Nothing
		// Special case, No filters plus exclusive means nothing
        $populateType += "-exclusive ";
    }
    else if ($checkboxUseNonCurve == true)
    {   
        if ( $checkboxUseAnimCurve == false ) {
            $populateType += $animCurveType;
        }
        if ( $checkboxUseConstantValues == false) {
            $populateType += $constValueType;
        }
        $populateType += "-exclusive ";
    }
    else
    {    
        if ( $checkboxUseAnimCurve == true ) {
            // Anim curves only
            $populateType += $animCurveType;
        }
        if ( $checkboxUseConstantValues == true ) {
            // Const Values only
            $populateType += $constValueType;
        }
    }
    
    return $populateType;
}

proc int teCreateContainerNumAttr(string $object, int $useCheckBox, int $poseClip)
{
    int $checkboxUseConstantValues = 0;
    int $checkboxUseAnimCurve = 0;
    int $checkboxUseNonCurve = 0;
    int $checkBoxHierarchy = 0;
    int $checkBoxIncludeRoot = 0;
    int $checkboxUseAddRelatedKG = 0;

    if ($useCheckBox == 1) 
    {
        $checkboxUseConstantValues = `checkBoxGrp -q -value2 tePopulateAttribChkBox`;
        $checkboxUseAnimCurve      = `checkBoxGrp -q -value1 tePopulateAttribChkBox`;
        $checkboxUseNonCurve       = `checkBoxGrp -q -value3 tePopulateAttribChkBox`;
        $checkBoxHierarchy         = `checkBoxGrp -q -value1 tePopulateHierarchyChkBox`;
        $checkBoxIncludeRoot       = `checkBoxGrp -q -value1 tePopulateIncludeRootChkBox`;
        $checkboxUseAddRelatedKG   = `checkBoxGrp -q -value1 tePopulateCompleteHIKChkBox`;
        
    }
    else
    {
        $checkboxUseConstantValues = `optionVar -q ctePopulateUseNonAnimAttrib`;
        $checkboxUseAnimCurve      = `optionVar -q ctePopulateUseCurveAnim`;
        $checkboxUseNonCurve       = `optionVar -q ctePopulateUseNonCurveAnim`;
        $checkBoxHierarchy         = `optionVar -q ctePopulateHierarchy`;
        $checkBoxIncludeRoot       = `optionVar -q ctePopulateIncludeRoot`;
        $checkboxUseAddRelatedKG   = `optionVar -q ctePopulateCompleteHIK`;
    }
    
    string $populateCmd = "timeEditorClip ";

    if ($checkboxUseAnimCurve || $checkboxUseNonCurve || $checkboxUseConstantValues || $checkBoxIncludeRoot )
    {
        string $populateType = teGetAllowedSourceTypes($useCheckBox);
        $populateCmd += $populateType + " ";
        if( $checkboxUseAddRelatedKG )
        {
            $populateCmd += "-addRelatedKG true ";
        }

		if( $checkBoxHierarchy ) 
		{
            $populateCmd += "-recursively ";
		}

		if( $checkBoxIncludeRoot ) 
		{
            $populateCmd += "-includeRoot ";
		}

    }
    else
    {
        return 0;
    }
    
	if($poseClip){
		$populateCmd += "-poseClip true ";
	}


    if($object == "")
    {
        $populateCmd += "-q -aso;";
    }
    else
    {
        $populateCmd += "-q -ao \"" + $object + "\";";
    }
	
    // Execute the command
    float $results[] = eval($populateCmd);
    int $numAttr = $results[0];
    
    global float $gCCanimStart;
    global float $gCCanimDuration;
    
    $gCCanimStart = $results[1];  // store queries animation start/duration
    $gCCanimDuration = $results[2];
    
    return $numAttr;
}

////////////////////////////////////////////////////////////////////////////////////

//  Description:
//      Generates the Add Animation option UI
//
//  Input Arguments:
//      $parent         - optionBox parent
//      $action         - Populating Animated Objects(3) or sets(4)
//      $useStartTime   - whether we should use the given $startTime
//      $startTime      - start time to be use to populate the clip
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode      - indicate the track to add the container, if none specified [empty string] 
//                           the current selected track will be chosen (and if none selected, a new track will be created)
//      $objectToAdd    - object to use to create the container option box. if empty string is passed in, current selection will be used instead
//      $poseOnly	    - if poseOnly don't display info about duration and move animation
//
//  Return Value:
//      None.
//
    
global proc teCreateAddAnimOptionsUI(string $parent, int $action, int $useStartTime, float $startTime, int $createNewTrack, string $trackNode, string $objectToAdd, int $poseOnly)
{   
    global string $gTEAddAnimApplyAndCloseBtn;
    global string $gTEAddAnimCloseBtn;

    setParent $parent;
    
    //  Activate the default UI template so that the layout of this 
    //  option box is consistent with the layout of the rest of the 
    //  application.
    setUITemplate -pushTemplate DefaultTemplate;

    waitCursor -state 1;

    scrollLayout -childResizable true teAddAnimOptionsTopLayout; 

    int $createAnimSourceOnly = `optionVar -q teCreateAnimSourceOnly`;
    int $createAnimParentXForm = `optionVar -q teCreateAnimParentXForm`;
    columnLayout -adjustableColumn 1 -rowSpacing 4;
        frameLayout -label (uiRes("m_teCreateContainer.kCreateContainerOptionsCreation")) -collapsable false -collapse false;
            columnLayout -adj 1;

                textFieldGrp 
                    -label (uiRes("m_teCreateContainer.kCreateContainerName")) 
                    -text `optionVar -q cteContainerName`
                    createContainerNameTextGrp;
                if(!$poseOnly)
				{

					columnLayout -adj 1;

						radioButtonGrp 
							-vertical
							-numberOfRadioButtons 2
							-label "" 
							-label1 (uiRes("m_teCreateContainer.kMoveAnimToScene"))
							-label2 (uiRes("m_teCreateContainer.kDuplicateAnimation"))
							-select `optionVar -q tePopulateAnimOptions`
							-cc "optionVar -intValue tePopulateAnimOptions #1"
							tePopulateAnimRadioGrp;

					setParent ..;
				}
					columnLayout;
						checkBoxGrp -ncb 1 -vr
							-label1 (uiRes("m_teCreateContainer.kTEChkBoxCreaeAnimSourceOnly"))
							-value1 $createAnimSourceOnly
							-changeCommand1 ("teCreateAnimSourceOnlyCB " + $poseOnly)
							teCreateAnimSourceOnlyChkBox;

                        checkBoxGrp -ncb 1 -vr
							-label1 (uiRes("m_teCreateContainer.kTEChkBoxCreateAnimParentXForm"))
							-value1 $createAnimParentXForm
							teCreateAnimParentXFormChkBox;
					setParent ..;   
				
            setParent ..;
        setParent ..;

        frameLayout -label (uiRes("m_teCreateContainer.kCreateContainerOptions")) -collapsable false -collapse false;
            rowColumnLayout -numberOfRows 1 teCreateAnimClipNbAttrsRowColumnLayout;
                textFieldGrp -editable false  -width 250 createContainerNumAttr;
                text -label (uiRes("m_teCreateContainer.kCreateAnimClipNbAttrs")) ;
            setParent ..; //rowColumnLayout

            columnLayout;
                checkBoxGrp -ncb 3 -vr 
                -labelArray3 (uiRes("m_teCreateContainer.kCTECheckBoxUseAnimCurve"))
                             (uiRes("m_teCreateContainer.kCTECheckBoxUseConstantValues"))
                             (uiRes("m_teCreateContainer.kCTECheckBoxUseNonCurveAnim"))
                -valueArray3 `optionVar -q ctePopulateUseCurveAnim`
                             `optionVar -q ctePopulateUseNonAnimAttrib`
                             `optionVar -q ctePopulateUseNonCurveAnim`

                -changeCommand1 ("teRefreshAttributesOptions \"" + $objectToAdd + "\"" + $useStartTime + " " + $startTime + " " + $poseOnly)
                -changeCommand2 ("teRefreshAttributesOptions \"" + $objectToAdd + "\"" + $useStartTime + " " + $startTime + " " + $poseOnly)
                -changeCommand3 ("teRefreshAttributesOptions \"" + $objectToAdd + "\"" + $useStartTime + " " + $startTime + " " + $poseOnly)

                tePopulateAttribChkBox;
            setParent ..;

            separator;

            columnLayout;
                checkBoxGrp -ncb 1 -vr
                    -label1 (uiRes("m_teCreateContainer.kCTECheckBoxHierarchy"))
                    -value1 `optionVar -q ctePopulateHierarchy`
                    -changeCommand ("teRefreshAttributesOptions \"" + $objectToAdd + "\"" + $useStartTime + " " + $startTime + " " + $poseOnly)
                    tePopulateHierarchyChkBox;
            setParent ..;
            
            columnLayout;
                checkBoxGrp -ncb 1 -vr
                    -label1 (uiRes("m_teCreateContainer.kCTECheckBoxIncludeRoots"))
                    -value1 `optionVar -q ctePopulateIncludeRoot`
                    -changeCommand("teRefreshCreateContainerNumAttr \"" + $objectToAdd + "\" " + $poseOnly )
                    tePopulateIncludeRootChkBox;
            setParent ..;

            separator;


            columnLayout;
                checkBoxGrp -ncb 1 -vr
                    -label1 (uiRes("m_teCreateContainer.kCTECheckBoxUseSet"))
                    -value1 `optionVar -q tePopulateSetChkBox`
                    -changeCommand ("teRefreshSetSelectionOption 1 \"" + $objectToAdd + "\" "  + $poseOnly)
                    tePopulateSetChkBox;
            setParent ..;
            
            columnLayout;
                checkBoxGrp -ncb 1 -vr
                    -label1 (uiRes("m_teCreateContainer.kCheckBoxUseAddRelatedKG"))
                    -value1 `optionVar -q ctePopulateCompleteHIK`
                    -changeCommand("teRefreshCreateContainerNumAttr \"" + $objectToAdd + "\" " + $poseOnly )
                    tePopulateCompleteHIKChkBox;
            setParent ..;

        setParent ..; //frameLayout
        if(!$poseOnly){
			frameLayout -label (uiRes("m_teCreateContainer.kCreateAnimTiming")) 
								-collapsable false 
								-collapse false 
								-enable ($createAnimSourceOnly==0)
								teAnimTimeOptionsFrameLayout;

				columnLayout -adj 1;
					checkBoxGrp -ncb 1 -vr
						-label1 (uiRes("m_teCreateContainer.kUseOrigTime"))
						-value1 (`optionVar -q teOriginalTimeAndDuration` == 1 && $useStartTime == 0)       // if start time specified, don't use animation time by default
						-changeCommand ("teOriginalTimeAndDurationCB")
						teOriginalTimeAndDurationChkBox;
				setParent ..;
            
				columnLayout teAnimTimeOptionsColumnLayout;
					columnLayout;
						textFieldGrp -label (uiRes("m_teCreateContainer.kCreateContainerStart")) 
											   -text ($useStartTime==1 ? $startTime : 1) 
											   -textChangedCommand "teUpdateDurationCB"
											   -width 250
												createContainerStart;
						rowLayout -numberOfColumns 4 -columnWidth4 170 110 110 110 -columnOffset4 5 1 1 1;
							text -label (uiRes("m_teCreateContainer.kStartResetOptions")) -align "right";
							button
								-label (uiRes("m_teCreateContainer.kButtonStartSetToCurrentLabel"))
								-command teStartSetToCurrent
								teSetStartToCurrentButton;

							button
								-label (uiRes("m_teCreateContainer.kButtonsSetToAnimStartLabel"))
								-command teStartSetToAnimStart
								teSetToAnimStartButton;

							button
								-label (uiRes("m_teCreateContainer.kButtonsSetToSceneStartLabel"))
								-command teStartSetToSceneStart
								teSetToSceneStartButton;
						setParent ..; //rowLayout
					setParent ..; //columnLayout

					columnLayout;
						textFieldGrp -label (uiRes("m_teCreateContainer.kTECreateAnimClipEnd")) 
											   -text ($useStartTime==1 ? $startTime+1 : 2) 
											   -textChangedCommand "teUpdateDurationCB"
											   -width 250
												createContainerEnd;
						rowLayout -numberOfColumns 4 -columnWidth4 170 110 110 110 -columnOffset4 5 1 1 1;
							text -label (uiRes("m_teCreateContainer.kCTEEndResetOptions")) -align "right";
							button
								-label (uiRes("m_teCreateContainer.kButtonsEndSetToCurrentLabel"))
								-command teEndSetToCurrent
								teSetEndToCurrentButton;

							button
								-label (uiRes("m_teCreateContainer.kButtonsSetToAnimLengthLabel"))
								-command teEndSetToAnimEnd
								teSetToAnimEndButton;

							button
								-label (uiRes("m_teCreateContainer.kButtonsSetToSceneLengthLabel"))
								-command teEndSetToSceneEnd
								teSetToSceneEndButton;
						setParent ..; //rowLayout
					setParent ..; //columnLayout

					rowColumnLayout -numberOfRows 1;            
						textFieldGrp -label (uiRes("m_teCreateContainer.kCreateContainerDuration")) -editable false  -width 250 createContainerDuration;
						text -label (uiRes("m_teCreateContainer.kTECreateAnimFrames")) ;
					setParent ..; //rowColumnLayout
				setParent ..; //columnLayout
            
			setParent ..;   // frameLayout
		}

        separator;
        
        frameLayout 
            -label ""
            -labelVisible false
            -collapsable false 
            -collapse false;
                            
            columnLayout -adj 1;
                checkBoxGrp -ncb 1 -vr
                    -label1 (uiRes("m_teCreateContainer.kShowOptionsOnEveryAdd"))
                    -value1 `optionVar -q teShowOptionsOnEveryAdd`
                    -changeCommand ("teShowOptionsOnEveryAddCB(" + $useStartTime + "," + $poseOnly + ")")     // only reset to default if no start provided
                    teShowOptionsOnEveryAddChkBox;
            setParent ..;
        setParent ..;
            
    setParent ..;   // columnLayout

    // Build the buttons in dialog
    //
    

    string $applyCmd = 
		"teCreateContainerSaveOptions " + $poseOnly + ";"  + 
		"teCreateContainerAction( " + ($poseOnly ? $useStartTime: "0") + "," + ($poseOnly ? $startTime: "0") + ", " + $createNewTrack + ", \"" + $trackNode + "\", \"" + $objectToAdd + "\", " +  $poseOnly + ");" + 
		"hideOptionBox;";
	


    $gTEAddAnimApplyAndCloseBtn = getOptionBoxApplyBtn();
    button -e -label (uiRes("m_teCreateContainer.kTEAddAnimGetApplyAndClose"))
           -command($applyCmd)
           $gTEAddAnimApplyAndCloseBtn;
           
    $gTEAddAnimCloseBtn = getOptionBoxCloseBtn();
    button -e -label (uiRes("m_teCreateContainer.kTEAddAnimGetClose"))
           -command("hideOptionBox")
           $gTEAddAnimCloseBtn;
           
    string $resetBtn = getOptionBoxResetBtn();
    button -e -command("teCreateContainerResetOptions(" + $action + ", " + $objectToAdd + "\"\", " + $useStartTime + ", " +$startTime + "," + $poseOnly + ");")
           $resetBtn;
           
    string $saveBtn = getOptionBoxSaveBtn();
    button -e -command("teCreateContainerSaveOptions(" + $poseOnly + ");")
           $saveBtn;

    setUITemplate -popTemplate;
    
    // Refresh
    teRefreshOptionsUI($action, $objectToAdd, $useStartTime, $startTime, $poseOnly);
    if($poseOnly)
		scriptJob -parent $parent -event "SelectionChanged" selectionChangedCBPose;
	else
		scriptJob -parent $parent -event "SelectionChanged" selectionChangedCB;
    
    waitCursor -state 0;
}

////////////////////////////////////////////////////////////////////////////////////

//  Description:
//      Pop up the option modal dialog
//
//  Input Arguments:
//      $action       - which action are we actually performing
//                          3: Populating Animated Objects
//                          4: Populating Sets
//      $useStartTime - whether we should use the given $startTime
//      $startTime    - start time to be use to populate the clip
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode    - indicate the track to add the container, if none specified [empty string] the current selected track will be chosen (and if none selected, a new track will be created)
//      $objectToAdd  - object to use to create the container option box. if empty string is passed in, current selection will be used instead
//
//  Return Value:
//      None.
//
proc teCreateContainerOptionBox(int $action, int $useStartTime, float $startTime, int $createNewTrack, string $trackNode, string $objectToAdd)
{
    string $commandName = "TimeEditorAddAnimation";
    
    global string $gOptionBoxOptions;
    $gOptionBoxOptions = "noApplyAndClose";
    string $layout = getOptionBox();
    
    setOptionBoxCommandName($commandName);
    
    teCreateAddAnimOptionsUI($layout, $action, $useStartTime, $startTime, $createNewTrack, $trackNode, $objectToAdd, 0);
    
    setOptionBoxTitle((uiRes("m_teCreateContainer.kCTECreateContainerOptionsTitle")));
    setOptionBoxHelpTag($commandName);
    
    showOptionBox();
    
    global string $gOptionBox;
    window -e -widthHeight 555 650 $gOptionBox;
}


////////////////////////////////////////////////////////////////////////////////////

//  Description:
//      Pop up the option modal dialog
//
//  Input Arguments:
//      $action       - which action are we actually performing
//                          1: Populating Animated Objects
//                          2: Populating Sets
//      $useStartTime - whether we should use the given $startTime
//      $startTime    - start time to be use to populate the clip
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode    - indicate the track to add the container, if none specified [empty string] the current selected track will be chosen (and if none selected, a new track will be created)
//      $objectToAdd  - object to use to create the container option box. if empty string is passed in, current selection will be used instead
//
//  Return Value:
//      None.
//
proc teCreatePoseOptionBox(int $action, int $useStartTime, float $startTime, int $createNewTrack, string $trackNode, string $objectToAdd)
{

    string $commandName = "TimeEditorAddPose";
    
    global string $gOptionBoxOptions;
    $gOptionBoxOptions = "noApplyAndClose";
    string $layout = getOptionBox();
    
    setOptionBoxCommandName($commandName);
    
    teCreateAddAnimOptionsUI($layout, $action, $useStartTime, $startTime, $createNewTrack, $trackNode, $objectToAdd, 1);
    
    setOptionBoxTitle((uiRes("m_teCreateContainer.kCTECreatePoseOptionsTitle")));
    setOptionBoxHelpTag($commandName);
    
    showOptionBox();
    
    global string $gOptionBox;
    window -e -widthHeight 555 650 $gOptionBox;
}



//  Description:
//      Creates a Container Clip and Populates Scene Selection into the clip.
//
//  Input Arguments:
//      $action         - Which action to execute
//                          1: Populate using current setting
//                          2: Bring up population option box (not sure, figure out at runtime)
//                          3: Bring up population option box (for objects)
//                          4: Bring up population option box (for sets)
//      $useStartTime   - Determine whether or not to specify start time
//      $startTime      - Specify the start time
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode    - indicate the track to add the container, if none specified [empty string] the current selected track will be chosen (and if none selected, a new track will be created)
//      $objectToAdd  - object to use to create the container option box. if object is part of selection, entire selection will be used, but if it's not part of the selection, only the object will be used. if empty string is passed in, current selection will be used.
//		$poseClip     - if true it create a pose 
//
//  Return Value:
//      None.
//
proc tePerformContainerCreate(int $action, int $useStartTime, float $startTime, int $createNewTrack, string $trackNode, string $objectToAdd, int $poseClip)
{
    // gather a list of selected objects (will exclude CTE objects e.g. tracks, clips, groups and etc.)
    string $selectedObjs[] = `ls -sl -dep`;
    
    if($objectToAdd != "")
    {
        // if objectToAdd is valid and part of selection, wipe out that string since -aso flag will be used
        if(stringArrayContains($objectToAdd, $selectedObjs))
        {
            $objectToAdd = "";
        }
        // if objectToAdd is valid and not part of current selection, replace selection with that object
        else
        {
            clear($selectedObjs);
            $selectedObjs[0] = $objectToAdd;
        }
    }
    
    if(size($selectedObjs) == 0)
    {
        warning (uiRes("m_teCreateContainer.kCTENoSelectionFoundOnClipCreate"));
        return;
    }
    
    string $warningMsg = (uiRes("m_teCreateContainer.kCreateContainerOptionErrorMsg"));
    
    // if any of the selected object doesn't match, print error message and return 
    // (sets and animated object has a different population option, so if there's a mixture of set/object being selected, reject the cmd)
    switch ($action)
    {
    case 1:
    case 2:
        int $type = 1; // when type is 1, we haven't validate which type of selection it will be
        for($obj in $selectedObjs)
        {
            if(`objectType -isAType "dagNode" $obj`)
            {
                if($type == 1)
                {
                    $type = 2;
                }
                else if($type == 3) // if we found object of another type during the loop, there is a mismatch
                {
                    warning $warningMsg;
                    return;                 
                }   
            }
            else if(`objectType -isAType "objectSet" $obj`)
            {
                if($type == 1)
                {
                    $type = 3;
                }
                else if($type == 2) // if we found object of another type during the loop, there is a mismatch
                {
                    warning $warningMsg;
                    return;                 
                }
            }
        }
        // Force to open the option box if user want to set name and time for every add
        int $showOptionsOnEveryAdd = `optionVar -q teShowOptionsOnEveryAdd`;
        if( $showOptionsOnEveryAdd == 1 || $action == 2 )
        {
			if( $type == 1 )
				// If our selection is still not validated, then we have nodes
				// that are neither dagNode nor objectSet. Run the command using the
				// current settings to add a clip for animation on the selected nodes.
				$action = 1;
            else if( $type == 2 )
                $action = 3;
            else if( $type == 3 )
                $action = 4;
        }
        break;      
    case 3:
        for($obj in $selectedObjs)
        {
            if(`objectType -isAType "dagNode" $obj` == false && `objectType -isAType "objectSet" $obj` == true)
            {
                warning $warningMsg;
                return;
            }
        }   
        break;
    case 4:
        for($obj in $selectedObjs)
        {   
            if(`objectType -isAType "objectSet" $obj` == false && `objectType -isAType "dagNode" $obj` == true)
            {
                warning $warningMsg;
                return;
            }
        }
        break;
    }   
    
    // set the optionVars first
    teCreateContainerOptionVars(false, $action);

    if($action == 1) {
        // run the command use current settings
        teCreateContainerAction $useStartTime $startTime $createNewTrack $trackNode $objectToAdd $poseClip;
    } else if ($action == 3) {
        // bring up the default option box
		if(!$poseClip){
			teCreateContainerOptionBox(3, $useStartTime, $startTime, $createNewTrack, $trackNode, $objectToAdd);
		} else {
			teCreatePoseOptionBox(3, $useStartTime, $startTime, $createNewTrack, $trackNode, $objectToAdd);
		}

    } else if ($action == 4) {
        // bring up the option box for sets
		if(!$poseClip){
			teCreateContainerOptionBox(4, $useStartTime, $startTime, $createNewTrack, $trackNode, $objectToAdd);
		} else {
			teCreatePoseOptionBox(4, $useStartTime, $startTime, $createNewTrack, $trackNode, $objectToAdd);
		}
    }
}

//  Description:
//      Initialize the option values.
//
//  Input Arguments:
//      Whether to set the options to default values.
//
//  Return Value:
//      None.
//
global proc teCreateContainerOptionVars(int $reset_default, int $action)
{
    int $setContainerName = ($reset_default || !`optionVar -exists cteContainerName`);

    optionVar -init $reset_default -category "Time Editor.Create Clip"
        -sv cteContainerName "anim_Clip1"
        -iv ctePopulateUseNonAnimAttrib 0
        -iv ctePopulateUseCurveAnim 1
        -iv ctePopulateUseNonCurveAnim 0
        -iv ctePopulateHierarchy 1
        -iv ctePopulateIncludeRoot 1
        -iv ctePopulateCompleteHIK 1
        -iv tePopulateAnimOptions 1
        -iv teCreateAnimSourceOnly 0
		-iv teCreateAnimParentXForm 1
        -iv teOriginalTimeAndDuration 1
        -iv teShowOptionsOnEveryAdd 0
        ;

    if ($setContainerName && $action == 4) {
        optionVar -sv cteContainerName "set_Group1";
    }
}

//  Description:
//      Updates the Option Vars from current check box if $gTECreateContainerSaveOptionAsDefault is false
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc teCreateContainerSaveOptions(int $poseOnly)
{
    global int $gTECreateContainerSaveOptionAsDefault;
    
    if(!$gTECreateContainerSaveOptionAsDefault)
    {
        $sVal = `textFieldGrp -q -text createContainerNameTextGrp`;
        optionVar -stringValue cteContainerName $sVal;
        
        $val = `checkBoxGrp -q -value2 tePopulateAttribChkBox`;
        optionVar -intValue ctePopulateUseNonAnimAttrib $val;

        $val = `checkBoxGrp -q -value1 tePopulateAttribChkBox`;
        optionVar -intValue ctePopulateUseCurveAnim $val;

        $val = `checkBoxGrp -q -value3 tePopulateAttribChkBox`;
        optionVar -intValue ctePopulateUseNonCurveAnim $val;

        $val = `checkBoxGrp -q -value1 tePopulateHierarchyChkBox`;
        optionVar -intValue ctePopulateHierarchy $val;

        $val = `checkBoxGrp -q -value1 tePopulateIncludeRootChkBox`;
        optionVar -intValue ctePopulateIncludeRoot $val;

        $val = `checkBoxGrp -q -value1 tePopulateCompleteHIKChkBox`;
        optionVar -intValue ctePopulateCompleteHIK $val;
		if(!$poseOnly){
			$val = `radioButtonGrp -q -select tePopulateAnimRadioGrp`;
			optionVar -intValue tePopulateAnimOptions $val;
		}

        $val = `checkBoxGrp -q -value1 teCreateAnimSourceOnlyChkBox`;
        optionVar -intValue teCreateAnimSourceOnly $val;

        $val = `checkBoxGrp -q -value1 teCreateAnimParentXFormChkBox`;
        optionVar -intValue teCreateAnimParentXForm $val;

		if(!$poseOnly){
			$val = `checkBoxGrp -q -value1 teOriginalTimeAndDurationChkBox`;
			optionVar -intValue teOriginalTimeAndDuration $val;
		}

        $val = `checkBoxGrp -q -value1 teShowOptionsOnEveryAddChkBox`;
        optionVar -intValue teShowOptionsOnEveryAdd $val;
    }
}

//  Description:
//      Reset Values in Option Box
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc teCreateContainerResetOptions(int $action, string $objectToAdd, int $useStartTime, float $startTime, int $poseOnly)
{
    // reset the option vars
    teCreateContainerOptionVars 1 $action;

    // update the UI widgets
    // Assumption - All UI widgets are created
    //
    textFieldGrp -e -text `optionVar -q cteContainerName` createContainerNameTextGrp;
    checkBoxGrp -e -value2 `optionVar -q ctePopulateUseNonAnimAttrib` tePopulateAttribChkBox;
    checkBoxGrp -e -value1 `optionVar -q ctePopulateUseCurveAnim` tePopulateAttribChkBox;
    checkBoxGrp -e -value3 `optionVar -q ctePopulateUseNonCurveAnim` tePopulateAttribChkBox;

    checkBoxGrp -e -value1 `optionVar -q ctePopulateHierarchy` tePopulateHierarchyChkBox;

    checkBoxGrp -e -value1 `optionVar -q ctePopulateIncludeRoot` tePopulateIncludeRootChkBox;

    checkBoxGrp -e -value1 `optionVar -q ctePopulateCompleteHIK` tePopulateCompleteHIKChkBox;

    checkBoxGrp -e -value1 `optionVar -q teCreateAnimSourceOnly` teCreateAnimSourceOnlyChkBox;
    
    checkBoxGrp -e -value1 `optionVar -q teCreateAnimParentXForm` teCreateAnimParentXFormChkBox;
    
	if(!$poseOnly)
	{
        radioButtonGrp -e -select `optionVar -q tePopulateAnimOptions` tePopulateAnimRadioGrp;
		checkBoxGrp -e -value1 `optionVar -q teOriginalTimeAndDuration` teOriginalTimeAndDurationChkBox;
	}

    checkBoxGrp -e -value1 `optionVar -q teShowOptionsOnEveryAdd` teShowOptionsOnEveryAddChkBox;

    
    // refresh the UI
    teRefreshOptionsUI($action, $objectToAdd, $useStartTime, $startTime, $poseOnly);
}

////////////////////////////////// Procs for Refreshing UI //////////////////////////////////
//  Input Arguments:
//      $action         - Which action to execute
//                          3: Bring up population option box (for objects)
//                          4: Bring up population option box (for sets)
//      $useStartTime   - Determine whether or not to specify start time
//      $startTime      - Specify the start time
//      $objectToAdd    - Specify the object explicitly to cacualte the number of attributes to be populated.
global proc teRefreshOptionsUI(int $action, string $objectToAdd, int $useStartTime, float $startTime, int $poseOnly)
{
    teCreateAnimSourceOnlyCB($poseOnly);
    teRefreshAttributesOptions $objectToAdd $useStartTime $startTime $poseOnly;
    
    if($action == 3)
    {
        checkBoxGrp -e -enable false -value1 0 tePopulateSetChkBox;
    }
    else if($action == 4)
    {
        checkBoxGrp -e -enable true -value1 1 tePopulateSetChkBox;
    }  
     
    teRefreshSetSelectionOption 1 $objectToAdd $poseOnly;     
    if($action == 4)
    {
        global int $gTECreateContainerSaveOptionAsDefault;
        $gTECreateContainerSaveOptionAsDefault = true; // since a refresh has been called, this global var will be set to false, so force it to true (since user hasn't actually made any changes)  
    }
    
    if($useStartTime == 1 && !$poseOnly)
    {
        float $duration = (float)`textFieldGrp -q -text createContainerEnd` - (float)`textFieldGrp -q -text createContainerStart`;

        // If a valid start Time is given, we should actually use that instead
		textFieldGrp -edit -text $startTime createContainerStart;
		textFieldGrp -edit -text ($startTime + $duration) createContainerEnd;
    }
    
    teShowOptionsOnEveryAddCB($useStartTime, $poseOnly);
	if(!$poseOnly){
		teUpdateDurationCB();
		teOriginalTimeAndDurationCB();
	}
}

global proc teRefreshCreateContainerNumAttr(string $object, int $poseClip)
{
    int $numAttr = teCreateContainerNumAttr($object, 1, $poseClip);
    textFieldGrp -e -text $numAttr createContainerNumAttr;
    
    global string $gTEAddAnimApplyAndCloseBtn;
    if($numAttr > 0){
        button -edit -enable true $gTEAddAnimApplyAndCloseBtn;
    }
    else {
        button -edit -enable false $gTEAddAnimApplyAndCloseBtn;
    }
}

//  Description:
//      Refresh the options which are used to determine the types of attributes to be populated.
//
//  Input Arguments:
//      $refreshNumAttr: Determine whether or not to refresh the number of attributes control
//      $object: Specify the object explicitly to cacualte the number of attributes to be populated.
//
//  Return Value:
//      None.
//
global proc teRefreshAttributesOptions(string $object, int $useStartTime, float $startTime, int $poseOnly)
{
    // Gather the number of attributes to be populated
    // and the animation start and end.
    teRefreshCreateContainerNumAttr($object, $poseOnly);

    // Set the anim start and end according the following rules:
    // 1: If "keyed" option is checked, set to original animation start and end
    // 2: If "Keyed" is unchecked, but "Constrained" is checked, set to scene start and end
    // 3: If only "static" is checked, set duration to 1 and start to current frame.
    //
    if(!$poseOnly){
		if(`checkBoxGrp -q -value1 tePopulateAttribChkBox`) // "Keyed"
		{
			if(!$useStartTime)
			{
				teStartSetToAnimStart;
				teEndSetToAnimEnd;  
			} else {
				global float $gCCanimDuration;
				float $animEnd = $startTime + $gCCanimDuration;   
				int $animEndInt = $animEnd;
				textFieldGrp -e -text $animEndInt createContainerEnd;
			}
        
		}
		else if(`checkBoxGrp -q -value3 tePopulateAttribChkBox`) // "Constrained, etc".
		{
			teEndSetToSceneEnd;
			if(!$useStartTime)
			{
				teStartSetToSceneStart;
			}
		}
		else if(`checkBoxGrp -q -value2 tePopulateAttribChkBox`) // "Static"
		{
			if(!$useStartTime)
			{
				int $currentTime = `timeEditorPanel -query -activeTabTime timeEditorPanel1TimeEd`;
				textFieldGrp -e -text $currentTime createContainerStart;
			} 
			else 
			{
				textFieldGrp -e -text ($startTime + 1) createContainerEnd;
			}
		}
		else
		{
			if(!$useStartTime){
				textFieldGrp -e -text 0 createContainerStart;
			}
			textFieldGrp -e -text 0 createContainerEnd;
		}
	}
}

//  Description:
//      Must be called whenever set selection option is toggled, this ensure populate by set/attributes are mutually exclusive
//
//  Input Arguments:
//      Which action to execute
//
//  Return Value:
//      None.
//
global proc teRefreshSetSelectionOption(int $refreshNumAttr, string $object, int $poseClip) {
    $val = `checkBoxGrp -q -value1 tePopulateSetChkBox`;        
    
    global int $gTECreateContainerSaveOptionAsDefault;
    $gTECreateContainerSaveOptionAsDefault = false; // as long as user edit the check box, set it to false
    
    // if populate by selection is checked, we force select the rest of the attributes
    if($val == 1)
    {
        checkBoxGrp -e -enable false -value1 1 -value2 1 -value3 1 tePopulateAttribChkBox;
        checkBoxGrp -e -enable false -value1 0 tePopulateCompleteHIKChkBox;         
    }
    // when we uncheck, we should renable all of them
    else
    {
        checkBoxGrp -e -enable true tePopulateAttribChkBox;
        checkBoxGrp -e -enable true tePopulateCompleteHIKChkBox;      
    }
    
    if($refreshNumAttr)
    {
        teRefreshCreateContainerNumAttr($object, $poseClip);
    }
}

global proc teCreateAnimSourceOnlyCB(int $poseOnly)
{
	if(!$poseOnly){
		int $enable = (`checkBoxGrp -q -value1 teCreateAnimSourceOnlyChkBox` == 0)? 1 : 0;
		frameLayout -e -enable $enable teAnimTimeOptionsFrameLayout;
	}
}

global proc teOriginalTimeAndDurationCB()
{
    int $visible = (`checkBoxGrp -q -value1 teOriginalTimeAndDurationChkBox` == 0)? 1 : 0;
    columnLayout -e -visible $visible teAnimTimeOptionsColumnLayout;
    if( $visible )
        checkBoxGrp -e -value1 1 teShowOptionsOnEveryAddChkBox;
}

global proc teShowOptionsOnEveryAddCB(int $useStartTime, int $poseOnly)
{
    int $enable = (`checkBoxGrp -q -value1 teShowOptionsOnEveryAddChkBox` == 1)? 1 : 0;
    if( !$enable && !$useStartTime && !$poseOnly)        // if start time was explicitly provided, don't use original time
    {
        optionVar -intValue teOriginalTimeAndDuration 1;
        checkBoxGrp -e -value1 1 teOriginalTimeAndDurationChkBox;
        teOriginalTimeAndDurationCB();
    }
}
global proc selectionChangedCB(){
	selectionChangedCBBase(0);
}
global proc selectionChangedCBPose(){
	selectionChangedCBBase(1);
}
global proc selectionChangedCBBase(int $poseOnly)
{
	global string $gTEAddAnimApplyAndCloseBtn;
    // gather a list of selected objects (will exclude CTE objects e.g. tracks, clips, groups and etc.)
    string $selectedObjs[] = `ls -sl -dep`;
    
    if(size($selectedObjs) == 0)
    {
        warning( uiRes("m_teCreateContainer.kCTENoSelectionFoundOnClipCreate") );
		button -edit -enable false $gTEAddAnimApplyAndCloseBtn;
        textFieldGrp -e -text 0 createContainerNumAttr;
        return;
    }
    
    string $warningMsg = uiRes("m_teCreateContainer.kCreateContainerOptionErrorMsg");
    
    int $type = 1; // when type is 1, we haven't validate which type of selection it will be
    for($obj in $selectedObjs)
    {
        if(`objectType -isAType "dagNode" $obj`)
        {
            if($type == 1)
            {
                $type = 2;
            }
            else if($type == 3) // if we found object of another type during the loop, there is a mismatch
            {
                warning $warningMsg;
                break;
            }   
        }
        else if(`objectType -isAType "objectSet" $obj`)
        {
            if($type == 1)
            {
                $type = 3;
            }
            else if($type == 2) // if we found object of another type during the loop, there is a mismatch
            {
                warning $warningMsg;
                break;               
            }
        }
    }
    
    int $action = $type + 1;

    teRefreshOptionsUI($action, "", 0, 0, $poseOnly);
}

////////////////////////////////// Procs for UI Buttons //////////////////////////////////
global proc teUpdateDurationCB()
{
    float $startFrame = (float)`textFieldGrp -q -text createContainerStart`;
    float $endFrame = (float)`textFieldGrp -q -text createContainerEnd`;
    float $duration = $endFrame - $startFrame;
	float $minDuration = `timeEditorClip -q -minClipDuration`;
    // Duration cannot be negative
    if($duration < $minDuration)
        $duration = $minDuration;
    textFieldGrp -e -text $duration createContainerDuration;
}

////////////////////////////////// Procs for UI Buttons //////////////////////////////////
global proc teStartSetToCurrent()
{
    int $currentTime = `timeEditorPanel -query -activeTabTime timeEditorPanel1TimeEd`;
    textFieldGrp -e -text $currentTime createContainerStart;
}

global proc teStartSetToAnimStart()
{
    global float $gCCanimStart; 
    float $animFirst = $gCCanimStart;
    // round down the start frame
    int $animFirstInt = floor($animFirst);
    textFieldGrp -e -text $animFirstInt createContainerStart;
}

global proc teStartSetToSceneStart()
{
    float $startScene = `playbackOptions -q -ast`;
    textFieldGrp -e -text $startScene createContainerStart;
}

global proc teEndSetToCurrent()
{
    int $currentTime = `timeEditorPanel -query -activeTabTime timeEditorPanel1TimeEd`;
    textFieldGrp -e -text $currentTime createContainerEnd;
}

global proc teEndSetToAnimEnd()
{
    global float $gCCanimStart; 
    global float $gCCanimDuration;
    float $animEnd = $gCCanimStart + $gCCanimDuration;   
    int $animEndInt = $animEnd;
    textFieldGrp -e -text $animEndInt createContainerEnd;
}

global proc teEndSetToSceneEnd()
{
    float $sceneLength = `playbackOptions -q -aet`;
    textFieldGrp -e -text $sceneLength createContainerEnd;  
}

//  Description:
//      Create the Container and Populates Selection
//
//  Input Arguments:
//      $useStartTime - whether to use the value given by $startTime
//      $startTime    - start time to be used to populate the clip
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode    - indicate the track to add the container, if none specified [empty string] the current selected track will be chosen (and if none selected, a new track will be created)
//      $objectToAdd  - object to use to create the container option box. if empty string is passed in, current selection will be used instead
//      $poseOnly	  - if poseOnly don't consider durtation part in the ui
//      
//  Return Value:
//      None.
//
global proc teCreateContainerAction(int $useStartTime, float $startTime, int $createNewTrack, string $trackNode, string $objectToAdd, int $poseOnly)
{
    int $checkboxUseConstantValues  = false;
    int $checkboxUseAnimCurve       = false;
    int $checkboxUseNonCurve        = false;

    int $checkboxHierarchy		    = true;
    int $checkboxIncludeRoot	    = true;
    int $checkboxUseAddRelatedKG    = `optionVar -q ctePopulateCompleteHIK`;
    
    int $usePopulateAttribChkBoxValues = false;

    // Populating from Sets implies that these flags are fixed at predefined values: useConstant, useCurve, useNonCurve.
    // These predefined values are not saved in optionVar, so we must obtain their values from the checkboxes instead.
    if (`checkBoxGrp -exists tePopulateSetChkBox`)
    {
        if (`checkBoxGrp -q -value1 tePopulateSetChkBox`)
        {
            $usePopulateAttribChkBoxValues = true;
        }
    }

    if ($usePopulateAttribChkBoxValues)
    {
        $checkboxUseConstantValues  = `checkBoxGrp -q -value3 tePopulateAttribChkBox`;
        $checkboxUseAnimCurve       = `checkBoxGrp -q -value1 tePopulateAttribChkBox`;
        $checkboxUseNonCurve        = `checkBoxGrp -q -value2 tePopulateAttribChkBox`;

	    $checkboxHierarchy		    = `checkBoxGrp -q -value1 tePopulateHierarchyChkBox`;
		$checkboxIncludeRoot	    = `checkBoxGrp -q -value1 tePopulateIncludeRootChkBox`;

    }
    else
    {
        $checkboxUseConstantValues  = `optionVar -q ctePopulateUseNonAnimAttrib`;
        $checkboxUseAnimCurve       = `optionVar -q ctePopulateUseCurveAnim`;
        $checkboxUseNonCurve        = `optionVar -q ctePopulateUseNonCurveAnim`;

	    $checkboxHierarchy		    = `optionVar -q ctePopulateHierarchy`;
		$checkboxIncludeRoot	    = `optionVar -q ctePopulateIncludeRoot`;

    }
    
    string $selectedObjs[] = `ls -sl -dep`;
    if((size($selectedObjs) > 1) && ($objectToAdd == ""))
    {
        if (`optionVar -q teCreateAnimParentXForm` != 0)
        {
            python("from maya.app.teUtils import teUtils");
            string $commonParentToSelectedTransforms[] = python("teUtils.getCommonParentForSelectedTransforms()");
            if (size($commonParentToSelectedTransforms) > 0 )
            {
                select -add $commonParentToSelectedTransforms[0];
            }
        }
    }

    if (($checkboxUseAnimCurve == 0) && ($checkboxUseNonCurve == 0) && ($checkboxUseConstantValues == 0) &&($checkboxIncludeRoot==0))
    {
        warning( (uiRes("m_teCreateContainer.kCreateContainerNoAttributes")) );
        return;
    }

    // Undo chunk for creating track and creating clip
    undoInfo -openChunk;
    
    int $chkBoxCreateAnimSourceOnly = `checkBoxGrp -exists teCreateAnimSourceOnlyChkBox` ? `checkBoxGrp -q -value1 teCreateAnimSourceOnlyChkBox` : `optionVar -q teCreateAnimSourceOnly`;
    int $originalTimeAndDuration = `checkBoxGrp -exists teOriginalTimeAndDurationChkBox` ? `checkBoxGrp -q -value1 teOriginalTimeAndDurationChkBox` : `optionVar -q teOriginalTimeAndDuration`;
    int $showOptionsOnEveryAdd = `optionVar -q teShowOptionsOnEveryAdd`;
    
    // This action can only be called without option box for populating Maya scenes.
    string $containerName = "anim_Clip1";
    string $customContainerName;
    int $customContainerNameEnabled = `textFieldGrp -exists createContainerNameTextGrp` ;

    if ($customContainerNameEnabled == 1) {
        $customContainerName = `textFieldGrp -q -text createContainerNameTextGrp`;
    }
    if ($customContainerNameEnabled == 1 && $customContainerName != "") {
        $containerName = $customContainerName;
    }
    
    string $populateType = teGetAllowedSourceTypes($usePopulateAttribChkBoxValues);
    if($checkboxUseAnimCurve || $checkboxUseNonCurve || $checkboxUseConstantValues || $checkboxHierarchy )
    {
        if ($checkboxUseAddRelatedKG)
        {
            if($populateType == "")
                $populateType += " ";
            $populateType += "-addRelatedKG true ";
        }

		if( $checkboxHierarchy ) 
		{
            $populateType += "-recursively ";
		}
    }

    if( $checkboxIncludeRoot ) 
    {
        $populateType += "-includeRoot ";
    }

    int $radioGrpAnimOptions = `optionVar -q tePopulateAnimOptions`;
    if($populateType == "")
        $populateType += " ";
    if (!$poseOnly && $radioGrpAnimOptions == 1)
        $populateType += "-rsa 1 ";
    else
        $populateType += "-rsa 0 ";

    string $populateCmd = "";
    // Only create animation source without clip population as required.
    //

	


	$populateCmd = "timeEditorAnimSource ";
	if($objectToAdd != "")
    {
        $populateCmd += "-ao \"" + $objectToAdd + "\" ";
    }
    else
    {   
        $populateCmd += "-aso ";
    } 

	if($poseOnly){
		$populateCmd += "-poseClip true ";
	}
	string $animSource;
    $populateCmd += $populateType + "\"" + $containerName + "\"" +";";
	int $error = catch($animSource = `evalEcho($populateCmd)`);  
	if($error)
	{
		undoInfo -closeChunk;
        int $queueEmpty = `undoInfo -undoQueueEmpty`;
        if ($queueEmpty == 1)
          undo;
		return;
	}
    
	if(!$chkBoxCreateAnimSourceOnly){
        if($createNewTrack)
        {
            $trackNode = teGetActiveTabNewTrackIdString();
        }
        else if($trackNode == "")
        {
            $trackNode = teGetTrackForClipCreation(1, 0); 
    
            if($trackNode == "")
            {
                error((uiRes("m_teCreateContainer.kNoTrackCreated")) );
                undoInfo -closeChunk;
                return;
            }
        }
        
        $populateCmd = "timeEditorClip " ;
		// Collect the duration
		float $minDuration = `timeEditorClip -q -minClipDuration`;
        // If UI doesn't exist, take this chance to check the number of attributes to be populated
        // and gather the animation start and end.
		float $duration = $minDuration;
		if(!$poseOnly)
		{
			global float $gCCanimStart;
			float $timeinfo[] = `timeEditorAnimSource -q -ct $animSource`;
			$gCCanimStart = $timeinfo[0];
			$duration = $timeinfo[1];
		}

        
        // if the clip start offset is not specified explicitly, 
        // set to the animation start by default
        if($useStartTime != 1)
        {
            if(`textFieldGrp -exists createContainerStart` && $originalTimeAndDuration == 0)
            {
                // Animation start offset is set by UI
                 $startTime = (float)`textFieldGrp -q -text createContainerStart`;
            }
            else
            {
                // By default, take original animation start into account
                global float $gCCanimStart;
                $startTime = $gCCanimStart;
            }
        }
        
        int $rootClipId = `timeEditorPanel -query -activeTabRootClipId timeEditorPanel1TimeEd`;
        $populateCmd += "-startTime " + $startTime + " ";
        $populateCmd += "-rootClipId " + $rootClipId + " ";
        
        
        
		if(!$poseOnly){
			if(`textFieldGrp -exists createContainerDuration` && $originalTimeAndDuration == 0)
			{
				$duration = `textFieldGrp -q -text createContainerDuration`;
				if($duration < `timeEditorClip -q -minClipDuration`)
				{
					error((uiRes("m_teCreateContainer.kInvalidDuration")) );
					undoInfo -closeChunk;
					return;
				}
			}
		}
        $populateCmd += " -duration " + $duration + " ";
    
		if($poseOnly){
			$populateCmd += "-poseClip true ";
		}

		$populateCmd += "-animSource " + "\"" + $animSource + "\" ";


        $populateCmd += "-track \"" + $trackNode + "\" " + "\"" + $containerName + "\"" +";";
    }
	
	$error = catch($newClipId = `evalEcho($populateCmd)`);  
	
    undoInfo -closeChunk;

	if ($error) {
		undo;	
	}
}

//  Description:
//      Creates a Container Clip at the specific time and Populates Scene Selection into the clip.
//
//  Input Arguments:
//      $action     - Which action to execute
//                          1: Populate using current setting
//                          2: Bring up population option box (not sure, figure out at runtime)
//                          3: Bring up population option box (for objects)
//                          4: Bring up population option box (for sets)
//      $startTime  - Start time
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode    - indicate the track to add the container, if none specified [empty string] the current selected track will be chosen (and if none selected, a new track will be created)
//      $objectToAdd  - object to use to create the container option box. if object is part of selection, entire selection will be used, but if it's not part of the selection, only the object will be used. if empty string is passed in, current selection will be used.
//
//  Return Value:
//      None.
//
global proc teCreateContainerAt(int $action, float $startTime, int $createNewTrack, string $trackNode, string $objectToAdd)
{
    tePerformContainerCreate($action, 1, $startTime, $createNewTrack, $trackNode, $objectToAdd, 0);
}

//  Description:
//      Return the last empty animation track in the current composition.
//
//  Return Value:
//      last empty track in the form of compositionName:trackId.
//
global proc string teLastEmptyAnimationTrack(int $trackType)
{
    string $comp = `timeEditorComposition -q -act`;
    string $tracks[] = `timeEditorTracks -q -allTracks $comp`;

    string $empty = "";
    for($i = size($tracks) - 1; $i >= 0; --$i){
        string $result[];
        tokenize($tracks[$i], ":", $result);
        int $tid = $result[1];
        if(`timeEditorTracks -q -trackType -trackIndex $tid $comp` != $trackType){ 
            continue;
        }
        int $clips[] = `timeEditorTracks -q -allClips -trackIndex $tid $comp`;
        if(!size($clips)){
            $empty = $tracks[$i];
        } else {
            break; //no empty clip found before something else
        }
    }
    return $empty;
}


//  Description:
//      Creates a Container Clip and Populates Scene Selection into the clip without a specified time.
//
//  Input Arguments:
//      $action - Which action to execute
//                          1: Populate using current setting
//                          2: Bring up population option box (not sure, figure out at runtime)
//                          3: Bring up population option box (for objects)
//                          4: Bring up population option box (for sets)
//      $createNewTrack - indicate if a new track should be created (if this is true, $trackNode parameter will be ignored)
//      $trackNode      - indicate the track to add the container, if none specified [empty string] the current selected track
//                        will be chosen (and if none selected, a new track will be created)
//
//  Return Value:
//      None.
//
global proc teCreateContainer(int $action, int $createNewTrack, string $trackNode)
{
    tePerformContainerCreate($action, 0, 0, $createNewTrack, $trackNode, "",  0);
}


//  Description:
//      Mute all unselected TimeEditor tracks and clips and expand selection
//      to add all driven objects of selected clips.
//      If no clip is currently selected, nothing is changed.
//
//  Output Arguments:
//    These output arguments will be updated and can be used later to restore 
//    the initial state, using teRestoreSelection() :
//		$initSelection	- Initial selection
//		$allClipIds		- All muted clip IDs
//      $mutedState		- Muted state of each clip (synced with preceding array)
//
//  Return Value:
//      Returns the information required to be able to reset the state and 
//      selection back to the previous state, using teRestoreSelection()
//
global proc teIsolateSelection(string $initSelection[], int $allClipIds[], int $mutedState[])
{
	// Preserve info to be able to restore selection and mute state
    $initSelection = `ls -sl`;
	int $selectedClipIds[] = `timeEditor -selectedClips ""`;
	
	if (`size($selectedClipIds)` == 0) {
		clear($allClipIds);
		clear($mutedState);
		print (uiRes("m_teCreateContainer.kFoobar"));
		return;
	}

	// Strategy : Mute all unselected clips, except if they are children of a selected parent group.
	
    // All container clips (recursive) in the active composition
    $allClipIds = `timeEditor -allClips "container"`;
	
	// All selected groups in the active composition
	int $selGroups[] = `timeEditor -selectedClips "group"`;
	
	// Remove all the children clips existing below all selected groups from the list of
	// potential clips to mute.
	if (`size($selGroups)` != 0) {
	    // build cmd to get all unique children container clips, existing below all selected groups	
		string $cmd = "timeEditor -allClips \"container\"";
		for($grpId in $selGroups) {
			$cmd += " -clipId " + string($grpId);
		}
		$cmd += ";";
		int $children[] = `eval($cmd)`;
		
		// Remove those children from list of potential clips to mute.
		int $purifiedList[];
		int $count = 0;
		for($clipId in $allClipIds) {
			// Does it exist as a selected group child?
			int $exists = 0;
			for($childId in $children) {
				if ($clipId == $childId) {
					$exists = 1;
					break;
				}
			}
			if (!$exists) {
				$purifiedList[$count++] = $clipId;
			}
		}
		$allClipIds = $purifiedList;
	}

	// Mute each unselected clip after saving their current state.
    // We do not affect groups, to avoid muting a group when one of its leaf is selected.
	int $clipCount = 0;
	for($clipId in $allClipIds) {
		int $isMuted = `timeEditorClip -q -mute -clipId $clipId`;
		$mutedState[$clipCount++] = $isMuted;
		
		int $isSelected = 0;
		for($selId in $selectedClipIds) {
			if ($selId == $clipId) {
				$isSelected = 1;
				break;
			}
		}
		
		if (!$isSelected) {
			timeEditorClip -e -mute 1 -clipId $clipId;
		}
	}
	
	// Now, make sure to select the driven objects of each selected clip/group
    for($clipId in $selectedClipIds) {
		teSelectDrivenObjects $clipId;
	}
}


//  Description:
//      Reverts the effect of teIsolateSelection()
//
//  Input Arguments:
//    These arguments should have been initialized with teIsolateSelection :
//		$initSelection	- Initial selection
//		$allClipIds		- All clip IDs
//      $mutedState		- Muted state of each clip (synced with preceding array)
//
//  Return Value:
//      None
//
global proc teRestoreSelection(string $initSelection[], int $allClipIds[], int $mutedState[])
{
	// Restore original selection
	select $initSelection;

	// restore original muted state
	int $clipCount = 0;
	for($clipId in $allClipIds) {
		int $isMuted = $mutedState[$clipCount++];
		timeEditorClip -e -mute $isMuted -clipId $clipId;
	}
}


//  Description:
//      Create a pose clip with current values at the current time
//   The populated attributes are either:
//      - Selected ones in the channel box
//      - Keyable ones 
//  Steps:
//      1. Create a new AnimSource
//      2. Create a new Track, if necessary
//      3. Create the pose Clip
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc teCreatePoseClip( int $action,  string $trackNode ) 
{
	if(!`exists selectedChannelBoxAttributes`) 
        source selectedChannelBoxAttributes.mel;
	
	// First, make sure to select the driven objects of each selected clip/group
	// and isolate (mute) all unselected tracks/clips, so the pose is only affected
	// by the user's selection
    string $initSelection[];	// Initial selection
	int    $allClipIds[];		// All clip IDs
	int    $mutedState[];		// Muted state of each clip (synced with preceding array)
	teIsolateSelection($initSelection, $allClipIds, $mutedState);

	tePerformContainerCreate($action, 1, `currentTime -q`, 0, $trackNode, "", 1);

	teRestoreSelection($initSelection, $allClipIds, $mutedState);
}
	



//
// Description:
//      Performs the necessary actions to create an audio container
//
// Input Argument:
//      None
//
global proc teCreateAudioContainer( string $trackNode ) 
{   
    optionVar -init false -category "Time Editor"
        -sv "teAudioImportFilterType" "All Allowed Audio Files";

    // open file dialog
    string $filter = (uiRes("m_teCreateContainer.kAudioFilter")) +" (*.wav *.aiff *.aif);;" +
                     (uiRes("m_teCreateContainer.kAudioWAV")) +" (*.wav);;" + 
                     (uiRes("m_teCreateContainer.kAudioAIFF")) + " (*.aiff *.aif)";

    string $selectedFilter = `optionVar -q "teAudioImportFilterType"`;
    string $startDir = teGetClipExportsDir();
    string $paths[] = `fileDialog2 -fileMode 1 -fileFilter $filter -caption (uiRes("m_teCreateContainer.kCTEImportAudioCaption")) -selectFileFilter $selectedFilter -returnFilter 1 -startingDirectory $startDir`;
    if ( size($paths) != 2 ) return;
    
    string $filename = $paths[0];

    // Remember the latest location accessed. 
    teSaveClipExportsDir($filename);

    optionVar -sv "teAudioImportFilterType" $paths[1]; // update the selected filter
    string $name = filepart($filename); 
    
    string $files[] = {$filename};

    float $startTime = `timeEditorPanel -query -activeTabTime timeEditorPanel1TimeEd`;
    int $rootClipId = `timeEditorPanel -query -activeTabRootClipId timeEditorPanel1TimeEd`;

    tePerformImportAudioFiles($files, $trackNode, $startTime, $rootClipId);
}

//
// Description:
//      Open Content Browser from Time Editor
//
// Input Argument:
//      None.
//
//  Return Value:
//      None.
//
global proc teOpenContentBrowser()
{
    // Create the default directory if it does not exist
    teInitClipExportsDir();
    
    // Open the content browser
    ContentBrowserWindow;

    // Hack workaround: 
    // Content browser will ignore the remembered location once the project is changed. It's not desired here.
    // As workaround, clear up previous saved context, so that it can reflect projec change.
    // Note: OptionVar "TimeEditorContentBrowserContext" is saved by content browser.
    string $wsName = `workspace -q -sn`; 
    if(`optionVar -exists "TimeEditorContentBrowserContext"`)
    {
        string $paths[] = `optionVar -q "TimeEditorContentBrowserContext"`;
        if(size($paths) > 1 && $paths[1] != $wsName)
        {
            optionVar -remove TimeEditorContentBrowserContext;
        }
    }
    
    // Set proper default location  
    contentBrowserSetContext("TimeEditor", "projects", $wsName + ";Time Editor/Clip Exports");
}

proc string sourceFileTypeFilter()
{
    string $filter = (uiRes("m_teCreateContainer.kAnimFilter1")) + " (*.mb *.ma *.fbx);;" + 
                     (uiRes("m_teCreateContainer.kAnimFilter2")) + " (*.mb);;" + 
                     (uiRes("m_teCreateContainer.kAnimFilter3")) + " (*.ma);;" + 
                     (uiRes("m_teCreateContainer.kAnimFilter4")) + " (*.fbx)";

	return $filter;
}


//
// Description:
//      Performs the necessary actions to import an animation clip
//
// Input Argument:
//      None
//
global proc teImportAnimationClip(string $trackString)
{
    optionVar -init false -category "Time Editor"
        -sv "teAnimImportFilterType" "Animation File";

    // open file dialog
	string $filter = sourceFileTypeFilter();
    string $selectedFilter = `optionVar -q "teAnimImportFilterType"`;
    string $startDir = teGetClipExportsDir();
    string $paths[] = `fileDialog2 -fileMode 1 -fileFilter $filter 
                                    -caption (uiRes("m_teCreateContainer.kCTEImportAnimationCaption")) 
                                    -selectFileFilter $selectedFilter 
                                    -returnFilter 1
                                    -startingDirectory $startDir`;
    if ( size($paths) != 2 ) return;
    
    string $filename = $paths[0];

    // Remember the latest location accessed. 
    teSaveClipExportsDir($filename);

    optionVar -sv "teAnimImportFilterType" $paths[1]; // update the selected filter

    string $trackNodeIndex = $trackString != "" ?
		$trackString :						// use provided animation track
		teGetTrackForClipCreation(0, 0);   	// get an animation track
    // Pass a special string to tell the command to create new track
    if($trackNodeIndex == "")
        $trackNodeIndex = teGetActiveTabNewTrackIdString();
        
    // Get current tab and root clip for the tab
    float $currentTime  = `timeEditorPanel -query -activeTabTime timeEditorPanel1TimeEd`;
    int $rootClipId     = `timeEditorPanel -query -activeTabRootClipId timeEditorPanel1TimeEd`;
    
    // The '2' parameter for tePerformImportAnimFiles means the type of action to execute.
    //  1 = Import using the current settings.
    //  2 = Popup the import option box prior to importing.
    string $files[] = {$filename};
    tePerformImportAnimFiles(2, $files, $trackNodeIndex, $currentTime, $rootClipId);
}

//
// Description:
//      Performs the necessary actions to import an animation source
//
// Input Argument:
//      None
//
global proc teImportAnimationSource()
{
    optionVar -init false -category "Time Editor"
        -sv "teAnimImportFilterType" "Animation File";

    // open file dialog
	string $filter = sourceFileTypeFilter();
    string $selectedFilter = `optionVar -q "teAnimImportFilterType"`;
    string $startDir = teGetClipExportsDir();
    string $paths[] = `fileDialog2 -fileMode 4 -fileFilter $filter 
                                    -caption (uiRes("m_teCreateContainer.kCTEImportSourceCaption")) 
                                    -selectFileFilter $selectedFilter 
                                    -returnFilter 1
                                    -startingDirectory $startDir -okCaption (uiRes("m_teCreateContainer.kCTEImportSourceAcceptText"))`;
    if ( size($paths) < 2 ) return; // < 2 because last elemennt does not contain a file path but a filter string
    
    // Remember the latest location accessed. 
    teSaveClipExportsDir($paths[0]);
    optionVar -sv "teAnimImportFilterType" $paths[size($paths)-1]; // update the selected filter

    stringArrayRemoveAtIndex( size($paths)-1, $paths );
    tePerformImportAnimFilesAsSources( $paths );
}
