// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Creation Date:  November 20, 1996
//
//  Description:
//      This script contains common menu definition routines shared
//	between the Graph Editor and the Dope Sheet.
//
//		A call to the proc 'loadAnimMenuLibrary' will make sure that
//	all the other helper procs defined in here are loaded and available
//
//	Procs defined within this script:
//
//	defineEditMenu (string $editor, string $animEditor, string $parentMenu, string $buildMenuCommand)
//		Define the elements of the Edit subMenu
//
//	defineCurvesMenu(string $editor, string $animEditor,
//		string $parentMenu, string $options, string $buildMenuCommand)
//		Define the elements of the Curves subMenu
//
//	defineListMenu (string $editor, string $animEditor, string $parentMenu)
//		Define the elements of the List subMenu
//
//	defineTangentsMenu (string $editor, string $animEditor, string $parentMenu)
//		Define the elements of the Tangents subMenu
//
//

global string $gEditorList[];
global string $gDefaultConnection[];

// Remember the tangent menu creation information so that plugin buttons
// can be managed as plugins are loaded and unloaded.
global string $gTangentParentEditor = "";
global string $gTangentAnimEditor = "";
global string $gTangentParentMenu = "";
global string $gTangentInParentMenu = "";
global string $gTangentOutParentMenu = "";
global string $gTangentMenuOptions = "";
global string $gTangentPluginItemList[];
global string $gTangentInPluginItemList[];
global string $gTangentOutPluginItemList[];

global string $gGraphEditorDefaultTanMenuItemNames[] = {
    "graphEdDefaultTanInMenuItem",
    "graphEdDefaultTanOutMenuItem"
};

global proc int pythonWrapper( string $nodeType, int $openDialog )
{
    int $success = 0;

    if ($openDialog) {
        $success = python("import maya.internal.common.cmd.base; maya.internal.common.cmd.base.openCommandDialog('" + $nodeType + "')");
    } else {
        $success = python("import maya.internal.common.cmd.base; maya.internal.common.cmd.base.executeCommand('" + $nodeType + "')");
    }
    return $success;
}

global proc performEulerFilter(string $selectionConnection) 
{
	string $objs[] = `findAnimCurves $selectionConnection`;
	int $nObjs = size($objs);
	int $i = 0;
	string $cmd = "filterCurve ";
	for ($i = 0; $i < $nObjs ; $i++) {
		$cmd += (" " + $objs[$i]);
	}

	if ($nObjs > 0) {
		evalEcho ($cmd);
	}
}

global proc performRotationInterpolation( string $mode, string $selectionConnection ) 
{
	// Query the curves which are selected in the graph editor viewport
	// and append the selected names to a rotationInterpolation command
	// string.
	//
	string $viewportSel[];
	if ( `isTrue SomethingSelected` != 0 ) {
		catch( $viewportSel = `keyframe -an keys -query -name` );
	}
	string $cmd = "rotationInterpolation -c " + $mode;
	int $i;
	int $viewportCount = size( $viewportSel );
	for ( $i = 0; $i < $viewportCount; $i++ ) {
	 	$cmd += (" " + $viewportSel[$i]);
	}

	// Query the curves which are selected in the graph editor outliner
	// and append the selected names to the command string.
	//
	string $outlinerSel[] = `selectionConnection -q -object $selectionConnection`;
	int $outlinerCount = size( $outlinerSel );
	for ( $i = 0; $i < $outlinerCount; $i++ ) {
	 	$cmd += (" " + $outlinerSel[$i]);
	}

	// If any curves were selected, execute the command string which we
	// built up.
	//
	if ( $viewportCount + $outlinerCount > 0 ) {
		evalEcho( $cmd );
	}
	animCurveEditor -e -upd graphEditor1GraphEd;
}

proc int
findEditorEntry (string $editor)
//
//	Procedure Name:
//		findEditorEntry
//
//	Description:
//		Helper method to find the index entry of a registered editor
//
//  Input Arguments:
//	string $editor		The name of the editor that is registered
//
//  Return Value:
//      int the index entry in $editorList (-1 if it is not registered)
//
{
	global string $gEditorList[];
	int $length = size ($gEditorList);
	for ($i = 0; $i < $length; $i++) {
		if ($gEditorList[$i] == $editor) {
			return ($i);
		}
	}
	return (-1);
}

global proc string
getDefaultConnection (string $editor)
//
//	Procedure Name:
//		getDefaultConnection
//
//	Description:
//		Helper method to find the name of the default selection connection
//	for a registered editor
//
//  Input Arguments:
//		string $editor			The name of the editor that is registered
//
//  Return Value:
//      string the name of the default selection connection, "animationList"
//	if the editor is not registered
//
{
	global string $gDefaultConnection[];

	int $entry = findEditorEntry ($editor);
	if ($entry == -1) {
		return ("animationList");
	}
	return ($gDefaultConnection[$entry]);
}

global proc
registerEditor (string $editor, string $defaultConnection)
//
//	Procedure Name:
//		registerEditor
//
//	Description:
//		Helper method to register the name of the default selection connection
//	for this editor
//
//  Input Arguments:
//		string $editor			The name of the editor that is being registered
//		string $defaultConnection	The name of the default selection connection
//
//  Return Value:
//      None.
//
{
	global string $gEditorList[];
	global string $gDefaultConnection[];

	int $entry = findEditorEntry ($editor);
	if ($entry == -1) {
		int $length = size ($gEditorList);
		$gEditorList[$length] = $editor;
		$gDefaultConnection[$length] = $defaultConnection;
	}
}

global proc string[] findActiveAnimCurves (string $editor)
//
//	Procedure Name:
//		findActiveAnimCurves 
//
//	Description:
//		This returns the list of highlighted anim curves 
//
//  Input Arguments:
//		string $editor			The name of the editor that is being checked
//								for highlighted curves
//
//  Return Value:
//      string[] $curves: 		String array of highlighted curves 
//
{
	string $activeConnectionList = `editor -query -highlightConnection $editor`;
	string $curves[] = `findAnimCurves $activeConnectionList`;
	return $curves;
}

global proc
buildAnimEditMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		buildAnimEditMenu
//
//	Description:
//		This actually builds the edit subMenu if necessary
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $animEditor		The name of the animation editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//		string $buildMenuCommand
//								An optional command to be called when
//								this menu is built.  The command will
//								be called with $editor $parentMenu
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	if (`menu -query -numberOfItems $parentMenu` != 0) {
		return;
	}

	// Check for the bufferCurve option
	//
	int $performBase = 0;
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$performBase = 3;
	}

	int $enableRegionTool = 0;
	if (match ("regionTool", $options) != "") {
		$enableRegionTool = 1;
	}

	int $enableRetimeTool = 0;
	if (match ("retimeTool", $options) != "") {
		$enableRetimeTool = 1;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kUndo")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kUndoAnnot")) 
		-command "Undo"
		animUndoItem;
	dimWhen -false "UndoAvailable" animUndoItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRedo")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kRedoAnnot"))
		-command "Redo"
		animRedoItem;
	dimWhen -false "RedoAvailable" animRedoItem;

	menuItem -divider true;

	string $selectionConnection = `editor -query -selectionConnection $editor`;
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$selectionConnection = $animEditor;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kCut")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCutAnnot")) 
		-command ("performCutKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}") 
		-dragMenuCommand( "performCutKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		cutItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCutOptionsAnnot")) 
		-command ("performCutKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}" ) 
		cutKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kCopy")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCopyAnnot"))
		-command ("performCopyKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}") 
		-dragMenuCommand( "performCopyKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		copyItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kCopyOptions")) 
		-command ("performCopyKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}" )
		copyKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPaste")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kPasteAnnot")) 
		-command ("performPasteKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}")
		-dragMenuCommand( "performPasteKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		pasteItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kPasteOptions")) 
		-command ("performPasteKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}")
		pasteKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kDelete")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kDeleteAnnot")) 
		-command ("performClearKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"0\", \"1\"}")
		-dragMenuCommand( "performClearKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + ", \"0\", \"1\"}")
		clearItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kDeleteOptions")) 
		-command ("performClearKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"0\", \"1\"}")
		clearKeyDialogItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kScale")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kScaleAnnot"))
		-command ("performScaleKeyArgList 1 {\"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\"}" )
		-dragMenuCommand( "performScaleKeyArgList 1 {\"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\"}")
		scaleItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kScaleOptions")) 
		-command ("performScaleKeyArgList 1 {\"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\"}")
		scaleKeyDialogItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kTransformTools"))
		-subMenu true -tearOff true
		-allowOptionBoxes true transAnimItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kMoveKeysTool")) 
		-annotation (getRunTimeCommandAnnotation("MoveTool"))
		-image "move_M.png"
		-command "MoveTool"
		-dragDoubleClickCommand "MoveToolOptions";

	menuItem -optionBox true
		-annotation (getRunTimeCommandAnnotation("MoveToolOptions"))
		-image "move_M.png" 
		-command "MoveToolOptions"
			;

	menuItem 
		-label (uiRes("m_loadAnimMenuLibrary.kScaleKeysTool"))  
		-annotation (getRunTimeCommandAnnotation("ScaleTool"))
		-image "scale_M.png"
		-command "ScaleTool"
		-dragDoubleClickCommand "ScaleToolOptions"
		;
	menuItem -optionBox true
		-annotation (getRunTimeCommandAnnotation("ScaleToolOptions"))
		-image "scale_M.png" 
		-command "ScaleToolOptions"
			;
	int $enableLattice = ($options != "noOptions");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kLatticeDeform")) 
		-annotation (getRunTimeCommandAnnotation("LatticeDeformKeysTool"))
		-enable $enableLattice
		-image "latticeDeformKeySmall.png"
		-command "LatticeDeformKeysTool";

	menuItem -optionBox true
		-enable $enableLattice
		-annotation (getRunTimeCommandAnnotation("LatticeDeformKeysToolOptions"))
		-image "latticeDeformKeySmall.png"
		-command "LatticeDeformKeysToolOptions";

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRegionKeysTool"))
		-enable $enableRegionTool
		-annotation (getRunTimeCommandAnnotation("RegionKeysTool"))
		-image "regionSelectKeySmall.png"
		-command "RegionKeysTool";

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRetimeKeysTool"))
		-enable $enableRetimeTool
		-annotation (getRunTimeCommandAnnotation("RetimeKeysTool"))
		-image "retimeKeySmall.png"
		-command "RetimeKeysTool";

	menuItem -optionBox true
		-enable $enableRetimeTool
		-annotation (getRunTimeCommandAnnotation("RetimeKeysToolOptions"))
		-image "retimeKeySmall.png"
		-command "RetimeKeysToolOptions";

	setParent -m ..;

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSnap")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSnapAnnot"))
		-command ("performSnapKeyArgList 1 { \"" + $performBase + "\", \"" + $selectionConnection + "\", \"1\" }" )
		-dragMenuCommand( "performSnapKeyArgList 1 { \"" + ($performBase + 2) + "\", \"" + $selectionConnection + "\", \"1\" }" )
		snapItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSnapOptions")) 
		-command ("performSnapKeyArgList 1 { \"" + ($performBase + 1) + "\", \"" + $selectionConnection + "\", \"1\" }")
		snapKeyDialogItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSelectUnsnapped")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSelectUnsnappedAnnot")) 
		-command ("performSnapKeyArgList 1 { \"6\", \"" + $selectionConnection + "\", \"1\" } " )
		-dragMenuCommand( "performSnapKeyArgList 1 { \"7\", \"" + $selectionConnection + "\", \"1\" } " )
		selectUnsnappedItem;
		
	menuItem -divider true;
	
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSelectCurveNodes")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSelectCurveNodesAnnot")) 
		-command ( "string $curves[] = `findActiveAnimCurves " + $editor + "`;select -replace $curves;" )
		selectCurveNodesItem;
		
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kChangeCurveColor")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kChangeCurveColorAnnot")) 
		-command ( "performChangeAnimCurveColor 0 " + $editor )
		changeCurveColorItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kChangeCurveColorOptionsAnnot")) 
		-command ( "performChangeAnimCurveColor 1 " + $editor )
		changeCurveColorOptionsItem;
		
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kRemoveCurveColor")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kRemoveCurveColorAnnot")) 
		-command ( "string $curves[] = `findActiveAnimCurves " + $editor + "`;for ($curve in $curves){setAttr ($curve + \".useCurveColor\") 0;}" )
		removeCurveColorItem;
	
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSetCurveColors")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSetCurveColorsAnnot")) 
		-command ( "showCurveColorWindow " + $editor )
		setCurveColorsItem;

	menuItem -divider true;
		
	string $timeWarpSubMenu =
	`menuItem -subMenu true -label (uiRes("m_loadAnimMenuLibrary.kTimeWarp"))  
		-tearOff true
		-allowOptionBoxes true
		timeWarpSubMenu`;

		// 	Add Time Warp
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kAddTimeWarp"))  -command "AddTimeWarp" 
			-annotation (uiRes("m_loadAnimMenuLibrary.kAddTimeWarpAnnot")) 
			addTimeWarpItem;

		// 	Select Time Warp
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSelectTimeWarp"))  -command "SelectTimeWarp" 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSelectTimeWarpAnnot")) 
			selectTimeWarpItem;

		// 	Delete Time Warp
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kDeleteTimeWarp"))  -command "DeleteTimeWarp" 
			-annotation (uiRes("m_loadAnimMenuLibrary.kDeleteTimeWarpAnnot")) 
			deleteTimeWarpItem;

		// 	Enable Time Warp
		//
		string $enableTimeWarpItem = 
		`menuItem -label (uiRes("m_loadAnimMenuLibrary.kEnableTimeWarp"))
			-annotation (uiRes("m_loadAnimMenuLibrary.kEnableTimeWarpAnnot")) 
			-cb 1
			-command "setAttr time1.enableTimewarp (!`getAttr time1.enableTimewarp`); currentTime `currentTime -q`;"
			enableTimeWarpItem`;

		setParent -m ..;

	menuItem -e
		-pmc ( "menuItem -e -cb `getAttr time1.enableTimewarp` " + $enableTimeWarpItem )
		$timeWarpSubMenu;

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kOpenAnimationPreference"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kOpenAnimationPreferenceAnnot")) 
		-command ( "preferencesWnd Animation;" )
		openAnimPrefs;

	if ($buildMenuCommand != "") {
		eval (($buildMenuCommand + " " + $animEditor + " " + $parentMenu));
	}
}

global proc
defineEditMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		defineEditMenu
//
//	Description:
//		This creates the submenu for edit functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//	(make sure that the menu is defined to allow option boxes)
//
//		menuItem -label _L10N( kEdit, "Edit" ) 
//			-allowOptionBoxes true
//			-subMenu true
//			editHierItem;
//			defineEditMenu $editor "editHierItem" "optionalBuildMenuCommand"; 
//		setParent -menu ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//		string $buildMenuCommand
//								An optional command to be called when
//								this menu is built.  The command will
//								be called with $editor $parentMenu
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;

	menu -edit
		-postMenuCommand ("buildAnimEditMenu " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $options + "\"" + " " + "\"" + $buildMenuCommand + "\"")
		$parentMenu;

	// This section will allow the undo item to display what is going to
	// be undone.  This is the fix for bug 55712.  However the main undo
	// menu items no longer show this, so this block is commented out for
	// now
	//
//mm	menu -edit
//mm		-postMenuCommand ("handleEditMenuCmd " + $parentMenu)
//mm		$parentMenu;

}

global proc
handleEditMenuCmd (string $parentMenu)
//
//  Procedure Name:
//      handleEditMenuCmd
//
//  Description:
//		This proc is a -postMenuCommand callback which sets the state of
//	menu items in the Edit menu.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	string $undoName;
	string $buffer[];
	string $menuItemRes;
	
	setParent -menu $parentMenu;

	$undoName = `undoInfo -query -undoName`;
	tokenize ($undoName, $buffer);
	$menuItemRes = `uiRes("m_loadAnimMenuLibrary.kUndo")`;
	$undoName = ($menuItemRes + " " + $buffer[0]);
	menuItem -edit -label $undoName animUndoItem;

	$undoName = `undoInfo -query -redoName`;
	tokenize ($undoName, $buffer);
	$menuItemRes = `uiRes("m_loadAnimMenuLibrary.kRedo")`;
	$undoName = ($menuItemRes + " " + $buffer[0]);
	menuItem -edit -label $undoName animRedoItem;
}

global proc int
isAutoLoad (string $editor)
{
	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;

	// If it is NOT the active list, then check it off
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if(( $mainListConnection != "activeList" ) 
	&& ( $mainListConnection != $defaultConnection )) 
	{
		return (0);
	}
	else if (`selectionConnection -query -lock $mainListConnection`) {
		return (0);
	}
	return (1);
}

global proc
toggleAutoLoad (string $editor, int $toggle)
//
//  Procedure Name:
//      toggleAutoLoad
//
//  Description:
//		This proc is a helper to toggle the auto load state
//		of the outliner.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;
	// If it is NOT the active list, then force it to use the active list
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if (($mainListConnection != "activeList") && ($mainListConnection != $defaultConnection)) {
		editor -edit -unlockMainConnection $editor;
		editor -edit -mainListConnection $defaultConnection $editor;
	}
	else if ($toggle) {
		editor -edit -unlockMainConnection $editor;
	}
	else {
		editor -edit -lockMainConnection $editor;
	}

	// The best way to resolve the button name is to pass in the full
	// path to the button, however toggleAutoLoad is called from several
	// places (including some c++ code) and this makes it difficult.
	// So instead we will use a carefully constructed name for the
	// button
	//
	if (`iconTextCheckBox -exists ($editor + "loadToggleButton")`) {
		iconTextCheckBox -edit
			-value `isAutoLoad $editor`
			($editor + "loadToggleButton");
	}

	if (`iconTextButton -exists ($editor + "reloadButton")`) {
		iconTextButton -edit
			-enable (!`isAutoLoad $editor`)
			($editor + "reloadButton");
	}
}

global proc
doReload (string $editor)
//
//  Procedure Name:
//      doReload
//
//  Description:
//		This proc is a helper to have the outliner do a reload.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;
	// If it is NOT the active list, then force it to use the active list
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if (($mainListConnection != "activeList") && ($mainListConnection != $defaultConnection)) {
//		editor -edit -unlockMainConnection $editor;
//		editor -edit -mainListConnection $defaultConnection $editor;
//		editor -edit -lockMainConnection $editor;
		editor -edit -forceMainConnection $defaultConnection $editor;
	}
	// Otherwise switch the lock on the list off and on
	//
	else if (`selectionConnection -query -lock $mainListConnection`) {
//		editor -edit -unlockMainConnection $editor;
//		editor -edit -mainListConnection $defaultConnection $editor;
//		editor -edit -lockMainConnection $editor;
		editor -edit -forceMainConnection $defaultConnection $editor;
	}
}

global proc
handleListMenuCmd (string $options, string $editor, string $animEditor, string $parentMenu, string $buildMenuCommand)
//
//  Procedure Name:
//      handleListMenuCmd
//
//  Description:
//		This proc is a -postMenuCommand callback which sets the state of
//	menu items in the List menu.
//
//  Input Arguments:
//		string $options			Options for this menu
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "noScroll otherOption")
//
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				useHier			Add a "Hierarchy Below" entry
//				useCharacters	Add support for characters
//				useSUC			Add a "Show upstream curves" entry
//
//  Return Value:
//      None.
//
{
	// Set the proper check state of the AutoLoad menu
	//
	setParent -menu $parentMenu;

	string $objects = (uiRes("m_loadAnimMenuLibrary.kObjects"));
	string $bookmarkType = "bookmarkAnimCurves";
	string $toggleLoadCmd = ("toggleAutoLoad " + $editor + " #1");
	int $autoLoad = 1;
	string $editorName = (uiRes("m_loadAnimMenuLibrary.kGraphEditor"));
	if (match ("useCharacters", $options) == "useCharacters") {
		$objects = (uiRes("m_loadAnimMenuLibrary.kCharacters"));
		$bookmarkType = "bookmarkClips";
		$toggleLoadCmd += ("; optionVar -intValue traxAutoLoadSel #1");
		$editorName = (uiRes("m_loadAnimMenuLibrary.kTraxEditor"));
		if (`optionVar -exists traxAutoLoadSel`) {
			$autoLoad = `optionVar -q traxAutoLoadSel`;
		}
	}

	if (`menu -query -numberOfItems $parentMenu` == 0) {
		if (match ("useHier", $options) == "useHier") {
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kHierarchyBelow")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kHierarchyBelowAnnot"))
				-checkBox false
				-command ("setHierarchyBelow #1 " + $animEditor)
				hierItem;
		}
		string $autoLoadFormat = (uiRes("m_loadAnimMenuLibrary.kAutoLoad"));
		string $autoLoadAnnotFormat = (uiRes("m_loadAnimMenuLibrary.kAutoLoadAnnot"));
		string $autoLoadLabel = `format -stringArg $objects $autoLoadFormat`;
		string $autoLoadAnnot = `format -stringArg $editorName $autoLoadAnnotFormat`;

		menuItem -label $autoLoadLabel
			-checkBox $autoLoad
			-annotation $autoLoadAnnot
			-command $toggleLoadCmd
			autoLoadItem;

		string $loadSelFormat = (uiRes("m_loadAnimMenuLibrary.kLoadSel"));
		string $loadSelAnnotFormat = (uiRes("m_loadAnimMenuLibrary.kLoadSelAnnot"));
		string $loadSel = `format -stringArg $objects $loadSelFormat`;
		string $loadSelAnnot = `format -stringArg $editorName $loadSelAnnotFormat`;
		menuItem -label $loadSel
			-annotation $loadSelAnnot
			-command ("doReload " + $editor)
			reloadItem;

		string $addSelFormat = (uiRes("m_loadAnimMenuLibrary.kAddSel"));
		string $addSelAnnotFormat = (uiRes("m_loadAnimMenuLibrary.kAddSelAnnot"));
		string $addSel = `format -stringArg $objects $addSelFormat`;
		string $addSelAnnot = `format -stringArg $editorName $addSelAnnotFormat`;
		menuItem -label $addSel
			-annotation $addSelAnnot
			-command ("addSelectedToEditorWithOptions \"" + $options + "\" " + $editor)
			addToListItem;

		string $menuItem = `menuItem -label (uiRes("m_loadAnimMenuLibrary.kBookmarks")) 
			-subMenu true -allowOptionBoxes true
			bookMarkHierItem`;

		menuItem -edit
			-postMenuCommand ("buildBookmarkMenu -type " + $bookmarkType + " -editor " + $editor + " " + $menuItem)
			$menuItem;

		string $bookmarkFormat = (uiRes("m_loadAnimMenuLibrary.kBookmarkCurrent"));
		string $bookmark = `format -stringArg $objects $bookmarkFormat`;
			menuItem 
				-label $bookmark
				-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkAnnot")) 
				-command ("createBookmark " + $editor + " " + $bookmarkType + " false") 
				bookAnimMarkObjectsItem;
				menuItem -optionBox true
					-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkOptions")) 
					-command ("createBookmark " + $editor + " " + $bookmarkType + " true")
					bookAnimMarkObjectsDialog;
					
			//these menu items are not applicable to trax (clipEditor)	
			if (!`gmatch $editor "*clip*"`){
			menuItem 
				-label (uiRes("m_loadAnimMenuLibrary.kBookmarkCurves")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkCurvesAnnot")) 
				-command ("string $objects[] = `ls -sl`;" + "string $curves[] = `findActiveAnimCurves " + $editor + "`;select -replace $curves;createBookmark " + $editor + " " + $bookmarkType + " false; select -replace $objects;") 
				bookAnimMarkCurvesItem;
				menuItem -optionBox true
					-annotation (uiRes("m_loadAnimMenuLibrary.kBookmarkCurvesOptions")) 
					-command ("string $objects[] = `ls -sl`;" + "string $curves[] = `findActiveAnimCurves " + $editor + "`;select -replace $curves;createBookmark " + $editor + " " + $bookmarkType + " true; select -replace $objects;")
					bookAnimMarkCurvesDialog;
				}

			menuItem 
				-label (uiRes("m_loadAnimMenuLibrary.kRemoveBookmarks")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kRemoveBookmarksAnnot")) 
				-command ("removeBookmark {} " + $bookmarkType) 
				removeAllBookmarksItem;
			setParent -menu ..;

		if (match ("useSUC", $options) == "useSUC") {
			// Graph Editor-only menu items
			menuItem -divider true;

			menuItem -label (uiRes("m_loadAnimMenuLibrary.kShowUpstreamCurves")) 
				-checkBox true
				-annotation (uiRes("m_loadAnimMenuLibrary.kShowUpstreamCurvesAnnot"))
				-command (
					"outlinerEditor -e -suc #1 " + $editor + ";" +
					"animCurveEditor -e -suc #1 " + $animEditor + ";" +
					"optionVar -intValue graphEditorShowUpstreamCurves #1;"
				)
				showUpstreamCurvesItem;

			menuItem -label (uiRes("m_loadAnimMenuLibrary.kExpandAnimatedShapes"))
				-checkBox true
                -version 2022
				-annotation (uiRes("m_loadAnimMenuLibrary.kExpandAnimatedShapesAnnot"))
				-command (
					"outlinerEditor -e -xas #1 " + $editor + ";" +
					"optionVar -intValue graphEditorAutoExpandAnimatedShapes #1;"
				)
				expandAnimatedShapesItem;
		}

		if ($buildMenuCommand != "") {
			eval (($buildMenuCommand + " " + $editor + " " + $animEditor + " " + $parentMenu));
		}
	}

	if (match ("useHier", $options) == "useHier") {
		menuItem -edit
			-checkBox `dopeSheetEditor -query -hierarchyBelow $animEditor`
			hierItem;
	}

	if (match ("useSUC", $options) == "useSUC") {
		menuItem -edit
			-checkBox `outlinerEditor -q -suc $editor`
			showUpstreamCurvesItem;

		menuItem -edit
			-checkBox `outlinerEditor -q -xas $editor`
			expandAnimatedShapesItem;
	}

	// First, find out what is connected to this editor
	//
	string $mainListConnection = `editor -query -mainListConnection $editor`;
	if ($mainListConnection == "") {
		if (`modelEditor -exists $editor`) {
			$mainListConnection = "activeList";
		}
	}

	// If it is NOT the active list, then check it off
	//
	string $defaultConnection = getDefaultConnection ($editor);
	if(( $mainListConnection != "activeList") 
    && ( $mainListConnection != $defaultConnection )) 
	{
		menuItem -edit -checkBox off autoLoadItem;
		menuItem -edit -enable true reloadItem;
		menuItem -edit -enable true addToListItem;
	}
	else if (`selectionConnection -query -lock $mainListConnection`) {
		menuItem -edit -checkBox off autoLoadItem;
		menuItem -edit -enable true reloadItem;
		menuItem -edit -enable true addToListItem;
	}
	else {
		menuItem -edit -checkBox on autoLoadItem;
		menuItem -edit -enable false reloadItem;
		menuItem -edit -enable false addToListItem;
	}
}

global proc
defineListMenu (string $options, string $editor, string $animEditor,
				string $parentMenu, string $buildMenuCommand)
//
//	Procedure Name:
//		defineListMenu
//
//	Description:
//		This creates the submenu for list functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//	(make sure that the menu is defined to allow option boxes)
//
//		menuItem -label _L10N( kList, "List" ) 
//			-allowOptionBoxes true
//			-subMenu true
//			optionsHierItem;
//			defineListMenu $editor $animEditor "optionsHierItem"; 
//			{further menu items could be defined here}
//		setParent -m ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this menu
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "noScroll otherOption")
//
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				useHier			Add a "Hierarchy Below" entry
//				useCharacters	Add support for characters
//				useSUC			Set for Graph Editor to show graph editor specific menu items
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	menu -edit
		-postMenuCommand ("handleListMenuCmd " + $options + " " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $buildMenuCommand + "\"")
		$parentMenu;
}

global proc
doKeyTangent (string $commandOptions, string $selectionConnection, string $options)
//
//  Procedure Name:
//      doKeyTangent
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		keyTangent command, depending upon whether or not keys are active.
//
//  Input Arguments:
//		string $commandOptions			Options to be passed to the keyTangent
//										command
//		string $selectionConnection		The name of the selection connection
//										that contains potential objects to
//										perform the keyTangent command upon
//		string $options					Options for this proc
//										Option words are specified within the
//										the string, with each option seperated
//										by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions				A nice "do nothing" string to pass
//				bufferCurve				Issue commands to (possibly) create buffer curves
//
//  Return Value:
//      None.
//
{
	// Build up the command string
	//
	string $command = ("keyTangent " + $commandOptions);

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$command = "bufferCurve -animation \"keys\" -overwrite false; " + $command;
		}
	}

	// Check to see if any keys are selected
	//
	int $keys = 0;
	if (!`isTrue SomethingSelected`
	||	catch ($keys = `keyframe -animation keys -query -keyframeCount`)) {
		$keys = 0;
	}
	if ($keys == 0) {
		// No keys, so use the selection connection
		//
		$command = ($command + " -animation objects " + $realConnection);
	}
	// Now issue the command
	//
	catch( evalEcho ($command) );

	// Update tangent iconTextCheckBoxes
	doUpdateTangentFeedback( );
}

// Graph Editor wrappers - this avoids using hard coded values in
//	defaultRuhTimeCommands.mel.
//

//  Procedure Name:
//      geSelectionConnection
//
//	Returns the selection connection for the Graph Editor
//
proc string geSelectionConnection()
{
	return "graphEditor1GraphEd";
}

//  Procedure Name:
//      geOptions
//
//	Returns the standard options for the Graph Editor
//
proc string geOptions()
{
	return "useSmoothness bufferCurve";
}

//  Procedure Name:
//      gePerformAutoCustomTangents
//
//	Call performAutoCustomTangents, appending the standard Graph Editor
//	selectionConnection and options.
//
global proc string gePerformAutoCustomTangents(int $action, int $applyOptions)
{
	return performAutoCustomTangents($action, $applyOptions, geSelectionConnection(), geOptions());
}

//  Procedure Name:
//      performDoKeyTangent
//
//	Calls the doKeyTangent method, using the give options and the standard
//	Graph Editor selection connection.
//
proc performDoKeyTangent( string $commandOptions, string $options )
{
	doKeyTangent( $commandOptions, geSelectionConnection(), $options );
}

//
//  Procedure Name:
//      geDoKeyTangent
//
//	This is a wrapper for calling the doKeyTangent command from/for the Graph
//	Editor with the standard options.
//
global proc
geDoKeyTangent( string $commandOptions )
{
	performDoKeyTangent( $commandOptions, geOptions() );
}

//
//  Procedure Name:
//      geDoKeyTangentNoOptions
//
//	This is a wrapper for calling the doKeyTangent command from/for the Graph
//	Editor with noOptions
//
global proc
geDoKeyTangentNoOptions( string $commandOptions )
{
	performDoKeyTangent( $commandOptions, "noOptions" );
}

global proc
doEditDefaultTangent(int $outTangent, string $tanType)
//
//  Procedure Name:
//      doEditDefaultTangent
//
//  Description:
//      Issues the command to set the default in/out tangent and updates the UI
{
    // Set the optionVar
    string $ovar = ($outTangent ? "outTangentType" : "inTangentType");
    optionVar -sv $ovar $tanType;

    // Build up the command string
    //
    string $opt = ($outTangent ? "-ott" : "-itt");
    string $command = "keyTangent -e -global " + $opt + " " + $tanType;

    string $curTanType[] = `keyTangent -q -global $opt`;
    if ($curTanType[0] != $tanType)
        catch( evalEcho ($command) );
    // Update default tangent iconTextButtons
    doUpdateDefaultTangentFeedback();
}

global proc
doKeyEdit (string $commandOptions, string $selectionConnection, string $options)
//
//  Procedure Name:
//      doKeyEdit
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		keyframe command, depending upon whether or not keys are active.
//
//  Input Arguments:
//		string $commandOptions			Options to be passed to the keyTangent
//										command
//		string $selectionConnection		The name of the selection connection
//										that contains potential objects to
//										perform the keyTangent command upon
//		string $options				Options for this proc
//										Option words are specified within the
//										the string, with each option seperated
//										by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions				A nice "do nothing" string to pass
//				bufferCurve				Issue commands to (possibly) create buffer curves
//				addInbetween			Create options to add an inbetween at the current time
//				removeInbetween			Create options to remove an inbetween at the current time
//
//  Return Value:
//      None.
//
{
	// Build up the command string
	//
	string $command = ("keyframe " + $commandOptions);

	int $checkKeys = true;
	// Check for the inbetweens
	//
	if (match ("addInbetween", $options) == "addInbetween") {
		$command = $command + " -time \"" + `currentTime -query` + ":\" " +
			"-relative -timeChange 1 -option over";
		$checkKeys = false;
	}
	else if (match ("removeInbetween", $options) == "removeInbetween") {
		$command = $command + " -time \"" + `currentTime -query` + ":\" " +
			"-relative -timeChange -1 -option over";
		$checkKeys = false;
	}

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$command = "bufferCurve -animation \"keys\" -overwrite false; " + $command;
		}
	}

	// Check to see if any keys are selected
	//
	int $keys = 0;
	if ($checkKeys && (!`isTrue SomethingSelected`
	||	catch ($keys = `keyframe -animation keys -query -keyframeCount`))) {
		$keys = 0;
	}
	if ($keys == 0) {
		// No keys, so use the selection connection
		//
		$command = ($command + " -animation objects " + $realConnection);
	}
	// Now issue the command
	//
	evalEcho ($command);
}


global proc
int looksLikeAttr(string $nodeAttr)
//
//  Procedure Name:
//      looksLikeAttr
//
//  Description:
//      A convenience method to test if nodeAttr represents an attribute
//  written in the node.Attr format.
{
	int $result = 0;
	string $tokens[];
	tokenize($nodeAttr,".",$tokens);
	if(size($tokens) > 1) 
	{
		$result = 1;
	}
	return $result;
}


global proc string getAnimAttr(string $selectedItem)
//
//  Procedure Name:
//      getAnimAttr
//
//  Description:
//		This is a helper proc to get proper attribute from animCurve node
//
{
	if(looksLikeAttr($selectedItem))
		return $selectedItem;

	string $attr = $selectedItem;
	string $connectedNodes[] = `listConnections -source false $selectedItem`;

	if (size($connectedNodes) > 0) {
		string $objectType = `objectType $connectedNodes[0]`;
		string $characterNode;
		string $sattr;

		switch ($objectType){

			// Simple Anim
			case "transform":
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				$attr = $connectedNodes[0];
				break;

				// Simple and Muted
			case "mute":
				string $connectedNodes2[] = `listConnections -source false -type transform -plugs true $connectedNodes[0]`;
				if (size($connectedNodes2) > 0) 
				{
					$attr = $connectedNodes2[0];
				}
				else
				{
					$connectedNodes2 = `listConnections -source false -type animBlendNodeBase -plugs true $connectedNodes[0]`;
					$attr = $connectedNodes2[0];
				}
				break;

				// The attribute belongs to a character
			case "character":
				$characterNode = $connectedNodes[0];
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				int $mindex = `character -q -memberIndex $connectedNodes[0]`;
				$sattr = $characterNode + ".dnSetMembers[" + $mindex + "]";
				$connectedNodes = `listConnections -destination false -plugs true $sattr`;
				$attr = $connectedNodes[0];
				break;

				// The attribute belongs to a character and instanced to a clip
			case "clipLibrary":
				// Get character node
				$connectedNodes = `listConnections -destination false -type character $connectedNodes[0]`;
				$characterNode =  $connectedNodes[0];

				// Get character member index
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				string $strs[];
				tokenize($connectedNodes[0], ".", $strs);
				int $ssize = size($strs[2]);
				// clipEval index
				string $cindex = substring($strs[2], 10, $ssize-1);
				$sattr = $characterNode + ".dnSetMembers[" + $cindex + "]";

				$connectedNodes = `listConnections -destination false -plugs true $sattr`;
				$attr = $connectedNodes[0];
				break;
			default:
				$connectedNodes = `listConnections -source false -plugs true $selectedItem`;
				$attr = $connectedNodes[0];
		}
	}

	return $attr;
}

global proc
int isChannelFromClip(string $channel)
{
	int $result = 0;
	string $buffer[];
	tokenize($channel,".",$buffer);
	if (nodeType($buffer[0]) == "clipLibrary") {
		$result = 1;
	}
	return $result;
}


global proc
doTemplateChannel(string $selectionConnection, int $newState)
{
	string $command;
	int $result = 0;    

	string $membersArray[] = `keyframe -query -sl -name`;

	if (size($membersArray) == 0)
	{
		string $selConn[] = expandSelectionConnectionAsArray($selectionConnection);
		for ($sel in $selConn) {
			string $isPC[] = `ls -type animCurve $sel`;
			if (size($isPC)) {
				$membersArray[size($membersArray)] = $sel;
			} else {
				string $pc[] = `listConnections -type animCurve $sel`;
				if (size($pc) == 1) {
					$membersArray[size($membersArray)] = $pc[0];
				}
			}
		}
	}

	for ($m in $membersArray) {
		setAttr -l $newState ($m+".ktv");
		setAttr -l $newState ($m+".kix");
		setAttr -l $newState ($m+".kiy");
		setAttr -l $newState ($m+".kox");
		setAttr -l $newState ($m+".koy");
	}

	if (size($membersArray) == 0)
	{
		error( (uiRes("m_loadAnimMenuLibrary.kNoChannelsSelected")));
	}
}

global proc
doPinChannel( string $editor, string $selectionConnection, int $newState )
{
	string $selConn[] = expandSelectionConnectionAsArray( $selectionConnection );
	if ( size( $selConn ) == 0 )
	{
		error( (uiRes("m_loadAnimMenuLibrary.kPinNoChannelsSelected")) );
	}
	else
	{
		if ( $newState )
		{
			// pin
			for ( $sel in $selConn )
			{
				outlinerEditor -e -pin $sel $editor;
			}
		}
		else
		{
			// unpin
			for ( $sel in $selConn )
			{
				outlinerEditor -e -unp $sel $editor;
			}
		}
	}
}

global proc string[]
getMuteOperationChannelsFromCurve(string $curve, int $makeMute)
//
//  Procedure Name:
//     getMuteOperationChannelsFromCurve
//
//  Description:
//      This returns to the channels we can mute or not based on
//      the specified curve and the intended mute operation
{
    string $resultPlugs[];

    if(looksLikeAttr($curve))
        return $resultPlugs;

    int $isCurve = `objectType -isAType animCurve $curve`;

    if ($isCurve == 0)
        return $resultPlugs;

    string $curveOutput = $curve + ".output";
    string $connectedPlugs[] = `listConnections -source false -plugs true $curveOutput`;

    for ($p in $connectedPlugs) {
        // check if the node we are connected to is a mute node
        int $isMuteNode = `objectType -isAType mute $p`;
        if ($isMuteNode == $makeMute) {
            // Nothing to do...
        } else {
           if ($makeMute) {
                $resultPlugs[size($resultPlugs)] = $p;
           } else {
            // We are connected to a mute node.
            // Now find out what that one is connected to
            string $tokens[];
            tokenize($p,".",$tokens);
            string $muteOutput = $tokens[0] + ".output";
            string $plugs[] = `listConnections -source false -plugs true $muteOutput`;
            for ($q in $plugs)
                $resultPlugs[size($resultPlugs)] = $q;
           }
        }
    }

    return $resultPlugs;
}

global proc string[]
getMuteOperationChannelsFromPlug(string $plug, int $makeMute)
//
//  Procedure Name:
//     getMuteOperationChannelsFromPlug
//
//  Description:
//      This returns to the channels we can mute or not based on
//      the specified plug and the intended mute operation
{
    string $resultPlugs[];

    string $connectedPlugs[] = `listConnections -source true -plugs true $plug`;
    if (size($connectedPlugs) > 0) {
        int $hasMuteNode = 0;
        // check if we are connected to a mute node...
        for ($p in $connectedPlugs) {
            if (`objectType -isAType mute $p`)
                $hasMuteNode = 1;
        }

        if ($hasMuteNode == $makeMute) {
            // Nothing to do...
        } else {
            $resultPlugs[size($resultPlugs)] = $plug;
        }
    }

    return $resultPlugs;
}

global proc string[]
getMuteOperationChannels(string $selectionItem, int $makeMute)
//
//  Procedure Name:
//     getMuteOperationChannels
//
//  Description:
//      This returns to the channels we can mute or not based on
//      the specified selectionItem and the intended mute operation
{
    if(looksLikeAttr($selectionItem)) {
        // we have a plug
        return getMuteOperationChannelsFromPlug($selectionItem, $makeMute);
    } else {
        // this might be a curve node
        return getMuteOperationChannelsFromCurve($selectionItem, $makeMute);
    }
}

global proc
doMuteChannel (string $selectionConnection, string $flag)
//
//  Procedure Name:
//     doMuteChannel
//
//  Description:
//      This is a helper proc which will issue the proper form of the
//      mute command, depending upon whether or not channels are selected
{
    int $makeMute = ($flag == "-true");

    string $membersArray[] = expandSelectionConnectionAsArray($selectionConnection);

    int $result = 0;
    for ($m in $membersArray)
    {
        string $chanArray[] = getMuteOperationChannels($m, $makeMute);
        if (size($chanArray) > 0) {
            string $muted[];
            if ($makeMute) {
                $muted = `mute $chanArray`;
            } else {
                $muted = `mute -disable -force $chanArray`;
            }
            $result = 1;
        }
    }

	if ($result == 0)
	{
		string $errMsg;
		if ($makeMute) {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoChannelToMute"));
		}
		else {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoChannelToUnmute"));
		}
		error($errMsg);
	}
}

global proc
doMuteRegion(string $channel, string $flag, float $start, float $end)
//
//  Procedure Name:
//     doMuteRegion
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		mute command, depending upon which keys are selected

{

	int $value;
	int $result = 0;

	if ($flag == "-true") 
		$value = 1;
	else
		$value = 0;

	string $chan = getAnimAttr($channel);
	if ($chan == "") {
		$chan = $channel;
	}
	

	// skip mute channels. Don't want to mute mute channels
	if (match("mute", $chan) == "")
	{
		// create a mute channel or get it if it exits.
		string $muted[] = `mute $chan`;    

		for ($mute in $muted) {
			//test to see if this mute channel has keys

			float $mkeys[] = `keyframe -q -tc $mute`;

			float $endvalue[] = `keyframe -absolute -time ($end -1) -q -eval ($mute + ".mute")`;

			// We don't have any values keyed yet
			if (size($mkeys)!= 0) {
				string $range = "\"" + $start + ":" + $end + "\"";
				string $cmd = ("cutKey -time "+ $range +" -option keys " + $mute + ".mute");
				eval($cmd);
			}

			int $inverse = (1 - $value );
			float $playstart = `playbackOptions -q -min`;
			float $playend   = `playbackOptions -q -max`;

			int  $nbkeys = `keyframe -q -kc ($mute + ".mute")`;
			if ($nbkeys == 0) {
				// set the begin and end keys.
				setKeyframe -time $playstart -value 0 $mute;
				setKeyframe -time $playend -value 0 $mute;
			}

			// Move just abit along the curve (in case there is a key right on the
			// spot and get the reading
			float $keyvalue[] = `keyframe -absolute -time ($start +.001) -q -eval ($mute + ".mute")`;

			// Since the number is float it could be edited away from
			// 0 and 1 value.  Let it round to the neareast value.  This
			// matches up with stipple drawing in the graph editor and 
			// other places.
			if ($endvalue[0] > 0.5){
				$endvalue[0] = 1.0; 
			}
			else {
				$endvalue[0] = 0.0;
			}
			if ($keyvalue[0] > 0.5){
				$keyvalue[0] = 1.0; 
			}
			else {
				$keyvalue[0] = 0.0;
			}

			// Check if we need to add a new starting key.
			if ($keyvalue[0] != $value) {
				setKeyframe -time $start -value $value $mute;
				if ($endvalue[0] != $value) {
					// We want to mute the selected ticks but not the
					// effect the key at the end value. So move it back almost
					// a full key. This is currently composented for in the 
					// drawing routine.
					setKeyframe -time $end -value $inverse $mute;
				}
			}
			// Check if we need to an ending key
			else if ($keyvalue[0] != $endvalue[0] ) {
				setKeyframe -time $end -value $inverse $mute;
			}

		}
	}
}

global proc
doMuteKey (string $flag)
//
//  Procedure Name:
//      doMuteKey
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		mute command, depending upon which keys are selected

{
    string $curves[] = `keyframe -query -sl -name`;
    string $currentCurve;
    int $value;
    int $result = 0;
    
    if ($flag == "-true") 
        $value = 1;
    else
        $value = 0;
    
    for( $currentCurve in $curves ) {
        // skip mute channels. Don't want to mute mute channels
        if (match("mute", $currentCurve) == ""){
            
			string $chan = getAnimAttr($currentCurve);
            // create a mute channel or get it if it exits.
            string $muted[] = `mute $chan`;    
            
            //test to see if this mute channel has keys
            float $mkeys[] = `keyframe -q -tc $muted[0]`;
            int   $selectedKeyCount = `keyframe -q -kc $currentCurve` - 1;
            
            if (size($mkeys) == 0)
            {
                int $inverse = (1 - $value );
                
                // set the begin and end keys.             
                float $start[] = `keyframe -index 0 -q -tc $currentCurve`;
                float $end[] = `keyframe -index $selectedKeyCount -q -tc $currentCurve`;
                setKeyframe -time $start[0] -value 0 $muted[0] ;
                setKeyframe -time $end[0] -value 0 $muted[0] ;                        
            }
            
            // get the time of the keys
            int $selectedKeyIndices[] = `keyframe -sl -q -iv $currentCurve`;
            int $index, $i;
			$selectedKeyCount = `keyframe -q -kc $currentCurve`;
            for ($i = 0; $i < size($selectedKeyIndices); ++$i )
            {
                // set the key and mark it dirty to get let the 
                // graph editor pick up it.
				$index = $selectedKeyIndices[$i];
				float $t[] = `keyframe -index $index -q $currentCurve`;
                setKeyframe -time $t[0] -value $value $muted[0] ;
				$result = 1; 
				
				// if the next is not selected 
				if ($value == 1)
				{
					if ( ($i < (size($selectedKeyIndices) - 1) && $selectedKeyIndices[$i + 1] != ($index + 1) ) || 
                       ( $i == (size($selectedKeyIndices) - 1) &&  $index != ($selectedKeyCount-1) ) ) 
					{
                        float $tt[] = `keyframe -index ($index + 1) -q $currentCurve`;
                        // test to see if the key is already off.
                        float $va[] = `keyframe -time $tt[0] -q -eval $muted[0]`;
                        if ($va[0] > 0.0)
                            setKeyframe -time $tt[0] -value 0 $muted[0] ;                        

					}	
				}
			}
        }
    }
    
    if ($result == 0)
    {
    	string $errMsg;
    	if (size($curves) == 0) {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoObjectToMute"));
    	}
    	else {
			$errMsg = (uiRes("m_loadAnimMenuLibrary.kNoObjectToUnmute"));
    	}
		error($errMsg);    
    }
}




global proc
doSetInfinity (string $commandOptions, string $selectionConnection, string $options)
//
//  Procedure Name:
//      doSetInfinity
//
//  Description:
//		This is a helper proc which will issue the proper form of the
//		setInfinity command, depending upon whether or not keys are active.
//
//  Input Arguments:
//		string $commandOptions			Options to be passed to the setInfinity
//										command
//		string $selectionConnection		The name of the selection connection
//										that contains potential objects to
//										perform the setInfinity command upon
//		string $options					Options for this proc
//										Option words are specified within the
//										the string, with each option seperated
//										by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions				A nice "do nothing" string to pass
//				bufferCurve				Issue commands to (possibly) create buffer curves
//
//  Return Value:
//      None.
//
{
	// Build up the command string
	//
	string $command = ("setInfinity " + $commandOptions);

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$command = "bufferCurve -animation \"keys\" -overwrite false; " + $command;
		}
	}

	// Check to see if any keys are selected
	//
	int $keys = 0;
	if (!`isTrue SomethingSelected`
	||	catch ($keys = `keyframe -animation keys -query -keyframeCount`)) {
		$keys = 0;
	}
	if ($keys == 0) {
		// No keys, so use the selection connection
		//
		$command = ($command + " " + $realConnection);
	}
	// Now issue the command
	//
	evalEcho ($command);
}

//
//  Procedure Name:
//      cmdToRunTimeCommand
//
//  Description:
//
// Given a runTimeCommand name, prepend as follows:
//
// $applyOptions:
//      0 - Nothing
//      1 - In
//      2 - Out
//
proc string cmdToRunTimeCommand( string $cmd, int $applyOptions )
{
	if( $applyOptions == 1 ){
		return( "In" + $cmd );
	} else if( $applyOptions == 2 ){
		return( "Out" + $cmd );
	} else {
		return( $cmd );
	}
}

//
//  Procedure Name:
//      cmdToAnnotation
//
//  Description:
//
// Given a command, and applyOptions, get the runTime command, and then return
// its annotation.
//
proc string cmdToAnnotation( string $cmd, string $applyOptions )
{
	return getRunTimeCommandAnnotation(cmdToRunTimeCommand($cmd, $applyOptions));
}

//
//  Procedure Name:
//      flagToRunTimeCommand
//
//  Description:
//
// Given a tangent type flag, and apply options, return the default runTime command
//
proc string flagToRunTimeCommand( string $flag, int $applyOptions )
{
	string $cmd;
	if( $flag == "auto" ){
		$cmd = "TangentAuto";
	} else if( $flag == "autoease" ){
		$cmd = "TangentAutoEase";
	} else if( $flag == "automix" ){
		$cmd = "TangentAutoMix";
	} else if( $flag == "autocustom" ){
		$cmd = "TangentAutoCustom";
	} else if( $flag == "spline" ){
		$cmd = "TangentSpline";
	} else if( $flag == "linear" ){
		$cmd = "TangentLinear";
	} else if( $flag == "clamped" ){
		$cmd = "TangentClamped";
	} else if( $flag == "step" ){
		$cmd = "TangentStepped";
	} else if( $flag == "stepnext" ){
		$cmd = "TangentStepNext";
	} else if( $flag == "flat" ){
		$cmd = "TangentFlat";
	} else if( $flag == "fixed" ){
		$cmd = "TangentFixed";
	} else if( $flag == "plateau" ){
		$cmd = "TangentPlateau";
	}
	return cmdToRunTimeCommand( $cmd, $applyOptions );
}

//
//  Procedure Name:
//      flagToAnnotation
//
//  Description:
//
// Given a tangent type flag, and apply options, return the runTime command's
// annotation
//
proc string flagToAnnotation( string $flag, int $applyOptions )
{
	return cmdToAnnotation(flagToRunTimeCommand($flag, $applyOptions), 0);
}

//
//  Procedure Name:
//      flagToLabel
//
//  Description:
//
// Given a tangent type flag, return the label. This avoids the cumbersome
// re-use of labels via uiRes
//
proc string flagToLabel( string $flag )
{
	if( $flag == "auto" ){
		return (uiRes("m_loadAnimMenuLibrary.kAutoSpanLabel"));
	} else if( $flag == "autoease" ){
		return (uiRes("m_loadAnimMenuLibrary.kAutoEaseLabel"));
	} else if( $flag == "automix" ){
		return (uiRes("m_loadAnimMenuLibrary.kAutoMixLabel"));
	} else if( $flag == "autocustom" ){
		return (uiRes("m_loadAnimMenuLibrary.kAutoCustomLabel"));
	} else if( $flag == "spline" ){
		return (uiRes("m_loadAnimMenuLibrary.kSplineLabel"));
	} else if( $flag == "linear" ){
		return (uiRes("m_loadAnimMenuLibrary.kLinearLabel"));
	} else if( $flag == "clamped" ){
		return (uiRes("m_loadAnimMenuLibrary.kClampedLabel"));
	} else if( $flag == "step" ){
		return (uiRes("m_loadAnimMenuLibrary.kSteppedLabel"));
	} else if( $flag == "stepnext" ){
		return (uiRes("m_loadAnimMenuLibrary.kSteppedNextLabel"));
	} else if( $flag == "flat" ){
		return (uiRes("m_loadAnimMenuLibrary.kFlatLabel"));
	} else if( $flag == "fixed" ){
		return (uiRes("m_loadAnimMenuLibrary.kFixedLabel"));
	} else if( $flag == "plateau" ){
		return (uiRes("m_loadAnimMenuLibrary.kPlateauLabel"));
	}
}

//
//  Procedure Name:
//      buildTangentTypeCommand
//
//  Description:
//
// Build the appropriate tangent type command
// $applyOptions: Apply tangent type to:
//      0 - both input and output
//      1 - input only
//      2 - output only
// $useRunTimeCommand	- if true, use the default run time command, otherwise
//						  build the doKeyTangent command
// $flag				- tangent type flag
// $selectionConnection - the selection connection to be used
// $options				- options to pass to doKeyTangent command
//
proc string buildTangentTypeCommand( int $applyOptions
								   , int $useRunTimeCommand
								   , string $flag
								   , string $selectionConnection
								   , string $options
								   )
{
	if( $useRunTimeCommand ){
		return( flagToRunTimeCommand( $flag, $applyOptions ) );
	} else {
		string $cmd = "doKeyTangent \"";
		if( $applyOptions != 2 ){
			// Want either both flags, or just the input, so add the input
			//
			$cmd += ("-itt " + $flag);
		}
		if( $applyOptions != 1 ){
			// Want either both flags, or just the ouput, so add the ouput
			//
			$cmd += ("-ott " + $flag);
		}
		$cmd += ("\" " + $selectionConnection + " " + "\"" + $options + "\"");
		return( $cmd );
	}
}

//
//  Procedure Name:
//      buildTangentTypeMenuItems
//
//  Description:
//
// Build the common tangent type menu items. Caller must set parent.
//
// $applyOptions:
//      0 - to both
//      1 - to input only
//      2 - to output only
// $selectionConnection - the selection connection to be used
// $options				- options to pass to doKeyTangent command
// $isModernGraphEd		- if true, the auto tangent items use the appropriate
// 						  runTime command 
//
global proc buildTangentTypeMenuItems( int $applyOptions
									 , string $selectionConnection
									 , string $options
									 , int $isModernGraphEd
									 )
{
	// Build the auto submenu
	//
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kAutoSubMenu"))
		-subMenu true -tearOff true
		-version 2022
		-allowOptionBoxes true AutoSubMenuItem;
		string $autoFlags[] = {"auto","autoease","automix","autocustom"};
		for( $flag in $autoFlags )
		{
			menuItem -label (flagToLabel($flag))
				-annotation (flagToAnnotation($flag, $applyOptions))
				-command (buildTangentTypeCommand( $applyOptions,
				$isModernGraphEd, $flag, $selectionConnection, $options ));
		}
		// Add Option Box
		//
		$flag = "TangentAutoCustomOptions";
		string $cmd = isModernGraphEditor()
						? cmdToRunTimeCommand( $flag, $applyOptions )
						: ("performAutoCustomTangents 1 0 \"" + $selectionConnection + "\" \" " + $options + "\"");
		menuItem -optionBox true
			-annotation (cmdToAnnotation($flag, $applyOptions))
			-command ($cmd);

	setParent -m ..;

	// End of auto submenu
	//
            
	// Add items for the other types of tangent
	//
	string $otherFlags[] = {"spline","linear","clamped","step","stepnext","flat","fixed","plateau"};
	for( $flag in $otherFlags ){
		menuItem -label (flagToLabel($flag))
			-annotation (flagToAnnotation($flag, $applyOptions))
			-command (buildTangentTypeCommand( $applyOptions,
				false, $flag, $selectionConnection, $options ));
	}
}

global proc
buildInOutTangentsMenu(string $selectionConnection,string $options)
{
	global string $gTangentInPluginItemList[];
	string $plugins[] = `keyTangent -q -ptt`;
	string $plugin;
	string $pluginBtn;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kInTangent"))  -subMenu true -to true inTanHierItem;
		buildTangentTypeMenuItems( 1, $selectionConnection, $options, false );

		// Add menu items for the tangent plugins.
		for ($plugin in $plugins)
		{
			$pluginBtn = `menuItem -label $plugin
				-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot2")) 
				-command ("doKeyTangent \"-e -itt " + $plugin + "\" " + $selectionConnection + " " + "\"" + $options + "\"")`;
			$gTangentInPluginItemList[size($gTangentInPluginItemList)] = $pluginBtn;	
		}
			
	setParent -m ..;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kChangeMe"))  -subMenu true -to true outTanHierItem;
		buildTangentTypeMenuItems( 2, $selectionConnection, $options, false );

		// Add menu items for the tangent plugins.
		for ($plugin in $plugins)
		{
			$pluginBtn = `menuItem -label $plugin
				-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot3")) 
				-command ("doKeyTangent \"-e -itt " + $plugin + "\" " + $selectionConnection + " " + "\"" + $options + "\"")`;
			$gTangentInPluginItemList[size($gTangentInPluginItemList)] = $pluginBtn;	
		}

	setParent -m ..;
	
	menuItem -divider true;	
}

//
//  Procedure Name:
//      updateDefaultInOutTangentsMenu
//
//  Description:
//      This updates the default in/out tangent menu items in the Tangents
//      menu before the submenu is shown
global proc
updateDefaultInOutTangentsMenu(int $outTangent)
{
    global string $gGraphEditorDefaultTanMenuItemNames[];

    string $opt = ($outTangent ? "-ott" : "-itt");
    string $tt[] = `keyTangent -q -global $opt`;

    string $menu = $gGraphEditorDefaultTanMenuItemNames[$outTangent];
    string $arr[] = `menu -q -itemArray $menu`;
    int $narr = size($arr);
    for($i=0;$i<$narr;++$i) {
        menuItem -e -radioButton ($tt[0] == $arr[$i]) ($menu + "|" + $arr[$i]);
    }
}

global proc
buildDefaultTangentsMenuItems(int $outTangent)
//
//  Procedure Name:
//      buildDefaultTangentsMenuItems
//
//  Description:
//		This creates the (radio button) menu items for the default in/out tangents
{
    string $labelArray[];
    string $typeArray[] = { "auto", "autoease", "automix", "autocustom", "spline", "linear", "clamped", "flat", "plateau", "step" };
	for( $tanType in $typeArray ){
		$labelArray[size($labelArray)] = flagToLabel( $tanType );
	}
    int $ntypes = size($typeArray);

    radioMenuItemCollection;

    if ($outTangent) {
        string $dott = (uiRes("m_loadAnimMenuLibrary.kSetDefaultOutTangent")) ;

        for($i=0;$i<$ntypes;++$i) {
            menuItem -label $labelArray[$i]
                -command ("doEditDefaultTangent 1 " + $typeArray[$i])
                -annotation $dott -radioButton ($i == 1)
                $typeArray[$i];
        }
    } else {
        string $ditt = (uiRes("m_loadAnimMenuLibrary.kSetDefaultInTangent")) ;

        for($i=0;$i<$ntypes;++$i) {
            if ($typeArray[$i] == "step")
                continue;
            menuItem -label $labelArray[$i]
                -command ("doEditDefaultTangent 0 " + $typeArray[$i])
                -annotation $ditt -radioButton ($i == 1)
                $typeArray[$i];
        }
    }
}

global proc
buildPreferencesTangentsMenus()
//
//  Procedure Name:
//      buildPreferencesTangentsMenus
//
//  Description:
//		This function adds the menu items dealing with tangent preferences
{
    global string $gGraphEditorDefaultTanMenuItemNames[];

    menuItem -label (uiRes("m_loadAnimMenuLibrary.kDefaultInTangent")) -subMenu true
                -postMenuCommand ( "updateDefaultInOutTangentsMenu 0")
                -version "2020"
                $gGraphEditorDefaultTanMenuItemNames[0];
        buildDefaultTangentsMenuItems(0);

    setParent -m ..;

    menuItem -label (uiRes("m_loadAnimMenuLibrary.kDefaultOutTangent")) -subMenu true
                -postMenuCommand ( "updateDefaultInOutTangentsMenu 1")
                -version "2020"
                $gGraphEditorDefaultTanMenuItemNames[1];
        buildDefaultTangentsMenuItems(1);

    setParent -m ..;

    menuItem -divider true;
}

global proc
buildTangentsMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand) 
//
//  Procedure Name:
//      buildGraphEdTangentsMenu
//
//  Description:
//		Creates the menu entries that control
//		tangent settings in the graph editor.
//
//  Input Arguments:
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//				noBreakUnify	Do not show the break and unify tangent menus
//
//  Return Value:
//      None.
//
{
	global string $gTangentParentEditor;
	global string $gTangentAnimEditor;
	global string $gTangentParentMenu;
	global string $gTangentInParentMenu;
	global string $gTangentOutParentMenu;
	global string $gTangentMenuOptions;
	global string $gTangentPluginItemList[];
	global string $gTangentInPluginItemList[];
	global string $gTangentOutPluginItemList[];
	$gTangentParentEditor = $editor;
	$gTangentAnimEditor = $animEditor;
	$gTangentParentMenu = $parentMenu;
	$gTangentMenuOptions = $options;

	setParent -menu $parentMenu;
	if (`menu -query -numberOfItems $parentMenu` != 0) {
		return;
	}

	string $selectionConnection = `editor -query -selectionConnection $editor`;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$selectionConnection = $animEditor;
	}

	string $plugins[] = `keyTangent -q -ptt`;
  
	buildTangentTypeMenuItems( 0, $selectionConnection, $options, isModernGraphEditor() );

	// Add buttons for the tangent plugins.
	string $plugin;
	string $pluginBtn;
	for ($plugin in $plugins)
	{
		$pluginBtn = `menuItem -label $plugin
			-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot1")) 
			-command ("doKeyTangent \"-e -itt " + $plugin + " -ott " + $plugin + "\" " + $selectionConnection + " " + "\"" + $options + "\"")`;
		$gTangentPluginItemList[size($gTangentPluginItemList)] = $pluginBtn;	
	}

	menuItem -divider true;

	buildInOutTangentsMenu($selectionConnection,$options);
	buildPreferencesTangentsMenus();

	// Check for the "noBreakUnify" option
	//
	if (match ("noBreakUnify", $options) != "noBreakUnify") {

		menuItem -label (uiRes("m_loadAnimMenuLibrary.kBreakTangents")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kBreakTangentsAnnot")) 
			-command ("doKeyTangent \"-lock off\" " + $selectionConnection + " noOptions")
			breakTanItem;

        menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnifyTangents"))
                -annotation (uiRes("m_loadAnimMenuLibrary.kUnifyTangentsAnnot"))
                -command ("doKeyTangent \"-lock on\" " + $selectionConnection + " noOptions")
                unifyTanItem;

		menuItem -divider true;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kLockTangentWeight")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kLockTangentWeightAnnot")) 
		-command ("doKeyTangent \"-weightLock on\" " + $selectionConnection + " noOptions")
		tanWeightLockItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kFreeTangentWeight")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kFreeTangentWeightAnnot")) 
		-command ("doKeyTangent \"-weightLock off\" " + $selectionConnection + " noOptions")
		tanWeightFreeItem;

	if ($buildMenuCommand != "") {
		eval (($buildMenuCommand + " " + $editor + " " + $animEditor + " " + $parentMenu));
	}
}

global proc
defineTangentsMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		defineTangentsMenu
//
//	Description:
//		This creates the submenu for tangent setting functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//
//		menuItem -label _L10N( kTangents, "Tangents" ) 
//			-allowOptionBoxes false
//			-subMenu true
//			tangentsHierItem;
//			defineTangentsMenu $editor $animEditor "tangentsHierItem"; 
//			{further menu items could be defined here}
//		setParent -m ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//				noBreakUnify	Do not show the break and unify tangent menus
//
//  Return Value:
//      None.
//
{

	setParent -menu $parentMenu;
	menu -edit
		-postMenuCommand ("buildTangentsMenu " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $options + "\"" + " " + "\"" + $buildMenuCommand + "\"")
		$parentMenu;

}

global proc
updateTangentsMenu (string $plugin, int $isAdded) 
//
//  Procedure Name:
//      updateTangentsMenu
//
//  Description:
//		Updates the tangents menu in response to tangent plugins being added or removed.
//
//  Input Arguments:
//		string $plugin			The name of the tangent plugin being added or removed.
//		int	   $isAdded			Set to true if the plugin has been added.
//
//  Return Value:
//      None.
//
{
	global string $gTangentParentEditor;
	global string $gTangentAnimEditor;
	global string $gTangentParentMenu;
	global string $gTangentInParentMenu;
	global string $gTangentOutParentMenu;
	global string $gTangentMenuOptions;
	global string $gTangentPluginItemList[];
	global string $gTangentInPluginItemList[];
	global string $gTangentOutPluginItemList[];

	// If the editor has not been built yet, do nothing.
	if ($gTangentParentEditor == "")
		return;

	string $selConnection = `editor -query -selectionConnection $gTangentParentEditor`;
	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $gTangentMenuOptions) == "bufferCurve") {
		$selConnection = $gTangentAnimEditor;
	}

	// Update each tangent menu.
	setParent -menu $gTangentParentMenu;
	doUpdateTangentsMenu($plugin, $isAdded, $gTangentPluginItemList, $selConnection);
	setParent -menu $gTangentInParentMenu;
	doUpdateTangentsMenu($plugin, $isAdded, $gTangentInPluginItemList, $selConnection);
	setParent -menu $gTangentOutParentMenu;
	doUpdateTangentsMenu($plugin, $isAdded, $gTangentOutPluginItemList, $selConnection);
}

proc
doUpdateTangentsMenu (string $plugin, int $isAdded, string $itemList[],
					  string $selConnection) 
//
//  Procedure Name:
//      doUpdateTangentsMenu
//
//  Description:
//		Do the work of updating the given tangent menu.
//
//  Input Arguments:
//		string $plugin			The name of the tangent plugin being added or removed.
//		int	   $isAdded			Set to true if the plugin has been added.
//		string $itemList[]		The tangent menu to update.
//		string $selConnection	The selection connection to use when creating new items.
//
//  Return Value:
//      None.
//
{
	global string $gTangentMenuOptions;

	// Look for the plugin in the tangents menu.  If found, enable/disable it.
	// If not found, add it.
	string $item;
	for ($item in $itemList)
	{
		string $pluginLabel = `menuItem -q -label $item`;
		if ($pluginLabel == $plugin)
		{
			menuItem -e -enable $isAdded;
			return;
		}
	}

	// Add a new menu item if necessary.
	if ($isAdded == true)
	{
		string $pluginItem = `menuItem -label $plugin
			-annotation (uiRes("m_loadAnimMenuLibrary.kPluginAnnot4")) 
			-command ("doKeyTangent \"-e -itt " + $plugin + " -ott " + $plugin + "\" " + $selConnection + " " + "\"" + $gTangentMenuOptions + "\"")`;
		$itemList[size($itemList)] = $pluginItem;	
		setParent -m ..;
	}
}

//
// Create a reference curves and enable show buffer curve on success
//
global proc makeReferenceBufferCurve(string $animEditor)
{
    int $result = `bufferCurve -animation keys -overwrite true -useReferencedCurve`;
    if($result == 1)
    {
        animCurveEditor -e -showBufferCurves 1 $animEditor;
    }
}

global proc
updatePreferencesWeighting()
//
//  Procedure Name:
//      updatePreferencesWeighting
//
//  Description:
//      This updates the tangent weighting preferences menu items under the Curves menu
//      before the submenu is shown
{
    int $wt = `keyTangent -q -global -weightedTangents`;

    menuItem -e -radioButton ($wt == 0) "graphEdDefaultTangentWeightsItem|nonWeighted";
    menuItem -e -radioButton ($wt == 1) "graphEdDefaultTangentWeightsItem|weighted";
}

global proc
buildCurvesMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand) 
//
//  Procedure Name:
//      buildCurvesMenu
//
//  Description:
//		Creates the menu entries that control
//		curve editing within an animation editor.
//
//  Input Arguments:
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//				useSmoothness	Add a "Curve Smoothness" entry
//				usePin			Add "Pin channels" and "Unpin channels" entries
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	if (`menu -query -numberOfItems $parentMenu` != 0) {
		// Update radio button checks for curve smoothness
		//
		if (match ("useSmoothness", $options) == "useSmoothness") {
			string $curveSmoothness = `animCurveEditor -query -smoothness $animEditor`;
			menuItem -edit
				-radioButton ($curveSmoothness == "coarse")
				coarseCurveItem;
			menuItem -edit
				-radioButton ($curveSmoothness == "rough")
				roughCurveItem;
			menuItem -edit
				-radioButton ($curveSmoothness == "medium")
				mediumCurveItem;
			menuItem -edit
				-radioButton ($curveSmoothness == "fine")
				fineCurveItem;
		}

		global string $gUnisolatedCurves[];
		menuItem -edit -cb (size($gUnisolatedCurves) > 0) isolateCurveItem;
		
		return;
	}

	string $selectionConnection = `editor -query -selectionConnection $editor`;
	string $realSelectionConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	int $performBase = 0;
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$selectionConnection = $animEditor;
		$performBase = 3;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPreInfinity"))  -subMenu true -to true preInfinityHierItem;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kCycle")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleBeforeAnnot")) 
			-command ("doSetInfinity \"-pri cycle\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kCycleOffset")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleOffsetBeforeAnnot")) 
			-command ("doSetInfinity \"-pri cycleRelative\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kOscillate")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kOscillateBeforeAnnot")) 
			-command ("doSetInfinity \"-pri oscillate\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kMakeLinear")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kMakeLinearBeforeAnnot")) 
			-command ("doSetInfinity \"-pri linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kConstant")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kConstantBeforeAnnot"))
			-command ("doSetInfinity \"-pri constant\" " + $selectionConnection + " " + "\"" + $options + "\"");
	setParent -m ..; 

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPostInfinity"))  -subMenu true -to true postInfinityHierItem;
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kCycle" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleAfterAnnot")) 
			-command ("doSetInfinity \"-poi cycle\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kCycleOffset" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kCycleOffsetAfterAnnot")) 
			-command ("doSetInfinity \"-poi cycleRelative\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kOscillate" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kOscillateAfterAnnot")) 
			-command ("doSetInfinity \"-poi oscillate\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kLinear"))
			-annotation (uiRes("m_loadAnimMenuLibrary.kLinearAfterAnnot"))
			-command ("doSetInfinity \"-poi linear\" " + $selectionConnection + " " + "\"" + $options + "\"");
		menuItem -label `uiRes( "m_loadAnimMenuLibrary.kConstant" )`
			-annotation (uiRes("m_loadAnimMenuLibrary.kConstantAfterAnnot"))
			-command ("doSetInfinity \"-poi constant\" " + $selectionConnection + " " + "\"" + $options + "\"");
	setParent -m ..; 

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kIsolateCurve"))
		-cb false
		-annotation (uiRes("m_loadAnimMenuLibrary.kIsolateCurveAnnot"))
		-command ("isolateAnimCurve #1 "+$realSelectionConnection+" "+$animEditor)
		isolateCurveItem;

	if (match ("useSmoothness", $options) == "useSmoothness") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kCurveSmoothness"))  -subMenu true -tearOff true curveSmoothHierItem;
			//	Create a collection to keep the rb's in proper
			//	sync (IE: only one on at any one time. )
			//
			radioMenuItemCollection;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kCoarse")) 
				-radioButton true
				-annotation (uiRes("m_loadAnimMenuLibrary.kCoarseAnnot")) 
				-command ("animCurveEditor -edit -smoothness coarse " + $animEditor) coarseCurveItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kRough")) 
				-radioButton false
				-annotation (uiRes("m_loadAnimMenuLibrary.kRoughAnnot")) 
				-command ("animCurveEditor -edit -smoothness rough " + $animEditor) roughCurveItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kMedium")) 
				-radioButton false
				-annotation (uiRes("m_loadAnimMenuLibrary.kMediumAnnot")) 
				-command ("animCurveEditor -edit -smoothness medium " + $animEditor) mediumCurveItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kFine")) 
				-radioButton false
				-annotation (uiRes("m_loadAnimMenuLibrary.kFineAnnot")) 
				-command ("animCurveEditor -edit -smoothness fine " + $animEditor) fineCurveItem;
		setParent -m ..;
	}

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kBakeChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kBakeChannelAnnot")) 
		-c ("performBakeResults " + $performBase + " " + $selectionConnection) 
		-dragMenuCommand( "performBakeResults " + ($performBase + 2) + " \"" + 
						  $selectionConnection + "\"")
		bakeResultsItem;
		menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kBakeChannelOptions"))
		-c ("performBakeResults " + ($performBase + 1) + " " + $selectionConnection) bakeResultsOptionsItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kMuteChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kMuteChannelAnnot")) 
        -command ("doMuteChannel "+ $realSelectionConnection + " -true")
		muteChannelItem;
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnmuteChannel")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kUnmuteChannelAnnot")) 
        -command ("doMuteChannel "+ $realSelectionConnection + " -false")
        unmuteChannelItem;
        
    //
    // Create the Lock Channel / Template channel based on witch GE is used
    //
    if( isModernGraphEditor() )
    {
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kLockChannel")) 
            -annotation (uiRes("m_loadAnimMenuLibrary.kLockChannelAnnot")) 
            -command ("GraphEditorLockChannel")   // Runtime command
            templateChannelItem;
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnLockChannel")) 
            -annotation (uiRes("m_loadAnimMenuLibrary.kUnLockChannelAnnot")) 
            -command ("GraphEditorUnlockChannel") // Runtime command
            untemplateChannelItem;    
    }
    else
    {
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kTemplateChannel")) 
            -annotation (uiRes("m_loadAnimMenuLibrary.kTemplateChannelAnnot")) 
            -command ("doTemplateChannel "+ $realSelectionConnection + " 1")
            templateChannelItem;
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kUntemplateChannel")) 
            -annotation (uiRes("m_loadAnimMenuLibrary.kUntemplateChannelAnnot")) 
            -command ("doTemplateChannel "+ $realSelectionConnection + " 0")
            untemplateChannelItem;    
    }

	if (match ("usePin", $options) == "usePin") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kPinChannel")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kPinChannelAnnot")) 
	        -command ("doPinChannel " + $editor + " " + $realSelectionConnection + " 1")
			pinChannelItem;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kUnpinChannel")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kUnpinChannelAnnot")) 
	        -command ("doPinChannel " + $editor + " " + $realSelectionConnection + " 0")
	        unpinChannelItem;
	}

	menuItem -divider true -dividerLabel (uiRes("m_loadAnimMenuLibrary.kCurveFilters"));

	// Butterworth Filter
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kButterworthFilter"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kButterworthFilterAnnot"))
		-c ("performButterworth " + $performBase + " " + $selectionConnection)
		-dragMenuCommand( "performButterworth " + ($performBase + 2) + " \"" +
						  $selectionConnection + "\"")
		butterworthFilterItem;

	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kButterworthFilterOptions"))
		-c ("performButterworth " + ($performBase + 1) + " " + $selectionConnection)
		butterworthFilterOptionsItem;

	// Euler Filter
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kEulerFilter")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kEulerFilterAnnot"))
		-c ("performEulerFilter " + $realSelectionConnection)
		eulerFilterItem;

	// Key Reducer Filter
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kKeyReducerFilter"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kKeyReducerFilterAnnot"))
		-c ("performKeyReducer " + $performBase + " " + $selectionConnection)
		-dragMenuCommand( "performKeyReducer " + ($performBase + 2) + " \"" +
						  $selectionConnection + "\"")
		keyReducerFilterItem;

	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kKeyReducerFilterOptions"))
		-c ("performKeyReducer " + ($performBase + 1) + " " + $selectionConnection)
		keyReducerFilterOptionsItem;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kGaussianSmoothFilter"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kGaussianSmoothFilterAnnot"))
		-version "2022"
		-c ("pythonWrapper gaussiansmooth.cmd_create 0")
		gaussianSmoothFilterItem;

	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kGaussianSmoothFilterOptions"))
		-c ("pythonWrapper gaussiansmooth.cmd_create 1")
		gaussianSmoothFilterOptionsItem;

	// Peak Removal Filter
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kPeakRemoverFilter"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kPeakRemoverFilterAnnot"))
		-version "2022"
		-c ("performPeakRemover " + $performBase + " " + $selectionConnection)
		-dragMenuCommand( "performPeakRemover " + ($performBase + 2) + " \"" +
						  $selectionConnection + "\"")
		peakRemoverFilterItem;

	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kPeakRemoverFilterOptions"))
		-c ("performPeakRemover " + ($performBase + 1) + " " + $selectionConnection)
		peakRemoverFilterOptionsItem;

	// Key Sync Filter
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kKeySyncFilter"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kKeySyncFilterAnnot"))
		-c ("performKeySync " + $performBase + " " + $selectionConnection)
		-dragMenuCommand( "performKeySync " + ($performBase + 2) + " \"" +
						  $selectionConnection + "\"")
		keySyncFilterItem;

	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kKeySyncFilterOptions"))
		-c ("performKeySync " + ($performBase + 1) + " " + $selectionConnection)
		keySyncFilterOptionsItem;

	// Resample Curve
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kResampleCurve")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kResampleCurveAnnot"))	
		-c ("performResample " + $performBase + " " + $selectionConnection)
		-dragMenuCommand( "performResample " + ($performBase + 2) + " \"" +
						   $selectionConnection + "\"")
		resampleItem;
	menuItem -optionBox true
		-annotation (uiRes("m_loadAnimMenuLibrary.kResampleCurveOptions")) 
		-c ("performResample " + ($performBase + 1) + " " + $selectionConnection)
		resampleOptionsItem;

	// Simplify Curve
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSimplifyCurve")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSimplifyCurveAnnot")) 
		-c ("performSimplify " + $performBase + " " + $selectionConnection) 
		-dragMenuCommand( "performSimplify " + ($performBase + 2) + " \"" + 
						  $selectionConnection + "\"")
		simplifyItem;
	menuItem -optionBox true 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSimplifyCurveOptions")) 
		-c ("performSimplify " + ($performBase + 1) + " " + $selectionConnection) 
		simplifyOptionsItem;

	menuItem -divider true;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kChangeRotInterp"))  -subMenu true -tearOff true rotationInterpolationHierItem;
		//
		//	These are not radio buttons because we cannot show the type
		//	of the current selection: there could be many curves currently
		//	selected.
		//
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kIndEuler")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kIndEulerAnnot")) 
				-c ("performRotationInterpolation none " + $realSelectionConnection);
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncEuler")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncEulerAnnot")) 
				-c ("performRotationInterpolation euler " + $realSelectionConnection);		
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncQuatSlerp")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncQuatSlerpAnnot")) 
				-c ("performRotationInterpolation quaternionSlerp " + $realSelectionConnection);
	    menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncQuatSquad")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncQuatSquadAnnot")) 
				-c ("performRotationInterpolation quaternionSquad " + $realSelectionConnection);
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kSyncQuat")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSyncQuatAnnot")) 
				-c ("performRotationInterpolation quaternion " + $realSelectionConnection);				
	setParent -m ..;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kSpreadsheet")) 
		-annotation (uiRes("m_loadAnimMenuLibrary.kSpreadsheetAnnot")) 
		-command ("OpenAnimSpreadsheet " + $realSelectionConnection)
		spreadSheetItem;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kBufferCurve")) -subMenu true bufferCurveMenuItem;
			//	Create a collection to keep the rb's in proper
			//	sync (IE: only one on at any one time. )
			//
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kBufferCurveSnapshot")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kBufferCurveSnapshotAnnot")) 
				-command ("animCurveEditor -e -showBufferCurves 1 " + $animEditor + "; bufferCurve -animation \"keys\" -overwrite true")
				bufferSnapItem;
			menuItem -label (uiRes("m_loadAnimMenuLibrary.kBufferCurveReference")) 
				-annotation (uiRes("m_loadAnimMenuLibrary.kBufferCurveReferenceAnnot")) 
				-command ("makeReferenceBufferCurve " + $animEditor )
				bufferReferenceItem;
			setParent -m ..;
		menuItem -label (uiRes("m_loadAnimMenuLibrary.kSwapBufferCurve")) 
			-annotation (uiRes("m_loadAnimMenuLibrary.kSwapBufferCurveAnnot"))
			-command "bufferCurve -animation \"keys\" -swap"
			bufferSwapItem;
	}

	menuItem -divider true;

    menuItem -label (uiRes("m_loadAnimMenuLibrary.kDefaultWeightingTangent")) -subMenu true -version "2020"
                -postMenuCommand ( "updatePreferencesWeighting") graphEdDefaultTangentWeightsItem;
        radioMenuItemCollection;
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kNonWeightTangents"))
            -command ("keyTangent -edit -global -weightedTangents 0") -echoCommand 1 -radioButton 0
            -annotation (uiRes("m_loadAnimMenuLibrary.kDefaultNonWeightTangentsAnnot"))
            nonWeighted;
        menuItem -label (uiRes("m_loadAnimMenuLibrary.kWeightTangents"))
            -command ("keyTangent -edit -global -weightedTangents 1") -echoCommand 1 -radioButton 1
            -annotation (uiRes("m_loadAnimMenuLibrary.kDefaultWeightTangentsAnnot"))
             weighted;
        setParent -m ..;

	menuItem -label (uiRes("m_loadAnimMenuLibrary.kNonWeightTangents"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kNonWeightTangentsAnnot"))
		-command ("doKeyTangent \"-edit -weightedTangents false\" " + $selectionConnection + " " + "\"" + $options + "\"");
	menuItem -label (uiRes("m_loadAnimMenuLibrary.kWeightTangents"))
		-annotation (uiRes("m_loadAnimMenuLibrary.kWeightTangentsAnnot"))
		-command ("doKeyTangent \"-edit -weightedTangents true\" " + $selectionConnection + " " + "\"" + $options + "\"");

	if ($buildMenuCommand != "") {
		eval (($buildMenuCommand + " " + $editor + " " + $animEditor + " " + $parentMenu));
	}
}

global proc
defineCurvesMenu (string $editor, string $animEditor, string $parentMenu, string $options, string $buildMenuCommand)
//
//	Procedure Name:
//		defineCurvesMenu
//
//	Description:
//		This creates the submenu for curve editing functionality
//
//	Example:
//		Create a menu that this submenu is to be attached to
//
//		menuItem -label _L10N( kCurves, "Curves" ) 
//			-allowOptionBoxes false
//			-subMenu true
//			curvesHierItem;
//			defineCurvesMenu $editor $animEditor "curvesHierItem"; 
//			{further menu items could be defined here}
//		setParent -m ..;
//
//  Input Arguments:
//		string $editor			The name of the editor that this submenu
//								is being attached to
//		string $parentMenu		The name of the parent menu that this
//								submenu is being attached to
//		string $options			Options for this proc
//								Option words are specified within the
//								the string, with each option seperated
//								by a space (e.g. "bufferCurve otherOption")
//			Current options:
//				noOptions		A nice "do nothing" string to pass
//				bufferCurve		Issue commands to (possibly) create buffer curves
//
//  Return Value:
//      None.
//
{
	setParent -menu $parentMenu;
	menu -edit
		-postMenuCommand ("buildCurvesMenu " + $editor + " " + $animEditor + " " + $parentMenu + "\"" + $options + "\"" + " " + "\"" + $buildMenuCommand + "\"")
		$parentMenu;
}


global proc
OpenAnimSpreadsheet (string $selectionConnection)
//
//	Procedure Name:
//		OpenAnimSpreadsheet
//
//	Description:
//		This is a helper proc to open the attribute editor for
//		a selected curve (or the first curve if more than one
//		is selected)
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
{
	string $animCurves[];

	if (`isTrue SomethingSelected` != 0) {
		catch ($animCurves = `keyframe -an keys -query -name`);
	}
	if (size ($animCurves) == 0) {
		$animCurves = `findAnimCurves $selectionConnection`;
	}

	if (size ($animCurves) > 0) {
		showEditor $animCurves[0];
	}
	else {
		warning (uiRes("m_loadAnimMenuLibrary.kNoKeysSelected"));
	}
}

proc 
string findCommonSelectedKeyTangentInfo( string $queryOpt )
//
//	Procedure Name:
//		findCommonSelectedKeyTangentInfo
//
//	Description:
//		This is a helper procedure to find common tangent 
//      information given a selected keyset.
//
//  Input Arguments:
//      string $queryOpt A queryable flag
//
//  Return Value:
//      string The common tangent information for a selected keyset.
//      If no keys are selected or no common information is found
//      the string return is "-1"
//
{
    // Query selected key tangent specified information
    //
    string $info[];
    
    if( $queryOpt == "-itt" || $queryOpt == "-inTangentType" ||
        $queryOpt == "-ott" || $queryOpt == "-outTangentType" )
    {
        $info = `keyTangent -q $queryOpt`;
    }
    else if( $queryOpt == "-l"  || $queryOpt == "-lock"       ||
             $queryOpt == "-wl" || $queryOpt == "-weightLock" ||
             $queryOpt == "-wt" || $queryOpt == "-weightedTangents" )
    {
        int $intInfo[] = `keyTangent -q $queryOpt`;
        
        // FIXME : Is there a better way to do this sort of cast ?
        //
        int $i;
        for( $i = 0; $i < size( $intInfo ); ++$i )
            $info[ $i ] = $intInfo[ $i ];
    }
    else
    {
        float $floatInfo[] = `keyTangent -q $queryOpt`;
        
        // FIXME : Is there a better way to do this sort of cast ?
        //
        int $i;
        for( $i = 0; $i < size( $floatInfo ); ++$i )
            $info[ $i ] = $floatInfo[ $i ];
    }
    
    int $i;
    string $common = $info[ 0 ];
    for( $i = 1; $i < size( $info ); ++$i )
    {
        if( $common != $info[ $i ] )
            return "-1";
    }
    
    return $common;
} 

global proc
doUpdateTangentFeedback( )
//
//  Procedure Name:
//      updateTangentFeedback
//
//  Description:
//      This procedure updates the key tangent iconTextCheckBoxes based on
//      the current keyset selection.  It is called on a paramCurveChanged message
//      found in TgraphEditor class.
//
//  Input Arguments:
//      None
//
//  Return Value:
//      None
//
{
	global string $gGraphEditorTanButtonNames[];
	string $name;

	// Check existence
	//
	for( $name in $gGraphEditorTanButtonNames )
		if( !`iconTextCheckBox -ex $name` )
			return;

	// Reset tangent types
	//
	for( $name in $gGraphEditorTanButtonNames )
		iconTextCheckBox -e -v false $name;

    // if there is no selected curve
    if( !`animCurveEditor -q -acs graphEditor1GraphEd` )
        return;
        
        
	// Toggle correct in-out tangent types
	//
	string $types[] = { "-itt", "-ott" };
	for ($t in $types)
	{
		string $tmp0 = findCommonSelectedKeyTangentInfo($t);
		if ($tmp0 == "-1" || $tmp0 == "fixed" )
			continue;

		if ( `iconTextCheckBox -q -ex ($tmp0 + "TanButton" )` )
            catchQuiet( `iconTextCheckBox -e -v true ($tmp0+"TanButton")` );
	}

	// Toggle correct tangent lock state
	//
	$tmp0 = findCommonSelectedKeyTangentInfo( "-l" );
	if( $tmp0 != "-1" )
	{
		int $i = ( $tmp0 == "0" ) ? 10 : 11;
		iconTextCheckBox -e -v true $gGraphEditorTanButtonNames[ $i ];
	}

	// Toggle correct tangent weight lock state
	//
	$tmp0 = findCommonSelectedKeyTangentInfo( "-wl" );
	if( $tmp0 != "-1" )
	{
		int $i = ( $tmp0 == "0" ) ? 12 : 13;
		iconTextCheckBox -e -v true $gGraphEditorTanButtonNames[ $i ];
	}
}

global proc
doUpdateDefaultTangentFeedback()
//
//  Procedure Name:
//      doUpdateDefaultTangentFeedback
//
//  Description:
//      Updates the icons in the toolbar to reflect the default in/out tangent
{
    global string $gGraphEditorDefaultTanButtonNames[];

    if (size($gGraphEditorDefaultTanButtonNames) > 1 &&
        `iconTextButton -exists $gGraphEditorDefaultTanButtonNames[0]` &&
        `iconTextButton -exists $gGraphEditorDefaultTanButtonNames[1]`) {

        // Adjust the default tangent icons
        string $itt[]= `keyTangent -q -global -itt`;
		iconTextButton -e -i ($itt[0] + "TangentIn.png") $gGraphEditorDefaultTanButtonNames[0];

        string $ott[]= `keyTangent -q -global -ott`;
		iconTextButton -e -i ($ott[0] + "TangentOut.png") $gGraphEditorDefaultTanButtonNames[1];
    }
}

global
proc loadAnimMenuLibrary ()
{
}
