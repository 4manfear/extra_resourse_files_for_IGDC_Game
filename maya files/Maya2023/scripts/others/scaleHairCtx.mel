// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
global float $gScaleHairStartPress[];
global string $gScaleHairFollicles[];
global string $gScaleHairHairSystems[];
global float $gScaleHairFollicleScale[];
 	
proc forceHairSystemUpdate( string $hsys )
{
	string $hTime = ($hsys + ".currentTime");
	int $frame = getAttr( $hTime );
	disconnectAttr time1.outTime $hTime; 
	setAttr $hTime ($frame+1);
	refresh();
	setAttr ($hsys + ".lastEvalTime") ($frame-1);
	connectAttr time1.outTime $hTime; 
}	

global proc scaleHairContextPress()
{
	global string $gScaleHairFollicles[];
	global float $gScaleHairStartPress[];
	global float $gScaleHairFollicleScale[];
	global string $gScaleHairHairSystems[];
//	string $modifier   = `draggerContext -query -modifier scaleHairContext`;
//  if( $modifier == "shift"){}

	$gScaleHairStartPress = `draggerContext -query -anchorPoint scaleHairContext`;
	string $sel[] = `ls -sl`;
	convertHairSelection( "follicles" );	
	$gScaleHairFollicles = `ls -sl`;
	float $cTime = `currentTime -q`;
	convertHairSelection( "hairSystems" );	
	string $hsys[] = `ls -sl`;
	$gScaleHairHairSystems = {};
	int $curInd = 0;
	int $i;
	// We only add the hair systems which have a start time less
	// than the current time, and thus which will need to
	// be forced to update.
	for( $i = 0; $i < size( $hsys ); $i++ ){
		float $start = getAttr($hsys[$i] + ".startFrame");
		if($cTime > $start ){
			$gScaleHairHairSystems[ $curInd ] = $hsys[$i];
			$curInd++;
		}
	}
	if( $curInd > 0 ){
		print((uiRes("m_scaleHairCtx.kAdvanceSimulationWarning"))); 
	}

	select -r $sel;
	for( $i = 0; $i < size( $gScaleHairFollicles ); $i++ ){
		$gScaleHairFollicleScale[$i] = getAttr( $gScaleHairFollicles[$i] + ".scaleY");
	}
}
 	
global proc scaleHairContextDrag()
{
	global float $gScaleHairStartPress[];
	global string $gScaleHairFollicles[];
	global float $gScaleHairFollicleScale[];
	global string $gScaleHairHairSystems[];

	float  $dragPosition[] = `draggerContext -query -dragPoint scaleHairContext`;
 	// int    $button     = `draggerContext -query -button scaleHairContext`;
 	// string $modifier   = `draggerContext -query -modifier scaleHairContext`;
 	
	float $diff = $dragPosition[0] - $gScaleHairStartPress[0];	
	if( $diff == 0 ){
		return;
	}

	float $scaleFac;
	if( $diff > 0 ){
		$scaleFac = 1.0 + $diff * 0.01;
	} else {
		$scaleFac = 1.0/(1.0 - $diff *0.01);
	}
	int $i;
	for( $i = 0; $i < size( $gScaleHairFollicles ); $i++ ){
		float $scl = $scaleFac * $gScaleHairFollicleScale[$i];
		setAttr ($gScaleHairFollicles[$i] + ".scale") $scl $scl $scl;
	}
	for( $i = 0; $i < size( $gScaleHairHairSystems ); $i++ ){
		forceHairSystemUpdate( $gScaleHairHairSystems[$i] );
	}
	refresh();
}


global proc scaleHairCtx()
{
	if( !`contextInfo -exists scaleHairContext`){
		draggerContext
 			-helpString (uiRes("m_scaleHairCtx.kScaleHairTool"))
 			-pressCommand "scaleHairContextPress"
 			-dragCommand  "scaleHairContextDrag"
			-image1 	  "menuIconHair.png"
 			-cursor       "default"
			-undoMode     "sequence"
 			scaleHairContext;
		
	}
 	setToolTo scaleHairContext;
}
