// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//      ghostAppendedClip
//
//  Description:
//      This function makes sure the clipGhost node n/w is up to date
//      after an operation (e.g., splitting or duplicating) that can 
//      add an additional clip. To determine if a ghost should be added
//      we check if the original node that was split or duplicated had a
//      ghost. If it did, a ghost is added for the new clip as well. 
//      Otherwise, we setup the n/w correctly to permit a ghost to be 
//      added in the future.
//
// Input Arguments:
//      $sch         : The name of the scheduler managing the clips
//      $newClips[0] : The original clip that was duped/split
//      $newClips[1] : The new clip created as part of the operation
//      $option      : 0 - Do nothing
//                     1 - Copy Translation/Rotation offsets to new clip
//                     2 - Match clips so that new clip starts where old clip ends
//

proc string getOffsetObject( string $character )
{
    string $element = "";
    if ( size( $character ) )
    {
        string $object[] = `character -q -aoo $character`;
        if ( size( $object ) )
            $element = $object[0];
    }
    return $element;
}

proc matchClips( string $clips[] )
{
    string $character = getClipCharacter( $clips[0] );
    if ( size( $character ) == 0 )
        return;

    string $element = getOffsetObject( $character );
    if ( size($element) )
        clipMatching -mt 1 -mr 1 -cs $clips[1] 0.0 -cd $clips[0] 1.0 $character $element;
}

global proc ghostAppendedClip( string $scheduler, string $newClips[], int $option )
{
    // If the provided scheduler is invalid, bail. Don't issue a warning
    // as this can happen under various "normal" workflows.
    if (size($scheduler) == 0)
        return;

    // Check if the character has an offset object. If so, this is an
    // indication that other clips in the scene may be ghosted. To 
    // ensure that ghosting will also work correctly on this new
    // clip, run the procedure that 'sanitizes' clips, reusing the
    // current offset object. If some channels on the new clip are in
    // relative mode, the user will also be queried to see if these
    // channels should be changed to absolute.
    // 
    if ( size( $newClips[1] ) )
    {
        string $character[] = `clipSchedule -q -character $scheduler`;
        if ( size( $character ) )
        {
            string $offset = getOffsetObject( $character[0] );
            if ( size( $offset ) )
                verifyClipsAreValid( $character[0], $offset );
        }
    }

    // Get the clipToGhost node for the scheduler
    string $clipToGhost = getClipToGhostForScheduler($scheduler);
    if (size( $clipToGhost ) == 0)
        return;

    // Make sure the depend graph is modified to account for 
    // changes in clip order
    ghostReorderConnections($scheduler);

    // Hook up the new node to the clipToGhost node
    connectClipAndClipToGhost($newClips[1], $clipToGhost, $scheduler);

    // Next, create a clip ghost on the new clip
    performCreateClipGhost({ $newClips[1] });

    // If there is no original clip, or the original clip was not ghosted, bail.
    if (size($newClips[0]) == 0 ||
        clipsAreGhosted( { $newClips[0] } ) == false)
        return;

    // Copy the number of intermediate poses from the original clip onto the new clip
    string $ghost = getGhostShapeForClip($newClips[0]);
    if (size($ghost))
    {
        int $n = `getAttr ( $ghost + ".intermediatePoses")`;
        $ghost = getGhostShapeForClip($newClips[1]);
        if (size($ghost))
            setAttr ( $ghost + ".intermediatePoses") $n;
    }

    switch($option)
    {
        case 2:
            matchClips  $newClips; 
            return;

        case 1:
        default:
            return;
    }
}
