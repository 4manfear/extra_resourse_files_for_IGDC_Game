// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
// Creation Date:  May 2002
//
//
global proc fluidOceanAddSurfaceLocator(int $useSetAttr, int $type, int $isPond)
{
	$oceanShader = getCurrentOceanOrPond();

	if( $oceanShader != "" ){
		// ignore the isPond argument, just use the current ocean or pond
		$isPond = 0;
		if( nodeType($oceanShader) == "fluidShape" )
			$isPond = 1;

		if( $type == 0 ){
			if( $isPond ){
				pondLocator $oceanShader 0 0;
			} else {
				oceanLocator $oceanShader 0 0;
			}
		} else if( $type == 1 ){
			oceanDynamicLocator $oceanShader 0 0 $useSetAttr 0 "" 0 0 $isPond;
		} else if( $type == 2 ){
			oceanDynamicLocator $oceanShader 0 0 $useSetAttr 1 "" 0 0 $isPond;
		} else if( $type == 3 ){
			oceanDynamicLocator $oceanShader 0 0 $useSetAttr 0 "" 1 0 $isPond;
		} else {
			string $sel[] = `ls -sl -type transform`;
			int $i, $j;
			int $doBoat = ($type >= 5 );
			int $motorBoat = ($type == 6 );
			int $addedObject = false;

			for( $i = 0; $i < size( $sel ); $i++ ){
				string $dag[] = `ls -dag $sel[$i]`;
				int $isOceanPlane = false;
				for( $j = 0; $j < size( $dag ); $j++ ){
					if(  match("oceanPlane", $dag[$j]) != "" 
					   ||match("oceanPreviewPlane", $dag[$j]) != "" ){
						// TODO check for selected ponds
					   $isOceanPlane = true;
					   break;
					}
				}
				if( !$isOceanPlane ){
					oceanDynamicLocator $oceanShader 0 0 $useSetAttr 0 $sel[$i] $doBoat $motorBoat $isPond;
					$addedObject = true;
				}
			}
			if( $addedObject == false){
				error (uiRes("m_fluidOceanAddSurfaceLocator.kNoObjectSelected"));
			}
		}
	} else {
		// If no pond or ocean shader and the last selected item is a mesh, treat it as the ocean
		string $sel[] = `ls -sl -type transform`;
		int $numSel = size( $sel );
		if( $numSel > 0 ){
			string $lastItem = $sel[$numSel-1];
			string $meshes[] = `ls -dag -type mesh $lastItem`;	
			if( size( $meshes ) > 0 ){
				if( $numSel == 1 ){	
					if( $type == 0 ){
						oceanLocator $meshes[0] 0 0;
					} else if( $type == 1) {
						oceanDynamicLocator $meshes[0] 0 0 $useSetAttr 0 "" 0 0 false;
					} else if( $type == 2) {
						oceanDynamicLocator $meshes[0] 0 0 $useSetAttr 1 "" 0 0 false;
					} else if( $type == 3) {
						oceanDynamicLocator $meshes[0] 0 0 $useSetAttr 0 "" 1 0 false;
					} else {
						error (uiRes("m_fluidOceanAddSurfaceLocator.kMeshNoObjectSelected"));
					}
				} else {
					int $i;	
					int $doBoat = ($type >= 5);
					int $motorBoat = ($type == 6 );	
					for( $i= 0; $i < $numSel-1; $i++ ){
						oceanDynamicLocator $meshes[0] 0 0 $useSetAttr 0 $sel[$i] $doBoat $motorBoat false;

					}		
				}
			}
		}
	}
}

