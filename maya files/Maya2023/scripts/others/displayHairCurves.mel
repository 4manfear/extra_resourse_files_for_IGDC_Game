// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  2003
//
// Description:  Set the input curves to display for hairCurve nodes.
//	

global proc int displayHairCurves(string $element, int $entireSystems)
{
	string $hairCurves[];
	int $i; 
	string $hsys[] = getSelectedHairSystems();
	int $hasPfxHair = false;
	if( $entireSystems ){
		if( size( $hsys ) == 0 ){
			// if nothing is selected we apply the display to all hair systems
			$hsys = `ls -type hairSystem`;
			if( size( $hsys ) == 0 ){
				warning ((uiRes("m_displayHairCurves.kNoHairSystems")));
				return false;
			}
		}
		for( $i = 0; $i < size( $hsys); $i++ ){
			$hairCurves = stringArrayCatenate( 
					$hairCurves, hairCurvesFromSystem( $hsys[$i] ));
			string $pfxHair = destinationNodeNameFromConnection( $hsys[$i] + ".outputRenderHairs" );
			if( $pfxHair != "" ){
				$hasPfxHair = true;

				// set the intermediate on the pfxHair
				if( $element == "start" || 
					$element == "rest" ){
					setAttr ($pfxHair + ".intermediateObject") true;
				} else {
					setAttr ($pfxHair + ".intermediateObject") false;
				}

				// additionally set the intermediate on the mesh(es)
				string $worldMesh = destinationNodeNameFromConnection( $pfxHair + ".worldMainMesh[0]" );
				if( $worldMesh != ""){
					if( $element == "start" || 
						$element == "rest" ){
						setAttr ($worldMesh + ".intermediateObject") true;
					} else {
						setAttr ($worldMesh + ".intermediateObject") false;
					}
				}	
				$worldMesh = destinationNodeNameFromConnection( $pfxHair + ".worldLeafMesh[0]" );
				if( $worldMesh != ""){
					if( $element == "start" || 
						$element == "rest" ){
						setAttr ($worldMesh + ".intermediateObject") true;
					} else {
						setAttr ($worldMesh + ".intermediateObject") false;
					}
				}	
				$worldMesh = destinationNodeNameFromConnection( $pfxHair + ".worldFlowerMesh[0]" );
				if( $worldMesh != ""){
					if( $element == "start" || 
						$element == "rest" ){
						setAttr ($worldMesh + ".intermediateObject") true;
					} else {
						setAttr ($worldMesh + ".intermediateObject") false;
					}
				}
			}
		}
	} else {
		$hairCurves	 = getSelectedHairCurves();
	}

	int $numCurves = size( $hairCurves );
	int $foundRest = false;
	int $foundStart = false;
	int $foundCurrent = false;
	for( $i = 0; $i < size( $hairCurves ); $i++ ){
		string $hair = $hairCurves[$i];
		string $start = sourceNodeNameFromConnection ( $hair + ".startPosition" );
		string $rest  = sourceNodeNameFromConnection ( $hair + ".restPosition" );
		string $out   = destinationNodeNameFromConnection ( $hair + ".outCurve" );
		int $hasStart = size($start) > 0;
		int $hasRest = size($rest) > 0;
		int $hasOut = size($out) > 0;
		if( $hasOut && nodeType( $out ) != "nurbsCurve" ){
			string $hist[] = `listHistory -f true $out`;
			string $crvs[];
			if( size( $hist ) > 0 ){
				$crvs = `ls -type "nurbsCurve" $hist`;
			}
			if( size( $crvs ) > 0 ) {
				$out = $crvs[0];
			} else {
				$hasOut = false;
			}
		}
		if( !$hasStart ){
			int $method = getAttr( $hair + ".simulationMethod" );
			if( $method == 2 ){
				string $fmt = (uiRes("m_displayHairCurves.kNoStartCurve"));
				warning (`format -s $hair $fmt` );
			}
		}
		if( $element == "start" ){
			if( $hasStart ){
				setAttr ($start + ".intermediateObject") 0;
				$foundStart = true;
			}
			if( $hasRest ){
				setAttr ($rest + ".intermediateObject") 1;
			}
			if( $hasOut ){
				setAttr ($out + ".intermediateObject") 1;
			}
		} else if( $element == "rest" ){
			if( $hasStart ){
				setAttr ($start + ".intermediateObject") 1;
			}
			if( $hasRest ){
				setAttr ($rest + ".intermediateObject") 0;
				$foundRest = true;
			}
			if( $hasOut ){
				setAttr ($out + ".intermediateObject") 1;
			}
		} else if( $element == "current" ){
			if( $hasStart ){
				setAttr ($start + ".intermediateObject") 1;
			}
			if( $hasRest ){
				setAttr ($rest + ".intermediateObject") 1;
			}
			if( $hasOut ){
				$foundCurrent = true;
				setAttr ($out + ".intermediateObject") 0;
			}
		} else if( $element == "currentAndStart" ){
			if( $hasStart ){
				setAttr ($start + ".intermediateObject") 0;
				$foundStart = true;
			}
			if( $hasRest ){
				setAttr ($rest + ".intermediateObject") 1;
			}
			if( $hasOut ){
				setAttr ($out + ".intermediateObject") 0;
				$foundCurrent = true;
			}
		} else if( $element == "currentAndRest" ){
			if( $hasStart ){
				setAttr ($start + ".intermediateObject") 1;
			}
			if( $hasRest ){
				setAttr ($rest + ".intermediateObject") 0;
				$foundRest = true;
			}
			if( $hasOut ){
				setAttr ($out + ".intermediateObject") 0;
				$foundCurrent = true;
			}
		} else if( $element == "all" ){
			if( $hasStart ){
				setAttr ($start + ".intermediateObject") 0;
				$foundStart = true;
			}
			if( $hasRest ){
				setAttr ($rest + ".intermediateObject") 0;
				$foundRest = true;
			}
			if( $hasOut ){
				setAttr ($out + ".intermediateObject") 0;
				$foundCurrent = true;
			}
		} else {
			string $fmt = (uiRes("m_displayHairCurves.kUnknownElementWrn"));
			warning(`format -s $element $fmt`);
		}	
	}
	if( !$foundRest && ($element == "rest" || $element == "currentAndRest") ){
		warning ((uiRes("m_displayHairCurves.kNoRestCurves")));
	}
	if( !$foundStart && ($element == "start" || $element == "currentAndStart") ){
		warning ((uiRes("m_displayHairCurves.kNoStartCurves")));
	}
	if( !$foundCurrent && !$hasPfxHair && ($element == "current" || $element == "currentAndStart" || $element == "currentAndRest")){
		warning ((uiRes("m_displayHairCurves.kNoCurrentPosition")));
	}

	int $hairCurvesWerePicked = ($numCurves > 0 );
	return $hairCurvesWerePicked;
}
