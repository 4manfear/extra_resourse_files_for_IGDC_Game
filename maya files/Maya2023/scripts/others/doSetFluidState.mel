// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  20 Feb 2002
//
//  Description:
//      Create Fluids Playback + Render cache
//		
//
proc debugPrint( string $printThis )
{
	// print( " DEBUG: " + $printThis + "\n" );
}

proc saveActiveFluidICCaches( int $uiSettings[] )
{
	if( !`exists getActiveFluidShapes` ) {
		source "getFluidShape.mel";
	}

	string $fluidShapes[] = `getActiveFluidShapes`;	
	for( $fluid in $fluidShapes ) {
		saveFluidICCache( $fluid, $uiSettings );
	}
}

global proc string saveFluidICCache( string $object, int $uiSettings[] )
{
	debugPrint( "saveFluidICCache: $object=" + $object );

	string $prevSelection[] = `ls -sl`;

	string $dskC;
	int $createdCache = false;
	if(`connectionInfo -id ($object + ".diskCacheIC")` > 0 ) {
		debugPrint( "found existing IC cache" );
		string $src = `connectionInfo -sfd ($object + ".diskCacheIC")`;
		string $buffer[];
		tokenize($src, ".", $buffer);
		$dskC = $buffer[0];
		diskCache -empty $dskC;
	}
	else {
		debugPrint( "creating new IC cache" );
		$dskC = createAndAttachFluidDiskCache( $object, "mcfi" );
		$createdCache = true;
	}

	setAttr ($dskC + ".startTime") `getAttr ($object  + ".startTime")`;
	setAttr ($dskC + ".endTime") `getAttr ($object  + ".startTime")`;

	// The createNodes above have changed the selection.
	// Restore to what it was before.
	//
	if( $createdCache ) {
		select $prevSelection;
	}

	int $oldEnable = `getAttr globalCacheControl.writeEnable`;
	setAttr globalCacheControl.writeEnable 1;

	// Update the fluid's attrs with the requested optionVar settings
	// so the caching operation will store what we want...
	//
	string $addToInitialState = (uiRes("m_doSetFluidState.kAddtoInitialState"));
	applyFluidDiskCacheOptions( $uiSettings, "Set Initial State",
								 $addToInitialState);

	saveFluid $object;
	setAttr globalCacheControl.writeEnable $oldEnable;

	// If we're just hoooking up the node this time, then 
	// warn the user if his fluid Start Time isn't the
	// same as his Time Slider Start Time.  This could avoid
	// potential confusion later on, for instance, when users
	// have their playback min set on the time slider set to
	// 0.0 and then wonder why rewind doesn't display the
	// initial conditions for their fluid which has a start time
	// of 1.0.
	//
	float $fluidStart = `getAttr ( $object + ".startTime" )`;
	if( $createdCache 
	&&( $fluidStart != `playbackOptions -q -min` ) )
	{
		warning (uiRes("m_doSetFluidState.kFluidTimeWarning"));
		string $startFrameWarning = (uiRes("m_doSetFluidState.kStartFrameWarning"));
		warning(`format -s $fluidStart -s $object $startFrameWarning`);
	}

	return $dskC;
}

global proc doSetFluidState( int $version, string $args[] )
//
// Description:
//	
//	
{
	if(( $version < 1 ) || ( size( $args ) < 5 )) {
		error( (uiRes("m_doSetFluidState.kVersionWarning")) );
		return;
	}

	int $uiSettings[]       = { int( $args[0]),	// density
									 $args[1], 	// velocity
									 $args[2], 	// temperature
									 $args[3], 	// reaction
									 $args[4], 	// color
									 $args[5],  // texture coords
									 $args[6] };// falloff

	if( !`exists getActiveFluidShapes` ) {
		source "getFluidShape.mel";
	}

	// Make sure that we have a fluid selected
	// or warn the user and fail
	//
	string $fluidShapes[] = getActiveFluidShapes();
	if (size($fluidShapes) == 0)
	{
		warning (uiRes("m_doSetFluidState.kFluidSelectionWarn"));
		return;
	}

	// make sure that we know where the Fluids Cache goes
	//
	verifyWorkspaceFileRule( "diskCache", "data" );


	artFluidAttrICCacheSaved;
	saveActiveFluidICCaches( $uiSettings ); 

	// Not the most elegant way to update the
	// diskCache tab in the AttrEd, but it works
	// better than setting up an attrChanged scriptJob
	// on any of the diskCache attrs affected by the
	// Set Initial State call, since that would 
	// need to call updateCacheContents in AEdiskCacheTemplate.mel,
	// which calls fluidCacheInfo, which triggers an attrChanged
	// message, which calls... 
	//
	currentTime `currentTime -q`;
}
