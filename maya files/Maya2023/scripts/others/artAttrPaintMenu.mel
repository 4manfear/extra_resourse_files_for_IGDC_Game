// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//////////////////////////////////////////////////////////////////////////////
//	This file contains the MEL script to create the Paintable Attribute Menu
//////////////////////////////////////////////////////////////////////////////
global proc artAttrPaintMenu(
	string 	$parent
)
//
//	Description:
// 		Creates a menu that shows all the paintable attributes
// 
{
	if ( !(`popupMenu -exists $parent`) ) 
		return;

	// Get the name of the filter node.
	string $filterNode = "";

	string $tmp[];
	string $melArtAttrFilterLabel;
	if (`artAttrFilterLabel` == (uiRes("m_artAttrToolScript.kFilterAll"))) {
	    $melArtAttrFilterLabel = "Filter: all";
	} else {
		// I18N_TODO this value is localized though the logic
		// here implies that EN-only is expected.  Probably ok,
		// even if tokenize isn't MB-safe, as long as localized
		// string doesn't have a space embedded in a multibyte
		// character.
		//
	    $melArtAttrFilterLabel = `artAttrFilterLabel`;
	}
	 
	tokenize( $melArtAttrFilterLabel, " ", $tmp );
	if ( size($tmp) == 2 ) 
		if ( $tmp[1] != "all" )
			$filterNode = $tmp[1];
		
	// Get the list of all paintable attributes.
	string $artCommand = "artAttrCtx";

	string $cmd = "artAttrCtx -q -objattrArray " + `currentCtx`;
	string $paintAttr = `eval $cmd`;

	// Filter out the attributes which do not belong 
	// to the current filter selection.
	string $attributes[];
	if ( $filterNode != "" ) {
		tokenize( $paintAttr, " ", $attributes );

		// Recreate the paintAttr list taking into 
		// accout the filter node type. 
		$paintAttr = "";

		string $buffer[];
		int $size = size($attributes);
		int $i;
		for( $i = 0; $i < $size; $i++ ) {
			tokenize( $attributes[$i], ".", $buffer );	
			if ( $buffer[0] == $filterNode ) {
				$paintAttr = $paintAttr + " " + $attributes[$i];
			} 
		}
	} 

	//skip vertexColorRGB and vertexFaceColorRGB attrs as they cannot be painted
	// with Attribute paint tool till we support color painting.
	tokenize( $paintAttr, " ", $attributes );

	// Recreate the paintAttr list by removing vertex* attrs if they are present
	$paintAttr = "";

	string $buffer[];
	int $size = size($attributes);
	int $i;
	for( $i = 0; $i < $size; $i++ ) {
		tokenize( $attributes[$i], ".", $buffer );	
		if ( $buffer[2] != "vertexColorRGB" && $buffer[2] != "vertexFaceColorRGB" ) {
			$paintAttr = $paintAttr + " " + $attributes[$i];
		} 
	}

	popupMenu -e -dai $parent;
	setParent -menu $parent;

	// Create menu items from the paintable attribute list.
	string $excludeNodes[];
	artAttrCreateMenuItems( $parent, $paintAttr, $excludeNodes );
}
