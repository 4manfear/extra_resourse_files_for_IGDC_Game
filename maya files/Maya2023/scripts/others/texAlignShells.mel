// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// ===========================================================================
//
//  Procedure Name:
//      texAlignShells
//
//  Description:
//      UV workflow function used for aligning UV shells to the minimum,
//      maximum or average U and/or V position of a given UV shell selection.
//      Also used by procedure texStackShells.
//
//  Input Arguments
//      action               - String   - The alignment action to perform.
//      shellList            - String[] - Empty list or a list of UV shells.
//      titleOverride        - String   - Progress bar title.
//
//  Return Value:
//      None.
//
//  Notes:
//  This script is part of the implementation of Nightshade UV Editor into
//  Autodesk Maya.
//
// ===========================================================================

global proc texAlignShells(string $action, string $shellList[], string $titleOverride)
{
	// Get original selection and retrieve the selected UV shells
	string $selection[] = `ls -selection`;
	string $compSelType = `getComponentMask`;

	string $selectedUVs[] = `filterExpand -selectionMask 35`;
	string $selectedFaces[] = `filterExpand -selectionMask 34`;
	if (size($selectedUVs) == 0 && size($selectedFaces) == 0)
	{
		// If Convert Selection is ON, try to convert the current selection to uvs.
		int $val = `optionVar -q polyAutoConvertAction`;
		if ( 1 == $val ) {
			PolySelectConvert 4;
			$selectedUVs = `filterExpand -ex false -sm 35`;
		}

		// Check if the set of uvs is still empty.
		if (size($selectedUVs) == 0) {
			error((uiRes("m_texAlignShells.kNoUVsSelected")));
			return;
		}
	}

	if (size($shellList) == 0)
		$shellList = texGetShells();

	polySelectBorderShell(0);
	float $uvBoxAll[] = `polyEvaluate -boundingBoxComponent2d`;

	// Calculate U and V centers
	float $centerU = 0.5 * ( $uvBoxAll[0] + $uvBoxAll[1] );
	float $centerV = 0.5 * ( $uvBoxAll[2] + $uvBoxAll[3] );
	
	float $pointA[], $pointB[];
	string $extremePoints[];
	if($action == "linear")
	{
		if (size($selectedUVs) == 0)
		{
			PolySelectConvert 4;
			$selectedUVs = `filterExpand -ex false -sm 35`;
		}
		string $selectedUVFlattened[] = `ls -flatten $selectedUVs`;
		if (`size($selectedUVFlattened)` <= 1) return; // Early exit

		$extremePoints = texGetFurthestPoints($selectedUVFlattened);
		if(`size($extremePoints)` != 2) return;
		
		string $p0[] = stringToStringArray($extremePoints[0], ":");
		$pointA[0] = (float)$p0[0];
		$pointA[1] = (float)$p0[1];
		string $p1[] = stringToStringArray($extremePoints[1], ":");
		$pointB[0] = (float)$p1[0];
		$pointB[1] = (float)$p1[1];
	}

	$shellsRemaining = size($shellList); // Shell counters
	$shellsTotal = $shellsRemaining;

	// Create progress bar
	if ($titleOverride == "")
		$titleOverride = (uiRes("m_texAlignShells.kUvEditorAlignShellMsg"));
	global string $gMainProgressBar;
	progressBar -e
		-beginProgress
		-isInterruptable true
		-minValue 0
		-maxValue $shellsTotal
		-status $titleOverride
		$gMainProgressBar;

	// Start aligning
	for ($shell in $shellList)
	{
		// Break if  cancelled by user
		if (`progressBar -q -isCancelled $gMainProgressBar`)
		{
			warning((uiRes("m_texAlignShells.kUvEditorAlignShellInteruptMsg")));
			break;
		}

		// Edit the progress bar
		progressBar
			-edit
			-progress ($shellsTotal - $shellsRemaining)
			-status ((uiRes("m_texAlignShells.kUvEditorAlignShellMsg1")) + 
				$shellsRemaining + 
				(uiRes("m_texAlignShells.kUvEditorAlignShellMsg2")))
			$gMainProgressBar;

		// Select the shell and calculate new bounds
		eval("select " + $shell);
		float $uvBox[] = `polyEvaluate -boundingBoxComponent2d`;

		// Move the shell
		float $offset;
		switch($action){
		case "uMax":
		case "maxU":
			$offset = $uvBoxAll[1] - $uvBox[1];
			polyEditUV -relative true -uValue $offset;
			break;

		case "uMin":
		case "minU":
			$offset = $uvBoxAll[0] - $uvBox[0];
			polyEditUV -relative true -uValue $offset;
			break;

		case "uAvg":
		case "avgU":
			$offset = $centerU - ( 0.5 * ($uvBox[0] + $uvBox[1]) );
			polyEditUV -relative true -uValue $offset;
			break;

		case "vMax":
		case "maxV":
			$offset = $uvBoxAll[3] - $uvBox[3];
			polyEditUV -relative true -vValue $offset;
			break;

		case "vMin":
		case "minV":
			$offset = $uvBoxAll[2] - $uvBox[2];
			polyEditUV -relative true -vValue $offset;
			break;

		case "vAvg":
		case "avgV":
			$offset = $centerV - ( 0.5 * ($uvBox[2] + $uvBox[3]) );
			polyEditUV -relative true -vValue $offset;
			break;

		case "center":
		case "singularity":
			float $offsetU = $centerU - ( 0.5 * ($uvBox[0] + $uvBox[1]) );
			float $offsetV = $centerV - ( 0.5 * ($uvBox[2] + $uvBox[3]) );
			polyEditUV
				-relative true
				-uValue $offsetU
				-vValue $offsetV
			;
			break;
		
		case "linear":
			float $arctangent = texCalculateAngle($extremePoints[0], $extremePoints[1]);
			float $bork = int( texRoundOff($arctangent, 4) );
			float $angleValue = $bork;
			float $shellCenterU = 0.5 * ($uvBox[0] + $uvBox[1]);
			float $shellCenterV = 0.5 * ($uvBox[2] + $uvBox[3]);
			int $invertVal = 0;
			if (($angleValue == 0.0000) || ($angleValue == 90.0000) || ($angleValue == -90.0000)){
				// Type 0 - No rotation
				$angleValue = 0;

			} else if (($angleValue >= 45.0001) && ($angleValue <= 89.9999)){
				// Type B - Subtract angle from 90 and invert
				$angleValue = 90 - $angleValue;
				$invertVal = 1;

			} else if (($angleValue <= -45.0001) && ($angleValue >= -89.9999)){
				// Type C - Add 90 degrees to angle
				$angleValue = 90 + $angleValue;
				$invertVal = 0;

			}

			if ($invertVal == 1){
				$angleValue = -$angleValue;
			}
			polyEditUV -angle $angleValue -pivotU $shellCenterU -pivotV $shellCenterV -relative true;

			float $t = (($shellCenterU - $pointA[0]) * ($pointB[0] - $pointA[0]) + ($shellCenterV - $pointA[1]) * ($pointB[1] - $pointA[1])) / 
					   (($pointB[0] - $pointA[0]) * ($pointB[0] - $pointA[0]) + ($pointB[1] - $pointA[1]) * ($pointB[1] - $pointA[1]));
			float $offU = $t * ($pointB[0] - $pointA[0]) + $pointA[0] - $shellCenterU;
			float $offV = $t * ($pointB[1] - $pointA[1]) + $pointA[1] - $shellCenterV;
			polyEditUV -relative true -uValue $offU - vValue $offV;
			break;
		}

		// Decrease the shells remaining -counter
		$shellsRemaining -= 1;
	}

	// Close the progress bar
	progressBar -e -endProgress $gMainProgressBar;

	//restore the original component mask	
	setComponentMask($compSelType); 

	//select the original selection
	select -replace $selection;
}
