// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
// Creation Date:  Oct 15, 2004
//
//  Procedure Name:
//      proxyTags
//
//  Description:
//      Returns the proxy tags currently in use.
//

global proc string[] proxyUsedTags( string $refNode )
//
//	Description:
//		Returns the proxy tags in use in the proxy set to which refNode
//	belongs. If refNode is null, gAddProxyNode is used instead for refNode.
//
{
	if( !`exists isValidReference` ){
		source "proxyUtils.mel";
	}
	if( !isValidReference( $refNode ) ){
		global string $gAddProxyNode;
		if( !`isValidReference($gAddProxyNode)` ){
			// Clear gAddProxyNode, since it's not pointing to a valid
			// reference. This could happen if file -f -new is done at just the
			// wrong time.
			//
			$gAddProxyNode = "";
		}
		$refNode = $gAddProxyNode;
	}
	string $usedTags[];
	int $usedSize = 0;
	if( isValidReference( $refNode ) ){
		// Exclude the tag of the reference node
		//
		string $tag = `getAttr ($refNode + ".proxyTag")`;
		if( $tag == "" ){
			// An empty string gets replaced by the word "original" when we
			// turn the reference into a proxy.  This also happens in
			// proxyAdd.mel, so if you change it here, change it there too!
			// TODO Replace by a global constant of some sort so we don't
			// have to do worry about it.
			//
			$tag = (uiRes("m_proxyTags.kOriginal"));
		}
		$usedTags[$usedSize] = $tag;
		$usedSize++;

		// Find the proxy manager, and exclude tags from all other proxies.
		//
		string $proxyManagerPlug = `connectionInfo -sfd ($refNode + ".proxyMsg")`;
		if( $proxyManagerPlug != "" ){
			string $usedPM = `plugNode $proxyManagerPlug`;
			string $nodeType = `objectType $usedPM`;
			if( $nodeType == "proxyManager" ){
				// Go through all tags, and add them to the used list.
				//
				string $refNodes[] = `listConnections -type reference ($usedPM + ".proxyList")`;
				int $refSize = size($refNodes);
				int $refIndex = 0;
				
				while( $refIndex < $refSize ){
					$tag = `getAttr ($refNodes[$refIndex] + ".proxyTag")`;
					$usedTags[$usedSize] = $tag;
					$usedSize++;
					$refIndex++;
				}
			}
		}
	}
	if( $usedSize > 0 ){
		// Remove duplicates and sort
		//
		string $uniqTags[] = stringArrayRemoveDuplicates( $usedTags );
		$usedTags = sort( $uniqTags );
	}
	return( $usedTags );
}

global proc string[] proxyTags( int $excludeUsedTags )
//
//	Description:
//		Returns the proxy tags in use in the scene. If exludeUseTags is set to
//	true, tags that are already used in the proxy set to which gAddProxyNode
//	belongs are excluded, since we want tags to be unique.
//
{
	string $globalTags[];
	int $globalSize = 0;
	
	string $excludedTags[] = proxyUsedTags( "" );

	// Get all the proxy managers, and find the tags
	//
	string $proxyManagers[] = `ls -type proxyManager`;
	int $pmSize = size($proxyManagers);
	int $pmIndex = 0;
	while( $pmIndex < $pmSize ){
		string $pm = $proxyManagers[$pmIndex];
		// Go through each of the tags, and add it to the global list.
		//
		string $refNodes[] = `listConnections -type reference ($pm + ".proxyList")`;
		int $refSize = size($refNodes);
		int $refIndex = 0;
		
		while( $refIndex < $refSize ){
			string $tag = `getAttr ($refNodes[$refIndex] + ".proxyTag")`;
			if( !stringArrayContains( $tag, $excludedTags ) ){
				$globalTags[$globalSize] = $tag;
				$globalSize++;
			}
			$refIndex++;
		}
		$pmIndex++;
	}
	// Now make the list unique.
	//
	string $uniqTags[] = stringArrayRemoveDuplicates( $globalTags );
	$globalTags = sort( $uniqTags );
	return( $globalTags );
}
