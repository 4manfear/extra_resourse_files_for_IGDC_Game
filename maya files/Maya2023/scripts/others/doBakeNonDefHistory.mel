// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  April, 2006
//
//	Procedure Name:
//		doBakeNonDefHistory
//
//	Description:
//		Delete non-deformer history.
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//	Version 1
//		$args[0] : action: 	"pre" = preDeformers
//							"prePost" = prePostDeformers
//
//	Return Value:
//		None
//

proc string[] cachePointCountDifference(string $cacheFiles[], string $geom)
{
	string $result[];
	int $pointCount = 0;
	if (nodeType($geom) == "mesh") {
		int $pc[] = `polyEvaluate -vertex $geom`;
		$pointCount = $pc[0];
	} else if (nodeType($geom) == "nurbsSurface") {
		string $sel[] = `ls -sl`;
		select -r ($geom+".cv[*][*]");
		string $allPts[] = `ls -sl -flatten`;
		$pointCount = size($allPts);
		select -r $sel;
	}
	if ($pointCount > 0) {
		for ($cache in $cacheFiles) {
			int $cacheCount[] = `cacheFile -channelName $geom -q -pc $cache`;
			if (size($cacheCount) > 0) {
				if ($cacheCount[0] != $pointCount) {
					$result[size($result)] = $cache;
				}
			}
		}
	}
	return $result;
}

global proc doBakeNonDefHistory( string $version, string $args[] )
{
    string $currentSelection[] = `ls -selection`;
	string $mode = $args[0];

	if ($mode == "prePost") {
		string $topChangeGeoms[];
		string $topChangeCaches[];
		int $count = 0;

		for ($sel in $currentSelection) {
			string $geoms[] = getGeometriesToCache();
			for ($geom in $geoms) {
				string $cfs[] = findExistingCaches($geom);
				if (size($cfs) > 0) {
					string $diffs[] = cachePointCountDifference($cfs,$geom);
					if (size($diffs) > 0) {
						$topChangeGeoms[$count] = $geom;
						$topChangeCaches = stringArrayCatenate($topChangeCaches,$diffs);
						$count++;
					}
				}
			}
		}

		if ($count > 0) {
			string $geomsWithChange = (uiRes("m_doBakeNonDefHistory.kInvalidateDiskCache"));
			$geomsWithChange += "\n      ";
			for ($ii = 0; $ii < $count; $ii++) {
				$geomsWithChange += $topChangeGeoms[$ii];
				if ($ii != $count-1) {
					$geomsWithChange += ", ";
				}
			}
			string $aheadOnly = (uiRes("m_doBakeNonDefHistory.kPreOnly"));
			$geomsWithChange += ("\n"+$aheadOnly);
			string $preOnly = (uiRes("m_doBakeNonDefHistory.kDeletePre"));
			string $all = (uiRes("m_doBakeNonDefHistory.kDeleteAll"));
			string $cancel = (uiRes("m_doBakeNonDefHistory.kCancel"));
			string $confirm = `confirmDialog
				-title (uiRes("m_doBakeNonDefHistory.kWarningCache"))
				-message $geomsWithChange -button $preOnly -button $all
				-button $cancel
				-defaultButton $preOnly
				-cancelButton $cancel`;
			if ($confirm == $cancel) {
				return;
			} else if ($confirm == $preOnly) {
				$mode = "pre";
			} else {
				delete $topChangeCaches;
			}
		}
	}

	string $cmd = "bakePartialHistory ";

	if( $mode == "pre" ) {
		$cmd += "-preDeformers";
	} else {
		$cmd += "-prePostDeformers";
	}

	if (`optionVar -exists bakeNonDefHistorySmooth`) {
		int $smooth = `optionVar -q bakeNonDefHistorySmooth`;
		$cmd += (" -postSmooth "+$smooth);
	}
	
	eval($cmd);
}
