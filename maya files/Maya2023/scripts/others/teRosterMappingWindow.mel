// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
// Creation Date:  Apr, 2015
//
//
//  Procedure Name:
//      teRosterMappingWindow
//
//  Description:
//      Create a roster animation mapping window
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

global string $gRMLoadedAnimSource;
global string $gRMContinueCmd;
global string $gRMInitialMappedAttributes[];
global string $gRMNamespace = "";

proc string[] getSelectedAnimSources()
{
	return `ls -sl -type timeEditorAnimSource`;
}

// From a full attribute path, extract path to the node only
proc string getNodePath(string $attrPath)
{
	string $s[];
	int $num = tokenize($attrPath, ".", $s);
	string $result;
	int $i;
	
	for ($i = 0; $i < $num-1; $i++)
		$result += $s[$i] + ($i == $num-2 ? "" : ".");
	return $result;
}

// From a full attribute path, extract only the attribute
proc string getAttribute(string $attrPath)
{
	return `match "[^\.]+$" $attrPath`;
}

proc int[] getSelectedClips()
{
	return `timeEditor -selectedClips ""`;
}

proc int RMsetAnimSource(string $animSource)
{
	global string $gRMLoadedAnimSource;	

	$gRMLoadedAnimSource = $animSource;
	return 1;
}

proc int RMsetClip(int $clipId)
{
	global int $gRMLoadedClip;
	
	$gRMLoadedClip = $clipId;
	return 1;
}

proc string[] filterNodesOnly(string $attributes[])
{
	// convert list of attributes into a list of objects
	string $nodes[];
	string $a;
	int $count = 0;
	for ($a in $attributes) 
		$nodes[$count++] = getNodePath($a);
		
	return stringArrayRemoveDuplicates($nodes);
}

proc string[] RMgetClipMembers(int $clipId)
{
	string $attrs[] = `timeEditorClip -q -remappedTargetAttrs $clipId`;
	string $retVal[];
	int $count = 0;
	for ($i = 0; $i < size($attrs); $i += 2)
	{
		$retVal[$count++] = $attrs[$i + 1];
	}
	return $retVal;
}


proc string[] RMgetAnimSourceMembers(string $node)
{
	return `timeEditorAnimSource -q -targets $node`;
}


global proc int teRMLoadSource(string $side)
//
// Description: Load the character into the specified side of the window.
// Return: true/false = success/failure
//
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
	global string $gRMNamespace;
	string $list;
	string $character;
	
	int $nodesOnly = `optionVar -q RMnodesOnly`;

	// unmapped items
	//	
	if ($side == "left") {
		$character = $gRMLoadedAnimSource;
		$list = "cteUnmappedLeft";
		textFieldGrp -e -text $gRMLoadedAnimSource cteRMfromText; 
	} else {
		$character = `timeEditorClip -q -name $gRMLoadedClip`;
		
		$list = "cteUnmappedRight";
		string $clipName = `timeEditorClip -q -name $gRMLoadedClip`;
		textFieldGrp -e -text $clipName cteRMtoText;
	}

	if (size($character) == 0) {
		return 1;
	}
	
	// mapped items
	//
	string $mems[];
	if ($side == "left")
	{
		$mems = RMgetAnimSourceMembers($character);
	}
	else if ($side == "right")
	{
		$mems = RMgetClipMembers($gRMLoadedClip);
	}	


	if ($nodesOnly)
	{
		$mems = filterNodesOnly($mems);
	}


	// Add namespace transforms to the right list 
	// In addition to the nodes that were already there because of matching node names

	if ($nodesOnly && $side == "right" && $gRMNamespace != "" )
	{

		// if( size($incoming ) == 1 )
		{
			string $nodes[] = `namespaceInfo -listOnlyDependencyNodes $gRMNamespace -recurse`;

			for( $node in $nodes )
			{
				// Currently only transforms are added this way in order to reduce risk of incompatibility
				// between matched attributes
				if( size(`ls -type transform $node`) == 1 )
				{
					if( !stringArrayContains($node,$mems) )
					{
						$mems[size($mems)] = $node;
					}
				}
			}
		}
	}

	string $sorted[];
	$sorted = sort($mems);;
	
	for ($sortedItem in $sorted) {
		textScrollList -e -a $sortedItem $list;
	}
	
	return 1;
}

proc string getMapLabel(string $source, string $target)
{
	string $testObj = $source;
	if (size($source) == 0) {
		$source = "         ";
		$testObj = $target;
	}
	if (size($target) == 0) {
		$target = "         ";
	}
	string $assoc = ($source + " -----> " + $target);
	string $label = $assoc;

	return $label;
}

proc string[] parseObjString(string $item)
//
// String will be of form:  source -----> target
//	
{
	string $result[2];
	$result[0] = "";
	$result[1] = "";	
	string $buffer[];
	tokenize($item," ",$buffer);
	int $sizeBuf = size($buffer);

	$result[0] = $buffer[0];
	$result[1] = $buffer[2];

	return $result;
}


// Find all attributes that currently have mapping
proc string[] getMappedAttributes()
{
	global int $gRMLoadedClip;

	string $result[];
	int $count = 0;
	int $i;

	string $sources[] = `timeEditorClip -q -remappedSourceAttrs $gRMLoadedClip`;	// source
	string $targets[] = `timeEditorClip -q -remappedTargetAttrs $gRMLoadedClip`;	// target
	for ($i = 0; $i < size($sources); $i += 2)
	{
		string $target = $targets[$i + 1];
		string $source = $sources[$i + 1];
		if ($source == "") continue;
		$result[$count++] = $target;
		$result[$count++] = $source;
	}
	return $result;
}

proc updateMappedList()
//
// Update the "Mapped" list with the mapped attributes between the two characters.
// Or if the characters are not specified, simply clear the "Mapped" list.
//
{
	int $doMap = 0;
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;

	// clear the mapping
	//
	textScrollList -e -removeAll cteMappedObjects;	
	
	if (size($gRMLoadedAnimSource) && `timeEditorClip -q -exists $gRMLoadedClip` &&
		nodeType($gRMLoadedAnimSource) == "timeEditorAnimSource")
	{
		$doMap = 1;		
	}

	if ($doMap)
	{
		// get all mapped attributes first			
		int $itemCount = 0;
		int $nodesOnly = `optionVar -q RMnodesOnly`;
		string $newItems[];
		string $sources[] = `timeEditorClip -q -remappedSourceAttrs $gRMLoadedClip`;	// source
		string $targets[] = `timeEditorClip -q -remappedTargetAttrs $gRMLoadedClip`;	// target

		int $iter;
		for ($iter = 0; $iter < size($targets); $iter += 2)
		{
			int $i = $targets[$iter];
			string $plug = $targets[$iter + 1];
			string $source = $sources[$iter + 1];
			
			// if nothing mapped, skip
			if ($source == "") continue;
			
			// add mapped item to the list
			$newItems[$itemCount++] = getMapLabel($source, $plug);
			
			// remove map items from left and right unmapped lists			
			if (stringArrayFind($plug, 0, `textScrollList -q -allItems cteUnmappedRight`) != -1)		// check if the given source exists
				textScrollList -e -ri $plug cteUnmappedRight;
			
			if (stringArrayFind($source, 0, `textScrollList -q -allItems cteUnmappedLeft`) != -1)		// check if the given source exists
				textScrollList -e -ri $source cteUnmappedLeft;
		}	
	

		string $sorted[];
		$sorted = sort($newItems);
				
		for ($sortedItem in $sorted) {
			textScrollList -e -a $sortedItem cteMappedObjects;
		}
	}
}

global proc teRMmapCharLoad(string $side)
//
// Description: Callback called when the "Load Source" or "Load Target" button is pushed
//              to load characters based on the selection.	
//
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;

	if ($side == "left")
	{
		string $sources[] = getSelectedAnimSources();
		if (size($sources) == 0) 
		{
			error (uiRes("m_teRosterMappingWindow.kAnimSourceSelectionError"));
			return;
		}
		
		RMsetAnimSource($sources[0]);
		teRefreshRosterMappingWindow(1);
	}
	else if ($side == "right")
	{
		int $clips[] = getSelectedClips();
		if (size($clips) == 0) 
		{
			error (uiRes("m_teRosterMappingWindow.kRosterSelectionError"));
			return;
		}

		RMsetClip($clips[0]);
		teRefreshRosterMappingWindow(1);
	}
}

global proc teRMmapCharLoadText(string $side)
//
// Description: Callback called when the user types in the character name text box.
//
{
	string $textField;
	if ($side == "left") {
		$textField = "cteRMfromText";
	} else {
		$textField = "cteRMtoText";		
	}

	string $val = `textFieldGrp -q -text $textField`;
	
	if ($side == "left")
	{
		string $isAnimSource[] = `ls -type timeEditorAnimSource $val`;
		if (size($isAnimSource))
		{
			if (!RMsetAnimSource($val))
				textField -e -text "" $textField;
		}
		else
		{
			textFieldGrp -e -removeAll cteUnmappedLeft;
			string $errMsg = (uiRes("m_teRosterMappingWindow.kAnimSourceError")); 	
			string $errString =  `format -s $val $errMsg`;
			error($errString);
		}
	}
	else if ($side == "right")
	{
		string $isClip[] = `ls -type timeEditorClipBase $val`;
		int $clipId = 0;
		if (size($isClip))
		{
			$clipId = `timeEditorClip -q -clipIdFromNodeName $val`;
			if ($clipId != 0)
			{
				if (!RMsetClip($clipId))
					textField -e -text "" $textField;
			}
		}
		
		if ($clipId == 0)
		{
			textFieldGrp -e -removeAll cteUnmappedRight;
			string $errMsg = (uiRes("m_teRosterMappingWindow.kClipError")); 	
			string $errString =  `format -s $val $errMsg`;
			error($errString);
		}
	}	
	
	teRefreshRosterMappingWindow(1);
}

global proc teRMupdateMapButton()
//
// Description: Callback to enable/disable the map button based on the selection.
//
{
	string $right[] = `textScrollList -q -si cteUnmappedRight`;
	string $left[]  = `textScrollList -q -si cteUnmappedLeft`;

	int $enable = 0;
	if (size($right) > 0 && size($left) > 0) {
		$enable = 1;
		button -e -label (uiRes("m_teRosterMappingWindow.kMapOption"))  RMmapCharButton;
	}

	if (size($right) || size($left)) {
		textScrollList -e -da cteMappedObjects;
	}

	button -e -enable $enable RMmapCharButton;
}

global proc teRMupdateUnmapButton()
//
// Description: Callback to enable/disable the unmap button based on the selection.
//
{
	string $mapped[] = `textScrollList -q -si cteMappedObjects`;
	int $enable = (size($mapped) > 0);
	string $label = (uiRes("m_teRosterMappingWindow.kUpdateUnmap"));
	button -e -enable $enable RMmapCharButton;
	if ($enable) {
		button -e -label $label RMmapCharButton;
		textScrollList -e -da cteUnmappedRight;
		textScrollList -e -da cteUnmappedLeft;
		
		for ($mapItem in $mapped) {
			string $unmapObjs[] = parseObjString($mapItem);
			string $leftObj = $unmapObjs[0];
			string $rightObj = $unmapObjs[1];
		}
	}
}

proc unmapCharItem(string $item)
//
// Description: Callback for when the user pushes the "Unmap" button.
//
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
	
	string $unmapObjs[] = parseObjString($item);
	string $leftObj = $unmapObjs[0];
	string $rightObj = $unmapObjs[1];	
	
	int $doCharacterMap = ((nodeType($gRMLoadedAnimSource) == "timeEditorAnimSource") &&
						   $gRMLoadedClip != 0);
	if ($doCharacterMap) 
	{

		string $mapCmd = "timeEditorClip -e -remapSource "+$rightObj+" \"\" -clipId "+$gRMLoadedClip;
		evalEcho $mapCmd;
	}
	
	int $nodeView = `optionVar -q RMnodesOnly`;	
	
	// if showing only nodes, add just the node path (if doesn't exist yet)		
	if ($nodeView)			
		$rightObj = getNodePath($rightObj);	

	if (!stringArrayContains($rightObj, `textScrollList -q -allItems cteUnmappedRight`))
		textScrollList -e -a $rightObj cteUnmappedRight;

	// only add to the anim source list if the source really exists
	if (`timeEditorAnimSource -q -targetIndex $gRMLoadedAnimSource $leftObj` != -1)
	{
		if ($nodeView)			
			$leftObj = getNodePath($leftObj);
		
		if (!stringArrayContains($leftObj, `textScrollList -q -allItems cteUnmappedLeft`))
			textScrollList -e -a $leftObj cteUnmappedLeft;		
	}
	
	textScrollList -e -ri $item cteMappedObjects;
}

global proc teRMunmapAllSourceItems()
{
	global string $gRMLoadedAnimSource;

	string $mapped[]  = `textScrollList -q -allItems cteMappedObjects`;
	for ($mapItem in $mapped) {
		unmapCharItem($mapItem);
	}
}

global proc teRMmapSourceCallback()
//
// Description: Callback for when the user pushes the "Map" button.
//
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
	
	string $right[] = `textScrollList -q -si cteUnmappedRight`;
	string $left[]  = `textScrollList -q -si cteUnmappedLeft`;
	string $mapped[]  = `textScrollList -q -si cteMappedObjects`;

	if (size($mapped)) {
		for ($map in $mapped) {
			unmapCharItem($map);
		}
	} else {
		int $doCharacterMap = ((nodeType($gRMLoadedAnimSource) == "timeEditorAnimSource") &&
							   $gRMLoadedClip != 0);

		if ($doCharacterMap) 
		{
			int $nodeView = `optionVar -q RMnodesOnly`;	
						
			if ($nodeView)
			{
				string $object = $right[0];
				string $source = $left[0];
			
				// map all attributes from this clip for the selected object
				string $attributes[] = RMgetClipMembers($gRMLoadedClip);				
				string $sources[] = RMgetAnimSourceMembers($gRMLoadedAnimSource);
				
				// filter attributes to those of the current selected object, and sources
				// to those of a selected source object
				int $count = 0;
				string $s;
				string $filteredAttributes[];
				string $filteredSources[];
								
				for ($s in $attributes)
					if (getNodePath($s) == $object)
						$filteredAttributes[$count++] = $s;
				
				$count = 0;
				for ($s in $sources)
					if (getNodePath($s) == $source)
						$filteredSources[$count++] = $s;				
				
				// for every attribute, try to map to a matching source (if exists)
				for ($s in $filteredSources)
				{
					string $matchingDst = $object + "." + getAttribute($s);
					string $addCmd = "timeEditorClip -e -addAttribute "+ $matchingDst + " -clipId "+$gRMLoadedClip;
					evalEcho $addCmd;

					string $mapCmd = "timeEditorClip -e -remapSource "+ $matchingDst +" "+ $s + " -clipId "+$gRMLoadedClip;
					evalEcho $mapCmd;
				}
			}
			else
			{
				// just map this single clip attribute
				string $mapCmd = "timeEditorClip -e -remapSource "+$right[0]+" "+$left[0]+" -clipId "+$gRMLoadedClip;
				evalEcho $mapCmd;
			}			
		}
		
		teRefreshRosterMappingWindow 1;
	}
	button -e -enable false RMmapCharButton;
}

global proc teRMupdateMenuCheckBoxes()
{	
	int $nodeView = `optionVar -q RMnodesOnly`;	
	menuItem -e -cb $nodeView RMnodeViewItem;
}

global proc teRMupdateViewPrefs(int $nodeView, int $force)
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
	
	int $nodesOnly = `optionVar -q RMnodesOnly`;
	if ($force || ($nodeView != $nodesOnly)) 
	{
		optionVar -iv RMnodesOnly $nodeView;
		
		string $char1 = $gRMLoadedAnimSource;
		int $clipId = $gRMLoadedClip;
		teRMclearMapWindow(); 

		if (size($char1) > 0) RMsetAnimSource($char1);
		if ($clipId != 0) RMsetClip($clipId);
		teRMLoadSource("left");
		teRMLoadSource("right");
		updateMappedList();
	}

	teRMupdateMenuCheckBoxes();
}

global proc teRMupdateWindowMode()
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;

	if (`objExists $gRMLoadedAnimSource` && nodeType($gRMLoadedAnimSource) != "timeEditorAnimSource") {
		$gRMLoadedAnimSource = "";
	}
	if (!`timeEditorClip -q -exists $gRMLoadedClip`) {
		$gRMLoadedClip = 0;
	}
	
	teRMupdateViewPrefs(`optionVar -q RMnodesOnly`, 1);

	window -e -title (uiRes("m_teRosterMappingWindow.kRosterMapper"))  cteRosterMappingWnd;		
}

global proc teRMupdateNodeViewPrefs(int $nodeView)
//
// Description: Update the windows if a node view pref has changed.
//
{
	teRMupdateViewPrefs($nodeView, 0);
}

proc RMinitPrefs()
{
	optionVar -init false -category "Time Editor" -iv RMnodesOnly 1;
}

global proc teBuildMapCharacterContextHelpItems(string $nameRoot, string $menuParent)
{
	menuItem -label (uiRes("m_teRosterMappingWindow.kHelpRosterMapper")) 
		-enableCommandRepeat false
		-command "showHelp TimeEditorRosterMapper ";
}

proc string removeNamespace(string $path)
{
	string $s[];
	int $num = tokenize($path, ":", $s);
	return $s[$num - 1];		// return last token
}

// check if any entry in the mapped list ends with "----> $target" (meaning that target has been mapped to)
proc int existsInMappedList(string $mapped[], string $target)
{
	for ($m in $mapped)
	{
		if (endsWith($m, " "+$target)) return 1;		// "123 -----> abc" ends with " abc"
	}
	return 0;
}

// automatically map all attributes with matching paths
// ignore namespaces
global proc teRMmapByName()
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
	
	undoInfo -openChunk;
	
	string $mapped[]  = `textScrollList -q -allItems cteMappedObjects`;
	string $sources[] = RMgetAnimSourceMembers($gRMLoadedAnimSource);
	string $targets[] = RMgetClipMembers($gRMLoadedClip);
	
	// strip namespaces from all sources for quick comparison
	int $index = 0;
	string $sourcesWithoutNamespaces[];
	for ($source in $sources) 
		$sourcesWithoutNamespaces[$index++] = removeNamespace($source);	
		
	for ($target in $targets)
	{		
		// does source with same path exist (ignoring namespace)?
		$index = stringArrayFind(removeNamespace($target), 0, $sourcesWithoutNamespaces);
		if ($index == -1) continue;
		
		// is item already mapped?
		if (existsInMappedList($mapped, $target)) continue;		
		
		// not yet mapped, map now
		string $source = $sources[$index];

		string $cmd = "timeEditorClip -e -remapSource \"" + $target + "\" \"" + $source+ "\" -clipId "+$gRMLoadedClip;
		evalEcho $cmd;
	}
	
	undoInfo -closeChunk;
	teRefreshRosterMappingWindow 1;
}


// When "Continue" button is clicked. Closes the window and executes the previously set command
global proc teRMcontinue()
{
	global string $gRMContinueCmd;
	global string $gRMInitialMappedAttributes[];
	global int $gRMLoadedClip;	
    
    // Remember the old anim source
    int $clipId = $gRMLoadedClip;
    string $oldAnimSource;
	if (`timeEditorClip -q -exists $clipId`)
	{
        $oldAnimSource = `timeEditorClip -q -animSource $clipId`;
    }  
	
	// if specific command has been passed, execute it
	if (size($gRMContinueCmd))
	{
		evalEcho $gRMContinueCmd;
	}
	
	// update mapping of attributes that have changed	
	undoInfo -openChunk;

	string $mapped[]  = `textScrollList -q -allItems cteMappedObjects`;
	for ($item in $mapped) 
	{
		string $unmapObjs[] = parseObjString($item);
		string $source = $unmapObjs[0];												// anim source path
		string $attr = $unmapObjs[1];												// clip attribute path

		// see if this attribute has same mapping as initially
		int $index = stringArrayFind($attr, 0, $gRMInitialMappedAttributes);
		
		// if item was already mapped and is the same, remove from the initial array
		if ($index != -1 && $gRMInitialMappedAttributes[$index] == $source)
		{
			$gRMInitialMappedAttributes[$index-1] = $gRMInitialMappedAttributes[$index] = "";	// replace with empty string <mapped>
			continue;
		}			
		
		// if item was not initially mapped, or it was mapped to a different source, remap
		if ($index == -1 || $gRMInitialMappedAttributes[$index] != $source)
		{
			string $cmd = "timeEditorClip -e -remap \""+$attr+"\" \""+$source+"\" -clipId "+$gRMLoadedClip;
			evalEcho $cmd;
		}
	}
	
	// also, for all initially mapped attributes that have been unmapped, remap the back to initial values
	int $num = size($gRMInitialMappedAttributes);
	int $i;
	for ($i=0; $i<$num; $i+=2)
	{
		string $target = $gRMInitialMappedAttributes[$i];
		string $source = $gRMInitialMappedAttributes[$i+1];
		
		// if item was marked as <mapped>, skip
		if ($target == "") continue;
		
		// remap back to the default
		string $cmd = "timeEditorClip -e -remap "+$target+" \"\" -clipId "+$gRMLoadedClip;
		evalEcho $cmd;			
	}
	
	undoInfo -closeChunk;
	
	
	// adjust clip length (if enabled) 
	if (`checkBox -q -value cteAdjustClipLength` == 1)
	{
		if (`timeEditorClip -q -exists $clipId`)
		{
			string $animSource = `timeEditorClip -q -animSource $clipId`;
			string $clipNode = `timeEditorClip -q -clipNode $clipId`;
			if ($animSource != "" && $clipNode != "")
			{			
				float $ASduration = `getAttr ($animSource + ".initialClipDuration")`;
				string $cmd = 
					"setAttr "+$clipNode+".clip[0].curveStart 0;\n" +
					"setAttr "+$clipNode+".clip[0].clipDuration "+$ASduration+";\n";					
				evalEcho $cmd;
			}
		}		
	}
	
    // if this is remapping namespace process, delete the old anim source if exists
    global string $gRMNamespace;
	if ($gRMNamespace != "" )
	{
		if($oldAnimSource != "") delete $oldAnimSource;
		$gRMNamespace = "";  // Set to 0 so nothing is undone when closeCommand of window is executed
	}
	
	// destroy the dialog
	deleteUI cteRosterMappingWnd;
}	

global proc onTECancelRosterMappingWnd()
{
    // Remove the newly created clip and anim source for namespace remapping
    global string $gRMNamespace;
    if($gRMNamespace != "" )
    {
        undo;
		$gRMNamespace = "";
    }
}

proc createRosterMappingWindow()
//
//      Creates the roster map window, with
//      four textScrollLists. One pair of lists is for mapped
//      objects, and one is for unmapped.
//
//      If the window already exists, then the proc
//      simply shows the window, effectively popping it
//      to the top, if it's under other windows.
{
    global string $gRMNamespace = "";
	
	RMinitPrefs();
	
	string $title = (uiRes("m_teRosterMappingWindow.kRosterMapperTitle"));
	
	window -t $title
		-retain
		-iconName $title  -mb true
		-closeCommand onTECancelRosterMappingWnd 
		-s true -wh 500 775 cteRosterMappingWnd;

 	menu -label (uiRes("m_teRosterMappingWindow.kShow"))  -to true;
	
	int $nodeView = `optionVar -q RMnodesOnly`;
	menuItem -label (uiRes("m_teRosterMappingWindow.kDisplayNodeNames"))  -cb $nodeView
 		-c "teRMupdateNodeViewPrefs #1"
		RMnodeViewItem ;
 	
	menuItem -d true; 

 	setParent -m ..;

 	menu -label (uiRes("m_teRosterMappingWindow.kEdit")) 
		-to true;
 	menuItem -label (uiRes("m_teRosterMappingWindow.kUnmap")) 
 		-c "teRMmapSourceCallback";

 	menuItem -label (uiRes("m_teRosterMappingWindow.kUnmapAll")) 
 		-c "teRMunmapAllSourceItems"; 	

 	menuItem -label (uiRes("m_teRosterMappingWindow.kRefresh")) 
 		-c "teRefreshRosterMappingWindow 1";	
		
	menuItem -d true;
		
	menuItem -label (uiRes("m_teRosterMappingWindow.kMapByName")) 
 		-c "teRMmapByName"; 	

 	setParent -m ..;

	//	Adds support for the Context Sensitive Help Menu.
	//
	addContextHelpProc "cteRosterMappingWnd" "teBuildMapCharacterContextHelpItems";
	
	doHelpMenu "cteRosterMappingWnd" "cteRosterMappingWnd";

	setParent -m ..;

	formLayout cteRosterMapForm;	
	
	string $labelForm = `formLayout labelForm`;
    string $cteRMfromText = `textFieldGrp -p $labelForm -label (uiRes("m_teRosterMappingWindow.kFrom")) -cw2 50 230
		-annotation (uiRes("m_teRosterMappingWindow.kTypeNameFromAnnot")) 
		-enable 0
		-cc "teRMmapCharLoadText \"left\""  cteRMfromText`;
	string $cteRMtoText = `textFieldGrp -p $labelForm -label (uiRes("m_teRosterMappingWindow.kTo")) -cw2 45 230
		-annotation (uiRes("m_teRosterMappingWindow.kTypeNameToAnnot")) 
		-enable 0
		-cc "teRMmapCharLoadText \"right\"" cteRMtoText`;
	
	setParent ..;
	formLayout -e
		-af cteRMfromText left 2
		-af cteRMfromText top 2
		-af cteRMfromText bottom 5
		-ac cteRMfromText right 5 cteRMtoText
		
		-af cteRMtoText top 5
		-ap cteRMtoText left 1 50
		-af cteRMtoText right 2
		-af cteRMtoText bottom 5

		$labelForm;

	formLayout cteRMobjectsForm;
	
	frameLayout -label (uiRes("m_teRosterMappingWindow.kMapped")) 
		-bv false
		-cl false -cll false 
		-mh 5 -mw 10
		cteMappedLayout;
	
	formLayout mappedForm;
	textScrollList 
		-ams true
		-font "smallFixedWidthFont"
		-sc "teRMupdateUnmapButton"
		cteMappedObjects;
	setParent ..;

	formLayout -e
		-af cteMappedObjects top 0
		-af cteMappedObjects left 0
		-af cteMappedObjects right 0
		-af cteMappedObjects bottom 0
		mappedForm;
	
	setParent ..;

	// unmapped columns
    frameLayout -label (uiRes("m_teRosterMappingWindow.kUnmapped")) 
		-bv false
		-cl false -cll false 
		-mh 5 -mw 10
		cteUnmappedObjects;

	formLayout cteUnmappedForm;

	textScrollList 
		-ams false
		-sc "teRMupdateMapButton"
		cteUnmappedLeft;
	textScrollList 
		-sc "teRMupdateMapButton"
		-ams false
		cteUnmappedRight;
	setParent ..;

	formLayout -e
		-af cteUnmappedLeft top 0
		-af cteUnmappedLeft left 0
		-ap cteUnmappedLeft right 0 50
		-af cteUnmappedLeft bottom 0

		-af cteUnmappedRight top 0
		-ac cteUnmappedRight left 0 cteUnmappedLeft
		-af cteUnmappedRight right 0
		-af cteUnmappedRight bottom 0
		cteUnmappedForm;
	setParent ..;
	setParent ..;
	
	formLayout -e
		-af cteMappedLayout top 2
		-af cteMappedLayout left 2
		-af cteMappedLayout right 2
		-ap cteMappedLayout bottom 2 50

		-ac cteUnmappedObjects top 2 cteMappedLayout
		-af cteUnmappedObjects left 2
		-af cteUnmappedObjects right 2
		-af cteUnmappedObjects bottom 2
		cteRMobjectsForm;
		
		
	// options at the bottom
	formLayout RMoptionsLayout;
	
	checkBox 
		-label (uiRes("m_teRosterMappingWindow.kAdjustClipLength"))
		-annotation (uiRes("m_teRosterMappingWindow.kAdjustClipLengthAnnot")) 
		-value 1
		cteAdjustClipLength;
	setParent ..;
		
	formLayout -e
		-af cteAdjustClipLength top 2
		-af cteAdjustClipLength left 15
		-af cteAdjustClipLength bottom 2
		RMoptionsLayout;


	// buttons at the bottom
	formLayout cteRosterMapButtonForm;
	button -label (uiRes("m_teRosterMappingWindow.kMap")) 
		-enable false
		-annotation (uiRes("m_teRosterMappingWindow.kMapSelectedSourceAnnot")) 
		-c "teRMmapSourceCallback" RMmapCharButton;
	button -label (uiRes("m_teRosterMappingWindow.kClose")) 
		-c "onTECancelRosterMappingWnd; deleteUI cteRosterMappingWnd;" 
		cteCloseButton;
	button -label (uiRes("m_teRosterMappingWindow.kContinue")) 
		-c "teRMcontinue"
		cteContinueButton;
	setParent ..;
	
	formLayout -e
		-af RMmapCharButton left 2
		-af RMmapCharButton top 5
		-af RMmapCharButton bottom 5
		-ac RMmapCharButton right 2 cteCloseButton
		
		-af cteCloseButton top 5
		-af cteCloseButton bottom 5
		-ap cteCloseButton left 5 33
		-ac cteCloseButton right 2 cteContinueButton
		
		-af cteContinueButton top 5
		-af cteContinueButton right 2
		-ap cteContinueButton left 5 66
		-af cteContinueButton bottom 5
		
		cteRosterMapButtonForm;

	setParent ..;

	formLayout -e

		-af $labelForm top 5
		-af $labelForm left 5
		-af $labelForm right 5			

		-ac cteRMobjectsForm top 5 $labelForm
		-af cteRMobjectsForm left 5
		-af cteRMobjectsForm right 5	
		-ac cteRMobjectsForm bottom 5 RMoptionsLayout
		
		-af RMoptionsLayout left 5
		-af RMoptionsLayout right 5
		-ac RMoptionsLayout bottom 5 cteRosterMapButtonForm		

		-af cteRosterMapButtonForm left 5
		-af cteRosterMapButtonForm right 5		
		-af cteRosterMapButtonForm bottom 5			

		cteRosterMapForm;
}

global proc teRMclearMapWindow() 
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
    
	if( `window -exists cteRosterMappingWnd` ) 
	{
		textScrollList -e -removeAll cteMappedObjects;
		textScrollList -e -removeAll cteUnmappedLeft;
		textScrollList -e -removeAll cteUnmappedRight;
		textFieldGrp -e -text "" cteRMfromText;
		textFieldGrp -e -text "" cteRMtoText;		
	}
	$gRMLoadedAnimSource = "";
	$gRMLoadedClip = 0;
}

global proc teRefreshRosterMappingWindow(int $force) 
{
	if ($force || `window -q -vis cteRosterMappingWnd`) 
	{
		teRMupdateViewPrefs(`optionVar -q RMnodesOnly`, 1);
	}
}

global proc teRosterMappingWindow(string $animSource, int $clipId, string $continueCmd, string $remapNS)
{
	global string $gRMLoadedAnimSource;
	global int $gRMLoadedClip;
	global string $gRMContinueCmd;
    global string $gRMNamespace;
	global string $gRMInitialMappedAttributes[];
	
	// if window already exists, destroy it
	if( `window -exists cteRosterMappingWnd` ) 
	{
		deleteUI cteRosterMappingWnd;		
	} 
	
	// create new window
	createRosterMappingWindow();
	
	// command to be executed once the "Continue" button is clicked
	$gRMContinueCmd = $continueCmd;
    $gRMNamespace = $remapNS;
    
	scriptJob -protected
		-parent "cteRosterMappingWnd"
		-conditionTrue deleteAllCondition teRMclearMapWindow;

	scriptJob
		-parent "cteRosterMappingWnd"
		-event "Undo" "teRefreshRosterMappingWindow 0";
	scriptJob
		-parent "cteRosterMappingWnd"
		-event "Redo" "teRefreshRosterMappingWindow 0";
	

	showWindow cteRosterMappingWnd;	
	RMsetAnimSource($animSource);
	RMsetClip($clipId);
	teRefreshRosterMappingWindow(1);	
	
	// get initial mapped attributes
	$gRMInitialMappedAttributes = getMappedAttributes();
	
	// if replacing anim source, map attributes automatically
	if ($continueCmd != "") teRMmapByName();
}

global proc teAnimSourceRemapping(int $id)
//
//	Description:
//		Open Roster Remapping window for a specified clip
//
//	Input Argument:
//		Id of the clip.
//
//	Return:
//		None
//
{
	// get the first clip id in current selected
	int $clipId = teGetFirstClipInSelection($id, 1);
	if($clipId == -1)
		return;
	
	string $animSource = `timeEditorClip -q -animSource $clipId`;
	
	// open remapping window without post-command specified
	teRosterMappingWindow($animSource, $clipId, "", "");
}