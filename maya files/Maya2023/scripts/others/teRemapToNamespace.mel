// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
// Creation Date:  May, 2015
//
//
//  Procedure Name:
//      teRemapToNamespace
//
//  Description:
//      Remap and create clip for the namespace
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//

proc string removeNamespace(string $path) {
	string $s[];
	int $num = tokenize($path, ":", $s);
	return $s[$num - 1];		// return last token
}

// From a full attribute path, extract path to the node only
proc string getNodePath(string $attrPath) {
	string $s[];
	int $num = tokenize($attrPath, ".", $s);
	string $result;
	int $i;
	
	for ($i = 0; $i < $num-1; $i++)
		$result += $s[$i] + ($i == $num-2 ? "" : ".");
	return $result;
}

proc string[] filterNodesOnly(string $attributes[]) {
	// convert list of attributes into a list of objects
	string $nodes[];
	string $a;
	int $count = 0;
	for ($a in $attributes) 
		$nodes[$count++] = getNodePath($a);
		
	return stringArrayRemoveDuplicates($nodes);
}

// From a full attribute path, extract only the attribute
proc string getAttribute(string $attrPath)
{
	return `match "[^\.]+$" $attrPath`;
}

//  Description:
//		Remap and create clip for the namespace
//
//  Input Arguments:
//		$animSource - Remap from this animation source 
//   $targetNamspace - Remap to this specified namespace
//
//  Return Value:
//      None.
//
global proc teRemapToNamespace(string $animSource, string $targetNameSpace, int $startTime, int $duration, string $newClipName) {
	string $sources[] = `timeEditorAnimSource -q -targets $animSource`;    
	string $nodes[] = filterNodesOnly($sources);
    
    string $nodesWithoutNS[];    
    int $count = 0;
    for($node in $nodes)
        $nodesWithoutNS[$count++] = removeNamespace($node);  
        
    // Try to find the objects under the specified namespace which has same name to the source.
    // Collect the mappable attributes based on the anim source to populate.
	string $contents[] = `namespaceInfo -listOnlyDependencyNodes $targetNameSpace -recurse`;
    string $attributesToPopulate;
	if (`size $contents`){
		// For every namespace node
		for( $itemContent in $contents ) {
			string $nameWithoutNS = removeNamespace($itemContent);
			
			// If the namespace nodename match the name of ond of the nodes in th source
			if(stringArrayContains($nameWithoutNS, $nodesWithoutNS)) {
				string $itemAttributes;

				// Sub optimal code
				// Iterate on all the source attributes and add those that exist on the matching source node
	            for( $s in $sources) {
					string $attrNode = removeNamespace( getNodePath($s)); 
					if( $attrNode == $nameWithoutNS )
					{
						$itemAttributes += " -at " + $itemContent + "." + getAttribute($s);
					}
                }
				$attributesToPopulate += $itemAttributes;
			}								
		}
	}

	if( $attributesToPopulate == "" )
	{
		$attributesToPopulate = " -emptySource";
	}
	
    // Populate the target objects firstly
    string $currentComp			= `timeEditorComposition -q -active`;
    string $currentTracksNode	= `timeEditorComposition -q -tracksNode $currentComp`;
            
    string $trackNodeIndex		= "";
    int $currentTracksIndex  = -1;
    int $createNewTrack		= false;
    
    // Undo chunk for creating track and creating clip
    undoInfo -openChunk;
            
	if(!`exists teGetTrackForClipCreation`) source teTrackFunctions.mel;

	$trackNodeIndex = teGetTrackForClipCreation(1, 0);
	if($trackNodeIndex == "")
	{
		error((uiRes("m_teRemapToNamespace.kNoTrackCreated")) );
		return;
	}

    // Create the clip and animSource
    string $populateCmd = "timeEditorClip " + $attributesToPopulate + " -track \"" + $trackNodeIndex + "\" -startTime " + $startTime + " -duration "  + $duration + " \"" + $newClipName + "\"" +";";
            
    int $newClipId;
    int $error = catch($newClipId = `eval($populateCmd)`);
            
   	undoInfo -closeChunk;
            
    if ($error) undo;
            
    if(!`exists teRosterMappingWindow`) source teRosterMappingWindow.mel;
                    
    // Open remapping window to perform remapping 			
	string $cmd = "timeEditorClip -e -animSource " + $animSource + " -existingOnly -clipId " + $newClipId;         
    teRosterMappingWindow $animSource $newClipId $cmd $targetNameSpace;
}	

//  Description:
//		Remap the animation from an existing animation source to the given namespace
//
//  Input Arguments:
//   $nsName - Remap to this specified namespace
//
//  Return Value:
//      None.
//
global proc teRemapAnimSourceToNamespace(string $animSource, string $nsName) {
    int $startTime;
    int $duration;
    string $newClipName;
    
	if($animSource == "") {
        string $selClips[] = `ls -sl -o -type timeEditorClip`;
        if(size($selClips) == 0) {
            error (uiRes("m_teRemapToNamespace.kNoAnimSourceOrClipSelected"));
        } else {
            int $clipId = `getAttr($selClips[0] + ".clip[0].clipid")`;
            $animSource = `timeEditorClip -q -animSource $clipId`;
            // Remain the timing info from clip
            $duration = `getAttr($selClips[0] + ".clip[0].clipDuration")`;
            $startTime = `getAttr($selClips[0] + ".clip[0].clipStart")`;
            
             // The newly create clip contains the clip name and the target namespace name.
            $newClipName = $selClips[0] + "_" + removeNamespace($nsName);     
        }
	} else {
        // Respect the start and duration from anim source
        $duration = `getAttr($animSource + ".duration")`;
        $startTime = `getAttr($animSource + ".start")`;
        
        // The newly create clip should contain the source name and the target namespace name.
        $newClipName = $animSource + "_" + removeNamespace($nsName);           
    }
	
	teRemapToNamespace($animSource, $nsName, $startTime, $duration, $newClipName);
}

//  Description:
//		Remap the animation from an existing clip to a given namespace
//
//  Input Arguments:
//   $clipId - Existing clip Id
//   $nsName - Remap to this specified namespace
//
//  Return Value:
//      None.
//
global proc teRemapClipToNamespace(int $clipId, string $nsName) {
    string $animSource = `timeEditorClip -q -animSource $clipId`;
    if($animSource == "") return;
    
    // Remain the timing info from clip
    string $clipNode   = `timeEditorClip -q -clipNode -clipId $clipId`;
    int $duration = `getAttr($clipNode + ".clip[0].clipDuration")`;
    int $startTime = `getAttr($clipNode + ".clip[0].clipStart")`;
     // The newly create clip contains the clip name and the target namespace name.
    string $newClipName = $clipNode + "_" + removeNamespace($nsName);   
	teRemapToNamespace($animSource, $nsName, $startTime, $duration, $newClipName);
}
