// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Sept, 2002
//
//	Procedure Name:
//		doRemoveConstraintTarget
//
//	Description:
//      The user selects the target and the constrained object.
//		This script removes the selected target from the constraint
//		so that it no longer affects the object.
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//		"1" : first verison
//  
//	$args
//	Version 1
//	[0]		$which :  comma separated string of constraint types to affect, or "all" to remove the target from all existing constraint on the object
//  [1]     $maintainOffset: whether to maintain the existing offset to the remaining targets
//
//	Return Value:
//		none
//


global proc
doRemoveConstraintTarget( string $version, string $args[] )
{
	string $sel[] = `ls -sl`;
	if (size($sel) < 2) {
		error((uiRes("m_doRemoveConstraintTarget.kYouMustSelect")));
		return;
	}

	string $cmd;
	string $constrainedObj = $sel[size($sel)-1];

	int $maintainOffset = $args[1] ;
	string $remFlag = " -remove;";
	string $remMaintainOffsetFlag;
	if ($maintainOffset) {
		$remMaintainOffsetFlag = " -remove -maintainOffset; ";
	} else {
		$remMaintainOffsetFlag = " -remove; ";
	}
	
	if ($args[0] == "all") {
		string $p1 = `pointConstraint -q $constrainedObj`;
		if (size($p1)) {
			$cmd += "pointConstraint"+$remMaintainOffsetFlag;
		}
		string $a1 = `aimConstraint -q $constrainedObj`;
		if (size($a1)) {
			$cmd += "aimConstraint"+$remMaintainOffsetFlag;
		}
		string $o1 = `orientConstraint -q $constrainedObj`;
		if (size($o1)) {
			$cmd += "orientConstraint"+$remMaintainOffsetFlag;
		}
		string $s1 = `scaleConstraint -q $constrainedObj`;
		if (size($s1)) {
			$cmd += "scaleConstraint"+$remMaintainOffsetFlag;
		}
		string $par1 = `parentConstraint -q $constrainedObj`;
		if (size($par1)) {
			$cmd += "parentConstraint"+$remMaintainOffsetFlag;
		}
		string $g1 = `geometryConstraint -q $constrainedObj`;
		if (size($g1)) {
			$cmd += "geometryConstraint"+$remFlag;
		}
		string $t1 = `tangentConstraint -q $constrainedObj`;
		if (size($t1)) {
			$cmd += "tangentConstraint"+$remFlag;
		}			
		string $n1 = `normalConstraint -q $constrainedObj`;
		if (size($n1)) {
			$cmd += "normalConstraint"+$remFlag;
		}
		if (nodeType($constrainedObj) == "ikHandle") {
			// the poleVectorConstraint is only valid on ikHandles
			//
			string $pv1 = `poleVectorConstraint -q $constrainedObj`;
			if (size($pv1)) {
				$cmd += "poleVectorConstraint"+$remFlag;
			}
		}
		string $pop1 = `pointOnPolyConstraint -q $constrainedObj`;
		if (size($pop1)) {
			$cmd += "pointOnPolyConstraint"+$remMaintainOffsetFlag;
		}
	} else {
		string $buff[];
		tokenize($args[0],",",$buff);
		for ($constraint in $buff) {
			if ($constraint == "poleVector" &&
				nodeType($constrainedObj) != "ikHandle") {
				// the poleVectorConstraint is only valid on ikHandles
				//
				continue;
			}
			$tmpCmd = ($constraint+"Constraint -q "+$constrainedObj);
			string $ex = `eval $tmpCmd`;
			if (size($ex)) {
				$cmd += ($constraint+"Constraint"+$remFlag);
			}
		}
	}
	if (size($cmd) == 0) {
		error((uiRes("m_doRemoveConstraintTarget.kConstrainedObject")));
	}
	evalEcho $cmd;
}
