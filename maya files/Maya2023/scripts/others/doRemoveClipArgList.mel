// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Nov, 1999
//
//  Procedure Name:
//      doRemoveClipArgList
//
//  Description:
//      Remove a clip from the timeline or delete the clip altogether.
//
//  Input Arguments:
//  $version: The version of this option box.  Used to know how to 
//  interpret the $args array.
//  
//  $args
//  Version 1
//  [0]     $name :  name of the clip window
//  [1]       $op :  type of removal operation:
//                   0 = remove from timeline
//                   1 = delete from library
//
global proc
doRemoveClipArgList( string $version, string $args[] )
{
    string $clipWnd        = $args[0];
    int    $op             = $args[1];

    string $selClips[]  = getSelectedClips("allowAudioCache");
    string $selBlends[] = getSelectedBlends();
    string $selAudio[]  = `ls -sl -type audio -type cacheFile`;
    // Terminate the script if there are no nodes to process
    if ( ( size( $selClips  ) == 0 ) && 
         ( size( $selBlends ) == 0 ) && 
         ( size( $selAudio  ) == 0 ) )
        error( (uiRes("m_doRemoveClipArgList.kSelectTheClipsErr")) );

    // delete the blends first since deleting the clips will sometimes
    // delete associated blends
    //
    for ($blend in $selBlends)
        delete $blend;

    string $removedClips[];
    int $removeCount = 0;

    for ($clip in $selClips)
    {
        // If a clipGhostShape has been added for this particular clip, delete it.
        string $clipGhostShape = getGhostShapeForClip( $clip );
        if ( size( $clipGhostShape ) )
            delete $clipGhostShape ;

        string $sch = getClipScheduler($clip);
        int $clipIndex = getClipIndex($clip, $sch);

        if ($op == 0) {
            // remove from timeline
            //
            string $cmdString = ("clipSchedule -rm -ci "+$clipIndex+" "+$sch);
            evalEcho $cmdString;

        } else {
            string $character[] = `listConnections -type character $sch`;
            string $clipName = `clipSchedule -ci $clipIndex -q -n $sch`;
            if (size($clipName) && size($character)) {
                int $removeIt = 1;
                for ($rclip in $removedClips) {
                    if ($rclip == $clipName) {
                        $removeIt = 0;
                        break;
                    }
                }
                if ($removeIt) {
                    string $cmdString = ("clip -rm -name "+$clipName+" "+$character[0]);
                    evalEcho $cmdString;
                    $removedClips[$removeCount] = $clipName;
                    $removeCount++;
                }
            }
        }

        // Ensure that deletion of clips does not mess up ordering if
        // connections to/from clipToGhose node.
        ghostReorderConnections( $sch );

    }

    // Delete anything else we can select in Trax
    for ($audio in $selAudio)
        delete $audio;
}
