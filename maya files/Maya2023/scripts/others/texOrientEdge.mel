// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// ===========================================================================
//
//  Procedure Name:
//      texOrientEdge
//
//  Description:
//      Orienting a shell so that the selected edge runs parallel to the U or V axis.
//
//  Input Arguments
//      None.
//
//  Return Value:
//      None.
//
// ===========================================================================

global proc texOrientEdge()
{
	// Get selected edges
    $selEdge = `filterExpand -sm 32`; 
	// Get selected UVs
	$selUVs = `filterExpand -sm 35`;
	string $uvs[];
	if(size($selEdge) != 0)
	{
		$uvPairs = `polyEvaluate -uvEdgePairs`;
		for($uvPair in $uvPairs)
			$uvs = stringArrayCatenate(stringToStringArray($uvPair, " "), $uvs);
	}
	else if(size($selUVs) > 1)
	{
		$shells = texGetShells();
		for($shell in $shells)
		{
			$uvPair = eval("ls -sl -flatten " + $shell);
			if(size($uvPair) < 2)
				continue;
			// Only take the first two selected UVs in this shell
			$uvs[size($uvs)] = $uvPair[0];
			$uvs[size($uvs)] = $uvPair[1];
		}
	}
	if(size($uvs) == 0)
	{
		error((uiRes("m_texOrientEdge.kWrongSelection")));
		return;
	}
	// Begin progressBar
    global string $gMainProgressBar;
    progressBar -e -bp -max (size($uvs)) $gMainProgressBar; 
	string $lastPair[];
    for($i = 0; $i < size($uvs) && ($i + 1) < size($uvs); $i = $i + 2)
    {
		// Update the progress window
        progressBar -e -s 2 $gMainProgressBar; 
		// Break if cancelled by user 
        if (`progressBar -q -isCancelled $gMainProgressBar`) 
        { 
            warning((uiRes("m_texOrientEdge.kInteruptMsg"))); 
            break; 
        } 
		
		// Get UV pair on the edge
		$uv1 = $uvs[$i];
		$uv2 = $uvs[$i+1];
		
		// Check if this UV pair is already oriented
		if($uv1 == $lastPair[0] && $uv2 == $lastPair[1])
			continue;
		
		$lastPair[0] = $uv1;
		$lastPair[1] = $uv2;
		
		global int $invertVal;
        float $angle = texCalculateAngle($uv1, $uv2);
		
		// Reduce arctan angle to 4 decimals only
		$angle = texRoundOff($angle, 4);

		// Determine rotation type based on arc tangent
		// arctan range is -90 deg to +90 deg    
		if ($angle == 0.0000 || $angle == 90.0000 || $angle == -90.0000)
		{
			// Type 0 - No rotation
			$angle = 0;

		} else if ($angle >= -44.9999 && $angle <= 44.9999)
		{
			// Type A - Invert arctan
			$invertVal = 1;

		} else if ($angle >= 45.0001 && $angle <= 89.9999)
		{
			// Type B - Subtract arctan from 90
			$angle = 90 - $angle;
			$invertVal = 0;

		} else if ($angle <= -45.0001 && $angle >= -89.9999)
		{
			// Type C - Add 45 to arctan and invert
			$angle = 90 + $angle;
			$invertVal = 1;

		} else {
			// Type D - 45 degrees vector
			$angle = 45;
			$invertVal = 0;
		}

		if ($invertVal == 1) $angle = -$angle;
		
		// Get shell
		$shell =`polyListComponentConversion -tuv -uvs $uv1`;
		
		// Get pivot of shell
		float $uvBox[] = `polyEvaluate -bc2 $shell`;
		$pivot[0] = 0.5 * ($uvBox[0] + $uvBox[1]);
		$pivot[1] = 0.5 * ($uvBox[2] + $uvBox[3]);
		polyEditUV -pivotU $pivot[0] -pivotV $pivot[1] -angle $angle $shell;
    }
	// End progressBar
    progressBar -e -endProgress $gMainProgressBar;
}