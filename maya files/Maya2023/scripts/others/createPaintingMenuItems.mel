// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

global proc string[] createPaintingMenuItems(
	string 		$parent, 
	string 		$item
)
//
//	Description:
// 		Creates a menu that shows all the paintable objects and 
//		their attributes in the current selection
//  Returns:
//      A list of the node types for which painting items were made.
// 
{
 	string $shape = "";
	string $result[];

 	// Look at the shape child of this object
 	//
 	string $object[] = `listRelatives -path -noIntermediate -s $item`;

 	int $i;
 	for ($i = 0; $i < size($object); ++$i) {
		if ( (`nodeType $object[$i]` == "nurbsSurface") ||
			 (`nodeType $object[$i]` == "mesh") ) {
			$shape = $object[$i];
			break;
		}
 	}

	//==================================================================
	// If the $shape is an nBase mesh (ie, nCloth or nRigid), set up the
	// appropriate painting menu
	//
	string $nCloth = findTypeInHistory( $shape, "nBase", 1, 1 );
	string  $nType = "";
	if( $nCloth != "" ) {
		 $nType = `nodeType $nCloth`;
	}
	if(($nType != "") && ($nType != "nParticle")) {
		$result[0] = "nCloth";
		$result[1] = "nRigid";
		$result[2] = "nComponent";
		$result[3] = "cacheFile";
		
		// We have an nCloth/nRigid
		//		
		string $createNClothTextureItem;
		string $createNClothVtxItem;
		

		if( !`exists DynCreateNPaintPropertiesMenu` ){
			source "DynClothMenu.mel";
		}
		
		if( $nType == "nCloth" ){
			$createNClothTextureItem = `menuItem -label (uiRes("m_createPaintingMenuItems.kNClothPaintTexture"))
			-annotation (uiRes("m_createPaintingMenuItems.kNClothPaintTextureAnnot"))
			-subMenu true -tearOff false -allowOptionBoxes true`;
		} else if( $nType == "nRigid" ){
			$createNClothTextureItem = `menuItem -label (uiRes("m_createPaintingMenuItems.kNRigidPaintTexture"))
			-annotation (uiRes("m_createPaintingMenuItems.kNRigidPaintTextureAnnot"))
			-subMenu true -tearOff false -allowOptionBoxes true`;
		}
		DynCreateNPaintPropertiesMenu $createNClothTextureItem ("\"" + $shape + "\"") 1;
		
		if( $nType == "nCloth" ){
			$createNClothVtxItem = `menuItem -label (uiRes("m_createPaintingMenuItems.kNClothPaintVtx"))
			-annotation (uiRes("m_createPaintingMenuItems.kNClothPaintVertexAnnot"))
			-subMenu true -tearOff false -allowOptionBoxes true`;
		} else if( $nType == "nRigid" ){
			$createNClothVtxItem = `menuItem -label (uiRes("m_createPaintingMenuItems.kNRigidPaintVtx"))
			-annotation (uiRes("m_createPaintingMenuItems.kNRigidPaintVertexAnnot"))
			-subMenu true -tearOff false -allowOptionBoxes true`;
		}
		DynCreateNPaintPropertiesMenu $createNClothVtxItem ("\"" + $shape + "\"") 0;
		
		if( $nType == "nCloth" ) {
			// if it has a cache input, then there ought to be at least on upstream cache node
			// so it's meaningful to paint cache weights
			string $con[] = `listConnections ($nCloth + ".playFromCache")`;
			if( size($con) >= 1) {
     				menuItem -p $parent -l (uiRes("m_createPaintingMenuItems.kPaintCache"))
              				-annotation (getRunTimeCommandAnnotation("PaintCacheTool"))
               				-image "paintCacheWeights.png"
               				-c "PaintCacheTool"
              				nclothPaintCacheItem;
				menuItem -p $parent -optionBox true
					-image "paintCacheWeights.png"
					-annotation (getRunTimeCommandAnnotation("PaintCacheToolOptions"))
					-c "PaintCacheToolOptions"
					nClothPaintCacheOptItem;

			}
		}
	}

	// if there is no shape, then just return
	//
	if( $shape == "" ) {
		menuItem -l "(empty)" -en false;
	}
	return $result;
}
