// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  4 May 1998
//
//  Procedure Name:
//      performPolyMirror
//
//  Description:
//        Mirrors a polyObject
//			and optionally merges the mirror with the original.
//         
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        command string iff $option==2
//

proc setOptionVars (int $forceFactorySettings)
{
	optionVar -init $forceFactorySettings -category "Modeling.Mesh.Mirror"
		-iv polyMirrorAxis 0
		-iv polyMirrorDirection 1
		-iv polyMirrorStitch 1
		-iv polyMirrorThresholdType 0
		-fv polyMirrorThresholdCustom 0.001
		-iv polyMirrorAxisPosition 2
		-fv polyMirrorAxisOffset 0
		-fv polyMirrorSmoothingAngle 30.0
		-iv polyFlipUV 0
		-iv polyFlipUVDirection 0
		-iv polyMirrorGeoType 0
		-iv polyMirrorCutOption 1
		-iv polyMirrorCutPlane 0
		;
}

global proc performPolyMirrorSetup (string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
	setParent $parent;

	int $mDir = `optionVar -q polyMirrorDirection` + 1;
	if( $mDir > 2 )
		$mDir = 1;
	int $mAxis = `optionVar -q polyMirrorAxis` + 1;
	radioButtonGrp -e -select $mAxis polyMirrorAxis;
	optionMenuGrp -e -select $mDir polyMirrorAxisDirection;

	int $pmso = `optionVar -q polyMirrorStitch`;
	if ($pmso)
		optionMenuGrp -edit -enable on -select $pmso polyMirrorMergeVertices;
	else
		optionMenuGrp -e -enable off polyMirrorMergeVertices;

	checkBoxGrp -edit -value1 ($pmso!=0) polyMirrorStitchOption;

	int $pmtt = `optionVar -q polyMirrorThresholdType` + 1;
	radioButtonGrp -e -select $pmtt polyThresholdRadioButton;

	float $pmtc = `optionVar -q polyMirrorThresholdCustom`;
	floatFieldGrp -e -value1 $pmtc polyCustomThreshold;

	float $pmsa = `optionVar -q polyMirrorSmoothingAngle`;
	floatFieldGrp -e -value1 $pmsa polySmoothingAngle;

	int $pmap = `optionVar -q polyMirrorAxisPosition` + 1;
	optionMenuGrp -e -select $pmap polyMirrorAxisPosition;

	int $pmgt = `optionVar -q polyMirrorGeoType` + 1;
	optionMenuGrp -e -select $pmgt polyMirrorGeoType;

	float $pmac = `optionVar -q polyMirrorAxisOffset`;
	floatFieldGrp -e -value1 $pmac polyMirrorAxisOffset;

	int $fuv = `optionVar -q polyFlipUV`;
	checkBoxGrp -edit -value1 ($fuv!=0) polyMirrorFlipUV;
	int $fuvd = `optionVar -q polyFlipUVDirection` + 1;
	optionMenuGrp -e -select $fuvd polyMirrorFlipUVDirection;

	checkBoxGrp -edit -value1 (`optionVar -q polyMirrorCutOption`!=0) polyMirrorCutOption;
//	checkBoxGrp -edit -value1 (`optionVar -q polyMirrorCutPlane`!=0) polyMirrorCutPlane;

	updateGeoType;
	updateMirrorAxis;
}

global proc performPolyMirrorCallback (string $parent, int $doIt)
{
	setParent $parent;
	
	int $mAxis = `radioButtonGrp -q -select polyMirrorAxis` - 1;
	int $mDir = `optionMenuGrp -q -select polyMirrorAxisDirection` - 1;

	optionVar -intValue polyMirrorAxis $mAxis;
	optionVar -intValue polyMirrorDirection $mDir;

	int $val = 0;
	if (`checkBoxGrp -query -value1 polyMirrorStitchOption`)
		$val = `optionMenuGrp -q -select polyMirrorMergeVertices`;

	optionVar -intValue polyMirrorStitch $val;

	int $pmtt = `radioButtonGrp -query -select polyThresholdRadioButton` - 1;
	optionVar -intValue polyMirrorThresholdType $pmtt;

	float $pmtc = `floatFieldGrp -query -value1 polyCustomThreshold`;
	optionVar -floatValue polyMirrorThresholdCustom $pmtc;

	float $pmsa = `floatFieldGrp -query -value1 polySmoothingAngle`;
	optionVar -floatValue polyMirrorSmoothingAngle $pmsa;

	int $pmap = `optionMenuGrp -query -select polyMirrorAxisPosition` - 1;
	optionVar -intValue polyMirrorAxisPosition $pmap;

	int $pmgt = `optionMenuGrp -query -select polyMirrorGeoType` - 1;
	optionVar -intValue polyMirrorGeoType $pmgt;

	float $pmac = `floatFieldGrp -query -value1 polyMirrorAxisOffset`;
	optionVar -floatValue polyMirrorAxisOffset $pmac;

	int $fuv = `checkBoxGrp -query -value1 polyMirrorFlipUV`;
	int $fuvd = `optionMenuGrp -query -select polyMirrorFlipUVDirection` - 1;
	optionVar -intValue polyFlipUV $fuv;
	optionVar -intValue polyFlipUVDirection $fuvd;

	int $cb = `checkBoxGrp -query -value1 polyMirrorCutOption`;
	optionVar -intValue polyMirrorCutOption $cb;
//	$cb = `checkBoxGrp -query -value1 polyMirrorCutPlane`;
//	optionVar -intValue polyMirrorCutPlane $cb;

	if ($doIt) {
		performPolyMirror 0;
		addToRecentCommandQueue "performPolyMirror 0" "PolyMirror";
	}
}

global proc updateThreshold()
{
	int $thval = `radioButtonGrp -q -select polyThresholdRadioButton`;
	int $val = `optionMenuGrp -q -select polyMirrorMergeVertices`;
	int $gt = `optionMenuGrp -q -select polyMirrorGeoType`;

	if( (`checkBoxGrp -query -value1 polyMirrorStitchOption`) && $val == 1 && $gt == 1 )
	{
		radioButtonGrp -e -enable true polyThresholdRadioButton;
		if( $thval == 1 )
			floatFieldGrp -e -enable false polyCustomThreshold;
		else
			floatFieldGrp -e -enable true polyCustomThreshold;
		floatFieldGrp -e -enable true polySmoothingAngle;
	}
	else
	{
		radioButtonGrp -e -enable false polyThresholdRadioButton;
		floatFieldGrp -e -enable false polyCustomThreshold;
		floatFieldGrp -e -enable false polySmoothingAngle;
	}
}

global proc updateMirrorAxis()
{
	int $val = `optionMenuGrp -q -select polyMirrorAxisPosition`;

	int $co = `checkBoxGrp -query -value1 polyMirrorCutOption`;
	if( $val == 1 || $co == 1 )
		optionMenuGrp -e -enable true polyMirrorAxisDirection;
	else
		optionMenuGrp -e -enable false polyMirrorAxisDirection;

	optionMenuGrp -e -enable ($co==0) polyMirrorGeoType;
}

global proc updateGeoType()
{
	int $gt = `optionMenuGrp -q -select polyMirrorGeoType`;
	int $so = `checkBoxGrp -query -value1 polyMirrorStitchOption`;

	checkBoxGrp -edit -enable ($gt==1) polyMirrorStitchOption;
	optionMenuGrp -edit -enable ($gt==1 && $so==1) polyMirrorMergeVertices;
	updateThreshold;
	checkBoxGrp -edit -enable ($gt!=2) polyMirrorFlipUV;
	optionMenuGrp -edit -enable ($gt!=2) polyMirrorFlipUVDirection;

	checkBoxGrp -edit -enable ($gt==1) polyMirrorCutOption;
//	checkBoxGrp -edit -enable ($gt==1) polyMirrorCutPlane;
}

proc polyMirrorOptions ()
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateFrameSpacing;
	
	string $layout = getOptionBox();
	setParent $layout;

	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;
	
	tabLayout -tabsVisible 0 -scrollable 1;

	// Form layout
	string $parent = `formLayout polyMirrorOptions`;
	
	string $commandName = "performPolyMirror";
	string $callback = ($commandName + "Callback " + $parent + " ");
	string $setup = ($commandName + "Setup "  + $parent + " ");

	setOptionBoxCommandName($commandName);
	
		// Settings frame
		string $settingsFrame = 
		`frameLayout -label (uiRes("m_performPolyMirror.kSettingsFrame"))`;

			columnLayout;

				checkBoxGrp 
					-ncb 1
					-label (uiRes("m_performPolyMirror.kCutGeometry"))
					-on1 ("optionMenuGrp -e -enable false polyMirrorGeoType")
					-of1 ("optionMenuGrp -e -enable true polyMirrorGeoType")
					polyMirrorCutOption;
//				checkBoxGrp 
//					-ncb 1
//					-label1 _L10N( kMirrorCutPlane, "Mirror Cut Plane" )
//					polyMirrorCutPlane;

                optionMenuGrp
                    -label (uiRes("m_performPolyMirror.kMirrorGeoType"))
					-cc ("updateGeoType")
                    polyMirrorGeoType;

                    menuItem -label (uiRes("m_performPolyMirror.kGeoCopy"));
                    menuItem -label (uiRes("m_performPolyMirror.kGeoInstance"));
                    menuItem -label (uiRes("m_performPolyMirror.kGeoFlip"));

                optionMenuGrp
                    -label (uiRes("m_performPolyMirror.kMirrorAxisPosition"))
					-cc ("updateMirrorAxis")
                    polyMirrorAxisPosition;

                    menuItem -label (uiRes("m_performPolyMirror.kAxisBoundingBox"));
                    menuItem -label (uiRes("m_performPolyMirror.kAxisObject"));
                    menuItem -label (uiRes("m_performPolyMirror.kAxisWorld"));

				floatFieldGrp 
					-label (uiRes("m_performPolyMirror.kMirrorAxisOffset"))
					polyMirrorAxisOffset;

				radioButtonGrp 
					-label (uiRes("m_performPolyMirror.kMirrorAxis"))
					-numberOfRadioButtons 3 
					-label1 (uiRes("m_performPolyMirror.kXPlus"))
					-label2 (uiRes("m_performPolyMirror.kYPlus"))
					-label3 (uiRes("m_performPolyMirror.kZPlus"))
					polyMirrorAxis;

                optionMenuGrp
                    -label (uiRes("m_performPolyMirror.kMirrorAxisDirection"))
                    polyMirrorAxisDirection;

                    menuItem -label (uiRes("m_performPolyMirror.kAxisPositive"));
                    menuItem -label (uiRes("m_performPolyMirror.kAxisNegative"));

			setParent ..; // columnLayout

		string $mergeFrame = 
		`frameLayout -label (uiRes("m_performPolyMirror.kMergeFrame"))`;

			columnLayout;

				checkBoxGrp 
					-ncb 1
					-label (uiRes("m_performPolyMirror.kMergeWithOriginal"))
					-on1 ("optionMenuGrp -e -enable on  polyMirrorMergeVertices;updateThreshold")
					-of1 ("optionMenuGrp -e -enable off polyMirrorMergeVertices;updateThreshold")
					polyMirrorStitchOption;

                optionMenuGrp
                    -label (uiRes("m_performPolyMirror.kMergeVerticesType"))
                    -cc ("updateThreshold")
                    polyMirrorMergeVertices;

                    menuItem -label (uiRes("m_performPolyMirror.kMergeVertices"));
                    menuItem -label (uiRes("m_performPolyMirror.kConnectBorderEdges"));
                    menuItem -label (uiRes("m_performPolyMirror.kDontMerge"));					
				
				radioButtonGrp 
					-label (uiRes("m_performPolyMirror.kMergeThreshold")) 
                    -cc ("updateThreshold")
					-numberOfRadioButtons 2
					-label1 (uiRes("m_performPolyMirror.kAutomaticThreshold")) 
					-label2 (uiRes("m_performPolyMirror.kCustomThreshold"))
					-select 1
					-enable true
					-vertical
					polyThresholdRadioButton;

				floatFieldGrp polyCustomThreshold;
					
				floatFieldGrp 
					-label (uiRes("m_performPolyMirror.kSmoothingAngle")) 
					polySmoothingAngle;

			setParent ..; // columnLayout

		string $uvFrame = 
		`frameLayout -label (uiRes("m_performPolyMirror.kUVFrame"))`;

			columnLayout;

				checkBoxGrp 
					-ncb 1
					-label (uiRes("m_performPolyMirror.kFlipUV"))
					-on1 ("optionMenuGrp -e -enable on  polyMirrorFlipUVDirection")
					-of1 ("optionMenuGrp -e -enable off polyMirrorFlipUVDirection")
					polyMirrorFlipUV;

                optionMenuGrp
                    -label (uiRes("m_performPolyMirror.kFlipUVDirection"))
                    polyMirrorFlipUVDirection;

                    menuItem -label (uiRes("m_performPolyMirror.kFlipUVLocalU"));
                    menuItem -label (uiRes("m_performPolyMirror.kFlipUVLocalV"));
                    menuItem -label (uiRes("m_performPolyMirror.kFlipUVWorldU"));
                    menuItem -label (uiRes("m_performPolyMirror.kFlipUVWorldV"));
				
			setParent ..; // columnLayout

		setParent $parent; // frameLayout

	setParent ..; // formLayout

	// Attach Description/Settings frames to form layout
	formLayout -e
		-af $settingsFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $settingsFrame "bottom"
	$parent;

	waitCursor -state 0;
	setUITemplate -popTemplate;
	   
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyMirror.kMirrorButton"))
	       -command ($callback + 1)
		$applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + 0 + "; hideOptionBox")
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + 1)
		$resetBtn;
			 
	setOptionBoxTitle( (uiRes("m_performPolyMirror.kMirrorOptions")) );

	//	Customize the 'Help' menu item text.
	//
	setOptionBoxHelpTag( "MirrorGeometry" );

	eval (($setup + 0));
	showOptionBox();

	global string $gOptionBox;
	window -e -widthHeight 546 500 $gOptionBox;
}

proc string assembleCmd()
{
	setOptionVars(0);						// Without this the option vars don't exist and the parameters are not initialized if we run the command without opening the options window.

	int $doHistory = `constructionHistory -q -toggle`;

	string $cmd="polyMirrorFace ";

	$cmd+= " -cutMesh " + (`optionVar -q polyMirrorCutOption`);
	$cmd+= " -axis " + (`optionVar -q polyMirrorAxis`);
	$cmd+= " -axisDirection " + (`optionVar -q polyMirrorDirection`);
	$cmd+= " -mergeMode " + (`optionVar -query polyMirrorStitch`);
	$cmd+= " -mergeThresholdType " + (`optionVar -query polyMirrorThresholdType`);
	$cmd+= " -mergeThreshold " + (`optionVar -query polyMirrorThresholdCustom`);
	$cmd+= " -mirrorAxis " + (`optionVar -query polyMirrorAxisPosition`);
	$cmd+= " -mirrorPosition " + (`optionVar -query polyMirrorAxisOffset`);
	$cmd+= " -smoothingAngle " + (`optionVar -query polyMirrorSmoothingAngle`);
	
	int $flipUV = `optionVar -query polyFlipUV`;
	if( $flipUV )
	{
		int $flipUVD = `optionVar -query polyFlipUVDirection`;
		$flipUV += $flipUVD;
	}
	$cmd+= " -flipUVs " + $flipUV;

	return $cmd;	
}

proc performInstanceAndFlip( int $gt )
{
	string $sc[] = {"X", "Y", "Z"};
	int $axis = `optionVar -q polyMirrorAxis`;
	int $adir = `optionVar -q polyMirrorDirection`;
	int $dir = $axis * 2 + $adir;
	int $type = `optionVar -query polyMirrorAxisPosition`;
	float $point[] = {0, 0, 0};

	if( $type == 0 )				// Bounding box
	{
		float $bBox[] = `exactWorldBoundingBox`;
		if( 0 == $dir )
			$point[0] = $bBox[3];
		if( 1 == $dir )
			$point[0] = $bBox[0];
		if( 2 == $dir )
			$point[1] = $bBox[4];
		if( 3 == $dir )
			$point[1] = $bBox[1];
		if( 4 == $dir )
			$point[2] = $bBox[5];
		if( 5 == $dir )
			$point[2] = $bBox[2];
	}

	string $pivStr = "";
	if( $type != 1 )				// Not object local
		$pivStr = " -pivot " + $point[0] + " " + $point[1] + " " + $point[2];

	string $cmd = "scale -r" + $pivStr + " -scale" + $sc[$axis] + " -1";
	if( $gt == 1 )
	{
		string $inst[] = `instance`;
		$cmd = $cmd + " 1 1 " + $inst[0];
	}

	eval( $cmd );

	int $flipUV = `optionVar -query polyFlipUV`;
	if( $flipUV && $gt == 2 )
	{
		int $flipUVD = `optionVar -query polyFlipUVDirection`;
		polyFlipUV -flipType ($flipUVD % 2) -local ($flipUVD < 2);
	}
}

proc string findNode( string $nt )
{
	if( 0 != size(`ls -sl`) || (0 != size(`ls -hl`)) )
	{
		string $tmp[] = `listHistory`;
		string $totalSel[];
		for ($opNode in $tmp)
			if (`nodeType $opNode` == $nt)
				$totalSel[size($totalSel)] = $opNode;
			
 		if (size($totalSel) > 0) 
 			return $totalSel[0];
	}
	return "";
}

global proc string performPolyMirror (int $option)
{
    string $cmd="";
    string $lbl;

	switch ($option) {
	case 0:
			int $ap = `optionVar -q polyMirrorAxisPosition`;
			int $cut = `optionVar -q polyMirrorCutOption`;
			int $gt = `optionVar -q polyMirrorGeoType`;
			if( $gt > 0 )
			{
				performInstanceAndFlip( $gt );
				break;
			}

			string $sel[] = `ls -sl -o`;
			for ($selo in $sel)
			{
				string $chList[] = `listRelatives -c -typ "transform" $selo`;
				if( size( $chList ) > 0 )
				{
					select -d $selo;
					select -add $chList;
				}
			}

			$cmd=`assembleCmd `;
            polyPerformAction $cmd "f" 0;

			string $mirrorNode = findNode( "polyMirror" );
			int $comb = `optionVar -query polyMirrorStitch`;
			if( $comb == 0 )
			{
				string $selObj[] = `ls -sl -o -typ "transform"`;
				for ($io in $selObj)
				{
					if( `nodeType $io` == "transform" )
					{
						string $sepCmd = "polySeparate -uss 1 -inp 1 " + $io;
						evalEcho $sepCmd;

						string $sepNode = findNode("polySeparate");
						if( $sepNode != "" && $mirrorNode != "" )
						{
							string $connectCmd = "connectAttr -f " + $mirrorNode + ".firstNewFace " + $sepNode + ".startFace";
							evalEcho $connectCmd;
							$connectCmd = "connectAttr -f " + $mirrorNode + ".lastNewFace " + $sepNode + ".endFace";
							evalEcho $connectCmd;
						}
					}
				}
			}

			// make sure node is selected when there is history
			select -add $mirrorNode;
			setToolTo ShowManips;
			break;
    case 1: polyMirrorOptions; break;
    case 2: 
			$cmd=`assembleCmd`;
			$cmd = ("polyPerformAction \"" + $cmd + "\" \"f\" 0");
			break;
    default:
        $cmd = ("performPolyMirror 0");
    }
    return $cmd;
}

