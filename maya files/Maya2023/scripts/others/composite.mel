// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//  Description:
//      Samples a user-specified shading node based on the following arguments.
//
//		int $xRes				width of sample image
//		int $yRes,				height of sample image
//		string $imageName,		name of image to be created
//		string $fileFormat,		file format of image to be created
//		string $filePath,		path to file to be created
//		float $startFrame,		start frame for range
//		float $endFrame,		end frame for range
//		float $by,				frame increments (i.e. sample every 2 frames)
//		int $padding,			number padding for image to be created
//		int $loadInImageViewer				load sequence into ImageViewer for user
//
//  Return Value:
//      None.
//
global proc composite ( int $xRes, 
						int $yRes,
						string $imageName,
						string $fileFormat,
						string $filePath,
						float $startFrame,
						float $endFrame,
						float $by,
						int $padding,
						int $loadInImageViewer
)
{
	// Need to run a test to make sure something is selected
	string $textureNode[] = `ls -selection`;
	if (`size ($textureNode)` < 1) {
		error ( (uiRes("m_composite.kNothingSelectedErr")));
	}
	else if (`size ($textureNode)` > 1) {
		warning ( (uiRes("m_composite.kMoreThanOneWarn")));
	}

	string $processingError = (uiRes("m_composite.kProcessingError"));
	// Need to run a test on the selected node to make sure we can sample it
	if (!(isClassified($textureNode[0], "texture"))) {
		if (isClassified($textureNode[0], "utility")) {
			string $connections[] = `listConnections -s 0 -d 1 $textureNode[0]`;
			if (`size ($connections)` < 2) {
				error $processingError;
			}
		} else {
			error $processingError;
		}
	}

	// Get currentTime before changing it in loop so it may be put
	// back where it was
	float $currentTime = `currentTime -query`;
	string $currentProject = `workspace -q -rootDirectory`;
	string $fileImageName = $currentProject;

	// Determine padding for file number
	string $fileNumber;
	string $pads;
	
	for ($i=$startFrame; $i<=$endFrame; $i+=$by) {
		
		// Determine file extension with padding
		$fileNumber = $i;
		$pads = "";
		int $size = size($fileNumber);
		if ($size < $padding){
			int $zeroes = $padding - $size;
			for ($j = 0; $j < $zeroes; $j++){
				$pads += "0";
			}
		}
		$fileNumber = $pads + $i;
		
		$fileImageName = ($fileImageName + "/" + $filePath + "/" 
			+ $imageName + "." + $fileNumber
			+ "." + $fileFormat);
		currentTime -edit $i;
		
		convertSolidTx -samplePlane true
			-alpha true
			-resolutionX $xRes
			-resolutionY $yRes
			-name "testComp"
			-fileFormat $fileFormat
			-fileImageName $fileImageName
			;

		$fileImageName = $currentProject;

		// Delete resultant node so it's not visible
		delete testComp;
	}
	
	// Assemble final image name
	string $finalImage = $fileImageName + $filePath;
	$finalImage += "/" + $imageName;
	
	int $isSequenceViewerDefined =  `optionVar -exists "ViewSequenceDir"` ;
	
	if ($loadInImageViewer && ! $isSequenceViewerDefined ) { // Only for  fcheck
		$finalImage += ".";
		for ($j = 0; $j < $padding ; $j++) { $finalImage += "@"; }
		$finalImage += "." + $fileFormat;
	} else { // For Render View and other Applications.
		$fileNumber = "." + $pads + ($i-1);
		// For renderView the image name needs to be in quotes
		$finalImage = "\"" + $finalImage;
		$finalImage += $fileNumber  + "." + $fileFormat + "\"";
	}

	if ($loadInImageViewer) {
		if ($isSequenceViewerDefined) {
			string $sequenceViewer = `optionVar -q "ViewSequenceDir"` +" "+  `optionVar -q "ViewSequenceCmdFormat"`;
			string $fileName = $finalImage ;
			string $Cmd1 = `substitute "%f" $sequenceViewer $fileName` ; // Substitute the file name
			string $Cmd2 = `substitute "%s" $Cmd1 (string($startFrame))` ; // Substitute start frame
			$Cmd1 = `substitute "%e" $Cmd2 (string($endFrame))` ; // Substitute end frame
			$Cmd2 = `substitute "%b" $Cmd1 (string($by))` ; // Substitute jump frames
			
			string $viewCmd = "start " ;
			$viewCmd += $Cmd2;
			system( $viewCmd ) ;	
		} else { // fcheck
			// Start fcheck
			$fcheckCmd = "fcheck -n ";
			$fcheckCmd += $startFrame + " " + $endFrame + " " + $by + " ";
			$fcheckCmd += "\"" + $finalImage + "\"";
			evalEcho ($fcheckCmd);
			}
	} else {
		// Load image into render view
		string $loadImageCmd = "renderWindowEditor -edit -loadImage ";
		$loadImageCmd += $finalImage;
		$loadImageCmd += " renderView";
		
		evalEcho($loadImageCmd);
		
		// This will only pop renderView if it's not currently visible
		string $visiblePanels[] = `getPanel -visiblePanels`;
		string $stringIntersector = `stringArrayIntersector`;
		stringArrayIntersector -e -intersect $visiblePanels $stringIntersector;
		stringArrayIntersector -e -intersect "renderView" $stringIntersector;
		string $intersectionResults[] = `stringArrayIntersector -q $stringIntersector`;
		if (`size ($intersectionResults)` == 0) {
			RenderViewWindow;
		}
	}

	currentTime -edit $currentTime;
}

