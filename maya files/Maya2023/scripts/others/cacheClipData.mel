// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
	//
//
//  Creation Date:  Oct, 2000
//
//	Procedure Name:
//		cacheClipData
//
//	Description:
//		Callback used before removing attributes from a character
//      to cache clip data for the attributes. The 
//		clip data is isolated separate from the character in a
//		clipLibrary from which it can be copied and pasted
//		onto a new character using copyCachedClipDataCallback.
//
//	Input Arguments:
//	$character :  	name of the original character
//  $attrs : 		attributes to be cached
//
//	Return Value:
//		Library file and clip names for the cached clips
//
global proc string[]
cacheClipDataForCharacter(string $character, string $attrs[])
{
	// Isolate any clips for channels that we want to copy to the other
	// new subcharacter
	//
	string $isolateResult[];
	if (size($attrs) > 0) {
		string $sch = `character -q -sc $character`;
		if (size($sch) > 0) {
			string $schedClips[] = `clipSchedule -q -n $sch`;
			if (size($schedClips) > 0) {
				string $isolateCmd = "clip -ignoreSubcharacters -isolate";
				for ($sc in $schedClips) {
					$isolateCmd += (" -name "+$sc);
				}
				for ($aic in $attrs) {
					$isolateCmd += (" -uc "+$aic);
				}
				$isolateCmd += (" "+$character);
				$isolateResult = eval($isolateCmd);
			}
		}
	}
	return $isolateResult;
}

global proc string[]
cacheClipData(string $character, string $attrs[])
{
	string $result[];
	
	// If the character isn't specified, find out if the attributes are in
    // a character
	//
	if ("" == $character) {
		int $ii, $jj;
		int $atCount = size($attrs);
		string $myAttrs[];
		string $myChars[];
		for ($ii = 0; $ii < $atCount; $ii++) {
			string $mem[] = `listConnections -d 1 -s 0 -type character $attrs[$ii]`;
			if (size($mem)) {
				$myAttrs[$ii] = $attrs[$ii];
				$myChars[$ii] = $mem[0];
			} else {
				$myAttrs[$ii] = "";
				$myChars[$ii] = "";				
			}
		}
		for ($ii = 0; $ii < $atCount; $ii++) {
			string $attrsToAdd[];
			if ($myAttrs[$ii] == "") continue;

			$attrsToAdd[0] = $myAttrs[$ii];
			string $currChar = $myChars[$ii];
			for ($jj = 0; $jj < $atCount; $jj++) {
				if ($myChars[$jj] == $currChar) {
					$attrsToAdd[size($attrsToAdd)] = $myAttrs[$jj];
					$myAttrs[$jj] = "";
					$myChars[$jj] = "";
				}
			}
			string $currR;
			string $currResult[];
			$currResult = cacheClipDataForCharacter($currChar,$attrsToAdd);
			for ($currR in $currResult) {
				$result[size($result)] = $currR;
			}
			clear($attrsToAdd);
		}
	} else {
		$result = cacheClipDataForCharacter($character,$attrs);
	}
	return $result;
}
