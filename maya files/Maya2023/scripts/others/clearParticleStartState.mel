// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

//<doc>
//<name clearParticleStartState>
//<owner "Unsupported">
//
//<synopsis>
//      clearParticleStartState particleNode
//
//<returns>
//      None.
//
//<description>
// This mel procedure resets the initial state of the particle system to empty, 
// or no particles. To do this it clears all the initial state attribute arrays
// on the particle or nParticle node. (these are all the arrays whose name ends in "0")
//
//<flags>
//  None.
//
//<examples>
//
// clearParticleStartState particleShape1;
//
//</doc>

global proc clearParticleStartState(string $part) {

		string $type = `nodeType $part`;
		if( $type == "transform"){
			string $sh[] = `ls -dag -leaf $part`;
			if( size($sh) > 0 ){
				$part = $sh[0];	
				$type = `nodeType $part`;
			}
		}
		if ( $type != "particle" && $type != "nParticle" ){
			warning( $part + (uiRes("m_clearParticleStartState.kNotParticle")));
			return;
		}

		// clear out all of the double arrays
		$attrs = `particle -q -ppd $part`;
		for ($attr in $attrs) {
			if (`attributeQuery -exists -n $part ($attr + "0")`){
				setAttr ($part+"."+$attr+"0") -type "doubleArray" 0;
			}
        }
        // clear out all of the vector arrays
		$attrs = `particle -q -ppv $part`;
		for ($attr in $attrs) {
			if (`attributeQuery -exists -n $part ($attr + "0")`){
				setAttr ($part+"."+$attr+"0") -type "vectorArray" 0;
			}
		}

		// other attributes that need to be cleared
		setAttr ($part+".nid0") 0;
		setAttr ($part+".particleId0") -type "doubleArray" 0;
		setAttr ($part+".age0") -type "doubleArray" 0;
		
		// Update the particle system if at or before start frame
		// Currently this is a bit tedious... we force it to evaluate
		// a frame then set it back to the current frame.
		string $curTime = ($part + ".currentTime");
		float $t = getAttr( $curTime );
		float $sf = getAttr( $part + ".startFrame" );
		if( $t <= $sf ){
			string $timeCon = `connectionInfo -sfd $curTime`;
			disconnectAttr $timeCon $curTime;
			setAttr $curTime ($sf+1.0);
			getAttr ($part + ".forceDynamics");
			connectAttr $timeCon $curTime;
		}
		
}
