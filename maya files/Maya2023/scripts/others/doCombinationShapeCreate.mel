// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
global proc doCombinationShapeCreate(int $createNewTarget, int $combineMethod, int $targetType, string $transformName)
//
//  Description:
// 		Create a combination shape node. 
//      If create new target: 
//      Add a new blend shape target as combination target, 
//      Set all selected blend shape targets as drivers. 
//      If don't create new target: 
//      Set last selected blend shape target as combination target.
//      Set other selected blend shape targets as drivers.
//
//  Input Arguments:
//		createNewTarget - If create a new blend shape target;
//		combineMethod   - Combine method of the new added combination shape.
//      targetType      - Target type if need to add new target
//      transformName   - Transform name if need to add new target
//
{
    string $targets[] = getShapeEditorTreeviewSelection(24);
    int $targetNum = size($targets);
    if($targetNum == 0 || ($targetNum == 1 && !$createNewTarget))
        return;
    string $oneBSD;
    int $driverTargetIndexes[];

    for ($i = 0; $i < $targetNum; ++$i)
    {
        string $subStrings[] = stringToStringArray($targets[$i], ".");
        if($i == 0) 
            $oneBSD = $subStrings[0];
        if($oneBSD != $subStrings[0])
            return; 
        intArrayInsertAtIndex( 0, $driverTargetIndexes, $subStrings[1] );
    }
	int $drivenTargetIndex;
    if($createNewTarget)
    {
		int $drivenTargetIndexes[] = doBlendShapeAddTarget($oneBSD, 1, $targetType, $transformName, 1, 0, {} );
		if(size($drivenTargetIndexes) == 0)
			return;
		$drivenTargetIndex = $drivenTargetIndexes[0];

		//Move new combination under select selected driver target
		$lastSelectedDriverIndex = $driverTargetIndexes[0];
		$cmd = "getAttr " + $oneBSD + ".parentDirectory[" + $lastSelectedDriverIndex + "]";
		int $directoryIndex = eval($cmd);
		if($directoryIndex >= 0)
		{
			$cmd = "getAttr " + $oneBSD + ".targetDirectory[" + $directoryIndex + "].childIndices";
			int $childIndices[] = eval($cmd);
			if(intArrayContains($drivenTargetIndex, $childIndices) && intArrayContains($drivenTargetIndex, $childIndices))
			{
				int $drivenIndex = intArrayFind($drivenTargetIndex, 0, $childIndices);
				intArrayRemoveAtIndex($drivenIndex, $childIndices);
				int $lastDriverIndex = intArrayFind($lastSelectedDriverIndex, 0, $childIndices);
				intArrayInsertAtIndex($lastDriverIndex + 1, $childIndices, $drivenTargetIndex);	
                $cmd = "setAttr " + $oneBSD + ".targetDirectory[" + $directoryIndex + "].childIndices  -type Int32Array ";
				$cmd += size($childIndices);
				$cmd += " ";
				for($id in $childIndices)
				{
					$cmd += $id;
					$cmd += " ";
				}
				eval($cmd);
			}
		}
    }
    else
    {
		$drivenTargetIndex = getLastSelectedTargetIndex();
		if($drivenTargetIndex < 0)
		    return; //Last Selection is not a target
	}
	
	$cmd = "combinationShape -bs " + $oneBSD + " -cti " + $drivenTargetIndex + " -cm " + $combineMethod;
	for($driverTargetIndex in $driverTargetIndexes)
	{
		if($drivenTargetIndex == $driverTargetIndex)
			continue;
		$cmd += " -dti ";
		$cmd += $driverTargetIndex;
	}
	evalEcho($cmd);
	
	//Rollback if cause cycle warning
	if(!$createNewTarget && evalEcho("cycleCheck " + $oneBSD + ".w[" + $drivenTargetIndex + "]"))
	{
		undo;
		error( (uiRes("m_doCombinationShapeCreate.kCauseCycleWarning")));
	}
}