// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Methods called from the trax and visor popup menus.
//
global proc clipApplyPoseMenuCommand(string $clip)
{
	string $character[] = `clip -q -ch $clip`;
	if (size($character) > 0)
	{
		// apply the clip
		for ($c in $character) {
			string $poseCmd = ("pose -apply -name "+$clip+" "+$c);
			evalEcho($poseCmd);
		}
	} else {
		string $errorStr = (uiRes("m_clipMenuCommands.kNotAttachedToChar"));
		error(`format -s $clip $errorStr`);
	}
}


global proc
clipDuplicateMenuCommand(string $clip)
{
	string $characters[] = `clip -q -ch $clip`;
	string $topCharacters[];
	if (size($characters) > 0)
	{
		// Schedule an duplicate of the clip at the current time
		//
		string $curTime = `currentTime -query`;
		
		if (size($characters) == 1) {
			$topCharacters[0] = $characters[0];
		} else {
			// find the top level characters, duplicating them
			// will also duplicate their subcharacters so we do not
			// need to duplicate the subcharacters on their own
			//
			int $isSubCharacter[];
			int $ii, $jj;
			int $charCount = size($characters);
			for ($ii = 0; $ii < $charCount; $ii++) {
				$isSubCharacter[$ii] = 0;
				for ($jj = 0; $jj < $charCount; $jj++) {
					if ($ii == $jj) continue;
					if (`character -isMember $characters[$jj] $characters[$ii]`)
					{
						$isSubCharacter[$ii] = 1;
						break;
					}
				}
				if (0 == $isSubCharacter[$ii]) {
					$topCharacters[size($topCharacters)] = $characters[$ii];
				}
			}
		}
			
		// duplicate the clip
		//
		for ($c in $topCharacters) {
			string $cmd = ("clip -startTime "+$curTime);
			$cmd += (" -duplicate -name "+$clip+" "+$c);
			evalEcho $cmd;
		}
	} else {
		string $errorStr = uiRes("m_clipMenuCommands.kNotAttachedToChar");
		error(`format -s $clip $errorStr`);
	}
}

global proc
clipInstanceMenuCommand( string $source )
{
	string $characters[] = `clip -q -ch $source`;
	if (size($characters) == 0)
	{
		string $errorStr = uiRes("m_clipMenuCommands.kNotAttachedToChar");
		error(`format -s $source $errorStr`);
	}

	string $curTime = `currentTime -query`;

	// Schedule an instance of the clip.
	for ( $character in $characters ) 
	{
		string $sch  = `character -q -sc $character`;
		string $cmd  = `format -s $curTime -s $source -s $sch "clipSchedule -start ^1s -allAbsolute -in ^2s ^3s"`;
		string $clip = eval( $cmd );
		ghostAppendedClip $sch { $clip, $clip } 0;
	}
}

global proc
clipCopyMenuCommand(string $clip)
{
	string $cmdString = ("clip -copy "+$clip);
	evalEcho($cmdString);
}
