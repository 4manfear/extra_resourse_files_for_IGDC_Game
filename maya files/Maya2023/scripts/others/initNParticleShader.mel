// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
global proc setupFluidShaderForParticles( string $fluid )
{
	setAttr ($fluid + ".densityMethod") 0;
	setAttr ($fluid + ".velocityMethod") 0;
	setAttr ($fluid + ".shadedDisplay") 0;
	setAttr ($fluid + ".boundaryDraw") 5;
	setAttr ($fluid + ".opacityInput") 4;
	setAttr ($fluid + ".selfShadowing") 1;
	setAttr ($fluid + ".opacityTexture") 1;
	setAttr ($fluid + ".opacityTexGain") 0.5;
	setAttr ($fluid + ".dropoffShape") 0;
	setAttr ($fluid + ".frequency") 4;
	setAttr ($fluid + ".opacityInputBias") -0.2;
	setAttr ($fluid + ".opacity[0].opacity_Position") 0.1;
	setAttr ($fluid + ".depthMax") 2;
	setAttr ($fluid + ".quality") 0.5;
	setAttr ($fluid + ".contrastTolerance") 0.02;
	setAttr ($fluid + ".inflection") 1;
}

global proc setupWaterShaderForParticles( string $blinn )
{
	setAttr ($blinn+".specularRollOff") 0.2;
	setAttr ($blinn+".diffuse") 0.5;
	setAttr ($blinn+".refractions") 1;
	setAttr ($blinn+".refractiveIndex") 1.3;
	setAttr ($blinn+".reflectivity") 1;
	setAttr ($blinn+".specularColor") -type double3 1 1 1 ;
}

global proc initNParticleShader(string $nParticle, string $style )
{
	string $shadingGroup = ("nParticle" + $style + "SE");
	int $createNew = true;
	if( !objExists( $shadingGroup )){
		$shadingGroup = `sets -renderable true -noSurfaceShader true -empty -name $shadingGroup`;
		// create a shading group for this preset type
		string $smplers[] = `ls -type particleSamplerInfo`;
		string $particleSampler = "";
		if( size( $smplers ) > 0 ){
			$particleSampler = $smplers[0];
		} else {
			$particleSampler = `createNode "particleSamplerInfo"`;
		}
		
		string $surfaceShad = "";
		string $volumeShad = "";
		int $fluidVolume = ($style == "ThickCloud");
		$surfaceShad = `shadingNode -asShader -name ("np"+$style+"Blinn") "blinn"`;

		if( $fluidVolume ){
			$volumeShad = `shadingNode -asShader -name ("np"+$style+"Fluid") "fluidShape"`;
		} else {
			$volumeShad = `shadingNode -asShader -name ("np"+$style+"Volume") "particleCloud"`;
		}
		connectAttr -f ($surfaceShad + ".outColor") ($shadingGroup+".surfaceShader");
		connectAttr -f ($volumeShad + ".outColor") ($shadingGroup+".volumeShader");
		
		if( $style == "Points" ){
			
		} else if ($style == "Balls"){

		} else if ($style == "Cloud"){

		} else if ($style == "ThickCloud"){
			setupFluidShaderForParticles( $volumeShad );
		} else if ($style == "Water"){
			setupWaterShaderForParticles( $surfaceShad );
		}
		
		
		connectAttr ($particleSampler + ".outColor") ($surfaceShad + ".color");
		connectAttr ($particleSampler + ".outTransparency") ($surfaceShad + ".transparency");
		connectAttr ($particleSampler + ".outIncandescence") ($surfaceShad + ".incandescence");
		
		connectAttr ($particleSampler + ".outTransparency") ($volumeShad + ".transparency");
		if( $fluidVolume ){
			connectAttr ($particleSampler + ".outColor") ($volumeShad + ".color[0].color_Color");
			connectAttr ($particleSampler + ".outIncandescence") ($volumeShad + ".incandescence[0].incandescence_Color");
		} else {
			connectAttr ($particleSampler + ".outColor") ($volumeShad + ".color");
			connectAttr ($particleSampler + ".outIncandescence") ($volumeShad + ".incandescence");	
		}
	}
	sets -e -forceElement $shadingGroup $nParticle;
}
