// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//

// 
// This procedure is used to create a new outliner panel, which should replace the given panel
//
global proc replaceCurrentPanelWithOutliner (string $targetPanel)
{
	// create a new outliner panel..
	OutlinerWindow;
	string $outlinerPanels[] = `getPanel -type outlinerPanel`;
	int $size = `size $outlinerPanels`;
	if($size >= 2) 
	{
		string $outliner = $outlinerPanels[$size-1];
		if($outliner != "" ) 
		{
			outlinerPanel -e -rp $targetPanel $outliner; 
		}
	}
}

// Make sure these procedures are defined so the menu commands below will
// be recognized.
// source "buildCameraSetLookthruMenu.mel";

global proc buildOtherPanelSubItemsNow (string $subMenuName, string $panelName)
{
    int $count = 0;
    string $label;

    string $panels[] = `getPanel -allPanels`;

    int $sz = size($panels);
    string $uiPanelNameList[];
    int $cntr = 0;
    for ($each in $panels) {
        $uiPanelNameList[$cntr] = `panel -q -label $each`;
        $cntr+=1;
    }

    $uiPanelNameList = sort($uiPanelNameList);
    $cntr = 0;
    string $sortedPanels[];

    for ($each in $uiPanelNameList) {
        $sortedPanels[$cntr] = `getPanel -withLabel $each`;
        $cntr+=1;
    }

    $panels = $sortedPanels;
    // Rebuild menu
    //
    setParent -m $subMenuName;

    popupMenu -e -deleteAllItems $subMenuName;

    string $command;
    string $item;
    int    $kNumItemsPerDivider = 3;

    $count = 0;
    int $createNodeCheck = 0;
    int $nodeEditorCheck = 0;
	int $outlinerCheck   = 0;
    for ($i in $panels) {

        $command = `getPanel -typeOf $i`;
        $label = `panel -q -label $i`;
        
        // Skip Top, Front, Side, and Persp Panels
        //
       if (($command != "modelPanel" ||
             ( (localizedPanelLabel("Top View")) != $label && (localizedPanelLabel("Front View")) != $label &&
             (localizedPanelLabel("Side View")) != $label && (localizedPanelLabel("Persp View")) != $label)) &&
            $command != "emptyPanel" && ($label != "ToggledOutliner") && ($label != "lightEditorLookThroughModelPanelLabel")) 
        {
            string $realType;
            if ($command == "scriptedPanel") {
                $realType = `scriptedPanel -q -type $i`;

                // Don't want obsolete panels
                //
                if ( `scriptedPanelType -q -obsolete $realType` )
                {
                    continue;
                }

            } else {
                $realType = $command;
            }

            if ($realType == "Stereo" && size( `ls -type "stereoRigFrustum"` ) == 0 )
            {
                continue;
            }

            if ($realType == "hyperGraphPanel")
            {
                continue;
            }

            // For now the preload reference editor should only be accessible
            // through the File > Open Scene Option Box
            //
            if ( $realType == "preloadReferenceEditorPanel" ) {
                continue;
            }

            // Don't put more than the first Create Node panel
            // in the menu (the first is the only one to reside
            // in the main window panels, the rest are independent
            // windows)
            //
            if( $realType == "createNodePanel" ) {
                if($createNodeCheck) {
                    continue;
                } else {
                    $createNodeCheck = 1;
                }
            }

            // Don't put more than the first Node Editor panel
            // in the menu (the first is the only one to reside
            // in the main window panels, the rest are independent
            // windows)
            //
            if( $realType == "nodeEditorPanel" ) {
                if($nodeEditorCheck) {
                    continue;
                } else {
                    $nodeEditorCheck = 1;
                }
            }

			if($command != "outlinerPanel") 
			{
			    if (($count > 0) && ($count % $kNumItemsPerDivider == 0)) {
					menuItem -divider true;
				}
				$item = `menuItem -label $label -ecr false
					-c ($command+" -e -rp "+$panelName+" "+$i)`;
			}
			else if(!$outlinerCheck)
			{
				if (($count > 0) && ($count % $kNumItemsPerDivider == 0)) {
					menuItem -divider true;
				}
				// there should only be one outliner entry in this menu..
				$item = `menuItem -label $label -ecr false
					-c ("replaceCurrentPanelWithOutliner " + $panelName)`;
			}

            // Highlight profiler
            if ( $realType == "profilerPanel" )
            {
                menuItem -e -version "2016" $item;
            }

            // Highlight 2017 panels
            if (    $realType == "shapePanel" 
                ||  $realType == "posePanel" 
                ||  $realType == "contentBrowserPanel" 
                ||  $realType == "timeEditorPanel" 
                )
            {
                menuItem -e -version "2017" $item;
            }
			if($realType != "outlinerPanel") 
			{
				// enable outliner entry all the time as a new outliner is created each time when is used..
				string $control = $i + "Window";
				if ( (`panel -q -to $i`) || (`workspaceControl -exists $control`) ) {
					menuItem -e -enable false $item;
				}
			}

			$continueCheck = 0;
			if($command != "outlinerPanel") {
				$count++;
			}
			else if(!$outlinerCheck) {
				$count++;
				$outlinerCheck = 1;
			}
			
        }
    }
}

global proc buildNamedArrangementsNow( string $menuName ) 
{
    string $configLabel;
    string $arrs[];
    int $i;
    int $nArr = 0;

    menu -e -deleteAllItems $menuName;
    setParent -m $menuName;

    $arrs = `getPanel -allConfigs`;
    $nArr = size($arrs);

    for ($i = 0; $i < $nArr; $i++) {
        $configLabel = `panelConfiguration -q -label $arrs[$i]`;
        if (localizedPanelLabel("Current Layout") != $configLabel) {
            menuItem -label $configLabel 
                -annotation (uiRes("m_buildPanelPopupMenu.kChangeLayoutAnnot"))
                -c ("setNamedPanelLayout \"" + $configLabel + "\"");
        }
    }

    menuItem -divider true;
    menuItem -label (uiRes("m_buildPanelPopupMenu.kEditLayouts")) 
        -annotation (uiRes("m_buildPanelPopupMenu.kEditLayoutsAnnot"))
        -c "panelEditor(uiRes(\"m_panelEditor.kLayouts\"))";
}
    
global proc tearOffCopyItemCmd(string $panelType, string $srcPanel) {

    string $cmd;
    string $type;

    if ("scriptedPanel" == $panelType) {
        $type = `scriptedPanel -q -type $srcPanel`;
        $cmd = ("scriptedPanel -toc "+ $srcPanel +" -type "+ $type);
        
    } else {
        $cmd = ($panelType + " -toc " + $srcPanel);
    }
    $newName = `eval $cmd`;

    panel -e -label (localizedPanelLabel(`interToUI $newName`)) $newName;
}

// To allow the addition of new categories into the Panels pulldown
// we keep a list of user-specified additions. The user adds a new
// category by calling addPanelCategory() and removes it via
// removePanelCategory(). Whenever the Panels pulldown is redrawn,
// a new button labelled using the category name is drawn.
//
global string $gCategoryName[];          // Name of category.
global string $gCategoryInsertAfter[];   // Button to insert after.
global string $gCategoryCmd[];           // MEL command for button.

// Description:  This procedure is called when user wants to tear
//      off a panel to put the content in a window.
//
global proc panelTearOff(string $paneType, string $panelName)
{
    // Make a special case for hyper graph panel.
    //
    if ($paneType == "scriptedPanel" && 
        `scriptedPanel -query -type $panelName` == "hyperGraphPanel")
    {
        hyperGraphWindow($panelName, "");
        return;
    }
    
    // For non-hyper-graph-panel, do a simple tear off.
    //
    string $cmd = $paneType + " -e -to " + $panelName; 
    eval($cmd);
}

global proc buildPanelItemsNow ( string $panelName, string $menuName )
{
    global string $gCategoryName[];
    global string $gCategoryInsertAfter[];
    global string $gCategoryCmd[];

    string $panelControl = `panel -q -control $panelName`;

    // if the menu name is specified, use it.  Otherwise, assume
    // it is the pop-up menu and build the name appropriately.
    //
    string $popMenuName;
    if ( $menuName == "" ){
        $popMenuName = ($panelControl + "|" + $panelName + "Pop1");
    } else {
        $popMenuName = $menuName;
    }
    string $panelType = `getPanel -typeOf $panelName`;
    string $itemName;

    setParent -m $popMenuName;  

    // The camera commands depend on the panel having focus for
    // getting the camera in the view.
    setFocus $panelName;

    if (0 != `menu -q -numberOfItems $popMenuName`) {
        if ($panelType == "modelPanel" && $menuName == "")
            menuItem -e -label `modelPanel -q -camera $panelName` menuTitle;

        menu -e -deleteAllItems $popMenuName;
    }

    // Titles are only needed for pop-up menu
    //
    if ( $menuName == "" ){
        if ($panelType == "modelPanel"){
            menuItem -label `modelPanel -q -camera $panelName` menuTitle;
        }
        else {
            menuItem -label `panel -q -label $panelName` menuTitle;
        }
        menuItem -divider true;
        menuItem -divider true;
    }

    string $menu;
    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kPerspective")) -subMenu true`;
    menuItem -e -postMenuCommand
        ("buildPerspLookthruMenu "+$menu+" "+$panelName) $menu;
    setParent -m ..;

    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kStereo")) -subMenu true`;
    menuItem -e -postMenuCommand
        ("buildStereoLookthruMenu "+$menu+" "+$panelName) $menu;
    setParent -m ..;

    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kOrthographic")) -subMenu true`;
    menuItem -e -postMenuCommand
        ("buildOrthoLookthruMenu "+$menu+" "+$panelName) $menu;
    setParent -m ..;

    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kLookThroughSelected"))
        -command ("lookThroughSelected 0 " + $panelName)`;
        
    // If a cameraSet is being viewed disable this menu item.
    string $cameraSetUsed = false;
    if ($panelType == "modelPanel")
    {
        string $chosenCameraSet = `modelEditor -q -cameraSet $panelName`;
        if ($chosenCameraSet != "")
        {
            $cameraSetUsed = true;
            menuItem -e -enable false $menu;
        }
    }


    $menu = `menuItem -optionBox true
        -annotation (uiRes("m_buildPanelPopupMenu.kLookThroughAnnot"))
        -c ("lookThroughSelected 1 " + $panelName )`;
    if ($cameraSetUsed)
        menuItem -e -enable false $menu;


    if ( `getenv ENABLE_DEFAULT_VIEWPORT_CAMERA_SETS` == 1 ) { 
        $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kCameraSet")) -subMenu true`;
        menuItem -e -postMenuCommand
            ("buildCameraSetLookthruMenu "+$menu+" "+$panelName) $menu;
        setParent -m ..;
    }

    menuItem -divider true;

    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kPanel")) -subMenu true`;
    menuItem -e -postMenuCommand
        ("buildOtherPanelSubItemsNow "+$menu+" "+$panelName) $menu;
    setParent -m ..;

    // Hypergraph panels
    //
    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kHypergraphPanel")) -subMenu true`;
    menuItem -e -postMenuCommand
        ("buildPanelHypergraphSubMenu "+$menu+" "+$panelName) $menu;
    setParent -m ..;

    menuItem -label (uiRes("m_buildPanelPopupMenu.kLayouts")) -subMenu true -tearOff true;
        menuItem -label (localizedPanelLabel("Single Pane")) -command "SingleViewArrangement"
            -annotation (getRunTimeCommandAnnotation("SingleViewArrangement"));

        menuItem -label (localizedPanelLabel("Two Panes Side by Side")) -command "TwoSideBySideViewArrangement"
            -annotation (getRunTimeCommandAnnotation("TwoSideBySideViewArrangement"));
        menuItem -label (localizedPanelLabel("Two Panes Stacked")) -command "TwoStackedViewArrangement"
            -annotation (getRunTimeCommandAnnotation("TwoStackedViewArrangement"));

        menuItem -label (localizedPanelLabel("Three Panes Split Top")) -command "ThreeTopSplitViewArrangement"
            -annotation (getRunTimeCommandAnnotation("ThreeTopSplitViewArrangement"));
        menuItem -label (localizedPanelLabel("Three Panes Split Left")) -command "ThreeLeftSplitViewArrangement"
            -annotation (getRunTimeCommandAnnotation("ThreeLeftSplitViewArrangement"));
        menuItem -label (localizedPanelLabel("Three Panes Split Bottom")) -command "ThreeBottomSplitViewArrangement"
            -annotation (getRunTimeCommandAnnotation("ThreeBottomSplitViewArrangement"));
        menuItem -label (localizedPanelLabel("Three Panes Split Right")) -command "ThreeRightSplitViewArrangement"
            -annotation (getRunTimeCommandAnnotation("ThreeRightSplitViewArrangement"));

        menuItem -label (localizedPanelLabel("Four Panes")) -command "FourViewArrangement"
            -annotation (getRunTimeCommandAnnotation("FourViewArrangement"));

        menuItem -divider true;

        menuItem -label (uiRes("m_buildPanelPopupMenu.kPreviousArrangement")) -command "PreviousViewArrangement"
            -annotation (getRunTimeCommandAnnotation("PreviousViewArrangement"));
        menuItem -label (uiRes("m_buildPanelPopupMenu.kNextArrangement")) -command "NextViewArrangement"
            -annotation (getRunTimeCommandAnnotation("NextViewArrangement"));

    setParent -menu ..;

    $menu = `menuItem -label (uiRes("m_buildPanelPopupMenu.kSavedLayouts")) -subMenu true`;
    menuItem -e -pmc ("buildNamedArrangementsNow " + $menu) $menu;
    setParent -m ..;


    menuItem -divider true;

    string $cmd = "panelTearOff " + $panelType + " " + $panelName + "; fillEmptyPanes;";
    string $evalCmd = "evalDeferred(\"" + $cmd + "\");";
    menuItem -label (uiRes("m_buildPanelPopupMenu.kTearOff")) -ecr false -c $evalCmd;
    $itemName = `menuItem -label (uiRes("m_buildPanelPopupMenu.kTearOffCopy")) -ecr false 
                        -c ("tearOffCopyItemCmd " +$panelType + " " + $panelName)`;
    if (`panel -q -iu $panelName`) {
        menuItem -e -enable false $itemName;
    }

    menuItem -divider true;

    menuItem -label (uiRes("m_buildPanelPopupMenu.kPanelEditor")) -c "panelEditor \"Panels\"";
    
    //  Create Context Sensitive Help Menu.
    //
    if (hasContextHelpProc($panelName))
    {
        doHelpSubMenu $panelName $menuName;
    }//if

    // At this point, menu has just been created, add any additional
    // user-defined categories.
    //
    int $i, $j;
    int $nc = size( $gCategoryName );
    string $insertAfter = "";
    for ( $i = 0; $i < $nc; $i++ ) {
        // Find the button to insert after.
        //
        string $items[] = `menu -q -ia $popMenuName`;
        int $ni = size( $items );
        for ( $j = 0; $j < $ni; $j++ ) {
            int $divider = `menuItem -q -d $items[$j]`;
            if ( $divider ) {
                continue;
            }
            string $label = `menuItem -q -l $items[$j]`;
            if ( $label == $gCategoryInsertAfter[$i] ) {
                $insertAfter = $items[$j];
                break;
            }
        }

        // Add the new button after the "insert after" button.
        if ( $j >= $ni ) {
            string $msg = (uiRes("m_buildPanelPopupMenu.kCategoryNotFound"));
            error `format -s $gCategoryInsertAfter[$i] $msg`;
            return;
        }
        $menu = `menuItem -l $gCategoryName[$i] -subMenu true -ia $insertAfter`;
        menuItem -e -postMenuCommand
            ($gCategoryCmd[$i]+" "+$menu+" "+$panelName) $menu;
        setParent -m ..;
    }
}

global proc buildPanelPopupMenu (string $panelName) {

    // Build the common menu if it has not already been
    // built. (and this is not a torn-off panel)
    //

	// For workspaces, add panels menu only to panels in Main Pane..
	global string $gViewportWorkspaceControl;

	// this would get all parents of the panel, we only want the top level parent & check if it's MainPane or not.
	string $parent = `panel -q -ctl $panelName`;
	string $tokenizedString[];
	int $isMainPanePanel = 0;
	int $numOfTokens = `tokenize $parent "|" $tokenizedString`;
	if($numOfTokens) {
		$isMainPanePanel = ($tokenizedString[0] == $gViewportWorkspaceControl) ;
	}

    if ( $isMainPanePanel ) 
	{
        string $panelControl = `panel -q -control $panelName`;
        if ( `menuBarLayout -exists $panelControl` ){
            setParent $panelControl;
            string $ma[] = `menuBarLayout -q -menuArray $panelControl`;
            int $found = 0;
            int $i;
            for ( $i=0; $i<size($ma) && $found == 0; $i++ ){
                if ( $ma[$i] == "Panels" ){
                    $found = 1;
                }
            }
            if ( $found == 0 ){
                setParent $panelControl;
                string $menuName = `menu -helpMenu true 
                            -allowOptionBoxes 1
                            -label (uiRes("m_buildPanelPopupMenu.kPanels")) 
                            -familyImage "menuIconPanels.png"
                            Panels`;
                menu -e -pmc ("buildPanelItemsNow "+$panelName+" "+$menuName) $menuName;
            }
        }
    } else {
        string $panelControl = `panel -q -control $panelName`;
        if ( `menuBarLayout -exists $panelControl` ){
            setParent $panelControl;
            string $ma[] = `menuBarLayout -q -menuArray $panelControl`;
            int $found = 0;
            int $i;
            //   Check for existing Help Menu.
            //
            for ( $i=0; $i<size($ma) && $found == 0; $i++ ){
                if ( $ma[$i] == "HelpMenu" ){
                    $found = 1;
                }
            }
            if ( $found == 0 ){
                doHelpMenu($panelName,$panelControl);
            }
        }
    }
}
