// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  20 Feb 2002
//
//  Description:
//      Time changes trigger an expression which sets the
//		cache name to the correct segment when using segmented
//		cache files.  
//
global proc updateCacheSegmentAtCurrentTime( string $cacheNode, 
											 string $namingPrefix ) 
{
	verifyWorkspaceFileRule( "diskCache", "data" );
	string $diskCacheDir = ( `workspace -q -rootDirectory` + 
	                         `workspace -fileRuleEntry "diskCache"` );

	// Find the expression connected to the cacheNode and back up
	// one level to get the animCurve.
	//
	string $connections[] = `listConnections -d false ($cacheNode + ".segmentStartFrame")`;
	if( size( $connections ) ) {
		$connections = `listConnections -d false ($connections[0] + ".segmentStartFrame")`;

		string $animCurve;
		if( size( $connections ) ) {
			$animCurve = $connections[0];
		}
		
		if( size( $animCurve ) ) {
			float  $time      = `currentTime -q`;
			float  $val[]     = `keyframe -t $time -q -eval $animCurve`;

			string $cacheName = `getAttr( $cacheNode + ".cacheName" )`;
			string $segName   = fluidCacheSegmentizeName( $cacheNode, $val[0], $namingPrefix );
			
			string $segFile = $diskCacheDir + "/" + $segName;
			
			if( `file -q -exists $segFile` ) {
				setAttr -type "string" ( $cacheNode + ".cacheName" ) $segFile;
			}

			// We're here because time changed.  If time changing caused
			// us to swap in a different segment of the cache file, the
			// fluid won't update because it thinks it already has (since 
			// the current frame isn't part of the swapped-out cache file).
			// We'll need to kick the fluid to update from the new cache file
			// name.
			//
			if( $cacheName != $segName ) {
				// Yes, this would normally cause another evaluation of
				// the expression, which would bring us back into this
				// MEL proc, but we will only execute this the FIRST time
				// the fluid evaluates from the swapped in cache file.
				//
				currentTime `currentTime -q`;
			}
		}
	}
}

