// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// ===========================================================================
//
//  Procedure Name:
//      texSnapPoints
//
//  Description:
//      UV workflow function used for snapping UV shells to each other by 
//      snapping point A to point B.
//
//  Input Arguments
//      None.
//
//  Return Value:
//      None.
//
//  Notes:
//  This script is part of the implementation of Nightshade UV Editor into
//  Autodesk Maya. For testing purposes, keep the source commands at the top
//  and then just source this entire script.
//
// ===========================================================================


global proc texSnapPoints(int $snapDirection)
{
	// Get original selection
	string $selection[] = `ls -selection`;
	string $compSelType = `getComponentMask`;

	string $selectedItems[] = `filterExpand -ex false -sm 35`;
	if (size($selectedItems) == 0)
	{
		// If Convert Selection is ON, try to convert the current selection to uvs.
		int $val = `optionVar -q polyAutoConvertAction`;
		if ( 1 == $val ) {
			PolySelectConvert 4;
			$selectedItems = `filterExpand -ex false -sm 35`;
		}

		// Check if the set of uvs is still empty.
		if (size($selectedItems) == 0) {
			error((uiRes("m_texSnapPoints.kNoUVsSelected")));
			return;
		}
	}

	if (size($selectedItems) != 2) {
		error((uiRes("m_texSnapPoints.kSelectTwoUVs")));
		setComponentMask($compSelType); 
		select -replace $selection;
		return;
	}

	string $selectedUVs[] = `ls -selection -flatten`;

	// Get U and V distances
	float $uvBox[] = `polyEvaluate -boundingBoxComponent2d`;
	float $distU = abs( $uvBox[1] - $uvBox[0] );
	float $distV = abs( $uvBox[3] - $uvBox[2] );

	// Store coordinate info
	float $pointA[] = `polyEditUV -q $selectedUVs[0]`;
	float $pointB[] = `polyEditUV -q $selectedUVs[1]`;

    // Snap A to B
	if ($snapDirection == 0)
	{
		// Shell position correction
		if ($pointA[1] > $pointB[1])
			$distV = -$distV;
		if ($pointA[0] > $pointB[0])
			$distU = -$distU;

		// Select UV from first shell
		select -replace $selectedUVs[0];
	}
	// Snap B to A 
	else
	{
		// Shell position correction
		if ($pointA[0] < $pointB[0])
			$distU = -$distU;
		if ($pointA[1] < $pointB[1])
			$distV = -$distV;

		// Select UV from second shell
		select -replace $selectedUVs[1];
	}

	// Move the shell
	polyEditUVShell
		-relative true
		-uValue $distU
		-vValue $distV
	;

	//restore the original component mask	
	setComponentMask($compSelType); 

	//select the original selection
	select -replace $selection;
}
