// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//  Proc:   polyMirror
//
//  Description:        
//
//		Mirror a poly object, by extruding and reverse scaling
//		Cleanup by collapsing the zero area edges.
//		To avoid confusion, the default mirroring (duplicate-negativeScale)
//		that does not merge the two objects is also provided as an option.
//
//	Usage:
//
//		polyMirror 1 0 0 0;	// Mirror along X, and dont stitch
//		polyMirror 0 0 1 1;	// Mirror along Z, merge overlapping verts
//		polyMirror 0 0 1 2;	// Mirror along Z, connect border edges
//	

global proc polyMirror(int $x, int $y, int $z, int $stitch)
{
	if ($x == -1) $x = 1; else if ($x == 1) $x = -1; else if ($x != 0) {
		error((uiRes("m_polyMirror.kErrorXDir")));
	}
	if ($y == -1) $y = 1; else if ($y == 1) $y = -1; else if ($y != 0) {
		error((uiRes("m_polyMirror.kErrorYDir")));
	}
	if ($z == -1) $z = 1; else if ($z == 1) $z = -1; else if ($z != 0) {
		error((uiRes("m_polyMirror.kErrorZDir")));
	}
	if ( ($x && $y) || ($y && $z) || ($z && $x) ) {
		warning((uiRes("m_polyMirror.kWarnMirror2Dir")));
	}

	string $cmd;

	// Get the name of the polyObject first...
	string $lis[]=`ls -sl`;
	if (size($lis) == 0) {
		error((uiRes("m_polyMirror.kEmptySelList")));
		return;
	}
	int $polyO = 0, $polyC = 0;
	string $filterInput[];

	$filterInput=`filterExpand -ex true -fp on -sm 12`;
	if (size($filterInput) > 0) $polyO = 1;

	if (!$polyO) {
		$filterInput=`filterExpand -ex true -sm 31 -sm 32 -sm 34 -sm 35`;
		if (size($filterInput) > 0) $polyC = 1;

		if ($polyC) {
			error((uiRes("m_polyMirror.kErrorPolyMirrorObj")));
        	return;
		}
		error((uiRes("m_polyMirror.kErrorNoPolyObj")));
        return;
	}
	$lis = $filterInput;
	if (size($lis) > 1) {
		warning((uiRes("m_polyMirror.kWarnMultipleObjs")));
	}
	getBorderEdges($lis[0]);
	string $bEdges[]=`ls -sl`;
	if (($stitch) && (size($bEdges) == 0)) {
		warning((uiRes("m_polyMirror.kWarnStichClosed")));
		$stitch = 0;
	}
	select -r $lis[0];

	if (2 == $stitch) {
		$cmd = "polyExtrudeFacet -ch 1 -kft 1 ";
	} else {
		$cmd = "polyChipOff -ch 1 -kft 1 ";
	}

	string $shapes[];
	if (`nodeType $lis[0]` != "mesh") {
		$shapes = `listRelatives -s -c -f -ni`;
	} else {	
		$shapes = $lis;
	}
	string $selError = (uiRes("m_polyMirror.kErrorNoMesh"));
	string $nType;
	if (size($shapes) == 0) {
		$nType=`nodeType $lis[0]`;
		if ($nType == "transform") {
			error((uiRes("m_polyMirror.kErrorTransformNodes")));
        	return;
		}
		error($selError);
        return;
    }
	$nType=`nodeType $shapes[0]`;
	if ($nType != "mesh") {
		error($selError);
        return;
	}	
	string $shape = $shapes[0];
	string $unknownError = (uiRes("m_polyMirror.kErrorUnknown"));
	string $test=$lis[0];
	string $bufVal[];
	tokenize $test "." $bufVal;
	if (size($bufVal) == 0) {
        error($unknownError);
        return;
    }
	string $polyObj=$bufVal[0];

	float $bb[] = `polyEvaluate -b`;
	if (size($bb) < 6) {
		error($unknownError);
        return;
	}
	float $xmin = $bb[0];	
	float $xmax = $bb[1];
	float $ymin = $bb[2];	
	float $ymax = $bb[3];
	float $zmin = $bb[4];	
	float $zmax = $bb[5];
	float $xcen = ($xmin + $xmax) / 2.0;
	float $ycen = ($ymin + $ymax) / 2.0;
	float $zcen = ($zmin + $zmax) / 2.0;

	float $xwidth = ($xmax - $xmin);	// will always be positive
	float $ywidth = ($ymax - $ymin);	// will always be positive
	float $zwidth = ($zmax - $zmin);	// will always be positive
	
	select -r $shape;

	// get faces
	select -r `polyListComponentConversion -tf`;

	string $in[]=`ls -sl`;

	$cmd += " -pvx " + $xcen;
	$cmd += " -pvy " + $ycen;
	$cmd += " -pvz " + $zcen;
	$cmd += " -rx 0 -ry 0 -rz 0 -ran 0 -off 0 -ltz 0 -ws 0 -ltx 0 -lty 0 -lrx 0 -lry 0 -lrz 0 -lsx 1 -lsy 1 -lsz 1 -ldx 1 -ldy 0 -ldz 0 -w 0 -gx 0 -gy -1 -gz 0 -att 0 -mx 0 -my 0 -mz 0 ";
	if ($x == 0) $cmd += " -sx 1";
	else $cmd += " -sx -1";
	if ($y == 0) $cmd += " -sy 1";
	else $cmd += " -sy -1";
	if ($z == 0) $cmd += " -sz 1";
	else $cmd += " -sz -1";

	$cmd += " -tx " + $x*$xwidth;
	$cmd += " -ty " + $y*$ywidth;
	$cmd += " -tz " + $z*$zwidth;
	
	$cmd += " " + $in[0];

	eval($cmd);

	string $nullEdges[];
	if ($stitch) {
		if (2 == $stitch) {
			// Connect border edges. (done through extrude face)
			//
			$nullEdges = getZeroLengthEdges($polyObj);
		} else if (1 == $stitch) {
			// Merge Overlapping Vertices (It can only overlap on borders)
			//
			$nullEdges = getBorderEdges($polyObj);
		}
		// (Now merge overlapping vertices)
		// 
		string $coVertices[]=getVerts();
		if (size($coVertices) != 0) {
		    // Merge these vertices...
		    string $mergeCmd="polyMergeVertex -d 0.000001 -tx 1 -ch 1 ";
		    for ($i in $coVertices)
		        $mergeCmd += ($i + " ");
		    eval($mergeCmd);
		}
	}

	select -r $shape;

	// get faces
	select -r `polyListComponentConversion -tf`;

	if (2 == $stitch) {
		// If extruded, the normals of the entire object has to be
		// reversed back
		;
	} else {
		// Deselect the original faces...
  		select -tgl $in[0];
	}

	// Reverse the normals of the current selection...
	polyNormal -normalMode 0;
	select -r $shape;
}
