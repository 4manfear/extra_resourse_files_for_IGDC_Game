// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc manipMoveBakeOrientation()
{
	if (`manipMoveContext -q -bakePivotOri Move`) {
		float $ori[] = `manipMoveContext -q -orientAxes Move`;
		$ori[0] = rad_to_deg($ori[0]);
		$ori[1] = rad_to_deg($ori[1]);
		$ori[2] = rad_to_deg($ori[2]);
		if (`bakeCustomOrient $ori[0] $ori[1] $ori[2]`) {
			manipMoveContext -e -mode 0 Move; // Set to object space
		}
	}
}

global proc manipMovePointHandleTowards(string $point, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	// Restore symmetry
	if ($restoreSymmetry) {
	   symmetricModelling -s 1;
	}

	// Restore component mask	
	if (size($compSelType) > 0) {
		string $selCmd = "selectType ";
		int $objectMode = `selectMode -q -o`;
		if ($objectMode) $selCmd += "-ocm ";
		if ($compSelType == "none") {
			$selCmd += "-alc 0";
		} else {
		    $selCmd += "-" + $compSelType + " 1";
		}
		eval($selCmd);
	}

	// Restore original hilite
	if (size($originalHilite[0]) > 0) {
		hilite $originalHilite;
	}
	
	// Restore original selection
	if(size($originalSelection[0]) > 0) {
		print($originalSelection);
		select $originalSelection;
	}
	
	// Make Move tool current
	setToolTo Move;

	// Get wold position of point
	float $pos[] = `pointPosition $point`;
	
	// Set options on the move manip
	manipMoveContext -edit -mode 6 -orientTowards $pos[0] $pos[1] $pos[2] Move;
	manipMoveBakeOrientation;
}

global proc manipMoveAlignHandleWith(string $object, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	int $doIt = false;
	string $typedObject[];
	string $verts[];
	float $vFrom[], $vTo[];

	int $haveVerts = false;
	int $haveObject = false;

	// See if we are dealing with polygon face
	$typedObject = `filterExpand -expand on -selectionMask 34 $object`;
	if(size($typedObject) > 0) {
		// Poly face
		$haveObject = true;
	} else {
		// See if we dealing with polygon edge
		$typedObject = `filterExpand -expand on -selectionMask 32 $object`;
		if(size($typedObject) > 0) {
			// Poly edge
			$haveObject = true;
		} else {
			// See if we dealing with subd edge
			$typedObject = `filterExpand -expand on -selectionMask 37 $object`;
			if(size($typedObject) > 0) {
				// Get the vertices from edge
				$verts = `subdListComponentConversion -fromEdge -toVertex $typedObject[0]`;
				$haveVerts = true;
			} 
		}
	}

	if(!$haveObject && !$haveVerts) {
		error (uiRes("m_manipMoveOrient.kInvalidSelection"));
		return;
	}

	if($haveVerts) {
		// Flatten verts selection in case they are compressed
		select -r $verts;
		$verts = `ls -sl -fl`;
		
		// We should get 2 verts
		if(size($verts) == 2) {
			$vFrom = `pointPosition $verts[0]`;
			$vTo = `pointPosition $verts[1]`;

			$vTo[0] -= $vFrom[0];
			$vTo[1] -= $vFrom[1];
			$vTo[2] -= $vFrom[2];
			
			$doIt = true;
		}
	} else if ($haveObject) {
		$doIt = true;
	}

	// Restore symmetry
	if ($restoreSymmetry) {
	   symmetricModelling -s 1;
	}

	// Restore component mask	
	if (size($compSelType) > 0) {
		string $selCmd = "selectType ";
		int $objectMode = `selectMode -q -o`;
		if ($objectMode) $selCmd += "-ocm";
		if ($compSelType == "none") {
			$selCmd += "-alc 0";
		} else {
		    $selCmd += "-" + $compSelType + " 1";
		}
		eval($selCmd);
	}

	// Restore original hilite
	if (size($originalHilite[0]) > 0) {
		hilite $originalHilite;
	}
	
	// Restore original selection
	if(size($originalSelection[0]) > 0) {
		print($originalSelection);
		select $originalSelection;
	}
	
	// Make Move tool current
	setToolTo Move;

	if($doIt) {
		if ($haveObject) {
			manipMoveContext -edit -mode 6 -orientObject $object Move;
		} else {
			manipMoveContext -edit -mode 6 -alignAlong $vTo[0] $vTo[1] $vTo[2] Move;
		}
		manipMoveBakeOrientation;
	}
}

global proc manipMoveAlignHandleToComponent(string $component, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	string $typedObject[];

	// 1) Polygon Face
	$typedObject = `filterExpand -expand on -selectionMask 34 $component`;
	if (size($typedObject) > 0) {
		manipMoveAlignHandleWith($component, $originalSelection, $originalHilite, $compSelType, $restoreSymmetry);
		return;
	}

	// 2) Polygon Edge
	$typedObject = `filterExpand -expand on -selectionMask 32 $component`;
	if (size($typedObject) > 0) {
		manipMoveAlignHandleWith($component, $originalSelection, $originalHilite, $compSelType, $restoreSymmetry);
		return;
	}

	// 3) Point or other component
	manipMovePointHandleTowards($component, $originalSelection, $originalHilite, $compSelType, $restoreSymmetry);
}

global proc manipMoveAlignHandleToObject(string $object, string $originalSelection[], string $originalHilite[], string $compSelType, int $restoreSymmetry) 
{
	float $vRot[];
	int $doIt = false;

    string $xform = $object;
	string $tmp[] = `ls -tr $xform`;
	if( size($tmp) == 0 ) {
		$tmp = `listRelatives -p $xform`;
		if (size($tmp) > 0) {
			$xform = $tmp[0];
		}
    }

	if ($xform != "") {
		$doIt = true;
	}

	// Restore symmetry
	if ($restoreSymmetry) {
	   symmetricModelling -s 1;
	}

	// Restore component mask	
	if (size($compSelType) > 0) {
		string $selCmd = "selectType ";
		int $objectMode = `selectMode -q -o`;
		if ($objectMode) $selCmd += "-ocm";
		if ($compSelType == "none") {
			$selCmd += "-alc 0";
		} else {
		    $selCmd += "-" + $compSelType + " 1";
		}
		eval($selCmd);
	}

	// Restore original hilite
	if (size($originalHilite[0]) > 0) {
		hilite $originalHilite;
	}
	
	// Restore original selection
	if(size($originalSelection[0]) > 0) {
		print($originalSelection);
		select $originalSelection;
	}
	
	// Make Move tool current
	setToolTo Move;

	if ($doIt) {
		manipMoveContext -edit -mode 6 -orientObject $xform Move;
		manipMoveBakeOrientation;
	}
}

// This procedure creates a script context that allows user to select point in the scene
// and orients current handle of the move manipulator so it points to it.
proc manipMovePointTo() 
{
	
	string $ctx;
	string $currentSelection[] = `ls -sl`;

	// Something has to be selected
	if(size($currentSelection[0]) == 0) {
		error((uiRes("m_manipMoveOrient.kOrientMoveManipNoSelectErr")));
	}

	string $cmd = "manipMovePointHandleTowards($Selection1[0], ";
	$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
	$cmd += "{}, \"\", 0);";

	string $pointMsg = (uiRes("m_manipMoveOrient.kOrientMoveManipPointPrompt"));
	$ctx = `scriptCtx
				-title (uiRes("m_manipMoveOrient.kOrientMoveManipMoveTo"))
				-toolStart "select -clear"
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of point allowed in selection
			// -----------------------------------
				-controlVertex on
				-editPoint on
				-polymeshVertex	on
				-locatorXYZ on
				-locator on
				-joint on
				-jointPivot on
				-scalePivot on
				-rotatePivot on
				-subdivMeshPoint on
				-latticePoint on
				-particle on
				-motionTrailPoint on
				-motionTrailTangent on
			// -----------------------------------
				-setNoSelectionPrompt $pointMsg
				-setNoSelectionHeadsUp $pointMsg
				-exitUponCompletion on
				-setAutoComplete on`;
			
	setToolTo $ctx;
}

// This procedure creates a script context that allows user to select face or edge in the scene
// and orients current handle of the move manipulator so it is parallel to the selected edge or the normal of selected face.
proc manipMoveAlignWith(string $component) 
{
	
	string $ctx;
	string $currentSelection[] = `ls -sl`;

	// Something has to be selected
	if(size($currentSelection[0]) == 0) {
		error (uiRes("m_manipMoveOrient.kNoSelection"));
	}

	string $cmd = "manipMoveAlignHandleWith($Selection1[0], ";
	$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
	$cmd += "{}, \"\", 0);";
	
	string $ctxTitle = (uiRes("m_manipMoveOrient.kOrientMoveManipAlignWith"));
	string $faceMsg = (uiRes("m_manipMoveOrient.kOrientMoveManipFace"));
	string $edgeMsg = (uiRes("m_manipMoveOrient.kOrientMoveManipEdge"));
	if ($component == "face"){
		$ctx = `scriptCtx
				-title $ctxTitle
				-toolStart "select -clear"
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of components allowed in selection
			// -----------------------------------
				-polymeshEdge off
				-polymeshFace on
				-subdivMeshEdge off
			// -----------------------------------
				-setNoSelectionPrompt $faceMsg
				-setNoSelectionHeadsUp $faceMsg
				-exitUponCompletion on
				-setAutoComplete on`;
	} else{//edge
		$ctx = `scriptCtx
				-title $ctxTitle
				-toolStart "select -clear"
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of components allowed in selection
			// -----------------------------------
				-polymeshEdge on
				-polymeshFace off
				-subdivMeshEdge on
			// -----------------------------------
				-setNoSelectionPrompt $edgeMsg
				-setNoSelectionHeadsUp $edgeMsg
				-exitUponCompletion on
				-setAutoComplete on`;				
				
	}
			
	setToolTo $ctx;
}


proc manipMoveAlignComponent(string $component) 
{
	string $ctx;
	string $currentSelection[] = `ls -sl`;

	// Something has to be selected
	if(size($currentSelection[0]) == 0) {
		error((uiRes("m_manipMoveOrient.kOrientMoveManipComponentNoSelectErr")));
	}

	string $currentHilite[] = `ls -hl`;
	int $objectMode = `selectMode -q -o`;
	string $ocm = ($objectMode ? "-ocm " : "");
	int $restoreSymmetry = `symmetricModelling -q -s`;

	// Save component selectType
	string $compSelType = "";
	string $selQuery = "selectType -q " + $ocm;
	if (eval($selQuery + "-vertex")) $compSelType = "vertex";
	else if (eval($selQuery + "-edge")) $compSelType = "edge";
	else if (eval($selQuery + "-facet")) $compSelType = "facet";
	else if (eval($selQuery + "-meshComponents")) $compSelType = "meshComponents"; 
	else if (eval($selQuery + "-cv")) $compSelType = "cv";
	else $compSelType = "none";

	// Build setup command
	string $titleMsg = (uiRes("m_manipMoveOrient.kOrientMoveManipComponentMoveTo"));
	if ($component == "object") {
		string $startCmd = "";
		$startCmd += "selectType " + $ocm + "-alc 0;";
		$startCmd += "selectMode -o;";
		$startCmd += "select -clear;";
		if ($restoreSymmetry) $startCmd += "symmetricModelling -s 0;";

		// Build final command
		string $cmd = "manipMoveAlignHandleToObject($Selection1[0], ";
		$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
		$cmd += "{\"" + stringArrayToString($currentHilite, "\", \"") + "\"}, ";
		$cmd += "\"" + $compSelType + "\", " + $restoreSymmetry + ");";

		string $objectMsg = (uiRes("m_manipMoveOrient.kOrientMoveManipObjectPrompt"));
		$ctx = `scriptCtx
				-title $titleMsg
				-toolStart $startCmd
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of point allowed in selection
			// -----------------------------------
				-allObjects 1
				-allComponents 0
				-controlVertex 0
				-editPoint 0
				-polymeshVertex	0
				-polymeshEdge 0
				-polymeshFace 0
				-locatorXYZ 1
				-locator 1
				-joint 1
				-jointPivot 0
				-scalePivot 0
				-rotatePivot 0
				-subdivMeshPoint 0
				-latticePoint 0
				-particle 0
				-motionTrailPoint 0
				-motionTrailTangent 0
			// -----------------------------------
				-setNoSelectionPrompt $objectMsg
				-setNoSelectionHeadsUp $objectMsg
				-exitUponCompletion on
				-setAutoComplete on`;
	} else {
		// Components
		string $startCmd = "";
		if (size($currentHilite) == 0) $startCmd += "hilite;";
		$startCmd += "selectType " + $ocm + "-alc 0;";
		$startCmd += "selectType " + $ocm + "-" + $component + " 1;";
		$startCmd += "select -clear;";
		if ($restoreSymmetry) $startCmd += "symmetricModelling -s 0;";

		// Build final command
		string $cmd = "manipMoveAlignHandleToComponent($Selection1[0], ";
		$cmd += "{\"" + stringArrayToString($currentSelection, "\", \"") + "\"}, ";
		$cmd += "{\"" + stringArrayToString($currentHilite, "\", \"") + "\"}, ";
		$cmd += "\"" + $compSelType + "\", " + $restoreSymmetry + ");";

		int $multi = ($component == "meshComponents");
		int $verts = ($multi || $component == "vertex");
		int $edges = ($multi || $component == "edge");
		int $faces = ($multi || $component == "facet");

		string $pointMsg = (uiRes("m_manipMoveOrient.kOrientMoveManipComponentPrompt"));
		$ctx = `scriptCtx
				-title $titleMsg
				-toolStart $startCmd
				-finalCommandScript $cmd
				-showManipulators off
				-totalSelectionSets 1
				-setSelectionCount 1
			// Types of point allowed in selection
			// -----------------------------------
				-controlVertex on
				-editPoint on
				-polymeshVertex	$verts
				-polymeshEdge $edges
				-polymeshFace $faces
				-locatorXYZ on
				-locator on
				-joint on
				-jointPivot on
				-scalePivot on
				-rotatePivot on
				-subdivMeshPoint on
				-latticePoint on
				-particle on
				-motionTrailPoint on
				-motionTrailTangent on
			// -----------------------------------
				-setNoSelectionPrompt $pointMsg
				-setNoSelectionHeadsUp $pointMsg
				-exitUponCompletion on
				-setAutoComplete on`;
	}		
	setToolTo $ctx;
}

// This procedure creates context to allow orient axis of move manipulator
// relative to existing objects in the scene.
// It orients selected handle based on the specified mode.
// Possible modes:
//		1 - point to vertex;
//		2 - align with edge;
//		3 - align with face normal;
//		4 - align to multi component (vertex/edge/face)
//		5 - align to object

global proc manipMoveOrient(int $mode) 
{
	global int $manipOrientLast = 4;
	if ($mode == -1) $mode = $manipOrientLast;
	else if ($mode != 0) $manipOrientLast = $mode;

	switch($mode) {
	case 0:
		manipMoveContext -edit -orientAxes 0 0 0 Move;
		manipMoveBakeOrientation;
		break;
	case 1:
		manipMoveAlignComponent("vertex");
		break;
	case 2:
		manipMoveAlignComponent("edge");
		break;
	case 3:
		manipMoveAlignComponent("facet");
		break;
	case 4:
		manipMoveAlignComponent("meshComponents");
		break;
	case 5:
		manipMoveAlignComponent("object");
		break;
	}
}
