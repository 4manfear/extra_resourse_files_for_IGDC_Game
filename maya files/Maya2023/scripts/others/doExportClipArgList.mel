// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Nov, 1999
//
//	Procedure Name:
//		doExportClipArgList
//
//	Description:
//		Export a clip
//
//	Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//  
//	$args
//	Version 1
//  [0] 	$editor: name of TraxEditor window or "" if none
//	Version 2
//  [0] 	$editor: name of TraxEditor window or "" if none
//  [1] 	$clipName: name of clipName. If specified, this clip overrides the selected clips.
//
//
global string $gExpClipName = "";

global proc int
clipEditorExportClip(string $fileName, string $fileType)
{
	global string $gExpClipName;

	if ($fileName == "") {
		error( (uiRes("m_doExportClipArgList.kNoFileNameSpecified")) );
		return 0;
	}
	
	if ($fileType == "ma") {
		$fileType = "mayaAscii";
	} else if ($fileType == "mb") {
		$fileType = "mayaBinary";
	} else if ($fileType != "mayaBinary" && $fileType != "mayaAscii" && $fileType != "mayaPLE") {
		string $errMsg = (uiRes("m_doExportClipArgList.kInvalidFileTypeErr"));
		$errMsg = `format -s $fileType $errMsg`;
		error($errMsg);
		return 0;
	}
	
	int $ii;
	string $selClips[];
	if ($gExpClipName != "") {
		$selClips[0] = $gExpClipName;
	}
	else {
		$selClips = getSelectedClips("noOptions");
	}
	if (size($selClips) == 0) {
		error( (uiRes("m_doExportClipArgList.kSelectClipsExportErr")) );
	}

	string $sourceClips[];
	string $sourceClipsAll[];
	for ($clipName in $selClips) {
		string $sourceClipName = `clip -q -scn $clipName`;
		if ($sourceClipName != $clipName) {
			copyAbsoluteChannelsClipData($sourceClipName, $clipName);
		}

		int $found = AWNumberOfOccurrencesInStringArray($sourceClipName,$sourceClips);
		if (0 == $found) {
			$sourceClips[size($sourceClips)] = $sourceClipName;
		}
	}

	if (size($sourceClips) == 0) {
		error( (uiRes("m_doExportClipArgList.kFoundNoSourceErr")) );
		return 0;
	}
	
	// save the current selection to restore it at the end
	//
	string $sel[] = `ls -sl`;

	// create the command string
	//
	string $result[];
	string $isolateCmd = "clip -isolate";
	string $clipNames = "";
	for ($clip in $sourceClips) {
		$clipNames += (" -name "+$clip);
	}
	$isolateCmd += $clipNames;
	catch($result = eval($isolateCmd));

	if (size($result)) {
		// Cache the current prompt state of the file command and temporarily set it the 
		// file command to NOT prompt users about overwriting files.
		// This is safe to do since doExportClipArgList (defined below) uses fileBrowser 
		// to display a file dialog allowing the user to select (or enter) a file name.
		// If the users enters the name of an existing file, the dialog will take care of
		// confirm whether or not the file should be overwritten. If the user selects NOT
		// to overwrite the file, the dialog will continue to be display until the user 
		// either presses cancel or enters a new valid name.
		int $state = `file -q -prompt`;
		file -prompt 0;

		select -r $result;
		file -f -type $fileType -exportSelected -channels true -constructionHistory true $fileName;
		$lib = `ls -type clipLibrary $result`;
		if (size($lib))
			delete $lib;

		// reset the state of the file command at the time the helper was called.
		file -prompt $state;
	}

	// restore selection
	//
	select -r $sel;

	if (size($result) == 0) 
		error( (uiRes("m_doExportClipArgList.kUnableToExportErr")) );

	return 1;
}

global proc
doExportClipArgList( string $version, string $args[] )
{
	int $versionNo = $version;

	global string $gExpClipName;

	if ($versionNo > 1) {
		$gExpClipName  = $args[1];
	} else {
		$gExpClipName = "";
	}

	string $sc[] = (size($gExpClipName)) ?
		{ $gExpClipName } : 
		getSelectedClips("noOptions");

	if (size($sc) == 0)
		error( (uiRes("m_doExportClipArgList.kSelectTheClipErr")) );

	string $fileRule = `workspace -q -fre "clips"`;
	string $buffer[];
	tokenize($fileRule,";",$buffer);
	if (size($buffer) == 0) {
		$buffer[0] = "clips";
	}

	for ($buf in $buffer) {
		string $clipsDir = (`workspace -q -rd`+$buf+"\/");
		if (`file -q -ex $clipsDir`) {
			workspace -dir $clipsDir;
			break;
		}
	}

	// bring up the file browser dialog so that they can choose a file name
	//
	fileBrowser("clipEditorExportClip",(uiRes("m_doExportClipArgList.kExportClip")),"ma",1);
}
