// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
global proc int hasInGroupConnection( string $cnv, int $i )
{
	string $conn[] = `listConnections ($cnv + ".segGroupIds[" + $i + "]")`;
	if ( size($conn) > 0 ) { 
		return 1; 
	}

	return 0; 
}

global proc string[] assignGroupIds( string $baseName, string $cnv, 
									 string $mesh )
{
	string $groupList[]; 
	int $groupCount = 0;

	int $segCount = `getAttr ($cnv + ".segmentCount")`;
	int $mapIndex;
	int $i; 

	for ( $i = 0; $i < $segCount; $i++ ) { 
		if ( !hasInGroupConnection( $cnv, $i ) ) {
			string $name = ($baseName + "Segment" + $i);
			string $group = `createNode groupId -n $name`;
			string $gid = ($group + ".groupId"); 

			$groupList[$groupCount] = $group; 
			$groupCount = $groupCount + 1;

			string $instance = ".instObjGroups[0]";
			string $instOG = 
				($instance + ".objectGroups[" + $i + "]" + ".objectGroupId");
			
			string $cnvGI = ($cnv + ".segGroupIds[" + $i + "]"); 
			connectAttr -f $gid ($mesh + $instOG);
			connectAttr -f $gid $cnvGI; 
		}
	}

	return $groupList;
}

proc string fitToSelection( string $cnv  )
{
	string $sel[] = `ls -sl`;
	if ( size( $sel ) > 1 ) { 
		error (uiRes("m_createTextureToGeom.kTooManyMeshes")); 
	} else if ( size( $sel ) == 0 ) { 
		error (uiRes("m_createTextureToGeom.kNoMesh"));
	}

	string $theSel = $sel[0]; 
	string $theShape;
	if ( `nodeType $theSel` == "transform" ) { 
		string $obj[] = `listRelatives -ni -s $theSel`;
		if ( size( $obj ) > 1 ) { 
			error (uiRes("m_createTextureToGeom.kTooManyMeshes2")); 
		}
		$theShape = $obj[0]; 
	} else if ( `nodeType $theSel` == "mesh" ) { 
		// The selection is a shape.  We must have a transform. So 
		// extend to the first parent.  
		//
		$theShape = $theSel; 
		string $parents[] = `listRelatives -p $theSel`; 
		if ( size( $parents ) >= 1 ) { 
			$theSel = $parents[0]; 
		} else { 
			error (uiRes("m_createTextureToGeom.kNoParent")) ;
		}
	} else { 
		error (uiRes("m_createTextureToGeom.kNotAMesh"));
	}

	if ( `objExists ($theShape + ".outMesh")` ) { 
		connectAttr -f ($theShape + ".outMesh") ($cnv + ".inputMesh" );
		return $theSel; 
	}
	
	error (uiRes("m_createTextureToGeom.kNotAMesh2"));
}

global proc string[] createTextureToGeom( string $inputFile, string $name,
										  string $valueAssign, int $fitToSel )
//
// Description: 
//  Create a texture to geometry converter node and hook it up to a polyMesh.
//  The method is also responsible for establishing groupId connections. 
//
{
	string $sel[] = `ls -l -sl`; 
	if ( !`filetest -r $inputFile` ) { 
		string $msg = (uiRes("m_createTextureToGeom.kFileDoesNotExist"));
		error(`format -stringArg $inputFile $msg`);
	}

	string $baseName = $name;
	if ( $name == "" ) { 
		$baseName = basenameEx( $inputFile ); 
	}

	string $cnv = `createNode textureToGeom -n ($baseName + "Converter")`;
	string $transform; 
	if ( $fitToSel ) { 
		select -r $sel;
		string $newTransform; 
		if ( catch( $newTransform = `fitToSelection( $cnv )` ) ) { 
			delete $cnv; 
			error (uiRes("m_createTextureToGeom.kFailedToConvert"));
		}
		$transform = `createNode transform -n $baseName -p $newTransform`;
	} else { 
		$transform = `createNode transform -n $baseName`;
	}
	
	string $mesh = `createNode mesh -n ($baseName + "Mesh") -p $transform`;

	addAttr -ln "converterNode" -sn "cnv" -bt "CNVN" -at message -r true -w true $mesh;
	
	// Assign the input image file. 
	//
	setAttr ($cnv + ".imageFile") -type "string" $inputFile;

	// Setup up the rest of the attributes. We do this here because we
	// want to make sure that we set up all parameters on the
	// converter before we do our first evaluation, which happens in
	// assignGroupIds.
	//
	if ( $valueAssign != "" ) { 
		select -r $sel; 
		string $assignValMethod = ($valueAssign + "( \"" + $cnv + "\" )"); 
		if ( catch( `eval( $assignValMethod )` ) ) { 
			// Something failed ... bail .. but clean up first. 
			//
			delete $transform; 
			delete $cnv; 
			error ( (uiRes("m_createTextureToGeom.kFailedToCreate")) ); 
		}
	}
	
	// Connect the mesh up to the shape.  
	//
	connectAttr ($cnv + ".output") ($mesh + ".inMesh");
	connectAttr ($cnv + ".message") ($mesh + ".converterNode");

	// Assign the group ids.  This call will actually trigger an 
	// evaluate on the mesh. 
	//
	string $groups[] = assignGroupIds( $baseName, $cnv, $mesh ); 

	return {$cnv, $mesh}; 
}
