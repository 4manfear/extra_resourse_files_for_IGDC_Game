// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// ===========================================================================
//
//  Procedure Names:
//      texRandomizeShells
//      texRandomizeSingleShell
//
//  Description:
//      UV workflow function used for randomizing UV shell transformations 
//      (translation, rotation and scaling). Sourcing this script pops up the
//      Randomize UVs -UI from Nightshade UV Editor.
//
//  Input Arguments
//      None - Neither one of these two functions use input arguments.
//      Instead the settings from the UI is stored into option variables.
//      These option variables are then used when doing the randomization.
//
//  Return Value:
//      None.
//
//  Notes:
//  This script is part of the implementation of Nightshade UV Editor into
//  Autodesk Maya. For testing purposes, keep the source commands at the top
//  and then just source this entire script. The UI allows for easy testing.
//
// ===========================================================================

// Randomizes the selected UV shells
global proc texRandomizeShells(int $translateU, int $translateV, float $translateValue,
							   int $rotateCW, int $rotateCCW, float $rotateValue,
							   int $scaleUp, int $scaleDown, float $scaleValue)
{
	// Get original selection and retrieve the selected UV shells
	string $selection[] = `ls -selection`;
	string $compSelType = `getComponentMask`;

	string $selectedUVs[] = `filterExpand -selectionMask 35`;
	string $selectedFaces[] = `filterExpand -selectionMask 34`;
	if (size($selectedUVs) == 0 && size($selectedFaces) == 0)
	{
		// If Convert Selection is ON, try to convert the current selection to uvs.
		int $val = `optionVar -q polyAutoConvertAction`;
		if ( 1 == $val ) {
			PolySelectConvert 4;
			$selectedUVs = `filterExpand -ex false -sm 35`;
		}

		// Check if the set of uvs is still empty.
		if (size($selectedUVs) == 0) {
			error((uiRes("m_texRandomizeShells.kNoUVsSelected")));
			return;
		}
	}

	polySelectBorderShell(0);
	string $shellList[] = texGetShells();

	int $shellsRemaining  = size($shellList); // Shell counters
	$shellsTotal = $shellsRemaining;

	// Create progress bar
	global string $gMainProgressBar;
	progressBar -e
		-beginProgress
		-isInterruptable true
		-minValue 0
		-maxValue $shellsTotal
		-status (uiRes("m_texRandomizeShells.kUvEditorRandomizeMsg"))
		$gMainProgressBar;

	// Start randomizing
	for ($shell in $shellList)
	{
		// Break if  cancelled by user
		if (`progressBar -q -isCancelled $gMainProgressBar`)
		{
			warning((uiRes("m_texRandomizeShells.kUvEditorRandomizeInteruptMsg")));
			break;
		}

		string $message = (uiRes("m_texRandomizeShells.kUvEditorRandomizeShellMsg1"));
		$message += $shellsRemaining;
		$message += (uiRes("m_texRandomizeShells.kUvEditorRandomizeShellMsg2"));

		// Edit the progress window
		progressBar
			-edit
			-progress ($shellsTotal - $shellsRemaining)
			-status $message
			$gMainProgressBar;

		// Select the shell and update the UV coordinates pivot
		eval("select -r " + $shell);
		texUpdateUvCoords();

		// Randomize the shell
		texRandomizeSingleShell($translateU, $translateV, $translateValue,
								$rotateCW, $rotateCCW, $rotateValue,
								$scaleUp, $scaleDown, $scaleValue);

		// Decrease the shells remaining -counter
		$shellsRemaining -= 1;
	}

	// Close the progress window and reselect the original selection
	progressBar -e -endProgress $gMainProgressBar;

	//restore the original component mask	
	setComponentMask($compSelType); 

	//select the original selection
	select -replace $selection;
}

// Randomizes a single UV shell
global proc texRandomizeSingleShell(int $translateU, int $translateV, float $translateValue,
									int $rotateCW, int $rotateCCW, float $rotateValue,
									int $scaleUp, int $scaleDown, float $scaleValue)
{
    // Translation
    if ($translateU || $translateV)
    {
        if ($translateU) // ...along U
        {
            $translateValue = `rand (-$translateValue) $translateValue`;
            polyEditUV -uValue $translateValue;
        }

        if ($translateV) // ...along V
        {
            $translateValue = `rand (-$translateValue) $translateValue`;
            polyEditUV -vValue $translateValue;
        }
    }

    // Rotation
    if ($rotateCW || $rotateCCW)
    {
        if (($rotateCW) && ($rotateCCW)){ // ...both directions
            $rotateValue = `rand (-$rotateValue) $rotateValue`;
            polyEditUV
                -angle $rotateValue
                -pivotU `optionVar -q "manipulatorCoordU_NSUV"`
                -pivotV `optionVar -q "manipulatorCoordV_NSUV"`
            ;
        } else if ($rotateCW){ // ...clockwise
            $rotateValue = `rand (-$rotateValue) 0`;
            polyEditUV
                -angle $rotateValue
                -pivotU `optionVar -q "manipulatorCoordU_NSUV"`
                -pivotV `optionVar -q "manipulatorCoordV_NSUV"`
            ;
        } else if ($rotateCCW){ // ...counter-clockwise
            $rotateValue = `rand 0 $rotateValue`;
            polyEditUV
                -angle $rotateValue
                -pivotU `optionVar -q "manipulatorCoordU_NSUV"`
                -pivotV `optionVar -q "manipulatorCoordV_NSUV"`
            ;
        }
    }

    // Scaling
    if ($scaleUp == 1 || $scaleDown == 1)
    {
        if (($scaleUp) && ($scaleDown)){ // ...up and down
            float $valueUp = ($scaleValue / 100) + 1; // Convert to decimal number
            float $valueDown = 1 - ($scaleValue / 100);
            $scaleValue = `rand $valueDown $valueUp`;
            polyEditUV
                -pivotU `optionVar -q "manipulatorCoordU_NSUV"`
                -pivotV `optionVar -q "manipulatorCoordV_NSUV"`
                -scaleU $scaleValue
                -scaleV $scaleValue
            ;
        } else if ($scaleUp){ // ...up
            float $valueUp = ($scaleValue / 100) + 1;
            $scaleValue = `rand 1.0 $valueUp`;
            polyEditUV
                -pivotU `optionVar -q "manipulatorCoordU_NSUV"`
                -pivotV `optionVar -q "manipulatorCoordV_NSUV"`
                -scaleU $scaleValue
                -scaleV $scaleValue
            ;
        } else if ($scaleDown){ // ...down
            float $valueDown = 1 - ($scaleValue / 100);
            $scaleValue = `rand $valueDown 1.0`;
            polyEditUV
                -pivotU `optionVar -q "manipulatorCoordU_NSUV"`
                -pivotV `optionVar -q "manipulatorCoordV_NSUV"`
                -scaleU $scaleValue
                -scaleV $scaleValue
            ;
        }
    }
}

