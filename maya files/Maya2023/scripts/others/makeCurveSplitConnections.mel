// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc getProjectCurveNodes(string $mesh, string $projectCurveNodes[]) 
{
	clear $projectCurveNodes;

	if (`objExists $mesh`)
	{
		string $attr = ($mesh + ".outMesh");
		$projectCurveNodes = `listConnections -type "polyProjectCurve" -destination true -source false $attr`; 
	}
}

proc string getCurveVarNode(string $projectCurveNode) 
{
	string $curveOutputNode;

	if (`objExists $projectCurveNode`)
	{
		string $attr;

		$attr = ($projectCurveNode + ".outputCurve");
		string $outputNodes[] = `listConnections -type "curveVarGroup" -destination true -source false $attr`;
		if (0 < size($outputNodes))
		{
			$curveOutputNode = $outputNodes[0];
		}
	}

	return $curveOutputNode;
}

proc getProjectedCurves(string $curveOutputNode, string $curves[]) 
{
	clear $curves;

	if (`objExists $curveOutputNode`)
	{
		string $attr;
		$attr = ($curveOutputNode + ".local");

		$curves = `listConnections -destination true -source false $attr`;
		$curves = `listRelatives -noIntermediate -shapes $curves`;
	}
}

proc getSelectedProjectedCurves( string $mesh, string $selectedCurves[], string $sourceAttributes[] )
{
	clear $sourceAttributes;

	string $projCurveNodes[];
	getProjectCurveNodes($mesh, $projCurveNodes);
	if (0 == size($projCurveNodes))
	{
		return;
	}

	string $intersector = `stringArrayIntersector`;

	for ($projCurveNode in $projCurveNodes)
	{
		string $curvVarNode = getCurveVarNode($projCurveNode);
		if ("" == $curvVarNode)
		{
			continue;
		}

		string $splitCurves[];
		getProjectedCurves($curvVarNode, $splitCurves);
		if (0 == size($splitCurves))
		{
			continue;
		}

		stringArrayIntersector -edit -intersect $selectedCurves $intersector;
		stringArrayIntersector -edit -intersect $splitCurves $intersector;

		string $nextCurves[] = `stringArrayIntersector -query $intersector`;
		stringArrayIntersector -edit -reset $intersector;

		string $projNodeSource = ($projCurveNode + ".curvePoints[");
		for ($curve in $nextCurves)
		{
			string $destAttr = ($curve + ".create");
			string $sourceAttr = `connectionInfo -sourceFromDestination $destAttr`;

			string $tokens[];
			int $size = `tokenize $sourceAttr "[]" $tokens`;
			if (2 == $size)
			{
				$sourceAttributes[size($sourceAttributes)] = ($projNodeSource + $tokens[1] + "]");
			}
		}
	}

	deleteUI $intersector;
}

proc getAvailableMultiIndices(string $destMulti, int $required, int $multiIndices[])
{
	clear $multiIndices;

	int $i, $lastIndex = 0;
	for ($i=0; $i<$required; $i++)
	{
		$lastIndex = getNextFreeMultiIndex( $destMulti, $lastIndex );
		$multiIndices[$i] = $lastIndex;

		$lastIndex++;
	}
}

global proc int makeCurveSplitConnections( string $node, string $mesh, string $curves[] )
{
	if (!`objExists $mesh` || 0 == size($curves))
	{
		return 0;
	}

	string $curveTransforms[] = `filterExpand -sm 9`;
	$curves = `listRelatives -noIntermediate -shapes $curveTransforms`;

	string $sourceAttributes[];
	getSelectedProjectedCurves( $mesh, $curves, $sourceAttributes );

	string $destAttr = ($node + ".splitPoints");

	int $multiIndices[], $i = 0;
	getAvailableMultiIndices($destAttr, size($sourceAttributes), $multiIndices);

	string $cmd;
	for ($sourceAttr in $sourceAttributes)
	{
		$cmd += ("connectAttr " + $sourceAttr + " " + $destAttr + "[" + $multiIndices[$i] + "];\n");
		$i++;
	}

	if ( catchQuiet( `eval $cmd` ) )
	{
		return 0;
	}

	return 1;
}
