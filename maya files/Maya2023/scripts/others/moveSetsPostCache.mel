// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

//
//  Description:
//	This method is called to move groupParts nodes for components
//  sets after the cache so that they get included in the cache.
//
//  Input Arguments:
//	  	$shape: the shape of interest
//
proc int checkIsTransform(string $obj)
{
	string $nt[] = `ls -type transform $obj`;
	return size($nt);
}

proc int checkIsDeformerSet(string $obj)
{
	string $conns[] = `listConnections -type geometryFilter $obj`;
	return size($conns);
}

global proc
moveSetsPostCache(string $shape)
{
	string $setsAll[] = `listConnections -type objectSet $shape`;
	string $sets[] = stringArrayRemoveDuplicates($setsAll);

	string $setNames[];
	int $setMemCount[];
	string $setMembers[];

	string $parent[] = `listRelatives -path -parent $shape`;
	string $uniqueName[] = `ls $shape`;
	
	// loop through the sets looking for component sets and save their members
	//
	for ($setName in $sets) {
		int $memCount = 0;

		if (checkIsDeformerSet($setName)) {
			continue;
		}

		string $members[] = `sets -q $setName`;
		for ($mem in $members) {
			string $buff[];
			tokenize($mem,".",$buff);

			if (size($buff) > 1) {
				string $toMatch = checkIsTransform($buff[0]) ? $parent[0] : $uniqueName[0];
				string $matching = `match $toMatch $mem`;
				if (size($matching) == size($toMatch)) {
					$setMembers[size($setMembers)] = $mem;
					if (0 == $memCount) {
						$setNames[size($setNames)] = $setName;
					}
					$memCount++;
				}
			}
		}
		if ($memCount > 0) {
			$setMemCount[size($setMemCount)] = $memCount;
		}
	}

	int $ii, $jj;
	int $index = 0;
	int $setCount = size($setNames);

	for ($ii = 0; $ii < $setCount; $ii++) {
		string $setName = $setNames[$ii];
		for ($jj = 0; $jj < $setMemCount[$ii]; $jj++, $index++) {
			string $flattened[] = `ls -flatten $setMembers[$index]`;
			for ($flatItem in $flattened) {
				sets -rm $setName $flatItem;
			}
		}
	}
	
	$index = 0;
	for ($ii = 0; $ii < $setCount; $ii++) {	
		string $setName = $setNames[$ii];
		for ($jj = 0; $jj < $setMemCount[$ii]; $jj++, $index++) {
			sets -forceElement $setName $setMembers[$index];
		}
	}
}
