// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
// Script:    texturePanel.mel
//
// SYNOPSIS
//		Creates a panel that contains the texture window
//

source texturePanelCommon;
source texturePanelMenus;

// The string prepended to the name of all controls that appear in
// the menubar (as opposed to the pop up menu)
//
global string $gTextureEditorMenubarPrefix = "M";
global int $gTextureEditorPopupType = 0;

global proc texturePanel(string $panelName) 
//
// Description:
//		Create a new scripted panel for the texture window
// Arguments:
//
// Returns:
//
//
{
	global string $gMainPane;

	if (!`scriptedPanelType -exists polyTexturePlacementPanel`) {
		scriptedPanelType
			-unique true
			-createCallback "createTextureWindow" 
			-addCallback "addTextureWindow" 
			-removeCallback "removeTextureWindow" 
			polyTexturePlacementPanel;

		setParent $gMainPane;
		scriptedPanel -unParent -type "polyTexturePlacementPanel" $panelName;
	}
}

global proc createTextureWindow(string $whichPanel)
//
// Description:
//		Create the window in the panel
// Arguments:
//
// Returns:
//
//
{
    textureWindow -unParent $whichPanel;
}

proc reassignCmd(string $nameCommand, string $cbCmd) {
	int $cmdIdx, $count = `assignCommand -query -numElements`;
	for ($cmdIdx = 1; $cmdIdx <= $count; $cmdIdx++) {
		$thisCmdName = `assignCommand -q -name $cmdIdx`;
		if($thisCmdName == $nameCommand) {
			string $curCmd = `assignCommand -q -c $cmdIdx`;
			if(!gmatch($curCmd, $cbCmd)) {
				assignCommand -e -i $cmdIdx -c $cbCmd;
			}
		}
	}
}

global proc initUnfold3DContext()
//
// Description:
//		Create the context from Unfold3D plug-in
{
	int $u3DLoaded = `pluginInfo -q -loaded Unfold3D`;
	if( $u3DLoaded )
	{
		string $tool = "texUnfoldUVContext";
		if( ! `Unfold3DContext -exists $tool` )
		{
			rememberCtxSettings `Unfold3DContext $tool`;
		}
	}
}

global proc setupHotkeyForUnfold3DContext()
//
// Description:
//		Setup the hotkey for Unfold3D Context
{
	reassignCmd("artisanModifyUpperRadius_press", "U3DBrushSizeOn");
	reassignCmd("artisanModifyUpperRadius_release", "U3DBrushSizeOff");
	reassignCmd("artisanModifyMaxDisplacement_press", "U3DBrushPressureOn");
	reassignCmd("artisanModifyMaxDisplacement_release", "U3DBrushPressureOff");
}

global proc teardownHotkeyForUnfold3DContext()
//
// Description:
//		Restore the hotkey to default
{
	if(`exists dR_brushResizeKeysCB`)
		dR_brushResizeKeysCB;

	reassignCmd("artisanModifyMaxDisplacement_press", "ModifyPaintValuePress");
	reassignCmd("artisanModifyMaxDisplacement_release", "ModifyPaintValueRelease");
}

global float $gOrgUnfoldBrushSize;
global int $gUnfoldBrushSizeOverrided = 0;

global proc Unfold3DContextHotkeyScriptJob()
//
// Description:
// 		scriptJob to override the hotkey for Unfold3D brushes
{
	global float $gOrgUnfoldBrushSize;
	global int $gUnfoldBrushSizeOverrided;
	string $currentCtx = `currentCtx`;
	if ( `contextInfo -exists $currentCtx` )
	{
		string $ctxType = `contextInfo -c $currentCtx`;
		if ($ctxType == "Unfold3DBrush")
		{
			if( $gUnfoldBrushSizeOverrided )
			{
				Unfold3DContext -e -sizeuv $gOrgUnfoldBrushSize $currentCtx;
				$gUnfoldBrushSizeOverrided = 0;
			}
		}
		else
		{
			if ($ctxType == "texSculptCacheContext")
			{
				$gOrgUnfoldBrushSize = `Unfold3DContext -q -sizeuv texUnfoldUVContext`;
				float $newUnfoldBrushSize = `texSculptCacheContext -q -size $currentCtx`;
				Unfold3DContext -e -sizeuv $newUnfoldBrushSize $currentCtx;
				Unfold3DContext -e -optimize texUnfoldUVContext;
				$gUnfoldBrushSizeOverrided = 1;
			}
		}
	}
}

global proc initSymmetrizeUVContext()
{
	int $mtkLoaded = `pluginInfo -q -loaded modelingToolkit`;
	if ($mtkLoaded) {
		string $tool = "texSymmetrizeUVContext";
		if (!`SymmetrizeUVContext -exists $tool` )
		{
			rememberCtxSettings `SymmetrizeUVContext $tool`;
		}
	}
}

global proc setupHotkeyForSymmetrizeUVContext()
{
	reassignCmd("artisanModifyUpperRadius_press", "SymmetrizeUVBrushSizeOn");
	reassignCmd("artisanModifyUpperRadius_release", "SymmetrizeUVBrushSizeOff");
}

global proc teardownHotkeyForSymmetrizeUVContext()
{
	if (`exists dR_brushResizeKeysCB`) dR_brushResizeKeysCB;
	reassignCmd("artisanModifyMaxDisplacement_press", "ModifyPaintValuePress");
	reassignCmd("artisanModifyMaxDisplacement_release", "ModifyPaintValueRelease");
}

global proc SetLastUVBrushTool()
{
	global string $gCurrentUVBrushMode;
	global string $gLastUVBrushMode;
	string $currentContext = `currentCtx`;
	if ( `contextInfo -exists $currentContext` )
	{
		string $ctx = `contextInfo -c $currentContext`;
		if ($currentContext == "superCutUVContext")
			$currentContext = "texCutUVContext";
		if( $ctx == "texSculptCacheContext" || $ctx == "texCutContext" )
		{
			string $newUVBrushMode = eval($ctx + "-q -mode " + $currentContext);
			if( $gCurrentUVBrushMode != $newUVBrushMode )
			{
				$gLastUVBrushMode = $gCurrentUVBrushMode;
				$gCurrentUVBrushMode = $newUVBrushMode;
			}
		}
		else if($ctx == "Unfold3DBrush")
		{
			string $newUVBrushMode = eval("Unfold3DContext -q -u " + $currentContext);
			int $setInt = $newUVBrushMode;
			if ($setInt)
				$newUVBrushMode = "Unfold";
			else
				$newUVBrushMode = "Optimize";
			if( $gCurrentUVBrushMode != $newUVBrushMode )
			{
				$gLastUVBrushMode = $gCurrentUVBrushMode;
				$gCurrentUVBrushMode = $newUVBrushMode;
			}
		}
		else if ($ctx == "SymmetrizeUVBrush")
		{
			string $newUVBrushMode = "Symmetrize";
			if ($gCurrentUVBrushMode != $newUVBrushMode) {
				$gLastUVBrushMode = $gCurrentUVBrushMode;
				$gCurrentUVBrushMode = $newUVBrushMode;
			}
		}
	}
}

global proc addTextureWindow(string $whichPanel)
//
// Description:
//		Add the texture window + menus to the panel
// Arguments:
//
// Returns:
//
//
{
	// create Unfold3D context
	initUnfold3DContext();

	// initialize texSculptCacheContextObj
	initUVSculptTool();

	initSymmetrizeUVContext();

	//
	// Build Menubar.
	//
	textureWindowCreateMenubar($whichPanel, "textureWindow");

	string $formName = `formLayout`;

		// Add in toolbar UI
		// Create new frame and form

		optionVar -init false -category "UV Editor"
			-iv "textureEditorToolbarState" 0
			-iv "textureEditorCustomShelfState" 1
			;

		int $toolBarState = `optionVar -q textureEditorToolbarState`;		
		int $customShelfState = `optionVar -q textureEditorCustomShelfState`;

		string $shelfBar = `frameLayout 
			-visible true 
			-borderVisible false 
			-collapsable true 
			-labelVisible false 
			-collapse $customShelfState 
			textureEditorShelfbarFrameLayout`; 
			
			textureWindowShelf($shelfBar);

		setParent ..;

		string $shelfTextBar = `frameLayout
			-visible false
			-borderVisible false
			-collapsable true
			-labelVisible false
			-collapse $customShelfState
			textureEditorShelfTextBarFrameLayout`;
			text -align "center"
				-label (uiRes("m_texturePanel.kEmptyShelfAnnotation")) ;
		setParent ..;

		if(`shelfLayout -exists textureCustomShelf`)
		{
			if(`shelfLayout -query -numberOfChildren textureCustomShelf` == 0)
			frameLayout -e -visible true $shelfTextBar;
		}

		string $toolBar = `frameLayout
			-visible true
			-borderVisible false
			-collapsable true
			-labelVisible false
			-collapse $toolBarState
			textureEditorToolbarFrameLayout`;

			string $toolForm = `columnLayout -adjustableColumn true`;
			//replace old toolbar.
			//textureWindowCreateToolBar ($toolForm, $whichPanel, "textureWindow");
			textureWindowToolbar($toolForm, $whichPanel, "textureWindow");
			setParent ..;
		setParent ..;	

	setParent ..;

	// Attach the editor to the UI
	textureWindow -e -parent $formName $whichPanel;

	string $textureEditorControl = `textureWindow -query -control $whichPanel`;

	// Add a popup marking menu and a popup version of the menubar
	//
	string $popupPostMenuCmd = "textureWindowUpdatePopup( \"";
	$popupPostMenuCmd += $whichPanel+"popupMenus\", \"";
	$popupPostMenuCmd += $whichPanel+"\", \"";
	$popupPostMenuCmd += "textureWindow\")";
	popupMenu -parent $textureEditorControl -mm true -b 3 -aob true -pmc $popupPostMenuCmd ($whichPanel+"popupMenus");
	textureWindowCreatePopupRadialMenu( $whichPanel, "textureWindow", 0 );
	textureWindowCreatePopupMenubar( $whichPanel, "textureWindow" );
	setParent -m ..;


	// Add a popup marking menu for the (SHIFT) modified click to access
	// quick selection conversion tools
	//

	string $contextMenuName = ($whichPanel + "popupMenusShift");
	if (!`popupMenu -exists $contextMenuName`) {
		popupMenu -parent $textureEditorControl -aob true $contextMenuName;
		string $buildCommandMM = "texturePanelCreatePopupContextMenu";

		popupMenu -edit
			-markingMenu true 
			-ctrlModifier false
			-shiftModifier true
			-button 3 
			-postMenuCommand ($buildCommandMM + " \"" + $contextMenuName + "\"")
			$contextMenuName;
	}
	setParent -m ..;

	// Add a popup marking menu for the (CTRL) modified click to access
	// quick selection conversion tools
	//	
	string $convertMenuName = ($whichPanel + "popupMenusCtl");
	if (!`popupMenu -exists $convertMenuName`) {
		popupMenu -parent $textureEditorControl -aob true $convertMenuName;
		string $buildCommandMM = "textureWindowCreatePopupConvertMenu";

		popupMenu -edit
			-markingMenu true 
			-ctrlModifier true
			-shiftModifier false
			-button 3 
			-postMenuCommand ($buildCommandMM + " \"" + $convertMenuName + "\" \"" + $whichPanel + "\" \"textureWindow\"")
			$convertMenuName;
	}
	setParent -m ..;

	//	 Constraints
	formLayout -e 
		-attachForm $shelfBar top 0 
		-attachForm $shelfBar right 0 
		-attachForm $shelfBar left 0 

		-attachForm $shelfTextBar top 10
		-attachForm $shelfTextBar right 0
		-attachForm $shelfTextBar left 0
 
		-attachControl $toolBar top 1 $shelfBar 
		-attachForm $toolBar top 0 
		-attachForm $toolBar right 0 
		-attachForm $toolBar left 0 
 
		-attachControl $whichPanel top 0 $toolBar
		-af $whichPanel "right" 0
		-af $whichPanel "left" 0
		-af $whichPanel "bottom"  0
		$formName;
	//setParent -m ..;

	// Add popup for tool options (shift ctrl)
	//
	string $toolOptionsMenuName = ( $whichPanel + "ToolOptionsPop" );
	if (!`popupMenu -exists $toolOptionsMenuName`) 
	{
		string $fullToolOptionsMenuName = `popupMenu -parent $textureEditorControl -allowOptionBoxes true $toolOptionsMenuName`;
		string $buildCommandMM = "buildToolOptionsMM";
		popupMenu -edit
			-markingMenu true
			-ctrlModifier true
			-shiftModifier true
			-button 3 
			-postMenuCommand ($buildCommandMM + " \"" + $fullToolOptionsMenuName + "\"")
			$toolOptionsMenuName;
	}

	//
	// If any changes goto update
	//
	textureWindow -e 
		-cc "txtWndUpdateEditor" $whichPanel
		"textureWindow" "null"
		$whichPanel;

	txtWndUpdateEditor($whichPanel,"textureWindow","addTextureWindow",101);

	//
	// change grid
	//
	if (`exists performTextureViewGridOptions`)
		performTextureViewGridOptions 0;

	// Change image range
	if (`exists performTextureViewImageRangeOptions`)
		performTextureViewImageRangeOptions 0;
		
	// Change texture bake
	if (`exists performTextureViewBakeTextureOptions`)
		performTextureViewBakeTextureOptions 0;
		
	// Change to baked texture mode to user's last pref
	if ( `optionVar -exists displayEditorImage` )
    {
        int $display = `optionVar -q displayEditorImage`;
        if ($display == 1)
            textureWindow -e -vpi 0 $whichPanel;
        else
            textureWindow -e -vpi 1 $whichPanel;
    }

	// scriptJob to override the hotkey for Unfold3D brushes
	int $u3DLoaded = `pluginInfo -q -loaded Unfold3D`;
	if( $u3DLoaded )
		scriptJob -event "ToolChanged" "Unfold3DContextHotkeyScriptJob";
	scriptJob -event "ToolChanged" "SetLastUVBrushTool";
}

global proc removeTextureWindow(string $whichPanel)
//
// Description:
//		Remove window from panel
// Arguments:
//
// Returns:
//
//
{
    textureWindow -e -unParent $whichPanel;
}

global proc updateTextureWindow(int $reason)
//
// Description:
//		Update texture window (unused ?)
// Arguments:
//
// Returns:
//
//
{;}

//////////////////////////////////////////////////////////////////////
// Popup menu and menubar routines
//////////////////////////////////////////////////////////////////////


global proc txtWndRelFacesMode(string $editor, string $editorCmd, int $internal)
//
// Description:
//		Set face selection filter modes
// Arguments:
//
// Returns:
//
//
{
	int	$state;
	if ($internal)
	{
		$state = eval( $editorCmd + " -q -internalFaces " + $editor );
		if ($state == 0){
			eval ( $editorCmd + " -e -if 1 "+$editor );
		}
		else
		{
			eval ( $editorCmd + " -e -if 0 "+$editor);
	}
	}
	else
	{
		$state = eval( $editorCmd + " -q -relatedFaces " + $editor );
		if ($state == 0){
			eval ( $editorCmd + " -e -rf 1 "+$editor );
		}
		else
		{
			eval ( $editorCmd + " -e -rf 0 "+$editor);
	}
}
}

global proc textureWindowShaderFacesMode(string $editor, 
										 string $editorCmd, 
										 int $isolate)
//
// Description:
//		Set shaderFacesMode
// Arguments:
//
// Returns:
//
//
{
	int $viewState = `optionVar -q textureWindowShaderFacesMode`;
	//0 off
	//1 view shaders
	//2 view isolate

	if ($isolate){
		if ($viewState != 2){
			optionVar -iv textureWindowShaderFacesMode 2;
			eval ( $editorCmd + " -e -useFaceGroup 1 "+$editor );
		}
		else 
		{
			optionVar -iv textureWindowShaderFacesMode 0;
			eval ( $editorCmd + " -e -useFaceGroup 0 "+$editor);
		}
	}
	else
	{
		if ($viewState != 1){
			optionVar -iv textureWindowShaderFacesMode 1;
		eval ( $editorCmd + " -e -useFaceGroup 1 "+$editor );
		}
	else
		{
			optionVar -iv textureWindowShaderFacesMode 0;
		eval ( $editorCmd + " -e -useFaceGroup 0 "+$editor);
}
	}
	// force texture window update since both modes here use the 
	// useFaceGroup flag
	txtWndUpdateEditor($editor, $editorCmd, "Thanks Jey, for showing me the way!", 101);
}

// This function is obsolete
global proc textureWindowToggleTextureImageOn(string $editor, string $editorCmd)
{
	textureWindowTextureImage(1,1) ;
}

// This function is obsolete
global proc textureWindowToggleTextureImageOff(string $editor, string $editorCmd)
{
	textureWindowTextureImage(1,0) ;
}

global proc textureWindowToggleTextureImage(string $editor, string $editorCmd)
//
// Description:
//		Toggle image display for the texture window
// Arguments:
//
// Returns:
//
//
{
	int $draw = textureWindowTextureImage(0,0);
	textureWindowTextureImage(1,!($draw));
}

global proc int textureWindowIsDisplayCheckerMap()
{
	int $draw = textureWindowDisplayCheckered(0,0);
	return $draw;
}
global proc textureWindowTurnOnDisplayCheckerMap()
{
	textureWindowDisplayCheckered(1,1);
}
global proc textureWindowTurnOffDisplayCheckerMap()
{
	textureWindowDisplayCheckered(1,0);
}

global proc textureWindowToggleCheckerMap(string $editor, string $editorCmd)
{
	int $draw = eval ( $editorCmd +" -q -displayCheckered "+ $editor ) ;
	if ($draw == 0) { 
		textureWindowTurnOnDisplayCheckerMap();
	}
	else {
		textureWindowTurnOffDisplayCheckerMap() ;
	}
}
global proc int textureWindowIsUVEditorOpen()
{
	string $texWin[] = `getPanel -sty polyTexturePlacementPanel`;

	string $visPanels[] = `getPanel -vis`;
	for ( $panel in $visPanels )
	{ 
		if( $panel == $texWin[0] )
		{ 
			return 1;
		}
	}
	return 0;
}

global proc textureWindowSetCheckerMapApplyOptionsUpdateTexEditor(int $display)
{
	if ($display == 0)
	{
		textureWindowTurnOffDisplayCheckerMap() ;

	}
	else
	{
		textureWindowTurnOnDisplayCheckerMap();
	}

	performTextureViewCheckerMapOptions 0;
	
	string $updateTexEditor = 
				"if (textureWindowIsUVEditorOpen())\n" + 
				"{\n" +
				 "	string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;\n" + 
				 "	txtWndUpdateEditor( $texWinName[0], \"textureWindow\", \"null\", 101 );\n" +
				 "}\n";
	eval($updateTexEditor);
}

global proc textureWindowToggleImageDimming(string $editor, string $editorCmd)
//
// Description:
//		Toggle image dimming for the texture window
// Arguments:
//
// Returns:
//
//
{
	int $dim = textureWindowImageDimming(0,0) ;
	textureWindowImageDimming(1,!($dim));
}

global proc textureWindowToggleMapOverlay(string $editor, string $editorCmd)
//
// Description:
//		Toggle map overlay for the texture window
// Arguments:
//
// Returns:
//
//
{
	int $draw = textureWindowSolidMap(0,0) ;
	textureWindowSolidMap(1,!($draw));
}

global proc textureWindowToggleUVDistortion(string $editor, string $editorCmd)
//
// Description:
//		Toggle UV distortion for the texture window
// Arguments:
//
// Returns:
//
//
{
	int $draw = textureWindowDistortion(0,0) ;
	textureWindowDistortion(1,!$draw);
}

global proc textureWindowToggleUnfiltered(string $editor, string $editorCmd)
{
	int $unfiltered = textureWindowImageUnfiltered(0,0);
	textureWindowImageUnfiltered(1,!($unfiltered));
}

global proc textureWindowToggleRatio(string $editor, string $editorCmd)
{
	int $ratio = textureWindowImageRatio(0,0) ;
	textureWindowImageRatio(1,!($ratio)) ;
}

global proc textureWindowToggleSnap(string $editor, string $editorCmd)
{
	int $snap = eval ( $editorCmd +" -q -ip "+ $editor ) ;
	if ($snap == 0) {
		eval( $editorCmd +" -e -ip 1 " + $editor ) ;
	}
	else {
		eval( $editorCmd +" -e -ip 0 " + $editor ) ;
	}
}

global proc textureWindowToggleGrid(string $editor, string $editorCmd)
//
// Description:
//		Toggle grid settings based on current state of grid toggle for
//		window
// Arguments:
//
// Returns:
//
//
{
	// textureView -q -tgl $editor (panelname)
	int $draw = textureWindowDisplayGrid(0,0) ;
	textureWindowDisplayGrid(1,!($draw));
}

global proc textureWindowToggleTileLabels(string $editor, string $editorCmd)
//
// Description:
//		Toggle tile label display based on current state of toggle for window
// Arguments:
//
// Returns:
//
//
{
	int $draw = eval ( $editorCmd +" -q -tlb "+ $editor ) ;
	if ($draw == 0) {
		eval( $editorCmd +" -e -tlb 1 " + $editor ) ;
	}
	else {
		eval( $editorCmd +" -e -tlb 0 " + $editor ) ;
	}
}

global proc textureWindowToggleToolbar()
//
// Description:
//		Toggle toolbar based on current state of toolbar toggle for
//		window
//
{
	int $toolBarState = `optionVar -q textureEditorToolbarState`;
	frameLayout -edit -collapse (!$toolBarState)
		textureEditorToolbarFrameLayout;
	optionVar -iv "textureEditorToolbarState" (!$toolBarState);
}

global proc textureWindowToggleCustomShelf()
//
// Description:
//		Toggle custom shelf based on current state of custom shelf toggle for
//		window
//
{
	int $customShelfState = `optionVar -q textureEditorCustomShelfState`;
	frameLayout -edit -collapse (!$customShelfState)
		textureEditorShelfbarFrameLayout;
	frameLayout -edit -collapse (!$customShelfState)
		textureEditorShelfTextBarFrameLayout;
	optionVar -iv "textureEditorCustomShelfState" (!$customShelfState);
}

global proc updateNurbsEditUVModeMenuItem( string $menuitem )
{
	int $value = queryNurbsEditUVMode();
	menuItem -e -checkBox $value $menuitem;
}


global proc textureWindowSelectImage(int $i, string $whichPanel)
{
	string $menuNames[] = `textureWindow -q -imageNames $whichPanel`;
	
	if (size($menuNames) == 0) return;

	string $buffer[];
	tokenize $menuNames[$i] " " $buffer;
	if (size($buffer) == 0) return;

	string $thisShader = $buffer[2];
	//string $thisObject = $buffer[0];
	if ($thisShader == "") return;

	string $objGroups[] = `listConnections -p on ($thisShader+".dsm")`; 
	string $shapes[] = `listConnections -sh on ($thisShader+".dsm")`;
	//string $objects[] = `listConnections ($thisShader+".dsm")`;

	int $j;
	for ($j=0; $j<size($shapes); $j++) {
		string $objGroup = $objGroups[$j];
		int $gid = -99;
		if (`objExists ($objGroup+".gid")`) {
			if( catchQuiet( $gid = `getAttr ($objGroup+".gid")`))
			{
				int $gids[] = `getAttr ($objGroup+".gid")`;
				if( size( $gids) > 0)
					$gid = $gids[0];
			}
		} else {
			//$gid = `getAttr ($objGroup+".cgid")`;
			continue;
		}
		if (`nodeType $shapes[$j]` != "mesh") {
			continue;
		}
		if( $gid != -99)
			setAttr ($shapes[$j]+".dfgi") $gid;
	}
	
	textureWindow -e -imageNumber $i $whichPanel;
}
global proc textureWindowSelectTexture(int $t, string $whichPanel)
{
	int $i = `textureWindow -q -textureToImageNumber $t $whichPanel`;
	textureWindowSelectImage $i $whichPanel;
}

global proc updateUVSetMenuWithCopyUVsCmd( 
		string $menuName, string $prefix,
		string $whichPanel)
{
	setParent -m $menuName;
	string $menuItems[] = `menu -q -itemArray $menuName`;
	string $menuNames[] = `textureWindow -q -uvs $whichPanel`;
	int $numUVSets = size($menuNames);

	// If there aren't any uv sets to display, then just return now.
	if( $numUVSets == 0 ) {
		return;
	}

	int $i;
	for( $i=0; $i<$numUVSets; $i++ ) 
	{
		string $buf[];
		tokenize $menuNames[$i] " " $buf;
		
		if( size($buf) == 0 ) continue;

		// for each menu item, disable it if it's the active one
		// or add a command to run the polyCopyUVs cmd
		string $currUVSet[] = `polyUVSet -q -currentUVSet $buf[0]`;
		string $destinationUVSet = $buf[size($buf) - 1];

		if ($currUVSet[0] == $destinationUVSet)
		{
			menuItem -e -enable false $menuItems[$i];
		} else {

			//  Overwrite the existing command with a polyCopyUVs cmd
			string $existingCmd = `menuItem -q -command $menuItems[$i]`;
			string $copyCmd = ( "if( `performPolyCopyUVsToUVsetArgList " 
				    + "\"1\" {"
					+ $currUVSet[0] + ",  " 
					+ $destinationUVSet + ", \"1\"}` > 0 ) { " 
					+ $existingCmd + "}");
			menuItem -e -command $copyCmd $menuItems[$i];
		}
	}
}

global proc textureWindowSelectConvert(int $toType)
{
	string $converted[];
	string $convSubd[];
	string $tokens[];
	string $evalStr;
	
	// To Face
	if ($toType == 1)
	{
		$converted = `polyListComponentConversion -in -fv -fe -fuv -fvf -tf`;
		if (`isTrue "SubdivUIExists"`) {
			$convSubd = `subdListComponentConversion -in -fv -fe -fuv -tf`;
		}
	}
	
	// To Edge
	else if ($toType == 2)
	{
		$converted = `polyListComponentConversion -fv -ff -fuv -fvf -te`;
		if (`isTrue "SubdivUIExists"`) {
			$convSubd = `subdListComponentConversion -fv -ff -fuv -te`;
		}
	}
	
	// To Vertex
	else if ($toType == 3)
	{
		$converted = `polyListComponentConversion -ff -fe -fuv -fvf -tv`;
		if (`isTrue "SubdivUIExists"`) {
			$convSubd= `subdListComponentConversion -ff -fe -fuv -tv`;
		}
	}
	
	// To UV
	else if ($toType == 4)
	{
		$converted = `polyListComponentConversion -fv -fe -ff -fvf -tuv`;
		if (`isTrue "SubdivUIExists"`) {
			$convSubd = `subdListComponentConversion -fv -fe -ff -tuv`;
		}
	}
	
	int $numConv = size($converted);
	int $numSubd = size($convSubd);
	if ( ($numConv > 0) || ($numSubd > 0 ) )
	{
		$evalStr = "select -r";
		for ( $i=0; $i<$numConv; $i++ )
		{
			$evalStr += " \"";
			$evalStr += $converted[$i];
			$evalStr += "\"";
		}
		for ( $i=0; $i<$numSubd; $i++ )
		{
			$evalStr += " \"";
			$evalStr += $convSubd[$i];
			$evalStr += "\"";
		}

		// Switching to the selection type they're converting to
		// beforehand ensures the selection preservation buffers remain
		// consistent.
		if(`selectPref -q -selectTypeChangeAffectsActive`)
		{
			string $selectType = textureWindowChangeSelectTypeString($toType);
			$evalStr = $selectType + $evalStr;
		}
		eval $evalStr;
	}
}


global proc int resetUVEditorUIToDefault()
{

   textureWindowColorChannel(1,"colorWithMask");
   setChannelButtonImage("");
   snapModePixelSnap(1,0);
   textureWindowImageRatio(1,0);
   textureWindowImageUnfiltered(1,0);
   textureWindowImageDimming(1,0);
   textureWindowTextureImage(1,1);
   textureWindowUVEditorDisplayUVStatisticsHUD(1,1);
   textureWindowUVEditorIsolateSelectHUD(1,1);
   textureWindowUVEditorUVPositionHUD(1,1);
   textureWindowDisplayGrid(1,1);
   textureWindowTexBorder(1,1);
   textureWindowDistortion(1,0);
   textureWindowSolidMap(1,0);
   textureWindowDisplayCheckered(1,0);

   textureWindowSetAutoLoadTextures(0);

   //Show toolbar 
   int $toolBarCollapseDefaultState = 0;
   frameLayout -edit -collapse ($toolBarCollapseDefaultState) textureEditorToolbarFrameLayout;
   optionVar -iv "textureEditorToolbarState" ($toolBarCollapseDefaultState);

   //Custom Shelf
   int $customShelfCollapseDefaultState = 1;
   frameLayout -edit -collapse ($customShelfCollapseDefaultState)
   textureEditorShelfbarFrameLayout;
   frameLayout -edit -collapse ($customShelfCollapseDefaultState)
   textureEditorShelfTextBarFrameLayout;
   optionVar -iv "textureEditorCustomShelfState" ($customShelfCollapseDefaultState);

   string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

   //UV Editor baking
   // Change to baked texture mode to default
   if ( `optionVar -exists displayEditorImage` )
   {
         int $display = `optionVar -q displayEditorImage`;
         if ($display == 1)
         {
		optionVar -intValue displayEditorImage 0;
            textureWindow -e -vpi 1 $texWinName[0];
		 }
   }

   txtWndUpdateEditor($texWinName[0],"textureWindow","null",101);

   return 1;

}

// -if setValue is 1, sets the value of -displayCheckered with $newValue and stores the variable
// -if setValue is 0, return the value of -displayCheckered after making sure it is consistent
// with stored value
global proc int textureWindowDisplayCheckered(int $setValue, int $newValue)
{

    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowDisplayCheckeredState`)
	{
	    int $temp = `textureWindow -q -displayCheckered $texWinName[0]`;
		optionVar -iv "textureWindowDisplayCheckeredState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowDisplayCheckeredState 0;

	int $storedState = `optionVar -q textureWindowDisplayCheckeredState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displayCheckered $texWinName[0]`;
	   if($actualValue != $storedState)
	   {
	       if($storedState == 1 ) performTextureViewCheckerMapOptions 0;
		   textureWindow -e -displayCheckered $storedState $texWinName[0];

	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		textureWindow -e -displayCheckered $newValue $texWinName[0];

		optionVar -iv "textureWindowDisplayCheckeredState" $newValue;


		$storedState = $newValue;
	}
	return $storedState;
}


// -if setValue is 1, sets the value of -displayStyle with $newValue and stores the variable
// -if setValue is 0, return the value of -displayStyle after making sure it is consistent
// with stored value
global proc string textureWindowColorChannel(int $setValue, string $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowColorChannelState`)
	{
	    string $temp = `textureWindow -q -displayStyle $texWinName[0]`;
		optionVar -sv "textureWindowColorChannelState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -sv textureWindowColorChannelState "colorWithMask";

	string $storedState = `optionVar -q textureWindowColorChannelState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   string $actualValue = `textureWindow -q -displayStyle $texWinName[0]`;
	   if($actualValue != $storedState)
	   {
		   textureWindow -e -displayStyle $storedState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		textureWindow -e -displayStyle $newValue $texWinName[0];

		optionVar -sv "textureWindowColorChannelState" $newValue;


		$storedState = $newValue;
	}
	return $storedState;
}

// -if setValue is 1, set the value of -pixelSnap with $newValue and stores the variable
// -if setValue is 0, return the value of -pixelSnap after making sure it is consistent
// with stored value
global proc int snapModePixelSnap(int $setValue, int $newValue)
{

	if (!`optionVar -exists snapModePixelSnapState`)
	{
	    int $temp = `snapMode -q -pixelSnap`;
		optionVar -iv "snapModePixelSnapState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv snapModePixelSnapState 0;

	int $storedState = `optionVar -q snapModePixelSnapState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `snapMode -q -pixelSnap`;
	   if($actualValue != $storedState)
	   {
		   snapMode -pixelSnap $storedState;
	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		snapMode -pixelSnap $newValue;

		optionVar -iv "snapModePixelSnapState" $newValue;

		$storedState = $newValue;
	}
	return $storedState;
}



// -if setValue is 1, set the value of -imageRatio with $newValue and stores the variable
// -if setValue is 0, return the value of -imageRatio after making sure it is consistent
// with stored value
global proc int textureWindowImageRatio(int $setValue, int $newValue)
{

    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowImageRatioState`)
	{
	    int $temp = `textureWindow -q -imageRatio $texWinName[0]`;
		optionVar -iv "textureWindowImageRatioState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowImageRatioState 0;

	int $storedState = `optionVar -q textureWindowImageRatioState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -imageRatio $texWinName[0]`;
	   if($actualValue != $storedState)
	   {
		   textureWindow -e -imageRatio $storedState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		textureWindow -e -imageRatio $newValue $texWinName[0];

		optionVar -iv "textureWindowImageRatioState" $newValue;


		$storedState = $newValue;
	}
	return $storedState;
}


// -if setValue is 1, set the value of -imageUnfiltered with $newValue and stores the variable
// -if setValue is 0, return the value of -imageUnfiltered after making sure it is consistent
// with stored value
global proc int textureWindowImageUnfiltered(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowImageUnfilteredState`)
	{
	    int $temp = `textureWindow -q -imageUnfiltered $texWinName[0]`;
		optionVar -iv "textureWindowImageUnfilteredState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowImageUnfilteredState 0;

	int $storedState = `optionVar -q textureWindowImageUnfilteredState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -imageUnfiltered $texWinName[0]`;
	   if($actualValue != $storedState)
	   {
		   textureWindow -e -imageUnfiltered $storedState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		textureWindow -e -imageUnfiltered $newValue $texWinName[0];

		optionVar -iv "textureWindowImageUnfilteredState" $newValue;


		$storedState = $newValue;
	}
	return $storedState;
}



// -if setValue is 1, set the value of -imageDim with $newValue and stores the variable
// -if setValue is 0, return the value of -imageDim after making sure it is consistent
// with stored value
global proc int textureWindowImageDimming(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowImageDimmingState`)
	{
	    int $temp = `textureWindow -q -imageDim $texWinName[0]`;
		optionVar -iv "textureWindowImageDimmingState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowImageDimmingState 0;

	int $storedState = `optionVar -q textureWindowImageDimmingState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -imageDim $texWinName[0]`;
	   if($actualValue != $storedState)
	   {
		   textureWindow -e -imageDim $storedState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		textureWindow -e -imageDim $newValue $texWinName[0];

		optionVar -iv "textureWindowImageDimmingState" $newValue;


		$storedState = $newValue;
	}
	return $storedState;
}


// -if setValue is 1, set the value of -imageDisplay with $newValue and stores the variable
// -if setValue is 0, return the value of -imageDisplay after making sure it is consistent
// with stored value
global proc int textureWindowTextureImage(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowImageDisplayState`)
	{
	    int $temp = `textureWindow -q -imageDisplay $texWinName[0]`;
		optionVar -iv "textureWindowImageDisplayState" $temp;
    }
	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowImageDisplayState 1;

	int $storedState = `optionVar -q textureWindowImageDisplayState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -imageDisplay $texWinName[0]`;
	   if($actualValue != $storedState)
	   {
		   textureWindow -e -imageDisplay $storedState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $storedState))
	{
		textureWindow -e -imageDisplay $newValue $texWinName[0];

		optionVar -iv "textureWindowImageDisplayState" $newValue;


		$storedState = $newValue;
	}
	return $storedState;
}


// -if setValue is 1, set the value of -displayUVStatisticsHUD with $newValue and stores the variable
// -if setValue is 0, return the value of -displayUVStatisticsHUD after making sure it is consistent
// with stored value
global proc int textureWindowUVEditorDisplayUVStatisticsHUD(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowUVEditorDisplayUVStatisticsHUDState`)
	{
	    int $temp = `textureWindow -q -displayUVStatisticsHUD $texWinName[0]`;
		optionVar -iv "textureWindowUVEditorDisplayUVStatisticsHUDState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowUVEditorDisplayUVStatisticsHUDState 1;

	int $uvStatisticsState = `optionVar -q textureWindowUVEditorDisplayUVStatisticsHUDState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displayUVStatisticsHUD $texWinName[0]`;
	   if($actualValue != $uvStatisticsState)
	   {
		   textureWindow -e -displayUVStatisticsHUD $uvStatisticsState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $uvStatisticsState))
	{
		textureWindow -e -displayUVStatisticsHUD $newValue $texWinName[0];

		optionVar -iv "textureWindowUVEditorDisplayUVStatisticsHUDState" $newValue;


		$uvStatisticsState = $newValue;
	}
	return $uvStatisticsState;
}


// -if setValue is 1, set the value of -displayUVPositionHUD with $newValue and stores the variable
// -if setValue is 0, return the value of -displayUVPositionHUD after making sure it is consistent
// with stored value
global proc int textureWindowUVEditorUVPositionHUD(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowUVEditorUVPositionHUDState`)
	{
	    int $temp = `textureWindow -q -displayUVPositionHUD $texWinName[0]`;
		optionVar -iv "textureWindowUVEditorUVPositionHUDState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowUVEditorUVPositionHUDState 1;

	int $uvPosState = `optionVar -q textureWindowUVEditorUVPositionHUDState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displayUVPositionHUD $texWinName[0]`;
	   if($actualValue != $uvPosState)
	   {
		   textureWindow -e -displayUVPositionHUD $uvPosState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $uvPosState))
	{
		textureWindow -e -displayUVPositionHUD $newValue $texWinName[0];

		optionVar -iv "textureWindowUVEditorUVPositionHUDState" $newValue;


		$uvPosState = $newValue;
	}
	return $uvPosState;
}

// -if setValue is 1, set the value of -displayIsolateSelectHUD with $newValue and stores the variable
// -if setValue is 0, return the value of -displayIsolateSelectHUD after making sure it is consistent
// with stored value
global proc int textureWindowUVEditorIsolateSelectHUD(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowUVEditorIsolateSelectHUDState`)
	{
	    int $temp = `textureWindow -q -displayIsolateSelectHUD $texWinName[0]`;
		optionVar -iv "textureWindowUVEditorIsolateSelectHUDState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowUVEditorIsolateSelectHUDState 1;

	int $isolateState = `optionVar -q textureWindowUVEditorIsolateSelectHUDState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displayIsolateSelectHUD $texWinName[0]`;
	   if($actualValue != $isolateState)
	   {
		   textureWindow -e -displayIsolateSelectHUD $isolateState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $isolateState))
	{
		textureWindow -e -displayIsolateSelectHUD $newValue $texWinName[0];

		optionVar -iv "textureWindowUVEditorIsolateSelectHUDState" $newValue;


		$isolateState = $newValue;
	}
	return $isolateState;
}

// -if setValue is 1, set the value of -toggle with $newValue and stores the variable
// -if setValue is 0, return the value of -toggle after making sure it is consistent
// with stored value
global proc int textureWindowDisplayGrid(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowToggleGridState`)
	{
	    int $temp = `textureWindow -q -toggle $texWinName[0]`;
		optionVar -iv "textureWindowToggleGridState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowToggleGridState 1;

	int $toggleState = `optionVar -q textureWindowToggleGridState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -toggle $texWinName[0]`;
	   if($actualValue != $toggleState)
	   {
		   textureWindow -e -toggle $toggleState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $toggleState))
	{
		textureWindow -e -toggle $newValue $texWinName[0];

		optionVar -iv "textureWindowToggleGridState" $newValue;


		$toggleState = $newValue;
	}
	return $toggleState;
}

// -if setValue is 1, set the value of -displayTextureBorder with $newValue and stores the variable
// -if setValue is 0, return the value of -displayTextureBorder after making sure it is consistent
// with stored value
global proc int textureWindowTexBorder(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowTexBorderState`)
	{
	    int $temp = `textureWindow -q -displayTextureBorder $texWinName[0]`;
		optionVar -iv "textureWindowTexBorderState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowTexBorderState 1;

	int $texBorderState = `optionVar -q textureWindowTexBorderState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displayTextureBorder $texWinName[0]`;
	   if($actualValue != $texBorderState)
	   {
		   textureWindow -e -displayTextureBorder $texBorderState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $texBorderState))
	{
		textureWindow -e -displayTextureBorder $newValue $texWinName[0];

		optionVar -iv "textureWindowTexBorderState" $newValue;


		$texBorderState = $newValue;
	}
	return $texBorderState;
}


// -if setValue is 1, set the value of -displayDistortion with $newValue and stores the variable
// -if setValue is 0, return the value of -displayDistortion after making sure it is consistent
// with stored value
global proc int textureWindowDistortion(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowDistortionState`)
	{
	    int $temp = `textureWindow -q -displayDistortion $texWinName[0]`;
		optionVar -iv "textureWindowDistortionState" $temp;
    }

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowDistortionState 0;

	int $distortionState = `optionVar -q textureWindowDistortionState`;

	// if we are just reading the saved state, make sure that it is applied
	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displayDistortion $texWinName[0]`;
	   if($actualValue != $distortionState)
	   {
		   textureWindow -e -displayDistortion $distortionState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $distortionState))
	{
		textureWindow -e -displayDistortion $newValue $texWinName[0];

		optionVar -iv "textureWindowDistortionState" $newValue;


		$distortionState = $newValue;
	}
	return $distortionState;
}

// -if setValue is 1, set the value of -displaySolidMap with $newValue and stores the variable
// -if setValue is 0, return the value of -displaySolidMap after making sure it is consistent
// with stored value
global proc int textureWindowSolidMap(int $setValue, int $newValue)
{
    string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;

	if (!`optionVar -exists textureWindowSolidMapState`)
	{
		optionVar -iv "textureWindowSolidMapState" `textureWindow -q -displaySolidMap $texWinName[0]`;
	}

	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureWindowSolidMapState 0;

	int $solidMapState = `optionVar -q textureWindowSolidMapState`;

	if($setValue == 0)
	{
	   int $actualValue = `textureWindow -q -displaySolidMap $texWinName[0]`;
	   if($actualValue != $solidMapState)
	   {
		   textureWindow -e -displaySolidMap $solidMapState $texWinName[0];
	   }
	}

	if (($setValue == 1 && $newValue != $solidMapState))
	{

		textureWindow -e -displaySolidMap $newValue $texWinName[0];
		if ($newValue == 0)
			optionVar -iv "textureWindowSolidMapState" 0;
		else
			optionVar -iv "textureWindowSolidMapState" 1;

		$solidMapState = $newValue;
	}
	return $solidMapState;
}

global proc textureWindowSetAutoLoadTextures(int $value)
{
	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureEditorAutoLoadTexturesState 0;

    optionVar -iv "textureEditorAutoLoadTexturesState" $value;

	// update uv toolkit icon status.
	if(`iconTextCheckBox -exists uvTkAutoLoadTexToggle`)
		iconTextCheckBox -e -value $value uvTkAutoLoadTexToggle;
		
	// update UV set menu check status.
	global string $gTextureEditorMenubarPrefix;
	string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;
	string $menubarPrefix = ($gTextureEditorMenubarPrefix + $texWinName[0]);
	if(`menuItem -exists ($menubarPrefix+"autoLoadTexturesItem")`)
		menuItem -e -cb $value ($menubarPrefix+"autoLoadTexturesItem");
}

global proc int textureWindowToggleAutoLoadTextures(int $toggle)
{
	// Set default value and category
	optionVar -init false -category "UV Editor" -iv textureEditorAutoLoadTexturesState 0;

	int $autoLoadState = `optionVar -q textureEditorAutoLoadTexturesState`;
	if ($toggle)
	{
		if ($autoLoadState == 0)
			optionVar -iv "textureEditorAutoLoadTexturesState" 1;
		else 
			optionVar -iv "textureEditorAutoLoadTexturesState" 0;

		// update uv toolkit icon status.
		if(`iconTextCheckBox -exists uvTkAutoLoadTexToggle`)
			iconTextCheckBox -e -value ($autoLoadState == 0) uvTkAutoLoadTexToggle;
			
		// update UV set menu check status.
		global string $gTextureEditorMenubarPrefix;
		string $texWinName[] = `getPanel -sty polyTexturePlacementPanel`;
		string $menubarPrefix = ($gTextureEditorMenubarPrefix + $texWinName[0]);
		if(`menuItem -exists ($menubarPrefix+"autoLoadTexturesItem")`)
			menuItem -e -cb ($autoLoadState == 0) ($menubarPrefix+"autoLoadTexturesItem");
	}
	return $autoLoadState;
}

global proc textureWindowAutoLoadTextures(string $uvSetName, string $object)
{
	string $linkedTextureName = "";
	
	string $attrUVSet = $object+".uvSet";
	int $idx[] = `getAttr -mi $attrUVSet`;
	for ($i = 0; $i < size($idx); ++$i)
	{
		string $attrUVSetName = $attrUVSet + "[" + $idx[$i] + "].uvSetName";
		$tmpUVSetName = `getAttr $attrUVSetName`;
		
		if ($tmpUVSetName == $uvSetName) 
		{
			string $links[] = `uvLink -query -uvSet $attrUVSetName`;			
			if (size($links))
				$linkedTextureName = $links[0];
		}
	}
	
	if ($linkedTextureName != "")
	{
		string $texWin[] = `getPanel -sty polyTexturePlacementPanel`;
		string $imageNames[] = `textureWindow -q -imageNames $texWin[0]`;
		
		for ($i = 0; $i < size($imageNames); ++$i)
		{
			string $tmpImageName = $imageNames[$i];
			if (`match $linkedTextureName $tmpImageName` != "")
			{
				$cmd = "textureWindow -e -imageNumber " + $i + " " + $texWin[0];
				eval($cmd);
			}
		}
	} 
}