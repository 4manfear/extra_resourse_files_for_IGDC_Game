// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//
//  Creation Date:  2003 
//
//<doc>
//<name createMotionField>
//
//<synopsis>
//		createMotionField
//
//<returns>
//		None.	
//
//<description>
//	This command creates a force that pushes a fluid based on the motion
//  of an object. One selects the objects that one wishes to push the fluid
//	with and the fluids one wishes to affect. At least one fluid and one 
//  non-fluid must be selected. One will not see an effect until the object
//  is animated. CreateMotionField creates a drag field for each object
//  and sizes the volume boundary of the force to be a bit larger than
//  the object. The drag field has inheritVelocity enabled, which causes it
//  to drag relative to the movement of the field.
//  Adjusting the scale and volume shape of the drag field can help to achieve
//  the best effect. If one collides the fluid with the object,then it may be good
//  to increase the drag field size, as the colliding voxels have all velocity
//  damped out.
//
//<flags>
//	None.
//
//<examples>
//	// Create a fluid with emitter
//  Create2DContainerEmitter;
//	// Create an animated sphere 
//	sphere;
//  move -r 3 3 0;
//	setKeyframe;
//  currentTime 100;
//  move -r -6 -6 0;
//	setKeyframe;
//  select -r fluidShape1 nurbsSphere1;
//  createMotionField;
//</doc>


global proc createMotionField()
{
	float  $pushIntensity = 10.0;
	float  $flOverScale = 1.6/2.0;
	float  $maxAspect = 0.1;

	string $fluids[] = `ls -sl -dag -type fluidShape`;
	string $selObjs[] = `ls -sl -type transform`;
	string $objs[];	
	int	   $numObjs=0;
	int $i;
	for( $i = 0; $i < size($selObjs); $i++ ){
		string $fls[] = `ls -dag -type fluidShape $selObjs[$i]`;
		if( 0 == size( $fls )){
			$objs[$numObjs] = $selObjs[$i];
			$numObjs++;
		}
	}
	if( $numObjs == 0 || size($fluids) == 0 ){
		warning ((uiRes("m_createMotionField.kNeedFluid")));
		return;
	}
	string $fields[];
	int $numFields =0;
	for( $i = 0; $i < $numObjs; $i++ ){
		select -r $fluids;
		Drag;
		$selObjs = `ls -sl`;
		string $field = $selObjs[0];
		$field = `rename $field "motionField#"`;
		$fields[ $numFields ] = $field;
		$numFields++;
		setAttr ($field + ".attenuation") 0;
		setAttr ($field + ".magnitude") 30.0; // should really be relative to frames/sec
		setAttr ($field + ".volumeShape") 2;
		setAttr ($field + ".inheritVelocity") 1;
		setAttr ($field + ".motionAttenuation") 0.1; // no drag when stationary

		string $obj = $objs[$i];
		float $bbox[] = `exactWorldBoundingBox $obj`;
		$min[0] = $bbox[0];
		$min[1] = $bbox[1];
		$min[2] = $bbox[2];
		$max[0] = $bbox[3];
		$max[1] = $bbox[4];
		$max[2] = $bbox[5];

		float $fsx =$flOverScale *( $max[0] - $min[0] );
		float $fsy =$flOverScale *( $max[1] - $min[1] );
		float $fsz =$flOverScale *( $max[2] - $min[2] );


		float $maxScale = $fsx;
		if( $maxScale < $fsy ){
			$maxScale = $fsy;
		}
		if( $maxScale < $fsz ){
			$maxScale = $fsz;
		}
		$maxScale *= $maxAspect;
		// avoid flat forces
		if( $fsx < $maxScale ) {
			$fsx = $maxScale;
		}
		if( $fsy < $maxScale ){
			$fsy = $maxScale;
		}
		if( $fsz < $maxScale ){
			$fsz = $maxScale;
		}

		setAttr ($field + ".tx") ($min[0] + 0.5 * ($max[0]-$min[0]));
		setAttr ($field + ".ty") ($min[1] + 0.5 * ($max[1]-$min[1]));
		setAttr ($field + ".tz") ($min[2] + 0.5 * ($max[2]-$min[2]));
		setAttr ($field + ".sx") $fsx;
		setAttr ($field + ".sy") $fsy;
		setAttr ($field + ".sz") $fsz;
		parent $field $obj;
	}
	select -r $fields;
	
}
