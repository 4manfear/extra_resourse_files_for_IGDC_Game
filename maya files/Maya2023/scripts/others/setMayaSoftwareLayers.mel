// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//      setMayaSoftwareLayers
//
//  Description:
//		Setup the Maya renderer to render only the specified layers
//		and passes.
//      Empty strings means to ignore this option.
//
global proc setMayaSoftwareLayers(string $layers, string $passes)
{
	int $i;
	int $j;
	int $state;
	string $allLayers[] = `listConnections renderLayerManager.renderLayerId`;
	
	// Treat the layers first
	if ($layers != "") {

		if ($layers == "off" || $layers == "false" || $layers == "0") {

			// Set the default layer to renderable, and all others to
			// non-renderable.
			// The subdirectory "defaultRenderLayer" will automatically
			// be created if any render layers (other than the default) exist.
			//
			for( $i=0 ; $i<size($allLayers) ; $i++ ){
				if( $allLayers[$i] == "defaultRenderLayer" ){
					removeRenderLayerAdjustmentAndUnlock ($allLayers[$i]+".renderable");
					catch(`setAttr ($allLayers[$i]+".renderable") true`);
				}else{
					removeRenderLayerAdjustmentAndUnlock ($allLayers[$i]+".renderable");
					catch(`setAttr ($allLayers[$i]+".renderable") false`);
				}
			}
		} else if( !($layers == "on" || $layers == "true" || $layers == "1") ){

			// Assume a list of layers.
			// Turn all layers off, except the ones explicitely named.
			string $selectedLayers[];
			tokenizeList($layers, $selectedLayers);

			// Special case: the internal name for masterLayer is
			// defaultRenderLayer
			for ($j =  0 ; $j<size($selectedLayers) ; $j++)
				if ($selectedLayers[$j] == "masterLayer")
					$selectedLayers[$j] = "defaultRenderLayer";

			if( mayaHasRenderSetup() )
			{
				// selectedLayers can either contain renderLayer or renderSetupLayer names
				// Try converting everything to renderLayer names
				for ($j =  0 ; $j<size($selectedLayers) ; $j++)
				{
					// Only attempt the change if the name does not match any existing renderLayer node
					if( size( `ls -type renderLayer ($selectedLayers[$j])` ) != 1 )
					{
						string $renderLayer[];
						if( !catch( $renderLayer = `renderSetupLegacyLayer $selectedLayers[$j] ` ) )
						{
							if( size( $renderLayer ) == 1 )
							{
								$selectedLayers[$j] = $renderLayer[0];
							}
						}
					}
				}				
			}



			for ($i = 0 ; $i<size($allLayers) ; $i++) 
			{
				string $currentLayer = $allLayers[$i];
				removeRenderLayerAdjustmentAndUnlock ($currentLayer+".renderable");

				$state = 0;
				for ($j =  0 ; $j<size($selectedLayers) ; $j++) {
					if ($currentLayer == $selectedLayers[$j]) {
						$state = 1;
						break;
					}
				}
				catch(`setAttr ($currentLayer+".renderable") $state`);
			}
		}
	}

	// Treat the passes
	if ($passes != "") {

		// These will filter down into the last if loop
		if ($passes == "off" || $passes == "false" || $passes == "0") {
			$passes = "beauty";
		}else if( $passes == "all" ){
			$passes = "beauty color ambient diffuse specular shadow";
		}
		if (!($passes == "on" || $passes == "true" || $passes == "1")) {

			// Assume a list of passes.
			// Turn all passes off, except the ones explicitely named.
			string $selectedPasses[];
			tokenizeList($passes, $selectedPasses);
			string $p[] = {"beauty", "color", "ambient",
							"diffuse", "specular", "shadow"};
			for ($i = 0 ; $i<size($p) ; $i++) {
				$state = 0;
				for ($j =  0 ; $j<size($selectedPasses) ; $j++) {
					if ($p[$i] == $selectedPasses[$j]) {
						$state = 1; break;
					}
				}

				for ($j =  0 ; $j<size($allLayers) ; $j++) {
					removeRenderLayerAdjustmentAndUnlock ($allLayers[$j]+"."+$p[$i]);
					catch(`setAttr ($allLayers[$j]+"."+$p[$i]) $state`);
				}
			}
		}
	}
}

