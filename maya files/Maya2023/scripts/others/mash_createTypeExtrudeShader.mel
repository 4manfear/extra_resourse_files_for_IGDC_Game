// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
source "buildShaderMenus.mel";

proc addFavouriteMenuItems(string $menuItems[], string $menuItemAnnotationFormat, string $item)
{
    if(size($menuItems) > 1)
        menuItem -divider true;
        
	for ($i = 0; $i < size($menuItems)-1; $i++)
	{
		//
		// Add a menu item to assign the favourite material to the
		// specified item, or to the current selection if item is
		// unspecified.
		//
		string $materialUIlabel = $menuItems[$i++];
		string $materialNodeID = $menuItems[$i];
        string $createMaterialAnnotation = `format -stringArg $materialNodeID $menuItemAnnotationFormat `;
        
		$menu = `menuItem 
		            -label $materialUIlabel
		            -annotation $createMaterialAnnotation
		            -command 
			            ("createAndAssignShader "
				            + $materialNodeID 
				            + " \""+$item+"\"")`;
	}
}

global proc createTypeExtrudeShaderWindow(string $typeExtrudeNode, string $typeRegion)
//
//	Creates the treeLister window to be used to create and
//	assign a new shader.
//
//	$item = object to act on, or null string if selection list should be used
//
{
	source "createAndAssignShader.mel";


	// Determine and save the classifications of the shaders and
	// shader types most appropriate to assign to the item.
	//
	string $classificationArray[] = {"shader/surface"};

	// Store classification array into a string to be passed on.
	string $filterString = stringArrayToString($classificationArray, " ");

    // Give 3rd parties a chance to append to the classification string filter
    string $thirdPartiesClassificationStrings[] = `callbacks -executeCallbacks -hook "provideClassificationStringsForFilteredTreeLister" $filterString`;
    for( $thirdPartiesClassificationString in $thirdPartiesClassificationStrings )
    {
	    $filterString = $filterString + " " + $thirdPartiesClassificationString; 
    }

	// Create the window and treeLister.
	//
	int $anmWindowWidth = 300; 
	global string $gAssignNewMaterialWindowTreeLister;
	global string $gAssignNewMaterialWindowLockButton;
	string $assignNewMaterial = (uiRes("m_buildShaderMenus.kCreateNewMaterial"));
	//string $postCommand = ("assignCreatedShader %type \"" + $item + "\" %node \"" + $objsString + "\"");
	string $postCommand = ("attachTypeExtrudeShader(\"" + $typeExtrudeNode + "\",\"" + $typeRegion + "\",\"%node\");");

	// Change the window title if there are no selected objects,
	// since in this case you can't actually assign the material
	// to anything.
	//

	if (!`window -exists assignNewMaterialWindow`) {
		window -rtf false
			-title $assignNewMaterial
			-iconName $assignNewMaterial
			-menuBar true
			-maximizeButton false
			-ret 
			-wh $anmWindowWidth 730 
			assignNewMaterialWindow;

		//
		// Setup up the menu bar
		//

		menu -label (uiRes("m_buildShaderMenus.kOptions")) optionsMenu;

			menuItem 
				-label (uiRes("m_buildShaderMenus.kAutomaticAttributeEditor"))
				-annotation (uiRes("m_buildShaderMenus.kAutomaticAttributeEditorAnnoation"))
				-checkBox (`optionVar -q AEpopupWhenCreatingShaders`)
				-command "optionVar -intValue AEpopupWhenCreatingShaders #1"
				attrEdPopupItem;
		
		setParent -m ..;  // from optionsMenu

		formLayout assignWindowForm;

			$gAssignNewMaterialWindowTreeLister = createRenderNodeTreeLister($postCommand, $filterString);
			$gAssignNewMaterialWindowLockButton = 
				`iconTextCheckBox 
					-w 26 -h 26
					-image1 "lock.png" 					
					-annotation (uiRes("m_buildShaderMenus.kLockButtonAnnotation"))`;
			button -label (uiRes("m_buildShaderMenus.kClose")) 
				-h 26
				-c "window -e -vis false assignNewMaterialWindow" 
				closeButton;
		setParent ..;

		formLayout -e
			-af $gAssignNewMaterialWindowTreeLister "left" 1
			-af $gAssignNewMaterialWindowTreeLister "right" 1
			-af $gAssignNewMaterialWindowTreeLister "top" 1
			-ac $gAssignNewMaterialWindowTreeLister "bottom" 5 closeButton

			-af $gAssignNewMaterialWindowLockButton "left" 5
			-an $gAssignNewMaterialWindowLockButton "right"
			-af $gAssignNewMaterialWindowLockButton "bottom" 5
			-an $gAssignNewMaterialWindowLockButton "top"

			-ac closeButton "left" 0 $gAssignNewMaterialWindowLockButton
			-af closeButton "right" 5
			-af closeButton "bottom" 5
			-an closeButton "top"
			assignWindowForm;

		// Set a script job to refresh the treeLister if the selection changes.
		//
		scriptJob -event "SelectionChanged" "refreshAssignNewMaterialTreeLister \"\"";
    } else {
		window -e -title $assignNewMaterial assignNewMaterialWindow;
		refreshRenderNodeTreeLister($gAssignNewMaterialWindowTreeLister, $postCommand, $filterString);
	}

	// Set the window to refresh the treeLister when it is restored after
	// being minimized, just in case the selection has changed since then.
	//
	string $command = ("refreshAssignNewMaterialTreeLister \"" + "" + "\"");
	window -e -restoreCommand $command assignNewMaterialWindow;

	showWindow assignNewMaterialWindow;
}

proc int get_free_index_without_connections(string $node, string $attribute)
{
    int $mi[] = `getAttr -mi ($node +"."+ $attribute)`;
    int $index = 0;
    if (size($mi)>0)
	{
		int $idx = 0;
		$index = -1;
        for($idx in $mi)
		{
			string $connections[] = `listConnections ($node + "." + $attribute + "[" + $idx + "]")`; 
            if (size($connections) == 0)
			{
                $index = $idx;
                break;
			}
		}
        if ($index == -1)
		{
            $index = $mi[size($mi)-1] + 1;
		}
	}
    return $index;
}

global proc attachTypeExtrudeShader(string $typeExtrudeNode, string $typeRegion, string $shader)
{
	// check if type region has already a groupid node
	string $groupIdNode = "";
	string $connections[] = `listConnections -p 0 -source 1 -t "groupId" ($typeExtrudeNode + "." +$typeRegion+ "GroupId")`;
	if (size($connections) > 0)
	{
		$groupIdNode = $connections[0];
	}
	else
	{
		$groupIdNode = `createNode -ss "groupId"`;
		connectAttr ($groupIdNode + ".groupId") ($typeExtrudeNode + "." +$typeRegion+ "GroupId") -f;
	}


	$connections = `listConnections -p 0 -d 1 -sh 1 ($typeExtrudeNode + ".outputMesh")`;
	if (size($connections) == 0)
	{
		return; 
	}
	string $outMesh = $connections[0];

	getAttr -type ($outMesh + ".instObjGroups[0]");
	getAttr -type ($outMesh + ".instObjGroups[0].objectGroups");

	// fix default shader
	string $defaultSgConnections[] = `listConnections -d 1 -p 1 -type "shadingEngine" ($outMesh + ".instObjGroups[0]")`;
	if (size($defaultSgConnections) > 0)
	{
		disconnectAttr ($outMesh + ".instObjGroups[0]") $defaultSgConnections[0];

		//connect it to the default shader slot
		string $buffer[];
		tokenize $defaultSgConnections[0] "." $buffer;
		string $sgDefaultNode = $buffer[0];
		string $defaultShaderConnections[] = `listConnections -s 1 -p 0 ($sgDefaultNode + ".surfaceShader")`;
		attachTypeExtrudeShader($typeExtrudeNode, "default", $defaultShaderConnections[0]);
		
	    int $extDivision = `getAttr ($typeExtrudeNode+".extrudeDivisions")`;
        evalDeferred("setAttr \""+$typeExtrudeNode+".extrudeDivisions\" "+($extDivision - 1)+";setAttr \""+ $typeExtrudeNode+".extrudeDivisions\" "+$extDivision+"; "); 
	}

	int $obj_inst_group_id = get_free_index_without_connections($outMesh, "instObjGroups[0].objectGroups");
	connectAttr ($groupIdNode + ".groupId") ( $outMesh + ".instObjGroups[0].objectGroups["+$obj_inst_group_id+"].objectGroupId") -f;

	
	string $sgConenctions[] = `listConnections -p 0 -d 1 -type "shadingEngine" ($shader + ".outColor")`;
	if (size($sgConenctions) == 0)
	{
		return; 
	}

	string $sgNode = $sgConenctions[0];
	int $group_node_index = get_free_index_without_connections($sgNode, "groupNodes");
	connectAttr ($groupIdNode + ".message") ($sgNode + ".groupNodes["+$group_node_index+"]");

	int $dag_set_member_id = get_free_index_without_connections($sgNode, "dagSetMembers");
	connectAttr ($outMesh + ".instObjGroups[0].objectGroups["+$obj_inst_group_id+"]")  ($sgNode + ".dagSetMembers["+$dag_set_member_id+"]");
	connectAttr ($sgNode + ".memberWireframeColor") ($outMesh + ".instObjGroups[0].objectGroups["+$obj_inst_group_id+"].objectGrpColor");  

	if ($typeRegion == "cap")
	{
		setAttr ($typeExtrudeNode + ".enableCapShader") 1;
	}

	if ($typeRegion == "extrude")
	{
		setAttr ($typeExtrudeNode + ".enableExtrudeShader") 1;
	}

	if ($typeRegion == "bevel")
	{
		setAttr ($typeExtrudeNode + ".enableBevelShader") 1;
	}
}
