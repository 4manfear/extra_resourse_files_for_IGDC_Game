// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  4 April 1997
//
//  Procedure Name:
//      performPolyWedgeFace
//
//  Description:
//        
//         
//  Input Arguments:
//        $option : Whether to set the options to default values.
//  Return Value:
//        command string iff $option==2
//

//
// Initialize optionVars for polyWedgeFace:
// 
// 

proc setOptionVars (
	int			$forceFactorySettings
)
{
	optionVar -init $forceFactorySettings -category "Modeling.Edit Mesh.Wedge"
		-fv "polyWedgeFaceAngle" 90.0	// -wa/-wedgeAngle
		-iv "polyWedgeFaceDivisions" 4	// -d/-divisions
		;
}

global proc performPolyWedgeFaceSetup (string $parent, int $forceFactorySettings)
{
	string $prefix = "polyWedgeFace";
	float $fval;
	
	setOptionVars($forceFactorySettings);
	setParent $parent;

	$fval = `optionVar -query "polyWedgeFaceAngle"`;
	floatSliderGrp -edit -value $fval polyWedgeFaceAngle;

	int $ival = `optionVar -query polyWedgeFaceDivisions`;
	intSliderGrp -edit -value $ival polyWedgeFaceDivisions;
}

global proc performPolyWedgeFaceCallback (string $parent, int $doIt)
{
	string $prefix = "polyWedgeFace";
	
	setParent $parent;
	
	optionVar -floatValue "polyWedgeFaceAngle"
		`floatSliderGrp -query -value polyWedgeFaceAngle`;
	
	optionVar -intValue "polyWedgeFaceDivisions" 
		(`intSliderGrp -query -value polyWedgeFaceDivisions`);

	if ($doIt) 
	{
		performPolyWedgeFace 0;
		addToRecentCommandQueue "performPolyWedgeFace 0" "PolyWedgeFace";
	}
}

proc polyWedgeFaceOptions (string $prefix)
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateDescriptionMarginWidth;
	global int $gOptionBoxTemplateFrameSpacing;
	
	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;
	//tabLayout -scr true -tv false;

	string $commandName = "performPolyWedgeFace";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");
	
	// Form layout
	string $parent = `formLayout polyWedgeFaceOptions`;
	
		// Description frame
		string $descriptionFrame = 
		`frameLayout -label (uiRes("m_performPolyWedgeFace.kDescriptionFrame")) -mw $gOptionBoxTemplateDescriptionMarginWidth`;	
		
			columnLayout;
			text -label (uiRes("m_performPolyWedgeFace.kDescription1"));
			text -label (uiRes("m_performPolyWedgeFace.kDescription2"));

		setParent $parent;

		// Settings frame
		string $settingsFrame = 
		`frameLayout -label (uiRes("m_performPolyWedgeFace.kSettingsFrame"))`;

			columnLayout;
			floatSliderGrp -label (uiRes("m_performPolyWedgeFace.kArcAngle")) -min -360.0 -max 360.0 polyWedgeFaceAngle;	
			intSliderGrp -label (uiRes("m_performPolyWedgeFace.kDivisions")) -min 1 -max 10 polyWedgeFaceDivisions;

		setParent $parent;

	setParent ..;

	// Attach Description/Settings frames to form layout
	formLayout -e
		-af $descriptionFrame "top" $gOptionBoxTemplateFrameSpacing
		-af $descriptionFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $descriptionFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $descriptionFrame "bottom"

		-ac $settingsFrame "top" $gOptionBoxTemplateFrameSpacing $descriptionFrame
		-af $settingsFrame "left" $gOptionBoxTemplateFrameSpacing
		-af $settingsFrame "right" $gOptionBoxTemplateFrameSpacing
		-an $settingsFrame "bottom"

	$parent;
	
	waitCursor -state 0;
	setUITemplate -popTemplate;

	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyWedgeFace.kWedgeFaceButton"))
	       -command ($callback + " " + $parent + " " + 1) $applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0 + "; hideOptionBox")
		$saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1) $resetBtn;

	setOptionBoxTitle( (uiRes("m_performPolyWedgeFace.kWedgeFaceOptions")) );

	setOptionBoxHelpTag("WedgeFaces");

	eval (($setup + " " + $parent + " " + 0));

	showOptionBox();
}

proc int polyVerifyInputSelection()
// 
// Verify that faces and one or more edges are selected for a wedge operation.
//
{
	string $msg1 = (uiRes("m_performPolyWedgeFace.kWedgeFaceErrorMsg"));

	// Verify that faces are selected.
	string $faces[] = `filterExpand -sm 34 -expand true`;
	if ( 0 == size($faces) ) { 
		string $msg = (uiRes("m_performPolyWedgeFace.kWedgeFaceNoFaceErrorMsg"));
		error( $msg + " " + $msg1 );
		return 0;
	}

	// Verify that edges are selected.
	string $edges[] = `filterExpand -sm 32 -expand true`;
	if ( 0 == size($edges) ) { 
		string $msg = (uiRes("m_performPolyWedgeFace.kWedgeFaceNoEdgeErrorMsg"));
		error( $msg + " " + $msg1 );
		return 0;
	}

	return 1;
}

proc int polyComponentId(string $selection)
{
	int $id;
	string $result[];
	tokenize $selection "[]" $result;
	if (size($result) < 1) return -1;
	if ($result[1] == "") return -1;
	$id = $result[1];
	return $id;
}

proc string assembleCmd()
{
	setOptionVars (false);

	// Before we go iterating over everything that is selected
	// lets filter out any dependancy nodes so that we only 
	// take a look at shapes / components once we execute the
	// operation.
	//
	select -deselect `ls -sl -dependencyNodes`;

	int $doHistory = `constructionHistory -q -toggle`;

	string $cmd = "polyWedgeFace";
	$cmd += " -ws 1";
	
	float $wa = `optionVar -query "polyWedgeFaceAngle"`;
	int	  $wd = `optionVar -query "polyWedgeFaceDivisions"`;

	$cmd += " -wedgeAngle " + $wa;
	$cmd += " -divisions " + $wd;

	// Check if all selected edges belong to selected faces.
	//
	string $edges[] = `filterExpand -sm 32 -expand true`;
	string $faces[] = `filterExpand -sm 34 -expand true`;
	string $faceE[] = `polyListComponentConversion -toEdge $faces`;
	string $faceEdges[] = `filterExpand -sm 32 -expand true $faceE`;
	int $numSelEdgesOnSelFaces = 0;
	for ( $e in $edges ) {
		int $foundFaceEdge = 0;
		for ( $fe in $faceEdges ) {
			if ($e == $fe) {
				$numSelEdgesOnSelFaces += 1;
			}
		}
	}

	if ( $numSelEdgesOnSelFaces == size( $edges ) ) {
		// All selected edges belong to the selected faces. We use the
		// -edge flag to pass the list of selected edges to the command.
		//
		for ($edge in $edges) {
			$cmd += " -ed " + polyComponentId($edge);
		}
	} else {
		// At least one of the edges does not lie on the selected face,
		// so instead of using the -edge flag, we'll instead use the
		// -center and -axis flags (these specify a point and vector to
		// rotate about). We compute the center to be the average of all
		// the midpoints for edges which are selected, and the axis to
		// be the average of the direction of each edge.
		//
		vector $center = <<0.0, 0.0, 0.0>>;
		$axis = $center;
		$first = true;
		vector $firstAxis = <<0.0, 0.0, 1.0>>;
		for ( $e in $edges ) {
			// Get the indices of the two vertices comprising the edge.
			//
			string $mesh = `match "^[^\.]*" $e`;
			string $vList[] = `listAttr $e`;
			string $vIdx0 = match( "[0-9]+", $vList[0] );
			string $vIdx1 = match( "[0-9]+", $vList[4] );

			// Add the location of the two vertices that comprise this edge
			// to the centre, and add the direction to the axis.
			//
			float $f[] = `pointPosition -w ($mesh+".vtx["+$vIdx0+"]")`;
			vector $v0 = <<$f[0], $f[1], $f[2]>>;
			$f = `pointPosition -w ($mesh+".vtx["+$vIdx1+"]")`;
			vector $v1 = <<$f[0], $f[1], $f[2]>>;
			$center += 0.5 * ( $v0 + $v1 );
			vector $dir = ( $v1 - $v0 );
			normalize( $dir );
			$axis += $dir;
			if ( $first ) {
				// Remember first edge in case subsequent edges make the
				// sum zero.
				//
				$firstAxis = $dir;
			}

			// Remove all edges from the selection list. Why? because
			// polyPerformAction executes the command we've assembled on
			// each unique mesh that we selected, and if an edge is
			// selected on a mesh with no face selected, it will try to
			// "wedge" that mesh. This is a better solution that adding a
			// special case inside polyPerformAction.
			//
			select -deselect $edges;
		}

		// Pass the -center and -axis using the average edge midpoint and
		// average direction.
		//
		$numE = size( $edges );
		if ( $numE > 1 ) {
			$center /= $numE;
			$axis /= $numE;
			if ( mag( $axis ) < 0.0005 ) {
				$axis = $firstAxis;
			}
		}
		$cmd += " -center " + $center.x + " " + $center.y + " " + $center.z;
		$cmd += " -axis " + $axis.x + " " + $axis.y + " " + $axis.z;
	}
	return $cmd;
}


global proc string performPolyWedgeFace (int $option)
{
	string $prefix = "polyWedgeFace";
	string $cmd="";

	switch ($option) 
	{
		case 0:
		// Verify that we have the correct selection.
		if ( polyVerifyInputSelection() ) {

			setOptionVars(false);
			
			string $cmd=`assembleCmd`;
		
			polyPerformAction $cmd "f" 0;    

			// make sure node is selected when there is history
			if ( 0 != size(`ls -sl`) || (0 != size(`ls -hl`)) ) {
				string $tmp[] = `listHistory`;
				string $totalSel[];
				for ($opNode in $tmp) {
					if (`nodeType $opNode` == "polyWedgeFace") {
						$totalSel[size($totalSel)] = $opNode;
					}
				}
			
 				if (size($totalSel) > 0) 
 					select -add $totalSel[0];
			}

			setToolTo ShowManips;
		}
		break;

		case 1:
			polyWedgeFaceOptions($prefix);
			break;
		case 2:
			$cmd="performPolyWedgeFace 0";
			break;
	}
	return $cmd;
}

