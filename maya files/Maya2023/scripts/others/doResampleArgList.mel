// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  February 01, 2001
//
//  Description:
//		doResampleArgList is the actual proc that is executed from the
//	Edit->Curves->Resample option box or menu
//
//  Input Arguments:
//	$version: The version of this option box.  Used to know how to 
//	interpret the $args array.
//		"1" : $timeRange, $timeTolerance, $valueTolerance,
//				$selectionConnection, $options
//
//	$args
//	Version 1
//	[0] 	$whichRange				1: time range all
//									2: use playback range
//									3: use $timeRange
//
//	[1] 	$timeRange 				startTime:endTime
//
//	[2]		$resampleKernel			1: Closest Sample
//									2: Linear Interpolation
//									3: Box Filter
//									4: Triangle Filter
//									5: Gaussian 1/sqrt(2)
//									6: Gaussian 1/2
//
//	[3]		$timeStep				The timesteps to use when resampling.
//	[4]		$selectionConnection	name of selection connection to use
//									unless $options has "bufferCurve" in which
//									case this is the name of the editor
//
//	[5]		$options				a ':' delimited list of options
//									noOptions       an empty placeholder
//									bufferCurve     create buffer curves
//
//  Return Value:
//      The number of curves resampled.
//
global proc int doResampleArgList (string $version, string $args[])
{
	int		$versionNum				= $version;

	int     $whichRange				= $args[0];
	string  $timeRange				= $args[1];
	int		$resampleKernel			= $args[2];
	string	$timeStep				= $args[3];
	string	$selectionConnection	= $args[4];
	string 	$options				= $args[5];

	string $cmd = "filterCurve -f resample ";
	string $kernelList[] = {"closest",
							"lirp",
							"box",
							"triangle",
							"gaussian2",
							"gaussian4"};

	$kernelString = $kernelList[$resampleKernel-1];
	$cmd += (" -kernel " + $kernelString + " ");

	string $realConnection = $selectionConnection;

	// Check for the bufferCurve option
	//
	if (match ("bufferCurve", $options) == "bufferCurve") {
		$realConnection = `editor -query -mainListConnection $selectionConnection`;
		// Check to see if we need to create buffer curves
		//
		if (`animCurveEditor -query -showBufferCurves $selectionConnection` == "on") {
			$cmd = "bufferCurve -animation \"keys\" -overwrite false; " + $cmd;
		}
	}

	// Get the target objects
	//
	string $members;
	$members = expandSelectionConnection ($realConnection);

	if ($whichRange > 1) {
		float $startTime = `playbackOptions -q -min`;
		float $endTime = `playbackOptions -q -max`;

		if ($whichRange == 3) {
			string $buff[];
			tokenize $timeRange ":" $buff;
			$startTime = $buff[0];
			$endTime = $buff[1];
		}

		$cmd = ( $cmd + "-startTime \"" + $startTime + "\" " );
		$cmd = ( $cmd + "-endTime \"" + $endTime + "\" " );
	}

	// Add on the tolerances
	//
	$cmd = $cmd + "-period " + $timeStep + " ";

	if (($members == "") || ($members == "{}")) {
		$cmd = "";
		warning ( (uiRes("m_doResampleArgList.kNoObjectsSelected")) );
	}
	else {
		$cmd = ($cmd + " " + $members);
	}

	if ($cmd == "") {
		return (0);
	} else {
		return evalEcho( $cmd );
	}
}
