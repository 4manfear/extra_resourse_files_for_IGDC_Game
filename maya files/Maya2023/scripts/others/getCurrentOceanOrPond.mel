// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  2002
//
// Description: Get selected or sole ocean shader
//	

proc int isUsablePond( string $fluid ){
	int $solver = getAttr ($fluid + ".solver");
	if( $solver < 2 ){
		return false;
	}
	int $is2d 		 = getAttr ($fluid + ".is2d");
	if( $is2d == 0 ){ return false; }

	int $heightField = getAttr ($fluid + ".heightField");
	if( !$heightField ){ return false; }

	int $opacityInput = getAttr ($fluid + ".opacityInput");
	if( $opacityInput != 5 ){ return false; }

	int $densityMethod = getAttr ($fluid + ".densityMethod");
	if( $densityMethod != 2 ){ return false; }

	return( true );
}

proc string[] getPondFluids() {
	string $pondFluids[];
	string $fluids[] = `ls -dag -type fluidShape`;
	for(  $i = 0; $i < size( $fluids ); $i++ ){
		if( isUsablePond( $fluids[$i] ) ){
			$pondFluids[size($pondFluids)] = $fluids[$i];
		}
	}
	return  $pondFluids;
}

global proc string getCurrentOceanOrPond()
{
	// if there is exactly one ocean or pond in the scene, use it

	string $shaders[] = `ls -type oceanShader`;
	string $fluids[] = getPondFluids();
	int $numThings = size($shaders) + size($fluids);
	if( $numThings == 0 ){
		warning((uiRes("m_getCurrentOceanOrPond.kNoOceanOrPOnd")));
		return( "" );
	}
	// If only one shader or pond then use it
	if( $numThings == 1 ){
		if( size( $shaders ) == 1 ){
			return( $shaders[0] );
		} else {
			return( $fluids[0] );
		}
	}

	// There is more than one, so we need to disambiguate using the selection
	// if there there is more than one ocean and/or pond selected, 
	// we will look for the first ocean or pond selected


	// First check for selected oceanShaders 
	string $sel[] = `ls -sl -type oceanShader`;
	if( size($sel) > 0 ){
		return( $sel[0] );
	}

	// next check for selected objects with ocean shaders or selected ponds
	$sel = `ls -sl -dag -type shape`;
	int $i;
	for( $i = 0; $i < size( $sel ); $i++ ){
		string $nType = `nodeType $sel[$i]`;
		if( $nType == "heightField" ){
			string $con[] = `listConnections ($sel[$i] + ".displacement")`;
			if( size( $con ) > 0){
				$nType = `nodeType $con[0]`;
				if( $nType == "oceanShader" ){
					return( $con[0] );
				}
			}
		} else if( $nType == "fluidShape" ){
			// is it a fluid shape that is a pond (and not already an ocean wake)
			if( isUsablePond( $sel[$i] ) ){
				return( $sel[$i] );
			}

		} else {
			string $con[] = `listConnections ($sel[$i] + ".instObjGroups[0]")`;
			if( size( $con ) > 0 ){
				string $con2[] = `listConnections ($con[0] + ".displacementShader")`;
				if( size( $con2 ) > 0 ){
					$nType = `nodeType $con2[0]`;
					if( $nType == "oceanShader" ){
						return( $con2[0] );
					}
				}
			}
		}
	}

	warning((uiRes("m_getCurrentOceanOrPond.kTooManyOceansOrPonds")));
	return( "" );	
}
