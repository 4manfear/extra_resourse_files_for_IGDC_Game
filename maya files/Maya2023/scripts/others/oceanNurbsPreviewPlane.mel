// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  2002
//
//
//<doc>
//<name oceanNurbsPreviewPlane>
//
//<synopsis>
//      oceanNurbsPreviewPlane xresolution, yresolution, textureName
//
//<returns>
//      None.
//
//<description>
// This mel procedure creates a poly plane with an expression to offset the uvs based
// on an input surface texture or oceanShader node. The input texture may be modified
// and the plane will interactively update. The generated expression provides
// an example of how one could use the colorAtPoint command to create a
// displacement mapping effect. Note that for
// preview uses the heightField node is more efficient for this general task,
// although it does not modify geometry that can be rendered or output.
// If one uses this for an ocean shader, the mapping is determined by the
// position of the plane, such that translating the plane moves it over the
// stationary ocean displacement. For surface textures the mapping is the same
// as the texture swatch( uv 0-1).
//
//
//<flags>
//  None.
//
//<examples>
//
// oceanNurbsPreviewPlane 10 10 oceanShader1;
// // Creates 10x10 nurbs surface with cvs displaced by ocean surface //
//</doc>


global proc oceanNurbsPreviewPlane(int $xres, int $zres, string $oceanShader)
{
	string $result[] = `nurbsPlane -w 1 -lr 1 -d 1 -u $xres -v $zres -ax 0 1 0 -ch 0`;
	string $plane = $result[0];
	setAttr -l true ( $plane+".rotate");
	setAttr -l true ( $plane+".scaleY");
	setAttr -l true ( $plane+".translateY");
	if( $zres < $xres ){
		setAttr ($plane+".scaleZ") ((float)$zres/(float)$xres);
	} else {
		setAttr ($plane+".scaleX") ((float)$xres/(float)$zres);
	}

	int $x,$y;
	int $xSize = $xres+1;
	int $zSize = $zres+1;
	int $planeZ, $planeX;

	string $exp = ( "float $u, $v;\n"
			  + "float $minx = " +$plane+ ".scaleX * -0.5 + " + $plane + ".translateX;\n"
			  + "float $maxx = " +$plane+ ".scaleX *  0.5 + " + $plane + ".translateX;\n"
			  + "float $minz = " +$plane+ ".scaleZ * -0.5 + " + $plane + ".translateZ;\n"
	  		  + "float $maxz = " +$plane+ ".scaleZ *  0.5 + " + $plane + ".translateZ;\n"
                    + "float $disp[] = `colorAtPoint -o A -su "+$xSize+" -sv "+$zSize
			      +" -mu $minx -mv $minz -xu $maxx -xv $maxz "+$oceanShader+"`;\n"
      );
	// unfold loop and use output connections 
	int $i=0;
	for( $x = 0; $x < $xSize; $x++ ){
		$planeX = $x * $zSize;
		for( $z = 0; $z < $zSize; $z++ ){
			$planeZ= $zSize - $z - 1;
			$exp +=  ($plane + ".cv[" + ($planeX + $planeZ) + "].yv = $disp["+$i+"];\n");
			$i++;
		}
	}

	expression -s $exp;
	select ($plane+".cv[0][0]");
	select $plane;
}
