// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

global proc int blendShapeTargetMove(string $bsdName, int $fromIndex, 
	int $toParent, int $toIndex, int $after)
// 
// Description:
//   Move the item (target or target directory) to the right place,
//   under the same blendShape node.	
// 
// Input: 
//   $fromIndex    this item will be moved, 
//                 >= 0 is a target, 
//                 < 0  is a target directory.
//   $toParent     this will be the new parent after moving, this must be a directory,
//                 >= 0, target directory,
//                 < 0, $toParent * -1 make it > 0.
//   $toIndex      this will be a new brother/sister after moving, 
//                 >= 0, target;
//                 < 0,  target directory. 
//   $after        0 before $toIndex; 
//                 1 after $toIndex;
//                 2 as the first child under $toParent, regardless what value $toIndex is;
//                 3 as the last child under $toParent, regardless what value $toIndex is;
// 
//   $toParent
//     |- 
//     |- $toIndex
//     |- 
// 
// Return: 
//   1 succeed, 0 fail.
// 
{	
	// this must be a target directory index
	if ($toParent < 0)
		$toParent *= -1; 

	// pre function check, make sure the $toParent and $toIndex are valid. 
	if ($after != 2 && $after !=3)
	{
		if ($toIndex >= 0)
		{
			$tempAttr = $bsdName + ".parentDirectory[" + $toIndex + "]";
			int $tempToParent = `getAttr $tempAttr`;
			if ($tempToParent != $toParent)
			{   
				return 0;
			} 
		}
		else
		{
			$tempAttr = $bsdName + ".targetDirectory[" + -$toIndex + "].parentIndex";
			int $tempToParent = `getAttr $tempAttr`;
			if ($tempToParent != $toParent)
			{   
				return 0;
			}
		}
			
		$tempAttr = $bsdName + ".targetDirectory[" + $toParent + "].childIndices";
		int $childIndices[] = `getAttr $tempAttr`;
		if ( intArrayFind($toIndex, 0, $childIndices) == -1 )
		{
			return 0; 
		}
	}
	
	// to remove the from item from the old parent directory.
	//
	int $fromParent = -1; 
	if ($fromIndex >= 0)
	{
		// the from item is a target.
	
		$tempAttr = $bsdName + ".parentDirectory[" + $fromIndex + "]";
		$fromParent = `getAttr $tempAttr`;
	}
	else
	{	
		// $fromIndex < 0, moving a target directory.
		
		$tempAttr = $bsdName + ".targetDirectory[" + -$fromIndex + "].parentIndex";
		$fromParent = `getAttr $tempAttr`;	
	}	
	if ($fromParent >= 0)
	{
		$tempAttr = $bsdName + ".targetDirectory[" + $fromParent + "].childIndices";
		int $childIndices[] = `getAttr $tempAttr`;
		int $toRemoveIndices[] = { $fromIndex }; // $fromIndex could be target(>=0), or directory(<0);
		$childIndices = intArrayRemove( $toRemoveIndices, $childIndices );
						
		$cmd = "setAttr " + $tempAttr + " -type Int32Array " + size($childIndices);
		for ($idx in $childIndices)
			$cmd += " " + $idx;
		eval($cmd);
	}	
	
	// point from item to the new parent directory.
	// 
	if ($fromIndex >= 0)	
	{	 
		// the from item is a target. 
		$tempAttr = $bsdName + ".parentDirectory[" + $fromIndex + "]";
		setAttr $tempAttr $toParent;
	}
	else
	{
		// the from item is a target directory.
		$tempAttr = $bsdName + ".targetDirectory[" + -$fromIndex + "].parentIndex";
		setAttr $tempAttr $toParent;
	}
	
	// to add the from item to the new parent directory.
	//
	$tempAttr = $bsdName + ".targetDirectory[" + $toParent + "].childIndices";
	int $childIndices[] = `getAttr $tempAttr`;
	
	int $insertLocation = size($childIndices);
	if ($after == 2)
	{				
		$insertLocation = 0; // to the head
	}
	else if ($after == 3)
	{
		$insertLocation = size($childIndices); // to the end 
	}
	else
	{
		int $findLocation = intArrayFind($toIndex, 0, $childIndices);
		if ($findLocation == -1) 
		{
			// this could be try when array is empty
			$insertLocation = size($childIndices); // find no match, add to end
		}	
		else
		{
			if ($after == 1)
				$insertLocation = $findLocation + 1; // add right after  
			else if ($after == 0)
				$insertLocation = $findLocation; // add right before   
		}				
	}
	intArrayInsertAtIndex($insertLocation, $childIndices, $fromIndex);
	
	$tempAttr = $bsdName + ".targetDirectory[" + $toParent + "].childIndices";
	$cmd = "setAttr " + $tempAttr + " -type Int32Array " + size($childIndices); 
	for ($idx in $childIndices)
		$cmd += " " + $idx;
	eval($cmd);

	// post function check
	$tempAttr = $bsdName + ".targetDirectory[" + $toParent + "].childIndices";
	$childIndices = `getAttr $tempAttr`;
	if ( intArrayFind($fromIndex, 0, $childIndices) == -1 )
	{
		return 0; 
	}
	
	return 1;
}	
