// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  20 Feb 2002
//
//  Description:
//      Return an approximation of the expected file size, in Kbytes,
//      per frame, to cache this fluid.
//
global proc float fluidCacheSize( string $fluid, int $numFrames )
{
    float $res[] = `getAttr ($fluid + ".resolution")`;

    int $tag          = 8;   // tag size in bytes
    int $val          = 4;   // value size in bytes

    int $header       = 60;  // FOR4 up to but not including next FOR4

    int $for4ThruRes  = 60;  // FOR4 through DRES
    int $NUMD         = $tag + $val;
    int $DENS         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NMVX         = $tag + $val;
    int $NMVY         = $tag + $val;
    int $NMVZ         = $tag + $val;
    int $VELX         = $tag + ( ($res[0]+1) * $res[1] * $res[2] * $val );
    int $VELY         = $tag + ( ($res[0]+1) * $res[1] * $res[2] * $val );
    int $VELZ         = $tag + ( ($res[0]+1) * $res[1] * $res[2] * $val );
    int $NUMT         = $tag + $val ;
    int $TEMP         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NUMR         = $tag + $val ;
    int $REAC         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NUMC         = $tag + $val ;
    int $COLR         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $COLB         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $COLG         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $NUMU         = $tag + $val ;
    int $TEXU         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $TEXV         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );
    int $TEXW         = $tag + ( ($res[0] * $res[1] * $res[2]) * $val );

	float $oneFrame = ( $for4ThruRes +
						$NUMD +
						$DENS +
						$NMVX +
						$NMVY +
						$NMVZ +
						$VELX +
						$VELY +
						$VELZ +
						$NUMT +
						$TEMP +
						$NUMR +
						$REAC +
						$NUMC +
						$COLR +
						$COLB +
						$COLG +
						$NUMU +
						$TEXU +
						$TEXV +
						$TEXW ); 
					
    int $overSampling = ( `optionVar -query fluidsDiskCacheSampling` == 1 );
    int $samplingRate = `optionVar -query fluidsDiskCacheSamplingRate`;

    if( $overSampling ) {
        $numFrames *= $samplingRate;
    } else if( $samplingRate != 0 ) {
        $numFrames /= $samplingRate;
    }

    // This isn't quite exact because it depends on whether the 
    // fluid grids have been allocated or not yet.  But this is 
    // a good place to start for a maximum value approximation.
    // 
    float $size = $header + ( $numFrames * $oneFrame );
    $size = $size / 1024.0; // kilobytes
	
    return $size;
}
