// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc string getNewTextureFileName(string $obj, string $textureNode, string $attrName)
{
	string $dirName;
	string $currName = `getAttr ($textureNode+"."+"ftn")`;
	string $ext = ".iff";
	if ($currName == "") {
		string $sceneName = `file -shn -q -loc`;
		if ($sceneName == "unknown") {
			$sceneName = "";
		} else {
			string $ext = fileExtension($sceneName);
			$sceneName = substring($sceneName,1,size($sceneName)-size($ext)-1);
		}
		// no name has yet been assigned, so generate a default
		//
		string $imageDir = (`workspace -q -rd`+"sourceimages\/");
		if (`file -q -ex $imageDir`) {
			workspace -dir $imageDir;
		}
		$imageDir += ($sceneName+"\/");

		if (! `file -q -ex $imageDir`) {
			sysFile -makeDir $imageDir;
		}
		$dirName = $imageDir;
	} else {
		$dirName = dirname($currName);
		$ext = fileExtension($currName);
		$dirName += "\/";
	}

	string $baseName = ($dirName+$obj+"_vtx_"+$attrName);
	int $counter = 1;
	string $fileName = ($baseName+$counter);
	while (`file -q -exists ($fileName+"."+$ext)`) {
		$counter++;
		$fileName = ($baseName+$counter);
	}
	return $fileName;
}

global proc nClothVtxMapToTextureMap( string $version, string $args[] )
{
	string $attr = $args[0];
	string $attrName = $args[1];	
	int $attrType = $args[2];
	string $useThisMesh = $args[3];

	string $cloth;
	string $mesh;
	// The 0 to getNMeshToPaint means we do not accept component
	// selections, the user must select an nCloth
	//
	string $meshAndCloth[] = getNMeshToPaint( $useThisMesh, 0 );
	string $nComponent;
	if ($attrType == 2) {
		$nComponent = getNComponentToEdit(0);
	}

	if( size($meshAndCloth) > 1 ){
		$mesh = $meshAndCloth[0];
		$cloth = $meshAndCloth[1];
	} else {
		error((uiRes("m_nClothVtxMapToTextureMap.kMustSelectNClothToPaint")));
	}

	string $currCtx = `currentCtx`;
	string $currentSelection[] = `ls -sl`;

	// Connect a file texture node if it isn't connected already.
	//
	string $fileName;
	string $fileType = "iff";
	string $tMapAttr = 	($attrType == 2) ? $nComponent : $cloth;
	$tMapAttr += ("."+$attr);
	string $con[] = `listConnections -d 1 -type file $tMapAttr`;
	string $extension;
	if ( size($con) == 0 ) {
		global int $g3dPaintDeferEval;
		int $oldVal = $g3dPaintDeferEval;
		$g3dPaintDeferEval = 0;
		catch(`paintNClothTexture $attr $attrName $attrType 0 $useThisMesh`);
		$con = `listConnections -d 1 $tMapAttr`;
		$g3dPaintDeferEval = $oldVal;
	}

	// get a new name for this converted texture
	//
	$fileName = getNewTextureFileName($cloth,$con[0],$attr);
	if (`file -q -exists $fileName`) {
		sysFile -del $fileName;
	}

	// Export the map for the influence using the new file name
	//
	select -r $currentSelection;
	if ($attrType == 2) {
		artAttrNComponentToolScript 4 $attrName;
	} else {
		artAttrNClothToolScript 4 $attrName;
	}
	string $currentCtx = `currentCtx`;
	artAttrCtx -e -exportfiletype "IFF" $currentCtx;
	catch(`artAttrCtx -e -exportfilesave $fileName $currentCtx`);
	string $nodeName = 	($attrType == 2) ? $nComponent : $cloth;
	nBase -e -clearCachedTextureMap $attr $nodeName;
	setAttr ($con[0]+".ftn") -type "string" ($fileName+".iff");

	// uncomment this line if we want to enter the paint tool after conversion
//	paintNClothTexture $attr $attrName $attrType 0 $useThisMesh;	

	// Go back to the original context.
	select -r $currentSelection;
	setToolTo $currCtx;
}
