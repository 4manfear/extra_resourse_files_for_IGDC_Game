// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  December 16, 1996
//
//  Description:
//      This script creates a panel which has a button line and a hyper panel 
//	in it.
//
//  Input Arguments:
//      panel name
//
//  Return Value:
//      None.
//

global int $gKeepHyperGraphWhileClosingWindow = false;
global int $gHeatMapAutoUpdateJob = -1;

global proc createHyperGraphPanel (string $whichPanel)
//
//  Description:
//		Define the editors that are used in this panel.  No
//		controls (widgets) are created at this point.
//		Adds support for the context sensitive help menu items.
//
{
	//  create unique names for editors based on panel name
	//
	string $hyperGraphEd = ($whichPanel + "HyperGraphEd");
	string $nameFilter = ($hyperGraphEd + "NameFilter");

	hyperGraph
		-unParent
		-popupMenuScript "HyperGraphEdMenu"
		$hyperGraphEd;

	if (`exists hyperUserInit`) hyperUserInit $hyperGraphEd;

	//	Add support for the Context Sensitive Help Menu.
	//
	addContextHelpProc $whichPanel "buildHyperGraphContextHelpItems";
}

global proc initHyperGraphPanel (string $whichPanel) 
//
//  Description:
//		Called on file -new/open.  
//
{
	string $hyperGraphEd = ($whichPanel + "HyperGraphEd");
	
	hyperGraph -e -filter "" $hyperGraphEd;

	// Apply any saved settings, if appropriate
	applyHypergraphSettings $whichPanel;
}

global proc dropDepth(string $hypergraphEd)
{
        int $depth =`hyperGraph -q -limitGraphTraversal $hypergraphEd`;

        // The depth number cannot go below -1.
        //
        if ($depth == -1)
        {
            return;
        } 

        $depth -= 1;
        hyperGraphDepthSet($hypergraphEd, $depth);
}

global proc raiseDepth(string $hypergraphEd)
{
        int $depth =`hyperGraph -q -limitGraphTraversal $hypergraphEd`;
        $depth += 1;
        hyperGraphDepthSet($hypergraphEd, $depth);
}

global proc unlimitedDepth(string $hypergraphEd)
{
        hyperGraphDepthSet($hypergraphEd, -1);  
}

global proc zeroDepth(string $hypergraphEd)
{
        hyperGraphDepthSet($hypergraphEd, 0);
}

global proc hyperGraphDepthSet(string $hypergraphEd, int $depth)
{
        if ($depth < 0)
        {
                // decrease the traversal depth 
                hyperGraph -e -limitGraphTraversal -1 $hypergraphEd;
        }
        else
        {
                // increase the traversal depth
                hyperGraph -e -limitGraphTraversal $depth $hypergraphEd;
        }
        
        // refresh the view
        showDGLevel $hypergraphEd;
        
        // set value in text box
        textField -e -text $depth hgDepthText;
}

global proc setHGDepth (string $hypergraphEd)
{
        // first get the actual amount from the text field
        int $depth = `textField -q -text hgDepthText`;
        hyperGraphDepthSet($hypergraphEd, $depth);
}

global proc	string[] hyperGraphs( int $all )
// Description:
//		Return a list of all HyperGraph windows which currently have heat
// map display enabled. If `all' is true, all HyperGraphs are returned.
// If false, only those with heat map display enabled are returned.
//
{
	string $result[];
	string $editors[] = `lsUI -editors`;
	string $editor;
	int	   $count = 0;

	for ( $editor in $editors ) {
		if ( `hyperGraph -exists $editor` ) {
			if ( $all || `hyperGraph -q -heatMapDisplay $editor` ) {
				$result[$count++] = $editor;
			}
		}
	}

	return( $result );
}

global proc doHeatMapUpdate( int $all )
// Description:
//		This procedure is a scriptJob which updates the heat map display
// by (1) regenerating the heat map and then (2) redrawing all HyperGraph
// windows in heat map display mode.
//
{
	global int		$gHeatMapAutoUpdateJob;
	global float	$gHeatMapMax;

	// Determine all hypergraphs which are currently in heat map display
	// mode.
	//
	string $editors[] = `hyperGraphs( $all )`;
	if ( size( $editors ) == 0 ) {
		return;
	}

	// Get the display parameters.
	//
	int $m = 1;
	string $metric;
	if ( `optionVar -exists heatMapMetric` ) {
		$m = `optionVar -q heatMapMetric`;
	} else {
		optionVar -iv heatMapMetric $m;
	}
	switch( $m ) {
		case 1:
			$metric = "callback";
			break;
		case 2:
			$metric = "compute";
			break;
		case 3:
			$metric = "dirty";
			break;
		case 4:
			$metric = "draw";
			break;
	}

	int	$t = 0;
	string $type;
	if ( `optionVar -exists heatMapType` ) {
		$t = `optionVar -q heatMapType`;
	} else {
		optionVar -iv heatMapType $t;
	}
	switch( $t ) {
		case 1:
			$type = "self";
			break;
		case 2:
			$type = "inclusive";
			break;
		case 3:
			$type = "count";
			break;
	}

	// Get the upper and lower threshold. Use the slider values if either
	// the remap or hide check boxes are true.
	//
	float $lower = 0.0;
	float $upper = 100.0;
	int $remap = false;
	int $hide = false;
	if ( `checkBoxGrp -q -exists heatMapThreshold` ) {
		$remap = `checkBoxGrp -q -v1 heatMapThreshold`;
		$hide = `checkBoxGrp -q -v2 heatMapThreshold`;

		if ( $remap || $hide ) {
			$upper = `floatSliderGrp -q -v heatMapThresholdUpper`;
			$lower = `floatSliderGrp -q -v heatMapThresholdLower`;
			if ( $lower > $upper ) {
				warning (uiRes("m_hyperGraphPanel.kBadRange"));
				$upper = 100.0;
			}
		}
	}

	// Recalculate the heat map.
	//
	float $L = $remap ? $lower : 0.0;
	float $U = $remap ? $upper : 100.0;
	$gHeatMapMax = `dgtimer -updateHeatMap 8 -rangeLower $L
			-rangeUpper $U -sortMetric $metric -sortType $type`;

	// If the hide option is enabled, we want the HyperGraph to hide
	// any nodes outside the range. Convert the range to use absolute
	// timings from percentages.
	//
	if ( $hide ) {
		$lower *= $gHeatMapMax * 0.01;
		$upper *= $gHeatMapMax * 0.01;
	} else {
		$lower = $upper = -1.0;
	}

	// Force hypergraphs to refresh.
	//
	for ( $editor in $editors ) {
		hyperGraph -e -range $lower $upper $editor;
		hyperGraph -e -forceRefresh $editor;
	}
}

global proc terminateHeatMapAutoUpdateCheck()
// Description:
//		To be called when heat map mode is toggled off in a HyperGraph
// window, or a HyperGraph window is closed. What it does is checks for
// any remaining HyperGraphs that are in heat map mode and if none,
// terminates the update scriptJob if still active.
//
{
	global int	$gHeatMapAutoUpdateJob;
	string $inHeat[] = `hyperGraphs( false )`;

	if ( size( $inHeat ) == 0 && $gHeatMapAutoUpdateJob != -1 ) {
		scriptJob -kill $gHeatMapAutoUpdateJob;
		$gHeatMapAutoUpdateJob = -1;
	}
}

global proc int isEvalModeDG(){
	string $evaluationMode[] = `evaluationManager -q -m`;
	string $em = $evaluationMode[0];
	
	return `strcmp $em "off"`; // 0 means mode is off(DG), ie enabled
}

global proc updateHeatMapDisplay( int $enable, string $editor )
// Description:
//      Updates the PER-hypergraph heat map display mode by enabling
// timing, updating the display and launching the auto-update job.
//
{
    global int  $gHeatMapAutoUpdateJob;

    if ( $enable ) {
		if ( `dgtimer -off -q` ) {
            dgtimer -on;
        }
        doHeatMapUpdate( false );
        if ( $gHeatMapAutoUpdateJob == -1 ) {
            // The heat map will update after playback finishes.
            //
            $gHeatMapAutoUpdateJob = `scriptJob -cf "playingBack" "doHeatMapUpdate(false)"`;
        }
    } else {
        terminateHeatMapAutoUpdateCheck();
		// If evaluation manager is disabled and timer is on, disable the timer since heat map
		// is being disabled. (MAYA-96691)
		if ( !`evaluationManager -q -e` && `dgtimer -on -q` ) {
 	 		dgtimer -off;
 	 	}
		hyperGraph -e -forceRefresh $editor;
    }
}

global proc addHyperGraphPanel (string $whichPanel)
//
//  Description:
//		Add the panel to a layout.
//		Parent the editors to that layout and create any other
//		controls (widgets) required.
//
{
	string $hyperGraphEd = ($whichPanel + "HyperGraphEd");

	waitCursor -state on;
	
	// Make sure that there is no template active
	setUITemplate -pushTemplate NONE;

	// Create Menu Bar, which will use exactly the same menu entries as the popupMenu
	// on the background of the hyperPanel

//	menuBarLayout hyperGraphMenu;
//	setParent -menu ..;

	// If this is the first Hypergraph to be created in this session
	// then get all of the options from the optionVars.
	//
	global int $gFirstHypergraph = 0;
	if ($gFirstHypergraph == 0) {
		$gFirstHypergraph = 1;  
		string $category = "Hypergraph";
		
		// Set default state for Display preferences
		//
		optionVar -init false -category $category
			-iv hypergraphDisplayShapeNodes 0
			-iv hypergraphDisplayInvisibleNodes 0
			-iv hypergraphDisplayUnderworldNodes 0
			-iv hypergraphDisplayExpressions 0
			-iv hypergraphDisplayConstraints 0
			-iv hypergraphSelectedFromConnection 0
			-iv hypergraphSelectedToConnection 0
			-iv hypergraphDisplayDeformers 0
			-iv hypergraphDisplayImage 0
			-iv hypergraphShowCachedConnections 0
			-iv hypergraphShowRelationships 1
			-iv hypergraphMergeConnections 1
			-iv hypergraphOpaqueContainers 0
			-sv hypergraphGraphLayoutStyle "HierarchicalLayout"
			;

		hyperGraph -e -showShapes `optionVar -q hypergraphDisplayShapeNodes` $hyperGraphEd;
		hyperGraph -e -showInvisible `optionVar -q hypergraphDisplayInvisibleNodes` $hyperGraphEd;
		hyperGraph -e -showUnderworld `optionVar -q hypergraphDisplayUnderworldNodes` $hyperGraphEd;
		hyperGraph -e -showExpressions `optionVar -q hypergraphDisplayExpressions` $hyperGraphEd;
		hyperGraph -e -showConstraints `optionVar -q hypergraphDisplayConstraints` $hyperGraphEd;
		hyperGraph -e -showDeformers `optionVar -q hypergraphDisplayDeformers` $hyperGraphEd;
		hyperGraph -e -imageEnabled `optionVar -q hypergraphDisplayImage` $hyperGraphEd;
		hyperGraph -e -showCachedConnections `optionVar -q hypergraphShowCachedConnections` $hyperGraphEd; 
		hyperGraph -e -showRelationships `optionVar -q hypergraphShowRelationships` $hyperGraphEd;
		hyperGraph -e -mergeConnections `optionVar -q hypergraphMergeConnections` $hyperGraphEd;
		hyperGraph -e -opaqueContainers `optionVar -q hypergraphOpaqueContainers` $hyperGraphEd;
		hyperGraph -e -graphLayoutStyle "hierarchicalLayout" $hyperGraphEd;
		hyperGraph -e -showConnectionFromSelected `optionVar -q hypergraphSelectedFromConnection` $hyperGraphEd;
		hyperGraph -e -showConnectionToSelected `optionVar -q hypergraphSelectedToConnection` $hyperGraphEd;
			
		// Set default state for Heat Map display options. These don't
		// have a "hypergraph" naming prefix because we may want to
		// use this setting in non-HG windows in the future and the
		// pref is thus Maya-wide.
		//
		optionVar -init false -category $category
			-iv heatMapDisplay 0
			-iv heatMapMetric 2
			-iv heatMapType 1
			-iv hypergraphFreeform 0
			-iv hypergraphUpdateSelection 1
			-iv hypergraphUpdateNodeAdded 1
			-iv hypergraphColorOverride 0
			;

		hyperGraph -e -freeform `optionVar -q hypergraphFreeform` $hyperGraphEd;
		hyperGraph -e -updateSelection `optionVar -q hypergraphUpdateSelection` $hyperGraphEd;
		hyperGraph -e -updateNodeAdded `optionVar -q hypergraphUpdateNodeAdded` $hyperGraphEd;
        hyperGraph -e -useDrawOverrideColor `optionVar -q hypergraphColorOverride` $hyperGraphEd;

	}

	// Set the heat map display mode for this new HyperGraph based on the
	// pref, and if we are in heat, update the state so that the editor
	// displays in the correct levels and auto-update is enabled.
	//
	int $how = `optionVar -q heatMapDisplay`;
	hyperGraph -e -heatMapDisplay $how $hyperGraphEd;
	if ( $how && isEvalModeDG() == 0 ) {
		updateHeatMapDisplay( $how, $hyperGraphEd );
	}

	string $baseForm = `formLayout hyperGraphBaseForm`;
        	frameLayout 
			-visible true 
			-borderVisible false
			-labelVisible false 
			-collapsable false 
			-collapse true
			hyperGraphToolbarFrame;
		string $toolBarForm = `flowLayout -visible true hyperGraphToolbarForm`;
		
		//
		// Create quick access buttons which will be hooked up later, 
		// so they can be in sync with the menu as well as the popupMenu.
		//
		
		int $iconsize = 26;
		
		setParent $toolBarForm;

			string $filterField 
				= filterUICreateField($hyperGraphEd, $toolBarForm);

			separator -h $iconsize -horizontal false -style single hgSeparator1;

			iconTextButton
				-i1 "frameGraph.png" 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kFrameAllAnnot"))
				frameGraphButton;
	
			iconTextButton
				-i1 "frameSelection.png" 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kFrameSelectionAnnot"))
				frameSelectionButton;

			iconTextButton
				-i1 "frameHierarchy.png" 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kFrameHierarchyAnnot"))
				frameHierButton;
			
			iconTextButton 
				-i1 "frameBranch.png" 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kFrameBranchAnnot"))
				frameBranchButton;

			separator -h $iconsize -horizontal false -style single hgSeparator2;

			iconTextButton
	 			-i1 "showDag.png" 
				-w $iconsize -h $iconsize
	 			-annotation (uiRes("m_hyperGraphPanel.kSceneHierarchyAnnot"))
	 			showDAGButton;

			iconTextButton
	 			-i1 "showDepend.png" 
				-w $iconsize -h $iconsize
	 			-annotation (uiRes("m_hyperGraphPanel.kInputOutputConnectAnnot"))
	 			showDGButton;

			separator -h $iconsize -horizontal false -style single hgSeparator3;

			iconTextButton
				-i1 "addBookmark.png" 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kCreateBookmarkAnnot"))
				addBookmarkButton;

			iconTextButton
				-i1 "editBookmark.png" 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kBookmarkEditorAnnot"))
				editBookmarkButton;

			separator -h $iconsize -horizontal false -style single hgSeparator4;
	
			iconTextCheckBox 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kToggleLayoutModeAnnot"))
				($hyperGraphEd+"freeformButton");

			// Set up the initial value
			if (`hyperGraph -q -freeform $hyperGraphEd`) {
				iconTextCheckBox -edit
					-i1 "freeformOn.png" 
					-value true
					($hyperGraphEd+"freeformButton");
			} else {
				iconTextCheckBox -edit
					-i1 "freeformOff.png" 
					-value false
					($hyperGraphEd+"freeformButton");
			}

            // Merged / Unmerged connections
			iconTextCheckBox 
				-w $iconsize -h $iconsize
				-annotation (uiRes("m_hyperGraphPanel.kMergeConnectionsToggle"))
                -i1 "mergeConnections.png"
                -value `hyperGraph -q -mergeConnections $hyperGraphEd`
				($hyperGraphEd+"mergeConnectionsButton");

			separator -h $iconsize -horizontal false -style single hgSeparator5;

            // create/remove container 
            //
            iconTextButton
                -width $iconsize -height $iconsize
                -image1 "createContainer.png" 
                -annotation (uiRes("m_hyperGraphPanel.kCreateContainer"))
                ($hyperGraphEd+"createContainerButton");
            
            iconTextButton
                -width $iconsize -height $iconsize
                -image1 "removeContainer.png" 
                -annotation (uiRes("m_hyperGraphPanel.kRemoveContainer"))
                ($hyperGraphEd+"removeContainerButton");

            // collapse/expand container
            //
            iconTextButton
                -width $iconsize -height $iconsize
                -image1 "collapseContainer.png" 
                -annotation (uiRes("m_hyperGraphPanel.kCollapseContainer"))
                ($hyperGraphEd+"collapseContainerButton");
            
            iconTextButton
                -width $iconsize -height $iconsize
                -image1 "expandContainer.png" 
                -annotation (uiRes("m_hyperGraphPanel.kExpandContainer"))
                ($hyperGraphEd+"expandContainerButton");

                        separator -h $iconsize -horizontal false -style single hgSeparator6;

                        iconTextButton
                                -i1 "zeroDepth.png" 
                                -w $iconsize -h $iconsize
                                -annotation (uiRes("m_hyperGraphPanel.kSetTraversalAnnot"))
                                -command ("zeroDepth " + $hyperGraphEd)
                                zeroDepthButton;
                                
                        iconTextButton
                                -i1 "reduceDepth.png" 
                                -w $iconsize -h $iconsize
                                -annotation (uiRes("m_hyperGraphPanel.kReduceTraversalDepthAnnot"))
                                -command ("dropDepth " + $hyperGraphEd)
                                reduceDepthButton;
                        
                        textField       -width 28
                                                -height 28
                                                -annotation (uiRes("m_hyperGraphPanel.kSetHypergraphDepthAnnot"))
                                                -changeCommand ("setHGDepth " + $hyperGraphEd)
                                                hgDepthText;
                                                
                        iconTextButton
                                -i1 "increaseDepth.png" 
                                -w $iconsize -h $iconsize
                                -annotation (uiRes("m_hyperGraphPanel.kIncreaseTraversalDepthAnnot"))
                                -command ("raiseDepth " + $hyperGraphEd)
                                increaseDepthButton;                                            
                                                
                        iconTextButton
                                -i1 "unlimitedDepth.png" 
                                -w $iconsize -h $iconsize
                                -annotation (uiRes("m_hyperGraphPanel.kSetTraversalDepthAnnot"))
                                -command ("unlimitedDepth " + $hyperGraphEd)
                                unlimitedDepthButton;          

			separator -h $iconsize -horizontal false -style single rightSeparator;

			setParent ..;
	setParent ..;		

	// Parent the editors to the editor layout
	//

	hyperGraph -edit -parent $baseForm $hyperGraphEd;
	formLayout -edit
		-attachForm hyperGraphToolbarFrame top 0
		-attachForm hyperGraphToolbarFrame left 0
		-attachForm hyperGraphToolbarFrame right 0
		-attachForm $hyperGraphEd left 0
		-attachForm $hyperGraphEd right 0
		-attachForm $hyperGraphEd bottom 0
		-attachControl $hyperGraphEd top 0 hyperGraphToolbarFrame
		$baseForm;
	setParent -top;

	//	Attach a procedure that will limit the kinds of filters displayed
	//	in the Hyper Graph's filter menus.
	//
	filterUISetRelatedFiltersProcedure($hyperGraphEd, "hyperGraphFilterCategories");

	setUITemplate -popTemplate;

	waitCursor -state off;
}

global proc removeHyperGraphPanel (string $whichPanel)
//
//  Description:
//		Remove the panel from a layout.
//		Delete controls.
//
{
	string $hyperGraphEd = ($whichPanel + "HyperGraphEd");

	if (`hyperGraph -exists $hyperGraphEd`) {
		hyperGraph -edit -unParent $hyperGraphEd;
		
		global int $gHeatMapJobNum;

		if ($gHeatMapJobNum && `scriptJob -exists $gHeatMapJobNum`){
			scriptJob -kill $gHeatMapJobNum;
		}
		
		// If evaluation manager is disabled and timer is on, disable the timer since heat map
		// is being disabled. (MAYA-96691)
		if ( !`evaluationManager -q -e` && `dgtimer -on -q` ){
 	 		dgtimer -off;
 	 	}
	}

	filterUIRemoveView($hyperGraphEd);
}

global proc deleteHyperGraphPanel (string $whichPanel)
//
//  Description:
//		This proc will delete the contents of the panel, but not
//		the panel itself.
//
//  Note:
//		We only need to delete editors here.  Other UI will be taken care of
//		by the remove proc.
//
{
	string $hyperGraphEd = ($whichPanel + "HyperGraphEd");

	if (`hyperGraph -exists $hyperGraphEd`) {
		deleteUI -editor $hyperGraphEd;
	}
}

global proc string saveStateHyperGraphPanel (string $whichPanel)
//
//  Description:
//		This proc returns a string that when executed will restore the
//		current state of the panel elements.
//
{
	string $indent = "\n\t\t\t";
	string $hyperGraphEd = ($whichPanel + "HyperGraphEd");

	return (
			$indent + "$editorName = ($panelName+\"HyperGraphEd\");\n" +
			`hyperGraph -query -stateString $hyperGraphEd`
	);
}

global proc hyperGraphPanel (string $panelName)
//
//  Description:
//		Create a new scripted fullGraphPanel.  If the scripted
//		panel hasn't yet been defined then define it.
//
{
	global string $gMainPane;

	if (!`scriptedPanelType -exists hyperGraphPanel`) {
		//
		//  Define the callbacks for the hyperGraphPanel
		//
		scriptedPanelType
			-unique true
			-createCallback		"createHyperGraphPanel" 
			-initCallback		"initHyperGraphPanel" 
			-addCallback		"addHyperGraphPanel"
			-removeCallback		"removeHyperGraphPanel"
			-deleteCallback		"deleteHyperGraphPanel"
			-saveStateCallback	"saveStateHyperGraphPanel"
			hyperGraphPanel;
	}

	//  instantiate a new hyperGraphPanel
	//
	setParent $gMainPane;
	scriptedPanel -unParent -type hyperGraphPanel $panelName;
}

global proc buildHyperGraphContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items for the hyper graph.  
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_hyperGraphPanel.kHelpOnHypergraph"))
		-enableCommandRepeat false
		-command "showHelp Hypergraph";
}

global proc string [] hyperGraphFilterCategories()
//
//	Description:
//		Return the types of filters that the Hyper Graph will display
//		in its "Show->Objects" filter menu.
//
{
	string $result[] = { "Modeling", "Camera", "Animating", "Lighting" };
	return $result;
}
