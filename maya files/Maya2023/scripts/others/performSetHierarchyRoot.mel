// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc findAllJoints( string $node, string $all[] )
{
	if ( `objectType -isAType "joint" $node` == false )
		return;

	$all[ size( $all ) ] = $node;

	string $children[] = `listRelatives -children $node`;
	for ( $child in $children )
		findAllJoints( ($node+"|"+$child), $all );
}

// Sever connections between a clip and its ghost
proc disconnectClipFromGhost( string $clip )
{
	if ( size($clip) == 0 )
		return;

	string $ghost = getGhostShapeForClip( $clip );
	if ( size($ghost) == 0 )
		return;

	disconnectAttr ( $ghost + ".clipData" ) ( $clip  + ".clipData" );
	delete $ghost;
}

global proc performSetHierarchyRoot()
{
	string $characters[] = getCharactersForAction();
	if ( size( $characters ) > 1 )
		error( (uiRes("m_performSetHierarchyRoot.kTooManyActiveCharacters")) );

	if ( size( $characters ) == 0  )
		error( (uiRes("m_performSetHierarchyRoot.kNoActiveCharacters")) );

	string $sel[] = `ls -sl`;
	if ( size( $sel ) == 0 )
		error( (uiRes("m_performSetHierarchyRoot.kNothingSelected")) );

	if ( `objectType -isAType "transform" $sel[0]` == false )
	{
		string $msg = (uiRes("m_performSetHierarchyRoot.kNodeNotATransform"));
		error( `format -s $sel[0] $msg` );
	}

	string $clips[];

	string $scheduler = `character -q -sc $characters[0]`;
	if ( size( $scheduler ) )
		$clips = `clipSchedule -q -name $scheduler`;

	// Check if a clipToGhost node exists ...
	string $clipToGhostNodes[] = `listConnections -type clipToGhostData -d 1 -s 0 ( $characters[0] + ".message" )`;
	string $ghostedClips[];

	// ... if so 
	if ( size( $clipToGhostNodes ) )
	{
		// ... determine the clips in the scene that are ghosted
		$ghostedClips = getGhostedClips( $clipToGhostNodes[0] );

		// ... delete the clipToGhost node
		delete $clipToGhostNodes[0];

		// ... and sever any remaining connections between the clips and the ghost.
		for ( $clip in $ghostedClips )
			disconnectClipFromGhost( $clip );
	}

	// At this point there is no clipToGhost node and any old ghosts have been removed.
	// Next, create a new clipToGhost node ...
	string $clipToGhost = `createNode clipToGhostData` ;

	//  ... connect joints required to visualize the ghost
	string $members[] = {};
	findAllJoints( $sel[0], $members );
	for ( $i=0; $i<size($members); $i++ )
		connectAttr ( $members[$i] + ".message" ) ( $clipToGhost + ".members[" + $i + "]" );

	connectAttr ( $characters[0] + ".message" ) ( $clipToGhost + ".character" );

	// ... and wire up all clips to the new clipToGhost node
	for ( $clip in $clips )
		connectClipAndClipToGhost( $clip, $clipToGhost, $scheduler );

	// ... recreate the ghost on the clips (if any existed before this operation)
	performCreateClipGhost($ghostedClips);

	// restore the original selection
	select -r $sel;
}

