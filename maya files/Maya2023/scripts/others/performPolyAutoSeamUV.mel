// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc int Unfold3DPluginLoaded()
{
	return `pluginInfo -q -loaded Unfold3D`;
}

proc setOptionVars(int $forceFactorySettings)
{
	optionVar -init $forceFactorySettings -category "UV Editor.Auto Seams"
		-iv Unfold3DAutoSeamOperation 1
		-iv Unfold3DAutoSeamMethord 1
		-fv Unfold3DAutoSeamSegment 0.0
		-iv Unfold3DAutoSeamPipeCut 1
		-iv Unfold3DFixNonManifoldBeforeAutoSeam 0
		-iv Unfold3DAskToFixNonManifoldBeforeAutoSeam 1
		;

	if(!`Unfold3DPluginLoaded`) //If Unfold3D not loaded, force to use Cut hard edges
		optionVar -iv Unfold3DAutoSeamMethord 2;
}

global proc performPolyAutoSeamUVSetup(string $parent, int $forceFactorySettings)
{
	int $ival;
	float $fval;
	setOptionVars($forceFactorySettings);
	setParent $parent;
	
	$ival = `optionVar -query Unfold3DAutoSeamOperation`;
	radioButtonGrp -e -sl $ival Unfold3DAutoSeamOperation_RBG;
	
	$ival = `optionVar -query Unfold3DAutoSeamMethord`;
	radioButtonGrp -e -sl $ival Unfold3DAutoSeamMethord_RBG;

	$fval = `optionVar -query Unfold3DAutoSeamSegment`;
	floatSliderGrp -e -v $fval Unfold3DAutoSeamSegment_FSG;

	$ival = `optionVar -query Unfold3DAutoSeamPipeCut`;
	checkBoxGrp -e -v1 $ival Unfold3DAutoSeamPipeCut_CBG;

	$ival = `optionVar -query Unfold3DFixNonManifoldBeforeAutoSeam`;
	checkBoxGrp -e -v1 (0 != $ival) Unfold3DAutoSeamFixNonManifold_CBG;
	
	performPolyAutoSeamUVMethodToggle();
}

global proc performPolyAutoSeamUVCallback(string $parent, int $doIt)
{
	int $ival;
	float $fval;
	setParent $parent;

	$ival = `radioButtonGrp -q -sl Unfold3DAutoSeamOperation_RBG`;
	optionVar -iv Unfold3DAutoSeamOperation $ival;
	
	$ival = `radioButtonGrp -q -sl Unfold3DAutoSeamMethord_RBG`;
	optionVar -iv Unfold3DAutoSeamMethord $ival;

	$fval = `floatSliderGrp -q -v Unfold3DAutoSeamSegment_FSG`;
	optionVar -fv Unfold3DAutoSeamSegment $fval;

	$ival = `checkBoxGrp -q -v1 Unfold3DAutoSeamPipeCut_CBG`;
	optionVar -iv Unfold3DAutoSeamPipeCut $ival;

	$ival = `checkBoxGrp -q -value1 Unfold3DAutoSeamFixNonManifold_CBG`;
	optionVar -intValue Unfold3DFixNonManifoldBeforeAutoSeam $ival;

	if ($doIt) 
	{
		performPolyAutoSeamUV 0;
		addToRecentCommandQueue "performPolyAutoSeamUV 0" "PolyAutoSeamUV";
	}
}

proc polyAutoSeamUVOptions()
{
	// Global template variables for form spacing
	global int $gOptionBoxTemplateFrameSpacing;

	string $commandName = "performPolyAutoSeamUV";
	string $callback = ($commandName + "Callback");
	string $setup = ($commandName + "Setup");

	string $layout = getOptionBox();
	setParent $layout;
	setUITemplate -pushTemplate OptionBoxTemplate;
	waitCursor -state 1;
	
	string $parent = `columnLayout`;

	// Setting frame
	string $settingsFrame = `frameLayout -l (uiRes("m_performPolyAutoSeamUV.kSettingsFrame"))`;
	string $settingsLayout = `columnLayout`;
	
		checkBoxGrp 
			-l "" -label1 (uiRes("m_performPolyAutoSeamUV.kFixNonManifold"))
			-value1 false 
			Unfold3DAutoSeamFixNonManifold_CBG;
		
		setParent ..; //columnLayout
	setParent $parent; // frameLayout
	
	string $optionsFrame = `frameLayout -label (uiRes("m_performPolyAutoSeamUV.kAutoSeamSettingsFrame"))`;
	string $optionsLayout = `columnLayout`;

		radioButtonGrp -nrb 2 -cw 2 70 -cw 3 70
			-l  (uiRes("m_performPolyAutoSeamUV.kOperation"))
			-label1 (uiRes("m_performPolyAutoSeamUV.kPixelUnits"))
			-label2 (uiRes("m_performPolyAutoSeamUV.kUVUnits")) 
			Unfold3DAutoSeamOperation_RBG;
			
		radioButtonGrp -nrb 2 -cw 2 70 -cw 3 70
			-l  (uiRes("m_performPolyAutoSeamUV.kMethod"))
			-label1 (uiRes("m_performPolyAutoSeamUV.kAutomatic"))
			-enable1 `Unfold3DPluginLoaded`
			-label2 (uiRes("m_performPolyAutoSeamUV.kCutAlongHardEdges")) 
			-cc "performPolyAutoSeamUVMethodToggle"
			Unfold3DAutoSeamMethord_RBG;

		floatSliderGrp -field true
			-l (uiRes("m_performPolyAutoSeamUV.kSplitShells"))
			-min 0.0 -max 1.0
			Unfold3DAutoSeamSegment_FSG;

		checkBoxGrp
			-l (uiRes("m_performPolyAutoSeamUV.kCutPipes"))
			Unfold3DAutoSeamPipeCut_CBG;

		setParent ..; // columnLayout

	setParent $parent; // frameLayout
	setParent ..; // columnLayout

	waitCursor -state 0;
	setUITemplate -popTemplate;

	string $applyBtn = getOptionBoxApplyBtn();
	button -edit -label (uiRes("m_performPolyAutoSeamUV.kAutoSeamUVs")) -command ($callback + " " + $parent + " " + 1) $applyBtn;
	string $saveBtn = getOptionBoxSaveBtn();
	button -edit -command ($callback + " " + $parent + " " + 0 + "; hideOptionBox") $saveBtn;
	string $resetBtn = getOptionBoxResetBtn();
	button -edit -command ($setup + " " + $parent + " " + 1) $resetBtn;

	setOptionBoxTitle (uiRes("m_performPolyAutoSeamUV.kAutoSeamUVsOptions"));
	setOptionBoxHelpTag( "AutoSeamUVs" );
	eval(($setup + " " + $parent + " " + 0));
	
	showOptionBox();
}

global proc performPolyAutoSeamUVMethodToggle()
{
	if(!`radioButtonGrp -q -ex Unfold3DAutoSeamMethord_RBG`)
		return;
	$enable = `radioButtonGrp -q -select Unfold3DAutoSeamMethord_RBG` == 1;
	if(`floatSliderGrp -q -ex Unfold3DAutoSeamSegment_FSG`)
		floatSliderGrp -e -en $enable Unfold3DAutoSeamSegment_FSG;
	if(`checkBoxGrp -q -ex Unfold3DAutoSeamPipeCut_CBG`)
	    checkBoxGrp -e -en $enable Unfold3DAutoSeamPipeCut_CBG;
}

proc string assembleCmd()
{
	setOptionVars(false);
	$methord = `optionVar -q Unfold3DAutoSeamMethord`;
	if($methord == 1) // Automatic
	{
		if (!`Unfold3DPluginLoaded`)
		    error (uiRes("m_performPolyAutoSeamUV.kLoadPluginError"));
		
		$cmd = "u3dAutoSeam";
		
		float $segment = `optionVar -q Unfold3DAutoSeamSegment`;
		$cmd += " -s " + $segment;

		int $pipeCut = `optionVar -q Unfold3DAutoSeamPipeCut`;
		$cmd += " -p " + $pipeCut;

		int $operation = `optionVar -q Unfold3DAutoSeamOperation`;
		if ($operation == /*select*/2) $cmd += " -sl";
		return $cmd;
	}
	else if($methord == 2) // Cut along hard edges
	{
		$cmd = "polyUVHardEdgesAutoSeams ";
		int $cut = (`optionVar -q Unfold3DAutoSeamOperation` == 1);
		$cmd += $cut;
		return $cmd;
	}
}

global proc Unfold3DFixNonManifoldBeforeAutoSeamDialog()
{
	string $commandName = "AutoSeam";
	string $commandDisplayName = (uiRes("m_performPolyAutoSeamUV.kAutoSeam"));
	Unfold3DFixNonManifoldDialog($commandName, $commandDisplayName);
}

global proc string performPolyAutoSeamUV(int $option)
{
	switch ($option)  {
	case 0: {
		$cmd = `assembleCmd`;

		// validate the mesh and clean it up
		string $topoValidCmd = "u3dTopoValid -type";
		string $topoErrors[] = eval($topoValidCmd);

		if (size($topoErrors) > 0)
		{
			int $doClean = 0;
			if (`optionVar -q Unfold3DFixNonManifoldBeforeAutoSeam`)
				$doClean = 1;
			else if (`optionVar -q Unfold3DAskToFixNonManifoldBeforeAutoSeam`)
			{
				string $ret = `layoutDialog -title (uiRes("m_performPolyAutoSeamUV.kFixNonManifold")) -ui "Unfold3DFixNonManifoldBeforeAutoSeamDialog"`;
				if($ret == "yes")
					$doClean = 1;
			}
			
			if ($doClean)
				Unfold3DFixNonManifold($topoErrors);
		}

		evalEcho($cmd);
		break;
	}
	case 1:
		polyAutoSeamUVOptions();
		if (!`Unfold3DPluginLoaded`)
		{
			warning (uiRes("m_performPolyAutoSeamUV.kLoadPluginError"));
		}
		break;
	case 2:
		$cmd = `assembleCmd`;
		break;
	}
	return $cmd;
}
