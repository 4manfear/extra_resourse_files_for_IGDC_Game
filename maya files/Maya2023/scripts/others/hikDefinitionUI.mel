// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
// hikDefinitionUI.mel
//
// Description:
//		Methods for creating and updating the skeleton definition UI
//


///////////////////////////////////////////////////////////////////
// Local Methods...
///////////////////////////////////////////////////////////////////

proc int getBoneAttr(string $characterName, string $attributeName)
// Description:
//		Helper method for updateInvertedBoneState
//
{
	// Does the attribute exists
	if ( ! `attributeQuery -node $characterName -exists $attributeName` )
		return 0;

	return `getAttr ( $characterName + "." + $attributeName )`;	
}

proc updateInvertedBoneState( string $characterName )
// Description:
//		Helper method for hikRebuildBoneAssignments
//
{
	if ( ! hikIsCharacterizationToolUICmdPluginLoaded() )
		return;

	if ( size($characterName) < 0 )
		return;

	// kLeftKnee = 0
	// kRightKnee = 1
	// kLeftElbow = 2
	// kRightElbow = 3

	int $invertedState = 0;
	
	$invertedState = getBoneAttr( $characterName, "leftKneeInverted" );
	characterizationToolUICmd -edit -character $characterName -invertbone 0 -invertstate $invertedState;

	$invertedState = getBoneAttr( $characterName, "rightKneeInverted" );
	characterizationToolUICmd -edit -character $characterName -invertbone 1 -invertstate $invertedState;

	$invertedState = getBoneAttr( $characterName, "leftElbowInverted" );
	characterizationToolUICmd -edit -character $characterName -invertbone 2 -invertstate $invertedState;
	
	$invertedState = getBoneAttr( $characterName, "rightElbowInverted" );
	characterizationToolUICmd -edit -character $characterName -invertbone 3 -invertstate $invertedState;
}




///////////////////////////////////////////////////////////////////
// Global Methods...
///////////////////////////////////////////////////////////////////

global proc hikBuildDefinitionUI()
{
	global int $gHIKDockableWindowWidth;
	global int $gHIKScrollBarWidth;
	global int $gHIKDefinitionTabHeight;

	scrollLayout 
		-p hikDefinitionLayout 
		-w ($gHIKDockableWindowWidth + $gHIKScrollBarWidth) 
		-h ($gHIKDefinitionTabHeight)
		hikDefinitionScrollLayout;

		characterizationToolUICmd;

	setParent ..;
}

global proc hikBuildDefinitionButtons()
{
    rowLayout -numberOfColumns 9 hikDefinitionButtons;
   
		// New definition
		iconTextButton
				-command "hikCreateDefinition()"
				-annotation (uiRes("m_hikDefinitionUI.kCreateDefinition"))
				-image "addCreateGeneric.png"
				hikDefinitionNewButton;

		// Lock
		iconTextCheckBox
				-changeCommand "hikToggleLockDefinition()"
				-selectionImage "lockGeneric.png"
				-annotation (uiRes("m_hikDefinitionUI.kLockDefinition"))
				-image1 "unlockGeneric.png"
				-value false
				hikDefinitionLockButton;

		// Mirror
		iconTextCheckBox
				-changeCommand "hikMirrorMatching()"
				-annotation (uiRes("m_hikDefinitionUI.kMirrorDefinition"))
				-image1 "HIKmirror.png"
				-value true
				hikDefinitionMirrorButton;

		// Name match
		iconTextButton
				-command "hikNameMatching()"
				-annotation (uiRes("m_hikDefinitionUI.kLoadDefinition"))
				-image1 "openLoadGeneric.png"
				hikDefinitionLoadMapButton;

		// Extract mapping template
		iconTextButton
				-command "characterizationToolUICmd -edit -extractmapping"
				-annotation (uiRes("m_hikDefinitionUI.kSaveDefinition"))
				-image1 "saveGeneric.png"
				hikDefinitionMapButton;

		// Delete
		iconTextButton
				-command "hikDeleteDefinition()"
				-annotation (uiRes("m_hikDefinitionUI.kDeleteDefinition"))
				-image "deleteGeneric.png"
				hikDefinitionDeleteButton;
        
        separator -height 12 -horizontal false;
            
         // New control rig
        iconTextButton
			-version 2017
            -command "hikCreateControlRig"
            -annotation (uiRes("m_hikDefinitionUI.kCreateNewControlRig"))
            -image "HIKcreateControlRig.png"
            hikControlRigNewButton;
        
         // New custom rig
        iconTextButton
            -command "hikCreateCustomRig( hikGetCurrentCharacter() )"
            -annotation (uiRes("m_hikDefinitionUI.kCreateNewCustomRigMapping"))
            -image "HIKcreateCustRig.png"
            hikCustomRigNewButton;

	setParent ..;

	rowLayout -e -manage false hikDefinitionButtons;
}

global proc hikInitializeDefinitionUI()
// Description:
//		Initializes the state of the definition tab
//		when the unified character context is opened.
//
{
	// Set the default state of the component. We want mirror matching on
	if ( ! `characterizationToolUICmd -query -ismirrortoggle` )
		characterizationToolUICmd -edit -mirrormatch;
}

global proc hikUpdateDefinitionUI()
// Description:
//		Updates all Skeleton Definition related UI
//
{
	// IMPORTANT:
	// The other tabs have code here that skips the entire
	// UI update if the tab is not visible. The definition
	// tab is special because the logic for whether a
	// skeleton definition is valid or not lives in the
	// qt widget. So it may be called even if it's not
	// visible. We need at least the QT widget to update.
	// We can safely skip the rest of the ui update though.

	// Update the component with the current name
	string $character = hikGetCurrentCharacter();
	
	// Update the component with the current list of characters
	// as well, since it keeps an internal list
	hikDefinitionUpdateCharacterLists();
	
	hikRebuildBoneAssignments($character);

	// Skip udating this ui if the defintion tab is not visible
	if( !hikIsDefinitionTabSelected() )
		return;

	hikUpdateDefinitionButtonState();
}

global proc hikUpdateDefinitionButtonState()
{
	int $lockState = 0;
	int $mirrorState = 0;
	string $currentName = hikGetCurrentCharacter();
		
	// Lock
	if ( size($currentName) > 0 && `objExists $currentName` )
	{
		$lockState = hikIsDefinitionLocked( $currentName  );
		int $uiLockState = `characterizationToolUICmd -query -islocked`;
		if ( hikIsCharacterizationInValidOrWarningState() )
		{
			if ( $lockState != $uiLockState )
			{
				// Toggle so we flip the state
				characterizationToolUICmd -edit -locktoggle;
			}
		}
	}

	// Mirror
	$mirrorState = `characterizationToolUICmd -query -ismirrortoggle`;
	iconTextCheckBox -edit -value $lockState hikDefinitionLockButton;
	iconTextCheckBox -edit -value $mirrorState hikDefinitionMirrorButton;
    
    int $hasControlRig = hikHasControlRig($currentName);
    int $hasCustomRig = hikHasCustomRig($currentName);
    int $canCreate = (!$hasCustomRig && !$hasControlRig);
            
    iconTextButton -e -enable $canCreate hikControlRigNewButton;
    iconTextButton -e -enable $canCreate hikCustomRigNewButton;
}

global proc hikUpdateEditDefinitionMenu()
{
    string $character = hikGetCurrentCharacter();
    int $pluginLoaded = hikIsCharacterizationToolUICmdPluginLoaded();

    int $hasDef = hikHasDefinition($character);
    int $defLocked	= hikIsDefinitionLocked($character);
    int $mirrorState = ($hasDef && $pluginLoaded && `characterizationToolUICmd -q -ismirrortoggle`); 
}

global proc hikRebuildBoneAssignments( string $characterName )
{
	if ( ! hikIsCharacterizationToolUICmdPluginLoaded() )
		return;

	// make sure we have a valid character
	if( $characterName == "" )
		return;

	int $i;
	for($i = 0; $i < hikGetNodeCount(); $i++)
	{
		string $nodeName = GetHIKNodeName($i);
			
		string $tmpNode[];
		clear($tmpNode);
		string $tmpCharObjectName = $characterName + "." + $nodeName;
		if (size(`listConnections $tmpCharObjectName`)>0)
			$tmpNode = `listConnections $tmpCharObjectName`;
					
		string $nameFieldName = "nameField" + $nodeName;
		// if(size($tmpNode)>0)
		characterizationToolUICmd -edit -characternodeassign $characterName -nodeid $i -mayanodename $tmpNode[0];
		// else clear the field...
	}
		
	updateInvertedBoneState( $characterName );
}
