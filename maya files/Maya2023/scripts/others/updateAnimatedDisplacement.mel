// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// updateAnimatedDisplacement
// This mel command allows one to convert to poly a displacement map that has animation.
// It generally should be called from within an expression.

// TODO?? allow creation of lower resolution displacement mesh for things like collision? (rendered displacement would then be left with intermediate object off)
// TODO?? allow for global disable of update of all animated displacement meshes?
global proc doUpdateAnimatedDisplacementImp(string $obj, string $mesh, string $displacementInput, string $shadOutDisp, string $oldSel[])
{
	setAttr ($obj + ".intermediateObject") false;
	select -r $obj;
	displacementToPoly;
	string $newDisp[] = `ls -sl -dag -type mesh`;
	setAttr ($obj + ".intermediateObject") true;

	disconnectAttr $displacementInput $shadOutDisp;
	string $oldDisp = "";
	string $inHist[] = `listHistory( $mesh + ".inMesh")`;
	
	if( size( $inHist ) > 0 ){
		int $i;
		for( $i = 1; $i < size($inHist); $i++ ){
			if( nodeType( $inHist[$i] ) == "mesh" ){
				$oldDisp = $inHist[$i];
			}
		}
	}
	
	if( $oldDisp != "" ){
		string $destCon[] = `connectionInfo -dfs ($oldDisp + ".outMesh")`;
		connectAttr -f ($newDisp[0] + ".outMesh") $destCon[0];
		setAttr ($newDisp[0] + ".intermediateObject") true;
		string $tforms[]= `listTransforms $oldDisp`;
		delete $tforms;
	} else {
		connectAttr -f ($newDisp[0] + ".outMesh") ($mesh + ".inMesh");
	}

	select -r $oldSel;
}

global proc doUpdateAnimatedDisplacement(string $obj, string $mesh, string $displacementInput)
{
	string $oldSel[] = `ls -sl`;
	if(!objExists( $obj ) || !objExists($mesh) || !objExists( $displacementInput ) ){
		return;
	}

	string $shadCons[] = `listConnections -d 1 -sh 1 -type "shadingEngine" ($obj + ".instObjGroups[0]")`;
	if( size( $shadCons ) < 1 ){
		return;
	}
	string $shadOutDisp = ($shadCons[0] + ".displacementShader");
	string $displacementConnection = `connectionInfo -sfd $shadOutDisp`;
	if( size( $displacementConnection ) < 1 ){
		connectAttr $displacementInput $shadOutDisp;
	} else {
		if( $displacementInput != $displacementConnection ){
			return;
		}
	}
	int $undoState = `undoInfo -q -state`;
	undoInfo -state false;
	catch(doUpdateAnimatedDisplacementImp($obj, $mesh, $displacementInput, $shadOutDisp, $oldSel));
	undoInfo -state $undoState;
}

global proc updateAnimatedDisplacement(string $obj, string $mesh, string $displacementInput)
{
	int $p = `play -q -state`;
	$p = true;
	string $exp = "doUpdateAnimatedDisplacement "+$obj+" "+$mesh+" "+$displacementInput+ ";";
	if( $p ){
		eval ($exp );
	} else {
		evalDeferred( $exp  );
	}
}