// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//	Creation Date : April 27 1999.
//
//<doc>
//<name stitchAndExplodeShell>
//
//<synopsis>
//      string[] stitchAndExplodeShell()
//
//<description>
//		Given a group of NURBS surfaces which are connected, the script
//		stitches the surfaces together as a shell and subsequently 
//		creates trimmed NURBS surface shapes corresponding to the 
//		faces comprising the shell using a surfaceVarGroup.
//<P>
//		The stitchAndExplode is performed  by hooking up
//		the selected NURBS surfaces to a stitchAsNurbsShell node,
//		which in turn is connected to a explodeNurbsShell node.
//<P>
//		This is useful in removing cracks which show up while
//		rendering NURBS surfaces as the tesselation carried out
//		to render the triangles do not have the same vertices 
//		across the shared edges.
//
//<flags>
//      none. 
//
//<returns>
//      string[] : The surface var group. 
//
//<examples>
// select -r sphere1 fillet1 sphere2 ;
// string $osrf[] = stitchAndExplodeShell();
// // Result : { varGroup } //
//
//</doc>
//

global proc string[] stitchAndExplodeShell()
//
//	Description :
//
{

	string $osrf[] ;
	global int $gSelectNurbsSurfacesBit ;

	string $slist[] = `ls -sl` ;
    if( size($slist) == 0 ) {
        error (uiRes("m_stitchAndExplodeShell.kSelectToConvert"));
    }
    string $srf[] ;
    $srf = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit $slist` ;
    if( size($srf) == 0 ) {
        error (uiRes("m_stitchAndExplodeShell.kSelectAtLeastOne"));
        return $osrf ;
    }

	// create a stitch node.
	//
	int $i;
	int $ns = size($srf) ;
	string $stitchShell ;
	if( catch( $stitchShell = `createNode stitchAsNurbsShell` ) ) {
		error (uiRes("m_stitchAndExplodeShell.kFailedStitchAsNurbsShell")) ;
		return $osrf ;	
	}

	string $inAttr ;
	string $outAttr;
	for( $i = 0 ; $i < $ns ; $i++ ) {
		$inAttr = $srf[$i] + ".ws[0]" ;
		$outAttr = $stitchShell + ".is[" + $i + "]" ;
		connectAttr $inAttr $outAttr ;
	}

	// create an explode node.
	//
	string $explodeShell ;
	if( catch( $explodeShell = `createNode explodeNurbsShell` ) ) {
		error (uiRes("m_stitchAndExplodeShell.kFailedExplodeNurbsShell")) ;
		delete $stitchShell ;
		return $osrf ;	
	}

	$inAttr = $stitchShell + ".osh" ;
	$outAttr = $explodeShell + ".ish" ;
	connectAttr $inAttr $outAttr ;

	// get the stitched pieces.
	//	
	string $varGroup ;
	if( catch( $varGroup = `createNode surfaceVarGroup` ) ) {
		error (uiRes("m_stitchAndExplodeShell.kFailedSurfaceVarGroup")) ;
		delete $stitchShell ;
		delete $explodeShell ;
		return $osrf ;	
	} 

	// connect explode shell output to
	// the vargroup input.
	//
	$inAttr = $explodeShell + ".os" ;
	$outAttr = $varGroup + ".cr" ;
	connectAttr $inAttr $outAttr ;

	// create a nurbs surface and temporarily hook
	// it to varGroup for a compute.
	//
	string $tempSrf = `createNode nurbsSurface` ;
	$inAttr = $varGroup + ".l[0]" ;
	$outAttr = $tempSrf + ".cr" ;
	connectAttr $inAttr $outAttr ;
	$outAttr = $tempSrf + ".degreeU" ;
	getAttr $outAttr ;
	
	// get the # of surfaces in var group.
	//
	$outAttr= $varGroup + ".mc" ;
	int $n = `getAttr $outAttr` ;

	// delete the temporary surface.
	//
	delete $tempSrf ;

	// select the var group.
	//
	if( $n > 0 )  {
		$osrf[0] =  $varGroup;
		select -r $varGroup ;
		string $child[] ;
		$child = `listRelatives $varGroup` ;
	}

	// delete history.
	// 
	//delete -ch $varGroup ;

	// error message on failure.
	//
	if( $n <= 0 ) {
		error (uiRes("m_stitchAndExplodeShell.kFailedOnSelectedNURBSSurfaces"));
	}

	return $osrf ;
}
