// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//<doc>
//<name setNClothRestShape>
//<owner "Autodesk">
//
//<synopsis>
//		setNClothRestShape( string $target )
//
//<returns>
//		None.	
//
//<description>
//	This sets the nCloth rest shape to the desired entity based on the current selection and the
//  passed in argument.  It is equivalent to the rest shape calls on the nMesh menu.
//
//<flags>
//	string $target    either "mesh", "start" or "input"
//
//<examples>
//  setNClothRestShape "input";
//</doc>

global proc setNClothRestShape( string $target )
{
	if($target == "mesh"){
		string $mesh = "";
		string $nCloth = "";
		string $nCloths[] = `ls -sl -dag -type nCloth`;
		string $meshes[] = `ls -sl -dag -ni -type mesh`;
		int $numCloth = size($nCloths);
		int $numMesh = size($meshes);
		string $selectWarn = (uiRes("m_setNClothRestShape.kMeshSelectWarn"));
		string $topologyWarn = (uiRes("m_setNClothRestShape.kMeshTopologyWarn"));

		if( ($numCloth + $numMesh) != 2 || $numCloth > 1){
			// need exactly one cloth and one rest shape mesh
			warning( $selectWarn );
			return;
		}
		if( $numCloth == 1 ){
			// We allow the rest shape mesh to be a cloth object
			// if a cloth node is explicitly selected.
			$nCloth = $nCloths[0];
			$mesh = $meshes[0];
			string $c = findTypeInHistory( $mesh, "nCloth", 0, 1 );
			if( $c == $nCloth ){
				// avoid using the output mesh as the rest shape 
				warning( $selectWarn );
				return;
			}
		} else {	
			string $c1 = findTypeInHistory( $meshes[0], "nCloth", 1, 1 );
			string $c2 = findTypeInHistory( $meshes[1], "nCloth", 1, 1 );
			if(($c1 == "") == ($c2 == "")){
				$c1 = findTypeInHistory( $meshes[0], "membrane", 0, 1 );
				$c2 = findTypeInHistory( $meshes[1], "membrane", 0, 1 );
			}
			if(($c1 == "") == ($c2 == "")){
				// both or neither are cloth objects
				warning( $selectWarn );
				return;
			} 

			if( $c1 != "" ){
				$nCloth = $c1;
				$mesh = $meshes[1];
			} else {
				$nCloth = $c2;
				$mesh = $meshes[0];
			}
		}
		if( nodeType( $nCloth ) != "membrane" ){
			// check that the mesh resolutions match
			string $cons[] = `listConnections -sh 1 -type mesh ($nCloth + ".inputMesh")`;
			if( size($cons) < 1 ){
				warning( $topologyWarn );
				return;
			}
			string $inputMesh = $cons[0];
			int $pEval[] = `polyEvaluate -v $inputMesh`;
			int $numVerts = $pEval[0];
			$pEval = `polyEvaluate -v $mesh`;
			if ($numVerts != $pEval[0] ){
				warning( $topologyWarn );
				return;
			}
		}
		connectAttr -f ($mesh + ".worldMesh") ($nCloth + ".restShapeMesh");
	} else {
		string $selectWarn = (uiRes("m_setNClothRestShape.kNoObjWarn"));
		string $nCloths[] = `ls -sl -dag -type nCloth`;
		string $meshes[] = `ls -sl -dag -ni -type mesh`;
		string $mesh;
		int $numCloths = size($nCloths);
		for( $mesh in $meshes ){
			string $c = findTypeInHistory( $mesh, "nCloth", 1, 1 );
			if( $c == "" ){
				$c = findTypeInHistory( $mesh, "membrane", 0, 1 );
			}
			if( $c != "" ){
				$nCloths[$numCloths] = $c;
				$numCloths++;
			} 
		}
		if( $numCloths < 1 ){
			warning( $selectWarn );
			return;
		}
		string $nCloth;

		for( $nCloth in $nCloths ){
			string $restCon = ($nCloth + ".restShapeMesh");
			if( $target == "start" ){
				string $s = `connectionInfo -sfd $restCon`;	
				if( $s != "" ){
					disconnectAttr $s $restCon; 
				}
			} else if ($target == "input" && (nodeType($nCloth) != "membrane")){
				string $s = `connectionInfo -sfd ($nCloth + ".inputMesh")`;	
				connectAttr -f $s $restCon;
			}
		}
	}	
}
