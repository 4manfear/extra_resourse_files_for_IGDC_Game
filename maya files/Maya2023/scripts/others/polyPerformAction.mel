// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  18 April 1997
//
//

proc int booleanOperation(string $action)
{
	string $tmp[];
	tokenize $action $tmp;
	return $tmp[2];
}

proc setOptionVars(int $forceFactorySettings)
{
	optionVar -init $forceFactorySettings -category "Modeling.Mesh.Booleans"
		-iv booleansUseBoolPlugin 1
		-iv booleansObjectDisplay 0
		-iv booleanOpUseLegacy 0
		-iv booleanOpTagIntersection 1
		-iv booleanUnionClassification 1
		-iv booleanDifferenceClassification 1
		-iv booleanIntersectionClassification 1
		-iv booleanOpPreserveColor 0
		;

	optionVar -init $forceFactorySettings -category "Modeling.Mesh.Combine"
		-iv uniteMergeUVSets 1
		-iv uniteCombineSkinning 0
		-iv unitePivotPosition 0
		;

	optionVar -init $forceFactorySettings -category "Modeling.Edit Mesh.Connect"
		-iv polyConnectComponentsInsertWithEdgeFlow 0
		-fv polyConnectComponentsAdjustEdgeFlow 1.0
		;
}

proc int carveClassification()
{
	int $classification = 1;
	if (`radioButtonGrp -exists booleanOpEdgeClassification_RBG`)
	{
		int $choice = `radioButtonGrp -q -select booleanOpNormalClassification_RBG`;
		if (1 != $choice)
			$classification = 1;
	}
	return $classification;
}

proc setCarveClassification(int $choice)
{
	if (`radioButtonGrp -exists booleanOpEdgeClassification_RBG`)
	{
		if (1 == $choice)
		{
			radioButtonGrp -e -select 1 booleanOpEdgeClassification_RBG;
		}
		else
		{
			radioButtonGrp -e -select 1 booleanOpNormalClassification_RBG;
		}
	}
}

global proc performActionBooleanPluginChange()
{
	if (`checkBoxGrp -exists booleansUseBoolPlugin`)
	{
		int $useBoolPlugin = `checkBoxGrp -query -value1 booleansUseBoolPlugin`;

		columnLayout -edit -enable (!$useBoolPlugin) LegacyAlgorithms_CL; 
		columnLayout -edit -enable (!$useBoolPlugin) BoolPluginLegacyOptions_CL; ;
	}
}

global proc applyActionLegacyBooleanOpChange(int $useLegacy)
{
	if (`checkBoxGrp -exists booleanOpUseLegacy`)
	{
		checkBoxGrp -edit -enable (!$useLegacy) booleanOpTagIntersection;
		checkBoxGrp -edit -enable $useLegacy booleanOpPreserveColor;

		rowColumnLayout -edit -enable (!$useLegacy) CarveClassification_RBG;
	}
}

global proc performActionLegacyBooleanOpChange()
{
	if (`checkBoxGrp -exists booleanOpUseLegacy`)
	{
		int $useLegacy = `checkBoxGrp -query -value1 booleanOpUseLegacy`;
		applyActionLegacyBooleanOpChange($useLegacy);
	}
}

proc polyBooleanOptionsInit(string $parent, int $op)
{
	polyBooleanOptionsSetup($parent, 0);

	int $classification = 2;
	switch ($op)
	{
	case 1:
		$classification = `optionVar -query booleanUnionClassification`;
		break;
	case 2:
		$classification = `optionVar -query booleanDifferenceClassification`;
		break;
	case 3:
		$classification = `optionVar -query booleanIntersectionClassification`;
		break;
	}
	setCarveClassification( $classification );
}


//
//  Procedure Name:
//      polyBooleanOptionsCallback
//
//  Description:
//		Update the option values with the current state of the option box UI
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	doIt                 - whether the command should execute
//
//  Return Value:
//      None.
//
global proc polyBooleanOptionsCallback(string $action, string $funtype, string $parent, int $doIt)
{
 	setParent $parent;

	int $useBoolPlugin = true;

	int $useLegacy = false;

	int $tagComp = `checkBoxGrp -query -value1 booleanOpTagIntersection`;
	optionVar -iv booleanOpTagIntersection $tagComp;

	string $tmp[], $actionbase;
	tokenize $action $tmp;
	$actionbase = $tmp[0];

	int $len = size($tmp), $i;

	if ($useBoolPlugin  && "booltool" != $actionbase)
	{
		$action = "booltool";
		for ($i=1; $i<$len; $i++)
		{
			$action += (" " + $tmp[$i]);
		}
	}
	else if (!$useBoolPlugin)
	{
		if ($useLegacy && "polyBoolOp" != $actionbase)
		{
			$action = "polyBoolOp";
			for ($i=1; $i<$len; $i++)
			{
				$action += (" " + $tmp[$i]);
			}
		}
		else if (!$useLegacy && "polyCBoolOp" != $actionbase)
		{
			$action = "polyCBoolOp";
			for ($i=1; $i<$len; $i++)
			{
				$action += (" " + $tmp[$i]);
			}
		}

		if( !$useLegacy ) {
			$action += " -ti " + $tagComp;
		}
	}

	//Add object display parameter
	if (`optionMenuGrp -exists booleanOpObjDisplay`)
	{
		int $selectedIdx = `optionMenuGrp -q -select booleanOpObjDisplay` - 1;
		optionVar -iv booleansObjectDisplay $selectedIdx;
	}

	int $classification = carveClassification();
	int $op = $tmp[2];
	switch ($op)
	{
	case 1:
		optionVar -iv booleanUnionClassification $classification;
		break;
	case 2:
		optionVar -iv booleanDifferenceClassification $classification;		
		break;
	case 3:
		optionVar -iv booleanIntersectionClassification $classification;		
		break;
	}	

	if ($doIt)
	{
		string $cmd =("polyPerformAction \"" + $action + "\" " + $funtype + " 0");
		eval($cmd);
	}
}

//
//  Procedure Name:
//      polyBooleanOptionsSetSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc polyBooleanOptionsSetup(string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
 	setParent $parent;

	int $tagComp = `optionVar -query booleanOpTagIntersection`;
	checkBoxGrp -e -value1 $tagComp booleanOpTagIntersection;

	performActionLegacyBooleanOpChange();
	applyActionLegacyBooleanOpChange(0);

	int $objectDisplay = `optionVar -q booleansObjectDisplay` + 1;
	optionMenuGrp -e -select $objectDisplay booleanOpObjDisplay;
}

//  Procedure Name:
//      polyBooleanOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc polyBooleanOptions(string $action, string $funtype)
{
	//	Name of the command for this option box.
	//
	string $commandName = "polyBooleanOptions";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback \"" + $action + "\" " + $funtype);
	string $setup = ($commandName + "Setup");

 	//	STEP 1:  Get the option box.
	//	============================
	//
	//	The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);
	
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -tabsVisible 0 -scrollable 1;
	
	string $parent = `columnLayout -adjustableColumn 1`;

	frameLayout -label (uiRes("m_polyPerformAction.kSettingsLabel")) -collapsable 0; 
		columnLayout LegacyAlgorithms_CL; 

		//	Create the widgets for this option box
		//

		checkBoxGrp -label1 (uiRes("m_polyPerformAction.kBooleanOpTagIntersection"))   
			 booleanOpTagIntersection;

		//Dropdown combobox
		optionMenuGrp -label (uiRes("m_polyPerformAction.kInputObjDisplayLable")) booleanOpObjDisplay;
            menuItem -label (uiRes("m_polyPerformAction.kObjDisplayWf"));
            menuItem -label (uiRes("m_polyPerformAction.kObjDisplayShaded"));
            menuItem -label (uiRes("m_polyPerformAction.kObjDisplayBb"));
			menuItem -label (uiRes("m_polyPerformAction.kObjDisplayXRay"));
			menuItem -label (uiRes("m_polyPerformAction.kObjDisplayHidden"));

		setParent ..;
	setParent ..;

	int $op = booleanOperation($action);

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//	Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.
	//
	//	'Reset' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 1)
		$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0)
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	switch ($op)
	{
	case 1:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kUnionOpWindowTitle")));
		break;
	case 2:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kDifferenceOpWindowTitle")));
		break;
	case 3:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kIntersectionOpWindowTitle")));
		break;
	case 4:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kDifferenceBAOpWindowTitle")));
		break;
	case 5:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kSliceOpWindowTitle")));
		break;
	case 6:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kHolePunchOpWindowTitle")));
		break;
	case 7:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kCutOutWindowTitle")));
		break;
	case 8:
		setOptionBoxTitle((uiRes("m_polyPerformAction.kSplitEdgesOpWindowTitle")));
		break;
	}

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	polyBooleanOptionsInit $parent $op;

	setOptionBoxHelpTag("PolyBoolean");
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

//
//  Procedure Name:
//      polyUniteOptionsCallback
//
//  Description:
//		Update the option values with the current state of the option box UI
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	doIt                 - whether the command should execute
//
//  Return Value:
//      None.
//
global proc polyUniteOptionsCallback(string $action, string $funtype, string $parent, int $doIt)
{
 	setParent $parent;

	int $mergeUVSets = `radioButtonGrp -query -select uniteMergeUVSets` - 1;
	optionVar -iv uniteMergeUVSets $mergeUVSets;

	int $combineSkinning = `checkBoxGrp -query -value1 uniteCombineSkinning`;
	optionVar -iv uniteCombineSkinning $combineSkinning;

	int $pivotPos = `radioButtonGrp -query -select unitePivotPosition` - 1;
	optionVar -iv unitePivotPosition $pivotPos;

	if ($doIt)
	{
		string $cmd =("polyPerformAction \"" + $action + "\" " + $funtype + " 0");
		eval($cmd);
	}
}

//
//  Procedure Name:
//      polyUniteOptionsSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc polyUniteOptionsSetup(string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
 	setParent $parent;

	int $mergeUVSets = `optionVar -query uniteMergeUVSets`;
	radioButtonGrp -e -select ($mergeUVSets+1) uniteMergeUVSets;

	int $combineSkinning = `optionVar -query uniteCombineSkinning`;
	checkBoxGrp -e -value1 $combineSkinning uniteCombineSkinning;

	int $pivotPos = `optionVar -query unitePivotPosition`;
	radioButtonGrp -e -select ($pivotPos+1) unitePivotPosition;
}

//  Procedure Name:
//      polyUniteOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc polyUniteOptions(string $action, string $funtype)
{
	//	Name of the command for this option box.
	//
	string $commandName = "polyUniteOptions";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback \"" + $action + "\" " + $funtype);
	string $setup = ($commandName + "Setup");

 	//	STEP 1:  Get the option box.
	//	============================
	//
	//	The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);
	
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	tabLayout -tabsVisible 0 -scrollable 1;
	
	string $parent = `columnLayout -adjustableColumn 1`;

	frameLayout -label (uiRes("m_polyPerformAction.kUniteSettingsLabel")) -collapse 0; 
		columnLayout; 

		//	Create the widgets for this option box
		//
		radioButtonGrp -nrb 3 -label (uiRes("m_polyPerformAction.kUniteMergeUVSets"))
			 -label1 (uiRes("m_polyPerformAction.kNoMerge"))
			 -label2 (uiRes("m_polyPerformAction.kMergeByName"))
			 -label3 (uiRes("m_polyPerformAction.kMergeByUVLinks"))
			 -cw4 100 120 120 120
			 uniteMergeUVSets;
		checkBoxGrp -label1 (uiRes("m_polyPerformAction.kCombineSkinning"))   
			 uniteCombineSkinning;
		radioButtonGrp -nrb 3 -label (uiRes("m_polyPerformAction.kUnitePivotPosition"))
			 -label1 (uiRes("m_polyPerformAction.kPivotCenter"))
			 -label2 (uiRes("m_polyPerformAction.kPivotLastSelected"))
			 -label3 (uiRes("m_polyPerformAction.kPivotOrigin"))
			 -cw4 100 120 120 120
			 unitePivotPosition;
		setParent ..;
	setParent ..;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//	Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.
	//
	//	'Reset' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 1)
		$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -edit 
		-command ($callback + " " + $parent + " " + 0)
		$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -edit 
		-command ($setup + " " + $parent + " " + 1)
		$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle((uiRes("m_polyPerformAction.kCombineWindowTitle")));

	setOptionBoxHelpTag("polyUniteOptions");

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	eval (($setup + " " + $parent + " " + 0));	
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

//
//  Procedure Name:
//		polyConnectComponentsCallback
//
//  Description:
//		Update the option values with the current state of the option box UI
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	doIt                 - whether the command should execute
//
//  Return Value:
//      None.
//
global proc polyConnectComponentsCallback(string $action, string $funtype, string $parent, int $doIt)
{
 	setParent $parent;

	optionVar -intValue polyConnectComponentsInsertWithEdgeFlow `checkBoxGrp -q -value1 insertWithEdgeFlow`;
	optionVar -floatValue polyConnectComponentsAdjustEdgeFlow `floatSliderGrp -q -value adjustEdgeFlow`;

	if ($doIt) {
		polyPerformAction $action $funtype 0;
	}
}

//
//  Procedure Name:
//		polyConnectComponentsSetup
//
//  Description:
//		Update the state of the option box UI to reflect the option values.
//
//  Input Arguments:
//      parent               - Top level parent layout of the option box UI.
//                             Required so that UI object names can be 
//                             successfully resolved.
//
//	forceFactorySettings - Whether the option values should be set to
//                             default values.
//
//  Return Value:
//      None.
//
global proc polyConnectComponentsSetup(string $parent, int $forceFactorySettings)
{
	setOptionVars($forceFactorySettings);
 	setParent $parent;

	int $insertWithEdgeFlow = `optionVar -q polyConnectComponentsInsertWithEdgeFlow`;
	checkBoxGrp -e -value1 $insertWithEdgeFlow insertWithEdgeFlow;

	float $adjustEdgeFlow = `optionVar -q polyConnectComponentsAdjustEdgeFlow`;
	floatSliderGrp -e -value $adjustEdgeFlow -enable $insertWithEdgeFlow adjustEdgeFlow;

}

//  Procedure Name:
//		polyConnectComponentsOptions
//
//  Description:
//		Construct the option box UI.  Involves accessing the standard option
//		box and customizing the UI accordingly.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
proc polyConnectComponentsOptions(string $action, string $funtype)
{
	//	Name of the command for this option box.
	//
	string $commandName = "polyConnectComponents";

	//	Build the option box actions.
	//
	string $callback = ($commandName + "Callback \"" + $action + "\" " + $funtype);
	string $setup = ($commandName + "Setup");

 	//	STEP 1:  Get the option box.
	//	============================
	//
	//	The value returned is the name of the layout to be used as
	//	the parent for the option box UI.
	//
	string $layout = getOptionBox();
	setParent $layout;
	
	//	STEP 2:  Pass the command name to the option box.
	//	=================================================
	//
	//	Any default option box behaviour based on the command name is set 
	//	up with this call.  For example, updating the 'Help' menu item with
	//	the name of the command.
	//
	setOptionBoxCommandName($commandName);
	
	//	STEP 3:  Activate the default UI template.
	//	==========================================
	//
	//	Activate the default UI template so that the layout of this 
	//	option box is consistent with the layout of the rest of the 
	//	application.
	//
	setUITemplate -pushTemplate DefaultTemplate;

	//	STEP 4: Create option box contents.
	//	===================================
	//	
	//	This, of course, will vary from option box to option box.	
	//	Turn on the wait cursor.
	//
	waitCursor -state 1;

	string $parent = `scrollLayout -childResizable 1`;
		
		columnLayout -adjustableColumn true;

			// Settings tab
			frameLayout -label (uiRes("m_polyPerformAction.kSettingsFrame")) -collapse 0;
				columnLayout;
					checkBoxGrp 
						-label1 (uiRes("m_polyPerformAction.kInsertWithEdgeFlow")) 
						-changeCommand1 ("setParent " + $parent + "; floatSliderGrp -e -enable #1 adjustEdgeFlow")
						insertWithEdgeFlow;

					floatSliderGrp 
						-field true
						-label (uiRes("m_polyPerformAction.kAdjustEdgeFlow")) 
						-min 0.0
						-max 1.0
						-fieldMinValue -1000000
						-fieldMaxValue 1000000
						adjustEdgeFlow;
				setParent ..;
			setParent ..;

		setParent ..;

	setParent ..;

	//	Turn off the wait cursor.
	//
	waitCursor -state 0;
	
	//	Step 5: Deactivate the default UI template.
	//	===========================================
	//
	setUITemplate -popTemplate;

	//	Step 6: Customize the buttons.  
	//	==============================
	//
	//	Provide more descriptive labels for the buttons.  This is not 
	//	necessary, but in some cases, for example, a button labelled 
	//	'Create' may be more meaningful to the user than one labelled
	//	'Apply'.
	//
	//	Disable those buttons that are not applicable to the option box.
	//
	//	Attach actions to those buttons that are applicable to the option
	//	box.  Note that the 'Close' button has a default action attached 
	//	to it that will hide the window.  If a a custom action is
	//	attached to the 'Close' button then be sure to call the 'hide the
	//	option box' procedure within the custom action so that the option
	//	box is hidden properly.
	//
	//	'Reset' button.
	//
	string $applyBtn = getOptionBoxApplyBtn();
	button -e -label (uiRes("m_polyPerformAction.kConnect"))
			-command ($callback + " " + $parent + " " + 1)
			$applyBtn;

	string $saveBtn = getOptionBoxSaveBtn();
	button -e 
			-command ($callback + " " + $parent + " " + 0)
			$saveBtn;

	string $resetBtn = getOptionBoxResetBtn();
	button -e 
			-command ($setup + " " + $parent + " " + 1)
			$resetBtn;

	//	Step 7: Set the option box title.
	//	=================================
	//
	setOptionBoxTitle((uiRes("m_polyPerformAction.kConnectComponentsOptions")));

	//	Step 8: Set the current values of the option box.
	//	=================================================
	//
	eval (($setup + " " + $parent + " " + 0));

	setOptionBoxHelpTag("Connect_Components");
	
	//	Step 9: Show the option box.
	//	=============================
	//
	showOptionBox();
}

proc string quoteStarSelection(string $searchString)
// Some of the poly actions require a star to be quoted when the
// command is called.
// eg. will generate an error if passed in something like:
//     poly1.e[*], this will be replace by poly1.e["*"]
{
    string $regExpr = "\\[\\*]";
    string $swapString = "[\"*\"]";
    string $returnString = $searchString;
    
    string $temp = `match $regExpr $returnString`;
        
    while ($temp != "")
    {
        $returnString = `substitute $regExpr $returnString $swapString`;
        $temp = `match $regExpr $returnString`;
    }
    
    return $returnString;
}

global proc polyFinalizeAction ()
{
	global string $gPolyLastTool;
	global string $gSelect;
	if ($gPolyLastTool != "" && $gPolyLastTool != $gSelect)
		setToolTo $gPolyLastTool;
	$gPolyLastTool="";
}

proc selectResultAndFinalizeAction(string $result[])
{
	int $hasOptionsScript = false;
	if (0 < `size $result` && "" != $result[0])
	{
		$hasOptionsScript = ("" != optionsPopupFile($result[0]));
	}

	if ($hasOptionsScript)
	{
		global string $gPolyLastTool;
		$gPolyLastTool="";

		setToolTo ShowManips;
	}
	else
	{
		polyFinalizeAction;
	}
}

proc int useBoolPlugin()
{
	if (!`pluginInfo -q -loaded "polyBoolean"`)
	{
		string $lpResult[] = `loadPlugin "polyBoolean"`;
		if (0 == `size $lpResult`)
		{
			warning (uiRes("m_polyPerformAction.kBoolToolPluginError"));
			return 0;
		}
	}

	return 1;
}

global proc string polyPerformBooleanAction (int $op, string $funtype, int $ret)
{
	setOptionVars(0);

	string $action;
	int $usePlugin = useBoolPlugin();
	int $useLegacy = `optionVar -query booleanOpUseLegacy`;
	if (1 == $usePlugin)
	{
		// This is a fake command that just allows us to integrate with the polyPerformAction
		// code mostly as-is.
		$action = "booltool -op ";
	}
	else if (1 == $useLegacy)
	{
		$action = "polyBoolOp -op ";
	}
	else
	{
		$action = "polyCBoolOp -op ";
	}

	$action += $op;

	return polyPerformAction($action, $funtype, $ret);
}

// Boolean operation values must match the TpolyBooleanType enum:
// 1 = Union, 2 = Difference, 3 = Intersection, 4 = B-A Difference, 5 = Slice
// 6 = Hole PUnch, 7 = Cut Out, 8 = Split Edges
global proc string polyPerformAction (string $action, string $funtype, int $ret)
{
	string $cmd="";
	string $sel[];
	
	string $tmp[], $actionbase;
	tokenize $action $tmp;
	$actionbase = $tmp[0];
	int $doHistory = `constructionHistory -q -toggle`;
	
	setOptionVars(0);

	switch ($ret) {
	case 0:
		waitCursor -state on;

		expandPolyGroupSelection;

		// check if any objects selected (shapes or transforms)
		string $objsSelected[] = `ls -sl -s -tr`; 
		int $objectMode = (size($objsSelected) > 0);

		int $cleanSelection = 0;
		if ($actionbase == "polySeparate") {
			$sel = `polyCheckSelection $actionbase $funtype 0`;
		} else {
            // Merge instances that refer to the same object/component
            if ($funtype != "o" && `filterInstances -q -shapes`) {
                select -r `filterInstances -shapes`;
            }

			$sel=`ls -sl`;
			// get preSelectHilite list when no selectList.
			if($actionbase == "polyMapCut" || $actionbase == "polyMapSew" || $actionbase == "polyMapDel" || $actionbase == "polyLayoutUV"){
				if(size($sel) == 0){
					$sel = `ls -preSelectHilite`;
					$cleanSelection = 1;
				}
			}
		}
		
		string $result[];

		if ($actionbase == "booltool") 
		{
			int $type = $tmp[2];
			int $objd = `optionVar -q booleansObjectDisplay`;
			int $tagi = `optionVar -q booleanOpTagIntersection`;

			$result = python ("import maya.plugin.polyBoolean.booltoolUtils as btUtils; btUtils.createBoolTool("+$type+","+$objd+","+$tagi+");");
			if (2 <= size($result))
			{
				select $result[0];
				showEditorExactHistoryNode $result[0] $result[1];
			}
		}
		else if (size($sel) != 0) 
		{
 			if ($actionbase == "polyUnite" || $actionbase == "polyBoolOp"|| $actionbase == "polyCBoolOp") 
			{
				// unite is the only action that can work on multiple objects at once
				// and needs to, in fact.
				// booleans are in the same case, but need to separate
				// lead from others (for difference)
				$cmd =($action + " -ch " + $doHistory);

				// old booleans have a threshold setting which is enabled by default
				// new booleans work in double precision and the threshold doesn't help as much
				if ($actionbase == "polyBoolOp") {
					$cmd += " -useThresholds 1";
				}

				if ($actionbase == "polyBoolOp" || $actionbase == "polyCBoolOp") {
					int $preserveColor = `optionVar -query booleanOpPreserveColor`;
					$cmd += " -preserveColor " + $preserveColor;
				}

				if ($actionbase == "polyCBoolOp") {
					int $classification = 2;
					int $op = $tmp[2];
					switch ($op)
					{
					case 1:
						$classification = `optionVar -query booleanUnionClassification`;
						break;
					case 2:
						$classification = `optionVar -query booleanDifferenceClassification`;
						break;
					case 3:
						$classification = `optionVar -query booleanIntersectionClassification`;
						break;
					}
					$cmd += " -classification " + $classification;
				}

				if ($actionbase == "polyUnite") {
					int $mergeUVSets = `optionVar -query uniteMergeUVSets`;
					$cmd += " -mergeUVSets " + $mergeUVSets;
					int $pivotPos = `optionVar -query unitePivotPosition`;
					if ($pivotPos == 0) $cmd += " -centerPivot";
					else if ($pivotPos == 1) $cmd += " -objectPivot";
					int $combineSkinning = `optionVar -query uniteCombineSkinning`;
					if ( $combineSkinning ) {
						$cmd = `substitute "^polyUnite" $cmd "polyUniteSkinned"`;
					}
				}

				int $addName = ($actionbase != "polyUnite" || 0 == `optionVar -q uniteCombineSkinning`);

				int $nsel = 0;
				for ($i in $sel)
				{
					if(`nodeType $i` == "transform" || `nodeType $i` == "mesh") {
						$nsel++;
						
						if ($addName && 1 == $nsel)
						{
							$cmd += (" -name " + $i);
						}

						$cmd=($cmd + " " + $i);
					}
				}
				if ($actionbase == "polyBoolOp" && $nsel != 2) {
					string $msg = (uiRes("m_polyPerformAction.kSelectMeshBoolError"));
 					error ($msg);
 					return $cmd;
				}
				if ($actionbase == "polyCBoolOp" && $nsel < 2) {
					string $msg = (uiRes("m_polyPerformAction.kSelectMeshBoolError2"));
 					error ($msg);
 					return $cmd;
				}
				$result = `evalEcho $cmd`;
			} 
			else
			{
				string $filteredSel[];
				for ($i in $sel)
				{
					string $theNodeType = `nodeType $i`;
					if( $theNodeType == "transform" || $theNodeType == "mesh" )
						$filteredSel[size($filteredSel)]=$i;
				}

				int $index=0;
				while (size($filteredSel) > $index) {
					string $cursel[];
					$index=`polyNextSelectionBatch $filteredSel $cursel $index`;

					$cmd =($action + " -ch " + $doHistory);

					if ($actionbase == "polyConnectComponents") {
						int $insertWithEdgeFlow = `optionVar -q polyConnectComponentsInsertWithEdgeFlow`;
						$cmd = ($cmd + " -insertWithEdgeFlow " + $insertWithEdgeFlow);

						float $adjustEdgeFlow = `optionVar -q polyConnectComponentsAdjustEdgeFlow`;
						$cmd = ($cmd + " -adjustEdgeFlow " + $adjustEdgeFlow);
					}

					if (size($cursel) != 0) 
					{
						for ($i in $cursel) 
						{
							$cmd=($cmd + " " + $i);
						}

						// The called command will generate an error if a non-quoted * is used
						// Do a substitution before eval'ing the command.
						$cmd = quoteStarSelection($cmd);
						
						$result = `evalEcho $cmd`;
					}
				}
			}

			if ($actionbase == "polyUnite" || 
				$actionbase == "polyBoolOp" ||
				$actionbase == "polySeparate" || 
				$actionbase == "polyCBoolOp") {
				
				// Initialize the just created mesh node with global settings
				setupNewMesh();
			}
			
			// make sure node is selected when there is history
			if ($actionbase == "polyCBoolOp") {
				if (0 != size(`ls -sl`) || (0 != size(`ls -hl`))) {
					string $tmp[] = `listHistory`;
					string $totalSel[];
					for ($opNode in $tmp) {
						if (`nodeType $opNode` == "polyCBoolOp") {
							$totalSel[size($totalSel)] = $opNode;
						}
					}

					if (size($totalSel) > 0) 
						select -add $totalSel[0];

					global string $gPolyLastTool;
					$gPolyLastTool="";
					setToolTo ShowManips;
				}
			}

			// go back to object mode if the original selection was an object
			if($objectMode) {
				setSelectMode("objects", "Objects");
			}

			selectResultAndFinalizeAction($result);

			//In order to make high light UV operations more smooth.
			//Remove remaining selection after UV deletion and UV high light operations
			if($cleanSelection || $actionbase == "polyMapDel")
				select -cl;
		}
		waitCursor -state off;
		break;
	case 1:
		if ($actionbase == "polyBoolOp" || $actionbase == "polyCBoolOp" || $actionbase == "booltool") {
			polyBooleanOptions($action, $funtype);
		} else if ($actionbase == "polyUnite") {
			polyUniteOptions($action, $funtype);
		} else if ($actionbase == "polyConnectComponents") {
			polyConnectComponentsOptions($action, $funtype);
		}
		break;
	case 2: $cmd =("polyPerformAction \"" + $action + "\" " + $funtype + " 0");
	}
	return $cmd;
}
