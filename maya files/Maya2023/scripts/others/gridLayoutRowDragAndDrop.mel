// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc string getShortName(string $name)
//
//	Description:
//		Given a full path name to an object return the short name.
//
//	Arguments:
//		$name - Full path name to an object.
//
//	Returns:
//		The short name.
//
{
	string $result = "", $tokenArray[];
	int    $tokenCount;

	//	To get the short name from a long name tokenize the long name
	//	using "|" as the split character because that is the path
	//	separator. The short name is simply the last token.
	//
	$tokenCount = `tokenize $name "|" $tokenArray`;
	if (0 < $tokenCount) $result = $tokenArray[$tokenCount - 1];

	return $result;
}

proc string getGridChildName(string $name, string $gridLayout)
//
//	Description:
//		Given a full path name to an object, if this object is 
//      under the $gridLayout, we return the child of the $gridLayout
//      along the path specified by the given object $name. 
//
//	Arguments:
//		$name - Full path name to an object.
//
//	Returns:
//		The short name of the child of the gridLayout.
//
{
    string $gridLayoutShortName = getShortName($gridLayout);

	string $result = "", $tokenArray[];
	int    $tokenCount;

	//	To get the short name of the gridLayout's child
    // from a long name tokenize the long name
	//	using "|" as the split character because that is the path
	//	separator. The short name of the gridLayout's child 
    //  is simply the token after the token for the gridLayout.
	//
	$tokenCount = `tokenize $name "|" $tokenArray`;
    int $i; 
    for ($i = 0; $i <= $tokenCount - 2; $i++)
    {
        if ($tokenArray[$i] == $gridLayoutShortName)
        {
            // The next token must be the child of the gridLayout.
            //
            $result = $tokenArray[$i+1];
            break;
        }
    }

	return $result;
}

// Description:  This procedure is called to drag the row of a 
//      gridLayout and drop it in a drop position in the gridLayout. 
//
global proc gridLayoutRowDragAndDrop(
    string $gridLayout, string $dragControl, string $dropControl)
{
     string $orderArray[];
     int    $index, $dragPosition = 0, $dropPosition = 0;

		//	Note that the drag and drop control arguments are long names and
		//	the items in the grid's array are short names (long names 
		//	contain the full path).
		//
		$dropControl = getGridChildName($dropControl, $gridLayout);
		$dragControl = getGridChildName($dragControl, $gridLayout);

		$orderArray = `gridLayout -query -gridOrder $gridLayout`;

		//	Determine the drag and drop positions.
		//
		for ($index = 0; $index < size($orderArray); $index++) {
			if ($dragControl == $orderArray[$index]) {
				$dragPosition = $index + 1;
			}
			if ($dropControl == $orderArray[$index]) {
				$dropPosition = $index + 1;
			}
		}

		if ($dragPosition < $dropPosition) {
			
			//	Put drag control at drop position.
			//
			gridLayout -edit -position $dragControl $dropPosition $gridLayout;

			//	Shuffle the items following the drop position.
			//
			for ($index = $dragPosition + 1; $index <= $dropPosition; $index++) {
				gridLayout -edit -position $orderArray[$index - 1] ($index - 1) $gridLayout;
			}

		} else if ($dragPosition > $dropPosition) {
		
			//	Put drag control at drop position.
			//
			gridLayout -edit -position $dragControl $dropPosition $gridLayout;

			//	Shuffle the items following the drop position.
			//
			for ($index = $dragPosition - 1; $index >= $dropPosition; $index--) {
				gridLayout -edit -position $orderArray[$index - 1] ($index + 1) $gridLayout;
			}

		} else {
			//
			//	Drag position is same as drop position. Nothing to do.
			//
		}
}
