// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
proc string [] getNComponentsForItem( string $item, int $matchComponentType )
{
	string $components[];
	string $info[];
	$info[0] = $item;
	$info[1] = 0;
	int $compType = itemComponentInfo( $item, $info );
	if( $compType == 7 ){
		$compType = 2; // particle components are defined as vertices on component node
	}
	if ( $compType != 0 ) { 
		string $mesh = $info[0];
		string $nObj = findTypeInHistory( $mesh, "nBase", 1,1 );
		if( $nObj != "" ){
			int $index = $info[1];
			string $cons[] = `listConnections -type nComponent ($nObj + ".nucleusId")`; 	
			string $component;
			for( $component in $cons ){
				int $currCompType = getAttr( $component + ".componentType");
				if ($matchComponentType && ( $compType != $currCompType )) {
					continue;
				}
	/*
				if( $compType != 6 ){
					int $elements = getAttr( $component + ".elements");
					if( $elements != 2 ){ // ALL Elements
						if( !inComponentList( $component, $index ) ){
							continue;
						}
					}
				}
	*/
				$components[size($components)] = $component;
			}
		}
	}
	
	return( $components );
}

proc string [] getNConstraintsForItem( string $item, int $matchComponentType )
{
	string $comps[] = getNComponentsForItem( $item, $matchComponentType );
	string $constraints[];
	string $comp;
	for( $comp in $comps ){
		string $cons[] = `listConnections -type dynamicConstraint ($comp + ".outComponent")`;
		if( size( $cons ) > 0 ){
			$constraints[size($constraints)] = $cons[0];
		}
	}
	return $constraints;
}

global proc string getNConstraintToEdit( string $action, int $matchComponentType )
//
//	Description:
//	  Get the constraint to be edited. Give an error message if too many
//    constraints or no constraints are found.
//
// Arguments:	
//    $action: string specifying the edit operation such as: add, replace, paint and
//    is used solely for error messages.
//
//    $matchComponentType: only allow matches to constraints containing components
//  	of appropriate type
//
{
	string $constraint;

	// Get the selection( including cvs )
	//
	string $obj;
	string $selected[] = `ls -sl -flatten`;
	for ($obj in $selected) {
		if (nodeType($obj) == "transform") {
			string $children[] = `listRelatives -shapes -path -noIntermediate`;
			for ($child in $children) {
				$selected[size($selected)] = $child;
			}
		}
	}
	
	$selected = stringArrayRemoveDuplicates( $selected );
	if (0 == size($selected)) {
		error( (uiRes("m_getNConstraintToEdit.kNothingSelected")));
		return $constraint;
	}

	// Get the selected constraint
	int $multipleConstraints = false;
	for ( $obj in $selected ){
		string $type = nodeType( $obj );
		if ( $type == "dynamicConstraint" || $type == "transform" ){
			continue;
		}
		string $cons[] = getNConstraintsForItem( $obj, $matchComponentType );
		if ( size($cons) < 1 ) {
			if ( $action == "remove" || $action == "paint" ){
				string $format = (uiRes("m_getNConstraintToEdit.kDoesNotBelong"));
				string $warnStr = `format -stringArg $obj $format`;
				warning( $warnStr );
			}
			continue;	
		} else if ( size($cons) > 1 ) {
			$multipleConstraints = true;
			$constraint = $cons[0];
		} else {
			if ( size($constraint) == 0 ) {
				$constraint = $cons[0];
			} else if ( $constraint != $cons[0] ){
				$multipleConstraints = true;
			}
		}
	}
	if ( size($constraint) == 0 || $multipleConstraints ){
		// need exactly one constraint selection to disambiguate
		//
		string $constraints[] = `ls -sl -dag -type dynamicConstraint`;
		if( size($constraints)==1 ){
			$constraint = $constraints[0];
		} else {
			if( size($constraints) > 1 ){
				error( (uiRes("m_getNConstraintToEdit.kSelectJustOne")));
			} else {
				if( $multipleConstraints ){
					error( (uiRes("m_getNConstraintToEdit.kMultipleConstraints")));
				} else {
					if( $action == "remove" ){
						error( (uiRes("m_getNConstraintToEdit.kSelectedItemsNot"))); 
					} else if( $action == "replace" ){
						error( (uiRes("m_getNConstraintToEdit.kAdditionallyReplace"))); 
					} else if( $action == "add" ){
						error( (uiRes("m_getNConstraintToEdit.kAdditionallyAdd"))); 
					}
				}
			}
		}
	}
	return $constraint;
}
