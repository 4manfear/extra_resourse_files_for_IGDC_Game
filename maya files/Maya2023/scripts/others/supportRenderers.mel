// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  May 16, 2002
//
//
// Description:
//
//
//
//

global string $gUpdateUIProcs[];


// Description: Returns a string identifying the current renderer.
//
global proc string currentRenderer()
{
	return `getAttr defaultRenderGlobals.currentRenderer`;
}


// Description: Sets the currentRenderer attribute to the specified renderer.
//
global proc int setCurrentRenderer(string $renderer)
{
	if( assertIsValidRenderer($renderer) )
	{
		// Matched. Set attribute and return success
		setAttr "defaultRenderGlobals.currentRenderer" -type "string" $renderer;
		return 1;
	}
	return 0;
}

//
// Description: Check currentRenderer exists.
//              Uses default renderer if the renderer does not exist.
//

global proc verifyCurrentRenderer()
{
	// Verify that the current renderer is actually available.
	// It is possible that we have loaded a new scene in which the current
	// renderer was set to some renderer which is no longer available.
	//
	string $currentRenderer = currentRenderer();

	string $msg = (uiRes("m_supportRenderers.kUnavailableRenderer"));
	string $preferredRenderer = `preferredRenderer -query`;

	// Old code that sets currentRenderer to preferredRenderer
	// is moved to TrenderBasket::setCurrentRendererCallback

	if (!`renderer -exists $currentRenderer`)
	{
        string $noWarningForMissingDefaultRenderer = `getenv "MAYA_NO_WARNING_FOR_MISSING_DEFAULT_RENDERER"`;
		if ($noWarningForMissingDefaultRenderer != "1")
		{
			warning(`format -stringArg $currentRenderer -stringArg $preferredRenderer $msg`);
		}

        {
            int $wasModified = `file -query -modified`;
            setAttr
                "defaultRenderGlobals.currentRenderer"
                -type "string"
                $preferredRenderer;
            // If the scene wasn't dirtied prior to setting the current renderer,
            // we want to set the scene as not modified to avoid dirtying the scene.
            if (!$wasModified)
            {
                file -modified false;
            }
        }
	}

    string $allowOpenGLWindowsRemoteSession = `getenv "MAYA_ALLOW_OPENGL_REMOTE_SESSION"`;   
    if (`ogs -irs` && $allowOpenGLWindowsRemoteSession != "1")
	{
		string $msg = (uiRes("m_supportRenderers.kSwitchToDx11"));
		global string $gVerifyRenderFirstTimeCalled = "Yes";
		if ($gVerifyRenderFirstTimeCalled == "Yes")
		{
			string $vp2DeviceOverride = `getenv "MAYA_VP2_DEVICE_OVERRIDE"`;
			string $vp2PrefEngine = `optionVar -query vp2RenderingEngine`;
			global string $gDeviceDirectX11; //global string value is "VirtualDeviceDx11"
			//if user prefers GL device or sets device override which is not dx11, inform user
			if(!`ogs -isRemoteGLSessionEnabled`)
			// If remote open gl is disabled for gl 442.92 and down
			// then switch to direct x
			{
				if ($vp2PrefEngine != "DirectX11" || ($vp2DeviceOverride  != "" && $vp2DeviceOverride != $gDeviceDirectX11)) print($msg);
			}

			$gVerifyRenderFirstTimeCalled = "No";
		}
	}
}

// Description: called when the currentRenderer attribute is changed
//				All render related UI changes are done here
//
global proc int rendererChanged()
{
    if (!`about -batch`)
    {
		if ((currentRenderer() == "mayaHardware") &&
			(! `hwRender -q -limitedRenderSupport`))
		{
			warning (uiRes("m_supportRenderers.kInsufficientGraphics"));
		}

		// Do additional UI changes here
		//
        updateRendererUI();
    }

	return 1;
}

// Description: Used to register an update UI procedure (a proc that
// updates any renderer specific UI created in that script)
//
// Returns: None
//
global proc registerUpdateRendererUIProc(string $procName)
{
	global string $gUpdateUIProcs[];

	int $lastIdx = size($gUpdateUIProcs);
	$gUpdateUIProcs[$lastIdx] = $procName;
}


// Description: Calls procedures within the UI modules to update their respective
//				renderer related UI
//
global proc updateRendererUI()
{
	// We only update the UI if it actually exists. If we are in batch
	// mode, the UI does not exist.
	//
	if (!`about -batch`)
	{
		global string $gUpdateUIProcs[];

		for ($i = 0; $i < size($gUpdateUIProcs); $i++)
		{
			eval $gUpdateUIProcs[$i];
		}
	}
}

// Description: raises an error if the renderer specified does not exists
//
global proc int assertIsValidRenderer(string $renderer)
{
	if(!`renderer -exists $renderer`)
	{
		string $msg = (uiRes("m_supportRenderers.kInvalidRenderer"));
		error -showLineNumber true `format -stringArg $renderer $msg`;
		return 0;
	}
	return 1;
}

global proc rendererSceneOpenedCallback()
{
	//
	// Description:
	//	This procedure is called when a scene is opened (which also happens on
	//	File->New).
	//	This procedure calls procedures which initialize the current renderer
	//	attribute and refresh rendering related UI correspondingly.
	//

	// Register if the scene was dirty, if not, we'll have to
	// restore the scene to be unmodified.
	// This was done to make new scene not be immediately dirty (MAYA-105363)
    $sceneDirty = `file -query -modified`;

	// make sure that currentRenderer is available
	//
	verifyCurrentRenderer();

	// Set up a scriptJob to react when the value of the
	// attribute changes.
	//
	scriptJob
        -killWithScene
		-attributeChange
			"defaultRenderGlobals.currentRenderer"
			"rendererChanged;";

	// Call the rendererChanged() procedure explicitly since the
	// verifyCurrentRenderer() procedure call above may have changed
	// the current renderer.
	//
	rendererChanged();

	// mental ray file compatibility
	if(`exists mentalrayCompatibility` ) {
		mentalrayCompatibility;
	}

	// Reset the un-modified flag on the scene, in case setting the renderer modified it.
	if (!$sceneDirty) {
		file -modified false;
	}
}

//
// Description: Called when a selection is made in the current renderer option
// menu. Sets the current renderer.
//
// Returns: None
//
global proc updateCurrentRendererSel(string $menu)
{
	string $selRenderer = `optionMenu -query -value $menu`;
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $rendererUIName = "";

	for ($i = 0; $i < size($renderers); $i += 1)
	{
        $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;
		if($selRenderer == $rendererUIName)
			break;
	}

	// If the select renderer is not installed, produce error
	//
	if($i == size($renderers))
	{
		error 	-showLineNumber	true
	       		($rendererUIName + " does not exist ");
	}
	else
	{
		setCurrentRenderer($renderers[$i]);
        string $cmd = "loadPreferredRenderGlobalsPreset(\"" + $renderers[$i] + "\")";
        evalDeferred $cmd;  
	}
}

// Description:  This procedure is called to initialize the
//  defaultRenderGlobals.currentRenderer dynamic attribute if it does
//  not exist yet, and set up callbacks for renderer related actions
//  which need to be executed during SceneOpened.
//
global proc setupRendererSceneOpenedCallback()
{
    // Create the defaultRenderGlobals.currentRenderer dynamic attribute
    // if it does not exist yet.
    //
    verifyCurrentRenderer();

    // Invoke the scene opened callback explicitly, since the event has already
    // occurred by the time this script is sourced during Maya startup. We want
    // everything that procedure does to also happen during startup.
    //
    evalDeferred rendererSceneOpenedCallback;

    // Set up a script job to call the scene opened callback whenever a new scene
    // is opened.
    //
    evalDeferred "scriptJob -event SceneOpened rendererSceneOpenedCallback;";
}

global proc string[] rendererListRenderTargetSupport()
{
    string $rtRenderers[] = { "mentalRay" };

    return $rtRenderers;
}

global proc int rendererRenderTargetSupport(string $renderer)
{
    string $renderers[] = rendererListRenderTargetSupport();

    for ($r in $renderers) {
       if ($r == $renderer) {
         return true;
       }
    }
    return false;
}

global proc int renderTargetHasInput(string $rt)
{
  if ($rt == "") {
    error((uiRes("m_supportRenderers.kEmptyRenderTarget")));
  }
  string $colorAttr = ($rt + ".color");
  string $alphaAttr = ($rt + ".alpha");
  string $colorSrc = `connectionInfo -sfd $colorAttr`;
  string $alphaSrc = `connectionInfo -sfd $alphaAttr`;
  int $hasInput = (size($colorSrc) > 0) || (size($alphaSrc) > 0);
  return $hasInput;
}

global proc renderTargetWarnIfNoInput(string $rt)
{
  if ($rt != "" && !renderTargetHasInput($rt)) {
    string $msg =
      (uiRes("m_supportRenderers.kRenderTargetHasNoInput"));
    $msg = `format -stringArg $rt $msg`;
    warning ($msg);
  }
}

//
//  Procedure Name:
//      onscreenPlayblastSupported
//
//  Description:
//		Check if the current renderer device support onscreen playblast.
//		OGS/DX mode do not support.
//
//  Input Arguments:
//      string - Current editor panel
//
//  Return Value:
//      int -	1: Support onscreen playblast;
//				0: Not support onscreen playblast;
//
global proc int onscreenPlayblastSupported(string $editor)
{
	int $onScreen = 1;	
	string $currentRendererDevice = getVP2RendererDevice($editor);
	global string $gDeviceDirectX11;
	if ($currentRendererDevice == $gDeviceDirectX11) {
		$onScreen = 0;
	}
	return $onScreen;
}
