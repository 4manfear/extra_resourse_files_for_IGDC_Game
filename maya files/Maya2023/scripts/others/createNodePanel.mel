// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Description:
//      Creation and manipulation of the createNode panel
//

global int $gCreateNodePanelInitDone = false;

global proc createNodePanel (string $panelName)
//
//  Description:
//		Create a new scripted createNodePanel.  If the scripted
//		panel hasn't yet been defined then define it.
//
{
	global string $gMainPane;

    if (!`scriptedPanelType -exists createNodePanel`) {
        //
        //  Define the callbacks for the createNode panel
        //
        scriptedPanelType
            -createCallback		"createNodeCreateCallback" 
            -initCallback		"createNodeInitCallback" 
            -addCallback		"createNodeAddCallback"
            -removeCallback		"createNodeRemoveCallback"
            -deleteCallback		"createNodeDeleteCallback"
            -saveStateCallback	"createNodeSaveStateCallback"
            createNodePanel;
    }

	//  instantiate a new createNodePanel
	//
	setParent $gMainPane;
	scriptedPanel 
        -unParent 
        -type createNodePanel 
        $panelName;
}

global proc createNodeCreateCallback(string $panelName) {
//
//  Description:
//      Create any editors unparented here and do
//      any other initialization required.
//
    addContextHelpProc $panelName "createNodeBuildContextHelpItems";
}


global proc createNodeInitCallback(string $panelName) {
//
//  Description:
//      Re-initialize the panel.
//
}

global proc createNodeSyncMenus(string $ned)
//
//  Description:
//     Sync the panel menu UI to current global state
//
{
    string $includeShadingGroupItem = ($ned + "ISGI");
    menuItem
        -edit
        -checkBox 
        `optionVar -query createMaterialsWithShadingGroup`
        $includeShadingGroupItem;

    string $createIncludePlacementItem = ($ned + "CIPI");
    menuItem
        -edit
        -checkBox 
        `optionVar -query createTexturesWithPlacement` 
        $createIncludePlacementItem;
}

proc createNodeAddMenus(string $ned)
//
//  Description:
//     Setup up the menu bar
//
{
    menu -label (uiRes("m_createNodePanel.kOptions")) 
        -pmc ("createNodeSyncMenus(\"" + $ned + "\")");

    string $includeShadingGroupItem = ($ned + "ISGI");
    menuItem 
        -label (uiRes("m_createNodePanel.kIncludeShadingGroupwithMaterials")) 
        -checkBox true
        -annotation 
        (uiRes("m_createNodePanel.kIncludeShadingGroupwithMaterialsAnnot"))
        $includeShadingGroupItem;

    menuItem
        -edit
        -checkBox 
        `optionVar -query createMaterialsWithShadingGroup` 
        -command 
        ("optionVar -intValue createMaterialsWithShadingGroup "
         + "`menuItem -query -checkBox " 
         + $includeShadingGroupItem
         + "`; refreshCreateNodeUI();")
        $includeShadingGroupItem;

    string $createIncludePlacementItem = ($ned + "CIPI");
    menuItem 
        -label (uiRes("m_createNodePanel.kIncludePlacementWithTextures")) 
        -checkBox true
        -annotation 
        (uiRes("m_createNodePanel.kIncludePlacementWithTexturesAnnot"))
        $createIncludePlacementItem;
    menuItem
        -edit
        -checkBox 
        `optionVar -query createTexturesWithPlacement` 
        -command 
        ("optionVar -intValue createTexturesWithPlacement "
         + "`menuItem -query -checkBox " 
         + $createIncludePlacementItem
         + "`; refreshCreateNodeUI();")
        $createIncludePlacementItem;
		
    setParent -m ..;  // from optionsMenu
}

// provide a unique option menu for the editor
proc string getOptionMenuName(string $ned)
{
    string $optName = $ned + "OptionMenu";
    return $optName;
}

global proc changeNodeLibrary(string $ned, string $library, int $force)
{
	// Something seriously went wrong if we can't find the nodeTreeLister.
	if (!`nodeTreeLister -q -ex $ned`)
		return;

	// First check to see if the nodeTreeLister is already viewing the input
	// library, so we don't needlessly destroy/re-create it.
	string $currLibrary = `nodeTreeLister -q -nodeLibrary $ned`;
	if (($currLibrary != "") && ($currLibrary == $library) && !$force) {
		return;
	}

	nodeTreeLister -e -clearContents $ned;

		createNodeBuildListerContent($ned);

		// Set the node library type, so we can query it later.
		nodeTreeLister -e -nodeLibrary "Hypershade" $ned;
}


global proc refreshListerContent(string $ned)
{
	// Force the nodeTreeLister to update.
	string $library = `nodeTreeLister -q -nodeLibrary $ned`;
	if ($library != "")
		changeNodeLibrary($ned, $library, true);
}

global proc createNodeBuildListerContent(string $ned)
//
//  Description:  Fill the treeLister with the desired contents
//
{
	buildRenderNodeTreeListerContent($ned, "", "");
}

proc createNodeOneTimeInit()
//
//  Description:  Do one-time 'global' initialization for this panel type
//
{
	// Establish callbacks which will be called when a plugin is loaded/unloaded
	//
	global int $gCreateNodePanelInitDone;

	if (!$gCreateNodePanelInitDone)
	{
		loadPlugin -addCallback createNodeLoadPluginCallback;
		unloadPlugin -addCallback createNodeUnloadPluginCallback;
		$gCreateNodePanelInitDone = true;
	}
}

global proc createNodeAddCallback(string $panelName) {
//
//  Description:  Create UI and parent any editors.
//

	string $ned = ( $panelName + "CreateNodeEd" );

	waitCursor -state on;

	// Make sure that there is no template active
	setUITemplate -pushTemplate NONE;
    
    createNodeOneTimeInit();

    createNodeAddMenus($ned);

    string $baseForm = `formLayout`;


	// Parent the editors to the editor layout
	//
    // We just create it here.
	// The default node library is "Hypershade" which we set on the nodeTreeLister
	// so we can query it later.
    //
	nodeTreeLister -nodeLibrary "Hypershade" $ned;
    createNodeBuildListerContent($ned);

		formLayout -edit
			-attachForm $ned left 0
			-attachForm $ned right 0
			-attachForm $ned bottom 0
			-attachForm $ned top 0
			$baseForm;
	setParent -top;

	setUITemplate -popTemplate;
	waitCursor -state off;
}

global proc createNodeRemoveCallback(string $panelName) {
//
//  Description:
//        Unparent any editors and save state if required.
//
	string $ned = ($panelName + "CreateNodeEd");
   	callPython "maya.app.general.tlfavorites" "detachStore" {$ned};

    if (`nodeTreeLister -q -ex $ned`) {
        deleteUI -control $ned;
    }
}

global proc createNodeDeleteCallback(string $panelName) {
//
//  Description:
//        Delete any editors and do any other cleanup required.
	string $ned = ($panelName + "CreateNodeEd");
    if (`nodeTreeLister -q -ex $ned`) {
        deleteUI -control $ned;
    }
}

global proc string createNodeSaveStateCallback(string $panelName) {
//
//  Description:
//        Return a string that will restore the current state
//        when it is executed.
//
    return "";
}

global proc createNodeBuildContextHelpItems(string $nameRoot, string $menuParent)
//
//  Description:
//		Build context sensitive menu items for the create node panel.  
//		
//  Input Arguments:
//		$nameRoot - name to use as the root of all item names
//		$menuParent - the name of the parent of this menu
//
//  Return Value:
//      None
//
{
	menuItem -label (uiRes("m_createNodePanel.kHelpOnCreateNode"))
		-enableCommandRepeat false
		-command "showHelp CreateNodePanel";
}

proc createNodePluginChange(string $changeType, string $plugin)
{
	//
	// Description:
	//	This procedure is called from createNodeLoadPluginCallback() or 
	//	from createNodeUnloadPluginCallback(). If this method has been 
	//	called because a plugin has finished loading, $changeType should be
	//	"load". If it has been called because a plugin is about to be
	//	unloaded, $changeType should be "unload".
	//
    
    // if this plugin doesn't define nodes then we are good
    //
	string $pluginNodeTypeArray[] = `pluginInfo -query -dependNode $plugin`;
    if (`size $pluginNodeTypeArray` == 0) {
        return;
    }

    // Be safe and reload all instances of the panel.
    string $panels[] = `lsUI -panels`;
    string $panelName;
    for($panelName in $panels)
    {
        if (startsWith($panelName, "createNodePanel")) 
        {
            string $ned = ($panelName + "CreateNodeEd");
            if (`nodeTreeLister -q -ex $ned`) {

                // detach favorites store, and rebuild contents
                // the build procedure will re-attach the store
                //
                callPython "maya.app.general.tlfavorites" "detachStore" {$ned};

                nodeTreeLister -e -clearContents $ned;
                if ($changeType == "unload") {
                    // plugin is not yet unloaded - so don't rebuild contents until
                    // later
                    evalDeferred("createNodeBuildListerContent(\"" + $ned + "\")");
                } else {
                    createNodeBuildListerContent($ned);
                }
            }
        }
    }
}

global proc createNodeUnloadPluginCallback(string $plugin)
{
	//
	// Description:
	//	This procedure is called immediately before a plugin is unloaded.
	//
	createNodePluginChange("unload", $plugin);
}

global proc createNodeLoadPluginCallback(string $plugin)
{
	//
	// Description:
	//	This procedure is called immediately after a plugin is loaded.
	//
	createNodePluginChange("load", $plugin);
}

