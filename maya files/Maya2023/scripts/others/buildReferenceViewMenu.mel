// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================


global proc referenceEditorViewSetEdit( string $item,
										string $parentMenu)
//  Procedure Name:
//      referenceEditorViewSetEdit
//
//  Description:
//      Create a dialog to edit the specified view set. User may
//		change name or delete the view set.
//
//  Input Arguments:
//		string $item: view set to edit
//		string $parentMenu: pulldown menu name
//
//  Return Value:
//      None.
//
{
	global string $gReferenceEditorPanel;

	string $result = `promptDialog
		-title (uiRes("m_buildReferenceViewMenu.kEditRefViewSet"))
		-message (uiRes("m_buildReferenceViewMenu.kViewSetName"))
		-text $item
		-button (uiRes("m_buildReferenceViewMenu.kRename"))
		-button (uiRes("m_buildReferenceViewMenu.kDelete"))
		-button (uiRes("m_buildReferenceViewMenu.kCancel"))
		-defaultButton (uiRes("m_buildReferenceViewMenu.kRename")) 
		-cancelButton (uiRes("m_buildReferenceViewMenu.kCancel"))
		-dismissString (uiRes("m_buildReferenceViewMenu.kCancel"))`;

	if ($result == (uiRes("m_buildReferenceViewMenu.kRename"))) {
		$text = `promptDialog -query -text`;
		rename $item $text;
	} else if ($result == (uiRes("m_buildReferenceViewMenu.kDelete"))){
		delete $item;
	}

	//rebuild view menu (deferred so that we don't delete an active menu)
	evalDeferred("buildReferenceViewMenu " + $parentMenu);
	evalDeferred("updateReferenceViewMenu " + $parentMenu);
}


global proc referenceEditorCreateViewSet(string $parentMenu)
//  Procedure Name:
//      referenceEditorCreateViewSet
//
//  Description:
//      Create a new reference view set.
//
//  Input Arguments:
//		string $parentMenu: pulldown menu name
//
//  Return Value:
//      None.
//
{
	global string $gReferenceEditorPanel;
	string $references[] = `sceneEditor -q -selectReference $gReferenceEditorPanel`;
	string $set;

	if( size( $references ) == 0 ) {
		warning (uiRes("m_buildReferenceViewMenu.kSelectAtLeastOne"));
		return;
	} else {
        // As "-text" is an annotation and it appears in the scene file, it must not be tagged
		//
        string $refViewSet = "referenceViewSet"; 
        string $refViewSetNr = "referenceViewSet#";
		$set = `sets -text $refViewSet -name $refViewSetNr $references`;

		//	rebuild view menu (deferred so that we don't delete an active menu)
		//
		evalDeferred("buildReferenceViewMenu " + $parentMenu);
		evalDeferred("updateReferenceViewMenu " + $parentMenu);

		//	apply new filter
		//
		referenceEditorViewSetCmd $set;
	}
}


global proc referenceEditorViewSetCmd (string $set)
										//string $parentMenu,
										//string $rp)
//  Procedure Name:
//      referenceEditorViewSetCmd
//
//  Description:
//      Set the outliner to display only the references in the 
//		specified view set
//
//  Input Arguments:
//		string $parentMenu: pulldown menu name
//
//  Return Value:
//      None.
//
{
	global string $gReferenceEditorPanel;
	string $references[] = `sets -query $set`;
	string $filter = `itemFilter -classification "builtIn" -byName ($references[0])`;
	if ( `size $references` > 1){
		int $i;
        for ($i = 1; $i < `size $references`; $i++){
			string $nextReference = `itemFilter -classification "builtIn" -byName ($references[$i])`;
			$filter = `itemFilter -classification "builtIn" -union $filter $nextReference`;
			delete $nextReference;
		}
	}

	//	apply filter
	//
	sceneEditor -edit
		-filter $filter
		$gReferenceEditorPanel;

}

global proc updateReferenceViewMenu(string $menu){
//  Procedure Name:
//      updateReferenceViewMenu
//
//  Description:
//      Update the dynamic reference editor view menu.
//		This menu is both a pulldown and a popup so when
//		one is rebuilt, force a rebuild of the other.
//
//  Input Arguments:
//		string $menu: menu name
//
//  Return Value:
//      None.
//
	if ($menu == "referenceEditorViewMenu")
		buildReferenceViewMenu referenceEditorViewMenuPopup;
	else
		buildReferenceViewMenu referenceEditorViewMenu;
}

global proc buildReferenceViewMenu(string $parentMenu)
//  Procedure Name:
//      referenceEditorViewSetMenu
//
//  Description:
//      Create a menu item for each reference view set.
//
//  Input Arguments:
//		string $parentMenu: pulldown menu name
//
//  Return Value:
//      None.
//
{
	global string $gReferenceEditorPanel;

	//	set menu up - delete all items as the contents are
	//	subject to change
	menu -edit
		-deleteAllItems
		$parentMenu;
	setParent -menu $parentMenu;

	//build persistent menuItems
	//
	menuItem -label (uiRes("m_buildReferenceViewMenu.kItemViewSelectedRefs"))
		-annotation (uiRes("m_buildReferenceViewMenu.kViewSelected"))
		-command ("referenceEditorCreateViewSet " + $parentMenu)
		;
	menuItem -label (uiRes("m_buildReferenceViewMenu.kItemViewAll"))
		-annotation (uiRes("m_buildReferenceViewMenu.kViewAll"))
		-command ("filterUIClearFilter " + $gReferenceEditorPanel)
		;
	menuItem -divider true;

	//build menuItems for each view set
	string $allSets[] = `ls -sets`;
	string $editViewset	= (uiRes("m_buildReferenceViewMenu.kEditViewset"));
	string $annViewset;
	for ($set in $allSets){
		if (`sets -q -text $set` == "referenceViewSet"){
			menuItem -label ($set)
				-command ("referenceEditorViewSetCmd " + $set)
				;
			$annViewset = `format -s $set $editViewset`;
			menuItem -optionBox true
				-annotation $annViewset
				-command ("referenceEditorViewSetEdit " + $set +
					" " + $parentMenu)
				;
		}
	}
}
