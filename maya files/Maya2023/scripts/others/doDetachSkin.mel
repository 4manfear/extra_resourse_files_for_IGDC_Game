// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Sept, 1998
//
//  Description:
//      This script performs a detachSkin operation
//
//

proc int checkReference(string $node)
// 
// Checks if the deformer node is from a reference
// Returns true if it isn't
//
{
	string $ref[] = `ls -ro $node`;

	if (size($ref) == 0)
		return true;
	else
	{
		error( (uiRes("m_doDetachSkin.kCantUnbind")));
		return false;
	}
}


global proc int doDetachSkin( string $version, string $args[] )
{
	string $bindSkinCmd = "bindSkin ";
	string $skinClusterCmd = "mSkinCluster \"-e ";
	
	int $historyMethod = $args[0];
	int $colorJoints = $args[1];
	$historyMethod -= 1;

	if ($colorJoints) {
		$bindSkinCmd += "-colorJoints ";
	}
	
	if (2 == $historyMethod) { // bake results
		$bindSkinCmd += " -ul; delete -ch";
		$skinClusterCmd = "bindSkin -ul; delete -ch";
	}
	else {
		if ($historyMethod) { // keep history
			$bindSkinCmd += "-ubk";
			$skinClusterCmd += " -ubk\"";
		} else { // remove history
			$bindSkinCmd += "-ub";
			$skinClusterCmd += " -ub\"";
		}
	}

	string $sArr[] = `ls -sl`;

	int $count = 0;
	for ($ii = 0; $ii < size($sArr); $ii++)
	{
		// Find all the DAG leaved under the selected transforms
		//
		string $allShapes[] = `ls -lf -dag $sArr[$ii]`;
		string $shape;
		for($shape in $allShapes)
		{
			// Check if the object still exists
			//
			string $exists[] = `ls $shape`;
			if (size($exists) == 0)
				continue;

			// Ignore intermediate objects
			//
			int $io = `getAttr ($shape+".io")`;
			if ($io == 1)
				continue;

			string $hist[] = `listHistory $shape`;
			for ($jj = 0; $jj < size($hist); $jj++)
			{
				string $node = $hist[$jj];

				string $nt = nodeType($node);
				if ($nt == "jointCluster")
				{
					if (checkReference($node))
					{
						string $cmd = $bindSkinCmd + " " + $shape;
						waitCursor -state on;
						eval($cmd);
						waitCursor -state off;
						$count++;
					}
					break;
				}
				else if ($nt == "skinCluster")
				{
					if (checkReference($node))
					{
						string $influences[] = `listConnections -s 1 ( $node + ".influenceColor" )`;

						select -r $shape;
						waitCursor -state on;
						eval($skinClusterCmd);

						if ($colorJoints)
							for ($inf in $influences)
								colorizeSkeleton($inf, false);

						waitCursor -state off;
						$count++;
					}
					break;
				}
			}
		}
	}
	for ($ii = 0; $ii < size($sArr); $ii++) {
		select -add $sArr[$ii];
	}
	if (0 == $count) {
		error( (uiRes("m_doDetachSkin.kMustSelectSkin")));
	}
	return 1;
}
