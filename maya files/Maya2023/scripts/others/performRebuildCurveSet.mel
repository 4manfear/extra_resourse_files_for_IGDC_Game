// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Mar 14, 1997
//
//  Description:
//      This script runs rebuild curve on the selection list.
//

proc int checkForBezier( string $objs[] )
{
	int $foundBezier = 0;
	int $i;
	for( $i = 0; $i < size($objs); $i++ )
	{
		string $shapes[] = `listRelatives -pa -s $objs[$i]`;
		int $j;
		for( $j = 0; $j < size($shapes); $j++ )
		{
			if( `objectType $shapes[$j]` == "bezierCurve" )
			{
				$foundBezier = 1;
				break;
			}
		}
		if( $foundBezier )
		{
			break;
		}
	}
	return $foundBezier;
}

global proc performRebuildCurveSet( int $doHistory, int $replaceOriginal,
									int $rebuildType, float $globalTol,
									int $crvNumSpans, int $crvDegree,
									int $endKnots,
									int $keepParmRange, int $keepControlPoints,
									int $keepEndPts, int $keepTan,
									int $crvUseGlobalTol, float $crvLocalTol)
{
	// Get a list of each type of acceptable object type - 
	// curves, and curves-on-surface.
	//
	global int $gSelectNurbsCurvesBit;
	global int $gSelectCurvesOnSurfacesBit;
	string $curveList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;
	string $cosList[] = `filterExpand -ex true -sm $gSelectCurvesOnSurfacesBit`;

	int $i;

	int $curveBezier = checkForBezier( $curveList );
	int $cosBezier = checkForBezier( $cosList );
	if( $curveBezier || $cosBezier )
	{
		error (uiRes("m_performRebuildCurveSet.kRebuildCurveBezierSelection"));
		return;
	}

	if( $rebuildType == 2 ) {
		if( (size($curveList) + size($cosList)) < 2 ) {
			error (uiRes("m_performRebuildCurveSet.kRebuildCurveInvalSelection")) ;
			return;
		}
	}
	else {
		if( (size($curveList) + size($cosList)) < 1 ) {
			error (uiRes("m_performRebuildCurveSet.kRebuildCurveImproperSelection"));
			return;
		}
	}

	// Execute rebuildCurve on all active curves.
	//
	$cmd = "rebuildCurve" + " -ch " + $doHistory + 
		   " -rpo " + $replaceOriginal+
		   " -rt " + $rebuildType + 
		   " -end " + $endKnots +
		   " -kr " + $keepParmRange +
		   " -kcp " + $keepControlPoints +
		   " -kep " + $keepEndPts + 
		   " -kt " + $keepTan;
    if ($rebuildType == 0 && $crvDegree <= 2 && $crvNumSpans <= 2) {
        $cmd += " -fr 0"; // Disable -fitRebuild to match spans on low degree curves
    }
	$cmd += " -s " + $crvNumSpans + " -d " + $crvDegree;
	if( $crvUseGlobalTol == 0 ) {	// Use globl tolerance vs. local tolerance
		$cmd += " -tol " + $crvLocalTol;
	} else {
		$cmd += " -tol " + $globalTol;
	}

	string $cosCmd;
	$cosCmd = $cmd;

	string $curveResults[] ;

	if( $rebuildType == 2 ) {
		int $l = size($curveList) ;
		if( $l > 2 ) {
			warning( (uiRes("m_performRebuildCurveSet.kWarningRebuilding")) );
		}
		if( $l >= 2 ) {
			int $nitems = 2 ;
			$cmd = appendToCmdPlaceHoldersForSelectionItems( $cmd, $nitems ) ;
			string $curvePair[2] ;

			for( $i=0; $i<($l-1); $i+=1 ) {
				$curvePair[0] = $curveList[$i] ;	
				$curvePair[1] = $curveList[$l-1];
				string $oneRes[] = executeCmdOnItems($cmd,$curvePair);
				appendStringArray( $curveResults, $oneRes, size($oneRes));
			}
		}
	} else {
		$cmd += " %s;";
		$curveResults = executeForEachObject( $curveList, $cmd );
	}

	// Execute rebuildCurve on all active curves-on-surface.
	//
	// $cosCmd +=  " -cos on ";
	string $cosResults[];
	if( $rebuildType == 2 ) {
		int $l = size($cosList) ;
		if( $l > 2 ) {
			warning( (uiRes("m_performRebuildCurveSet.kWarningRebuilding")));
		}
		if( $l >= 2  ) {
			int $nitems = 2 ;
			$cosCmd = appendToCmdPlaceHoldersForSelectionItems( $cosCmd, $nitems ) ;
			for( $i=0; $i<($l-1); $i+=1 ) {
				$curvePair[0] = $cosList[$i] ;	
				$curvePair[1] = $cosList[$l-1];
				string $oneRes[] = executeCmdOnItems($cmd,$curvePair);
				appendStringArray( $curveResults, $oneRes, size($oneRes));
			}
		}
	} else {
		$cosCmd += " %s;" ;
		$cosResults = executeForEachObject( $cosList, $cosCmd );
	}


	if( (size($curveResults)+size($cosResults)) == 0 ) {
		int $l = size($curveList) ;
		if( $rebuildType == 2  && (size($curveList) < 2) ) {
			error( uiRes( "m_performRebuildCurveSet.kRebuildCurveInvalSelection"));
		}
		else if( 0 == (size($curveList) + size($cosList)) ) {
			error (uiRes("m_performRebuildCurveSet.kRebuildCurvesImproperSelection"));
		}
		else {
			error( (uiRes("m_performRebuildCurveSet.kErrorRebuildFailed")) );
		}
	} else {
		// Select all the results with one select command
		//
		select -r $curveResults $cosResults;
	}
}

