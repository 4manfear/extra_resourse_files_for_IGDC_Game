// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  July 14, 1998
//<doc>
//<name formatPrint>
//
//<synopsis>
//		formatPrint(string $fmt)
//
//<flags>
//		string $fmt String for formatting.  Same as in MEL print command.
//
//<description>
//     This script defines a set of mel procedures to aid in the formatting
// of output.  It was written to help with test script output.  The main
// procedure, formatPrint, will print each line of the argument string
// with a preceeding number of indentation spaces and possibly the
// comment indicator "//".  This aids in the neat, indented presentation of
// textual output without having to remember how far you are already
// indented in the previous output lines.  The option to preceed each line
// with the comment indicator "//" allows for the output to be cut
// and pasted into other scripts or the command window without the concern
// of the text being interpreted as additional commands to MEL.  Here is
// a brief description of each of the procedures and global variables:
// <ol>
// <li>    global int $gFpIndentLevel<br>
//
//      This variable is used to tell formatPrint() how many times
//      to indent each line before it prints.</li>
//
// <li>    global int $gFpDanglingLine<br><br>
//
//      This is used internally to keep track of whether or not
//      the last line printed with formatPrint ended with a newline.</li>
//
// <li>    global int $gFpComment<br>
//
//      This lets formatPrint know if the user wants the output
//      to be formatted as a MEL comment.</li>
//
// <li>    global int $gFpHighlight<br>
//
//      This lets formatPrint know if the user wants the output
//      lines to be marked for easy location in the output.
//      This is handy for pointing out the failures in test scripts.</li>
//</ol>
//
//<returns>
//		void :
//
//<notes>
// <h3>formatPrint( string $text )</h3>
//
//           This is the main procedure.  The string passed into
//           it is of the exact same format as that passed into
//           the standard MEL command "print".  Even if this
//           string has newlines embedded in it, formatPrint
//           will properly indent those as well.  Since all of
//           the methods and variables are global, any script
//           that uses formatPrint and is called from a script
//           that uses formatPrint will properly embed its
//           output into the output of the first one.
//
// <h3>FP_startLevel</h3>
//
//           This procedure will start a new "level" of indentation.
//           This means that for every formatPrint call after this,
//           one more set of indentation spaces will be inserted
//           before each output line.
//
// <h3>FP_endLevel</h3>
//
//           This is exactly the opposite of FP_startLevel. It will
//           remove a set of indentation spaces from any subsequent
//           formatPrint output lines.  In general, there should be
//           one of these for each FP_startLevel call in a script,
//           so that the indentation level ends at the same place
//           that it started.
//
// <h3>FP_reset</h3>
//
//           This will reset the indentation level on a global basis.
//           This will not reset the $FP_COMMENT variable.  The user
//           should do that themself.
//
// <h3>FP_setComment( int $comment )</h3>
//
//           This procedure will tell formatPrint whether or not
//           the user wants the output to be printed as a MEL
//           comment or not.  Any non-zero number will turn commenting
//           ON, while a zero (0) will turn it OFF.
//
// <h3>FP_setHightlight( int $hightlight )</h3>
//
//           This procedure will tell formatPrint whether or not
//           the user wants the output to be marked with an arrow
//           or not.  Any non-zero number will increase the highlighting
//           "level", while a zero (0) will decrease it.  If this
//           "level" is non-zero, then hightlighting is ON.  Otherwise,
//           it is off.
//
// <h3>string FP_expandMultipleNewLines( string $text )</h3>
//
//           This method is used by formatPrint() to correctly handle
//           successive newlines in the text.  Since format print
//           breaks up the original text by the newline characters,
//           the fact that there are two newlines in a row would get
//           lost and interpretted as a single newline.  This method
//           just inserts a space between back-to-back newline
//           characters so that a "blank" line is read by formatPrint().
//
//<examples>
//
//	$gFpIndentLevel = 1;
//	formatPrint("\nMaya\n");
//	//	Maya
//
//</doc>

global int $gFpIndentLevel = 0;
global int $gFpDanglingLine = 0;
global int $gFpComment = 0;
global int $gFpHighlight = 0;

global proc formatPrint( string $text )
{
	global int $gFpIndentLevel;
	global int $gFpDanglingLine;
	global int $gFpComment;
	global int $gFpHighlight;

	//
	// Each separate line in $text is put into its own
	// string in the array $line[].  These are broken up
	// by the newline character "\n" in $text.
	//
	string $line[];
	clear( $line );

	//
	// Now check to see if the last line in $text ended with a
	// newline or not.
	//
	string $endOfLine = "";
	int $finalNewLine = 0;

	$text = FP_expandMultipleNewLines( $text );
	$endOfText = substring( $text, size( $text ), size( $text ) );
	if( $endOfText == "\n" )
	{
		$finalNewLine = 1;
	}

	//
	// Break up $text into separate lines and store them in
	// the array $line[].
	//
	int $lineCount = tokenize( $text, "\n", $line );

	int $l;
	for( $l = 0; $l < $lineCount; $l ++ )
	{
		//
		// If the last line printed by formatPrint did not
		// end with a newline, then do not put the comment
		// indicator or the indentation before this line.
		//
		if( ( $l > 0 ) || ( !$gFpDanglingLine ) )
		{
			//
			// If the user wants the output to be formatted as
			// a MEL comment, then preceed each line of output
			// with the comment indicator "//".
			//
			if( ( $gFpComment > 0 ) && ( ( $l > 0 ) || ( !$gFpDanglingLine ) ) )
			{
				if( $gFpHighlight )
				{
					print("//#");
				}
				else
				{
					print("// ");
				}
			}
	
			//
			// Now for each level of indentation, added a padding
			// of spaces to the beginning of each line.
			//
			for( $i = 0; $i < $gFpIndentLevel; $i ++ )
			{
				//
				// If the user has highlighting turned on, then
				// preceed the text with a long arrow instead
				// of spaces.  This will make the highlighted
				// lines easier to located within the output.
				//
				if( $gFpHighlight )
				{
					if( $i == $gFpIndentLevel - 1 )
					{
						print("##> ");
					}
					else
					{
						print("####");
					}
				}
				else
				{
					print("    ");
				}
			}
		}

		//
		// Print the actual contents of each line after the indentation
		// has been printed.
		//
		print( $line[$l] );

		//
		// If the current line printed was not the last line, then
		// print a newline character.  If it was the last line, then
		// check the $finalNewLine variable to see if the user wanted
		// a newline at the very end of the output.
		//
		if( $l != $lineCount - 1 )
		{
			print("\n");
		}
		else
		{
			if( $finalNewLine )
			{
				print("\n");
				$gFpDanglingLine = 0;
			}
			else
			{
				$gFpDanglingLine = 1;
			}
		}
	}
}

global proc int FP_startLevel()
{
	global int $gFpIndentLevel;
	global int $gFpDanglingLine;
	global int $gFpComment;

	$gFpIndentLevel ++;

	if( $gFpDanglingLine )
		print("\n");

	$gFpDanglingLine = 0;
	return $gFpIndentLevel;
}

global proc int FP_endLevel()
{
	global int $gFpIndentLevel;
	global int $gFpDanglingLine;
	global int $gFpComment;

	$gFpIndentLevel --;
	if( $gFpIndentLevel < 0 )
		$gFpIndentLevel = 0;

	if( $gFpDanglingLine )
		print("\n");

	$gFpDanglingLine = 0;
	return $gFpIndentLevel;
}

global proc int FP_reset()
{
	global int $gFpIndentLevel;
	global int $gFpDanglingLine;
	global int $gFpComment;
	global int $gFpHighlight;

	$gFpIndentLevel = 0;
	$gFpDanglingLine = 0;
	$gFpComment = 0;
	$gFpHighlight = 0;

	return $gFpIndentLevel;
}

global proc FP_setComment( int $comment )
{
	global int $gFpComment;

	if( $comment )
		$gFpComment ++;
	else
	{
		$gFpComment --;
		if( $gFpComment < 0 )
			$gFpComment = 0;
	}
}

global proc FP_setHighlight( int $highlight )
{
	global int $gFpHighlight;

	if( $highlight )
		$gFpHighlight ++;
	else
	{
		$gFpHighlight --;
		if( $gFpHighlight < 0 )
			$gFpHighlight = 0;
	}
}

global proc string FP_expandMultipleNewLines( string $text )
{
	string $from = "";
	string $to = $text;

	string $headOfText = "";
	if( size( $text ) > 0 )
	{
		$headOfText = substring( $to, 1, 1 );

		if( $headOfText == "\n" )
		{
			$to = ( " " + $to );
		}
	}

	while( $from != $to )
	{
		$from = $to;
		$to = substitute( "\n\n", $from, "\n \n" );
	}

	return $to;
}

