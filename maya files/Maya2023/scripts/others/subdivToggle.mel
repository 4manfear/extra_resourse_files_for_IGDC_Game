// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Dec 10, 1998
//
//
//  Description:
//      This implements subdiv toggles for mesh points and mesh edges
//
// 
// 
//

proc string dosubdivToggleMeshPointDisplay(string $subdiv)
{
	if( `getAttr ($subdiv + ".dispVertices")` > 0 ) {
		setAttr ($subdiv + ".dispVertices") 0;
	} else {
		setAttr ($subdiv + ".dispVertices") 1;
	}
	return $subdiv;
}

proc string dosubdivToggleMeshEdgeDisplay(string $subdiv)
{
	if( `getAttr ($subdiv + ".dispEdges")` > 0 ) {
		setAttr ($subdiv + ".dispEdges") 0;
	} else {
		setAttr ($subdiv + ".dispEdges") 1;
	}
	return $subdiv;
}

proc string dosubdivToggleMeshFaceDisplay(string $subdiv)
{
	if( `getAttr ($subdiv + ".dispFaces")` > 0 ) {
		setAttr ($subdiv + ".dispFaces") 0;
	} else {
		setAttr ($subdiv + ".dispFaces") 1;
	}
	return $subdiv;
}

proc string dosubdivToggleMeshMapDisplay(string $subdiv)
{
	if( `getAttr ($subdiv + ".dispMaps")` > 0 ) {
		setAttr ($subdiv + ".dispMaps") 0;
	} else {
		setAttr ($subdiv + ".dispMaps") 1;
	}
	return $subdiv;
}

proc string dosubdivToggleUVBorderDisplay(string $subdiv)
{
	if( `getAttr ($subdiv + ".dispUVBorder")` > 0 ) {
		setAttr ($subdiv + ".dispUVBorder") 0;
	} else {
		setAttr ($subdiv + ".dispUVBorder") 1;
	}
	return $subdiv;
}

proc string dosubdivToggleCreaseDisplay(string $subdiv)
{
	if( `getAttr ($subdiv + ".dispCreases")` > 0 ) {
		setAttr ($subdiv + ".dispCreases") 0;
	} else {
		// If displaying edges is also off, turn it on
		if( `getAttr ($subdiv + ".dispEdges")` == 0 ) {
			setAttr ($subdiv + ".dispEdges") 1;
		}
		setAttr ($subdiv + ".dispCreases") 1;
	}
	return $subdiv;
}

proc int findInList( string $list[], string $searchString) 
{
	// Returns 1 if the given string was found in the list, otherwise 0
	// Performs a linear search.
	//
	int $len = size($list);
	int $i;
	for( $i = 0; $i < $len; $i ++ ) {
		if( $list[$i] == $searchString ) {
			return 1;
		}
	}
	return 0;
}

global proc subdivToggle(int $item) 
{
	// Get all selected subdiv surfaces
	//
	string $subdivList[] = `filterExpand -ex true -sm 68`;

	// Get all subdiv surfaces with components selected
	//
	string $subdivCompList[] = `filterExpand -ex true -sm 36 -sm 37 -sm 38`; 
	int $len = size($subdivCompList);
	string $subdivSh;
	string $buffer[];
	for( $i = 0; $i < $len; $i ++ ) {

		// Get the shape name without the components
		//
		tokenize($subdivCompList[$i], ".", $buffer );
		$subdivSh = $buffer[0];
		if( size($subdivSh) == 0 ) continue;

		// If the shape is unique then add it to the subdivList
		//
		if( findInList($subdivList, $subdivSh) == 0 ) {
			$subdivList[size($subdivList)] = $subdivSh;
		}
	}

	// for each subdiv in $subdivList, toggle its component display state
	//
	$len = size($subdivList);
	for($i = 0; $i < $len; $i++) {

		if( `getAttr ($subdivList[$i] + ".visibility")` == 0 ) {
			continue;
		}
		string $subdiv;
		switch ($item) {

			// toggle Mesh Points
			case 1:
				$subdiv = dosubdivToggleMeshPointDisplay($subdivList[$i]);
			break;

			// toggle Mesh Edges
			case 2:
				$subdiv = dosubdivToggleMeshEdgeDisplay($subdivList[$i]);
			break;

			// toggle Mesh Faces
			case 3:
				$subdiv = dosubdivToggleMeshFaceDisplay($subdivList[$i]);
			break;

			// toggle Mesh Maps
			case 4:
				$subdiv = dosubdivToggleMeshMapDisplay($subdivList[$i]);
			break;

			// toggle UV Border
			case 5:
				$subdiv = dosubdivToggleUVBorderDisplay($subdivList[$i]);
			break;

			// toggle Creases
			case 6:
				$subdiv = dosubdivToggleCreaseDisplay($subdivList[$i]);
			break;
		}
	}

}
