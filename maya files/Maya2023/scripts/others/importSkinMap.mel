// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure: importSkinMap
//
//	Description:
//		This mel script is used to import a weight map for the skinning
//		data for each joint that affects the selected skin.
//
//	    To use, select the skin or skins, and type "importSkinMap"
//
//

proc int checkForLattice(string $obj) {
	
	string $cpShape[] = `ls -type controlPoint $obj`;
	int $isLattice = 0;
	if (size($cpShape) > 0) {
		if (nodeType($obj) == "lattice") {
			$isLattice = 1;
		}
	} else {
		$cpShape = `listRelatives -pa -type controlPoint $obj`;
		for ($cp in $cpShape) {
			if (nodeType($cp) == "lattice") {
				$isLattice = 1;
				break;
			}
		}
	}
	if ($isLattice) {
		string $warnMsg = (uiRes("m_importSkinMap.kSkippingWarn"));
		warning(`format -s $obj $warnMsg`);
	}
	return $isLattice;
}

global proc int importSkinWeightMap(string $fileName, string $fileType)
{
	string $ftype[] = `file -q -type $fileName`;
	if ($ftype[0] != "") {
		error (uiRes("m_importSkinMap.kFileExportError"));
		return 0;
	}
	
	source "artAttrSkinCallback.mel";
	source "artAttrSkinJointMenu.mel";

	// Make sure we are in Skin Paint Weight Tool.
 	string $currCtx = `currentCtx`;
	artAttrSkinToolScript 4;

	string $artCmd = "artAttrSkinPaintCtx -query -exportfiletype `currentCtx`";
    $fileType = eval( $artCmd );

	// Get the selected skins.
	int $skinCount = 0;
	int $latticeFound = 0;
	string $currentSelection[] = `ls -sl`;
	string $skins[];
	string $clusters[];
	for ($sel in $currentSelection) {
		if (checkForLattice($sel)) {
			$latticeFound = 1;
			continue;
		}
		
		// Find the cluster.
		string $buff[];
		tokenize($sel,".",$buff);
		string $cluster = findRelatedSkinCluster($buff[0]);
		if ("" != $cluster) {
			$skins[$skinCount] = $sel;
			$clusters[$skinCount] = $cluster;
			$skinCount++;
		}
	}

	if (0 == $skinCount) {
		if ($latticeFound) {
			error (uiRes("m_importSkinMap.kLatticeError"));
		} else {
			error (uiRes("m_importSkinMap.kSkinError"));
		}
		return 0;
	}

	$fileId = fopen( $fileName, "r" );
	if ($fileId == 0) {
		string $error = (uiRes("m_importSkinMap.kUnabletoOpenFile"));
		error(`format -s $fileName $error`);
		return 0;
	}

	int $passed = 1;

	// Find the file and directory name.
	string $buff[];
	tokenize($fileName,"/",$buff);
	string $fn = $buff[size($buff)-1];
	tokenize($fn,"\\",$buff);
	$fn = $buff[size($buff)-1];	
	$dir = substring($fileName,1,size($fileName)-size($fn));
	tokenize($fn,".",$buff);
	$fn = $buff[0];
	$dir += $fn;

	// Read in the master file that links the joint 
	// names to the map names.
	string $skinNames[];
	string $jointNames[];
	string $fileNames[];
	string $clusterNames[];
	string $skinNamesForC[];	
	int $lineCount = 0;
	
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 ) {
		int $numTokens = tokenize($nextLine,$buff);
		if ($numTokens == 3) {
			$skinNames[$lineCount] = $buff[0];
			$jointNames[$lineCount] = $buff[1];
			$fileNames[$lineCount] = $buff[2];
			if (`objExists $buff[0]`) {
				string $relCluster = findRelatedSkinCluster($buff[0]);
				if ($relCluster != "") {
					int $found = 0;
					for ($clusterN in $clusterNames) {
						if ($clusterN == $relCluster) {
							$found = 1;
							break;
						}
					}
					if (! $found) {
						int $which = size($clusterNames);
						$clusterNames[$which] = $relCluster;
						$skinNamesForC[$which] = $buff[0];
					}
				}
			}
			$lineCount++;
		}
		$nextLine = `fgetline $fileId`;
	}
	if (catch(`fclose $fileId`)) {
		string $error = (uiRes("m_importSkinMap.kFileCloseError"));
		error(`format -s $fileName $error`);
		$passed = 0;
	}

	// Import the maps for each joint.
 	if ($passed) {

		int $counter;
		int $oldNormWeights[];
 		for ($counter = 0; $counter < size($clusterNames); $counter++) {
			$oldNormWeights[$counter] = `getAttr ($clusterNames[$counter]+".normalizeWeights")`;
			setAttr ($clusterNames[$counter]+".normalizeWeights") 0;
			// set all weights to zero
			//
			skinPercent -prw 1.1 $clusterNames[$counter];
		}
			
		// Set the paint operation to 'replace'.
		artAttrSkinPaintCtx -e -selectedattroper "absolute" `currentCtx`;

 		$skinCount = 0;

 		for ($counter = 0; $counter < $lineCount; $counter++) {
			string $mapFn = ($dir+"/"+$fileNames[$counter]);
			string $jt = $jointNames[$counter];
			string $skin = $skinNames[$counter];
			if (`file -q -ex $mapFn`) {
				if (`objExists $jt` && `objExists $skin`) {

					// Make the joint a selected node.
					select -r $skin;
					artSkinSelectInfluence( "artAttrSkinPaintCtx", $jt );

					// Get the cluster name.
					string $cluster = findRelatedSkinCluster( $skin );
					if ( size($cluster) == 0 ) 
						continue;

					string $format = (uiRes("m_importSkinMap.kImportingFile"));
					string $infoMsg = `format -stringArg $fileNames[$counter] -stringArg $skin -stringArg $jt $format`;
					print $infoMsg;

					// Import the attribute map now.
					artAttrSkinPaintCtx -e -importfileload $mapFn `currentCtx`;
					getAttr -silent ($cluster+".og[0]");
				} else {
					if (! `objExists $jt`) {
						string $fmt = (uiRes("m_importSkinMap.kSkippingJoint"));
						string $infoMsg = `format -stringArg $jt $fmt`;
						print($infoMsg);
					} else {
						string $fmt = (uiRes("m_importSkinMap.kSkippingSkin"));
						string $infoMsg = `format -stringArg $skin $fmt`;
						print($infoMsg);
					}
				}
			} else {
				string $fmt = (uiRes("m_importSkinMap.kSkippingFile"));
				string $infoMsg = `format -stringArg $mapFn $fmt`;
				print($infoMsg);
			}
		}

 		for ($counter = 0; $counter < size($clusterNames); $counter++) {
			
			setAttr ($clusterNames[$counter]+".normalizeWeights") $oldNormWeights[$counter];
			select -r $skinNamesForC[$counter];
			skinPercent -normalize true $clusterNames[$counter];
		}
 	}

	// Go back to the original context.
 	setToolTo $currCtx;
	select -r $currentSelection;
	
	return $passed;
}

global proc importSkinMap( string $version, string $args[] ) {

	// set the fileBrowser directory to the images dir if it exists
	//
	string $imageDir = (`workspace -q -rd`+"sourceimages\/");
	if (`file -q -ex $imageDir`) {
		workspace -dir $imageDir;
	}

	// bring up the file browser dialog so that they can choose a file name
	//
	string $importMap = (uiRes("m_importSkinMap.kImportMap"));
	fileBrowser("importSkinWeightMap",$importMap,"map",0);
}
