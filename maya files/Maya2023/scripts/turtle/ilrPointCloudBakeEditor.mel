// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Point Cloud Bake Editor procedures
//

proc ilrMeshToPointCloudDo(string $shape)
{
	// Make sure the default nodes exists
	//
	ilrDefaultNodes();

	string $outputdir = `getAttr TurtleUIOptions.pcbDoughDirectory`;
	string $outputfile = `getAttr TurtleUIOptions.pcbDoughFile`;
	string $longOutputDir = `workspace -expandName $outputdir`;
	if ($longOutputDir == "/") {
		$longOutputDir = `workspace -expandName ""`;
	}
	if (!endsWith($longOutputDir, "/")) {
		$longOutputDir += "/";
	}
	if (!`filetest -d $longOutputDir`) {
		error "Output directory not found. Error creating point cloud!\n";
		return;
	}

	string $vertexType = `optionMenuGrp -query -value ilrVertexType`;

	string $cmd =  "ilrPointCloudCmd -create -type 6 ";
	$cmd += "-outputFile \"" + $outputfile + "\" ";
	$cmd += "-outputDirectory \"" + $longOutputDir + "\" ";
	$cmd += "-inputShape " + $shape + " ";
	$cmd += "-vertexType " + $vertexType + " ";
	$cmd += ";";
	print($cmd + "\n");
	eval($cmd);
}

global proc ilrMeshToPointCloudButtonAction()
{
	string $slct[]=`ls -selection`;

	if(size($slct) == 0) {
		error "No shapes selected!";
		return;
	}
	
	for ($s in $slct)
	{
		string $children[] = `listRelatives -shapes -noIntermediate -path $s`;
		for ($c in $children)
		{
			string $type = `nodeType $c`;
			if($type != "mesh")
			{
				warning("Node " + $c + " is not a valid mesh");
				continue;
			}
			ilrMeshToPointCloudDo($c);
		}
	}
}	

global proc ilrPCBSetDoughDirectoryCallback(string $path, string $type)
{
	string $fullPath = `workspace -expandName $path`;
	int $err = true;

	if (`file -query -exists $fullPath`) {
		string $typeList[] = `file -query -type $fullPath`;
		if (size($typeList) > 0 && $typeList[0] == "directory") {

			// If possible get the project relative part of the path
			$path = `workspace -projectPath $path`;

			// Make sure to end with a slash
 			if (!endsWith($path, "/")) {
 				$path += "/";
 			}

			setAttr -type "string" TurtleUIOptions.pcbDoughDirectory $path;
			ilrUpdatePointCloudBakeEditor;

			$err = false;
		}
	}
	if ($err) {
		error($path + " is not a valid directory!");
	}
}

global proc ilrPCBSetLuaFileCallback(string $file, string $type)
{
	string $fullPath = `workspace -expandName $file`;
	int $err = true;

	if (`file -query -exists $fullPath`) {
	
		// If possible get the project relative part of the file path
		$file = `workspace -projectPath $file`;

		setAttr -type "string" TurtleUIOptions.pcbLuaFile $file;
		ilrUpdatePointCloudBakeEditor;

		$err = false;
	}
	if ($err) {
		error($file + " is not a valid file!");
	}
}

global proc ilrPCBSetInputFileCallback(string $file, string $type)
{
	string $fullPath = `workspace -expandName $file`;
	int $err = true;

	if (`file -query -exists $file`) {

		// If possible get the project relative part of the file path
		$file = `workspace -projectPath $file`;

		setAttr -type "string" TurtleUIOptions.pcbInputFile $file;
		ilrUpdatePointCloudBakeEditor;

		$err = false;
	}
	if ($err) {
		error($file + " is not a valid file!");
	}
}

global proc ilrPCBSetOutputDirectoryCallback(string $path, string $type)
{
	string $fullPath = `workspace -expandName $path`;
	int $err = true;

	if (`file -query -exists $fullPath`) {
		string $typeList[] = `file -query -type $fullPath`;
		if (size($typeList) > 0 && $typeList[0] == "directory") {

			// If possible get the project relative part of the path
			$path = `workspace -projectPath $path`;

			// Make sure to end with a slash
 			if (!endsWith($path, "/")) {
 				$path += "/";
 			}

			setAttr -type "string" TurtleUIOptions.pcbOutputDirectory $path;
			ilrUpdatePointCloudBakeEditor;

			$err = false;
		}
	}
	if ($err) {
		error($path + " is not a valid directory!");
	}
}

global proc ilrPointCloudBakeButtonAction()
{
	string $source = `getAttr TurtleUIOptions.pcbSource`;
	
	string $luafile = `getAttr TurtleUIOptions.pcbLuaFile`;
	string $longLuafile = `workspace -expandName $luafile`;
	string $input = `getAttr TurtleUIOptions.pcbInputFile`;
	string $longInput = `workspace -expandName $input`;
	string $outputdir = `getAttr TurtleUIOptions.pcbOutputDirectory`;
	string $longOutputDir = `workspace -expandName $outputdir`;
	if ($longOutputDir == "/") {
		$longOutputDir = `workspace -expandName ""`;
	}
	if (!endsWith($longOutputDir, "/")) {
 		$longOutputDir += "/";
 	}
	if (!`filetest -d $longOutputDir`) {
		error "Output directory not found. Error creating point cloud!\n";
		return;
	}
	string $outputfile = `getAttr TurtleUIOptions.pcbOutputFile`;
	
 	string $vertexType = `optionMenuGrp -query -value ilrVertexType`;


	string $cmd = "ilrPointCloudCmd -bake ";
	$cmd += "-bakeSource " + $source + " ";
	if ($source != 0) {
		$cmd += "-inputFile \"" + $longInput + "\" ";
	}
	$cmd += "-luaFile \"" + $longLuafile + "\" ";
	$cmd += "-type 7 ";
	$cmd += "-vertexType " + $vertexType + " ";

	$cmd += "-outputFile \"" + $outputfile + "\" ";
	$cmd += "-outputDirectory \"" + $longOutputDir + "\" ";
	
	if ($source == 0) {
		
		// Collect all selected shapes

		string $slct[]=`ls -selection`;

		if(size($slct) == 0) {
			error "No shapes selected!";
			return;
		}

		for ($s in $slct)
		{
			string $children[] = `listRelatives -shapes -noIntermediate -path $s`;
			for ($c in $children)
			{
				string $type = `nodeType $c`;
				if($type != "mesh")
				{
					warning("Node " + $c + " is not a valid mesh");
					continue;
				}
				$cmd += "-inputShape " + $c + " ";
			}
		}
	}

	$cmd += ";";
	print($cmd + "\n");
	eval($cmd);
}

global proc ilrUpdatePointCloudBakeEditor()
{
	if(!`window -query -exists ilrPCBEMainWindow` || !`objExists TurtleUIOptions`) {
		return;
	}

	textFieldGrp -edit -text (`getAttr TurtleUIOptions.pcbDoughDirectory`) ilrPCBDoughDirectoryField;
	textFieldGrp -edit -text (`getAttr TurtleUIOptions.pcbDoughFile`) ilrPCBDoughFileField;
	textFieldGrp -edit -text (`getAttr TurtleUIOptions.pcbLuaFile`) ilrPCBLuaFileField;
	textFieldGrp -edit -text (`getAttr TurtleUIOptions.pcbInputFile`) ilrPCBInputFileField;
	textFieldGrp -edit -text (`getAttr TurtleUIOptions.pcbOutputDirectory`) ilrPCBOutputDirectoryField;
	textFieldGrp -edit -text (`getAttr TurtleUIOptions.pcbOutputFile`) ilrPCBOutputFileField;
	
	int $sourceisshape = ((`radioButtonGrp -q -sl ilrPCBakeSourceRadio` - 1) == 0);
	textFieldGrp -edit -enable (!$sourceisshape) ilrPCBInputFileField;
}

global proc ilrSetPointCloudBakeAttributes()
{
	setAttr -type "string" TurtleUIOptions.pcbDoughDirectory `textFieldGrp -query -text ilrPCBDoughDirectoryField`;
	setAttr -type "string" TurtleUIOptions.pcbDoughFile `textFieldGrp -query -text ilrPCBDoughFileField`;
	setAttr -type "string" TurtleUIOptions.pcbLuaFile `textFieldGrp -query -text ilrPCBLuaFileField`;
	setAttr -type "string" TurtleUIOptions.pcbInputFile `textFieldGrp -query -text ilrPCBInputFileField`;
	setAttr -type "string" TurtleUIOptions.pcbOutputDirectory `textFieldGrp -query -text ilrPCBOutputDirectoryField`;
	setAttr -type "string" TurtleUIOptions.pcbOutputFile `textFieldGrp -query -text ilrPCBOutputFileField`;
}

global proc ilrPointCloudBakeEditor()
{
	// Make sure the default nodes exists
	//
	ilrDefaultNodes();
	
	// Remove any existing UI to avoid duplicate element names
	//
	if(`window -query -exists ilrPCBEMainWindow`) {
		deleteUI ilrPCBEMainWindow;
	}
	
	// Build the UI
	//
	string $oldParent = `setParent -query`;
	setUITemplate -pushTemplate attributeEditorTemplate;

	string $editor = `window -title "Turtle Point Cloud Bake Editor" -resizeToFitChildren true -height 600 -width 450 ilrPCBEMainWindow`;

	setParent $editor;
	
	$tablayout = `tabLayout -tabsVisible 0 -scrollable 1 -childResizable 1`;
	
		columnLayout -adjustableColumn true "editortab";
		
			frameLayout -label "Point Generation Options" 
				-collapsable 1 ilrPCOptionFrameLayout;
					columnLayout -rowSpacing 4 -adjustableColumn true -cal "center";
						optionMenuGrp -label "Vertex Type" -columnAlign 1 "right" ilrVertexType;
							menuItem -label "Vertex" -data 0;
							menuItem -label "Face Vertex" -data 1;
							
				setParent ..;
			setParent ..;

			frameLayout -label "Create Dough Point Cloud"
				-collapsable 1 ilrPCCreateFrameLayout;
				columnLayout -rowSpacing 4 -adjustableColumn true -cal "center";

					rowLayout -numberOfColumns 2 -columnWidth2 377 40 -columnAttach 1 "left" 0 -columnAttach 2 "left" 5;
						textFieldGrp -label "Output Directory"
							-cc "ilrSetPointCloudBakeAttributes; ilrUpdatePointCloudBakeEditor;"
							ilrPCBDoughDirectoryField;
						symbolButton -image "navButtonBrowse.xpm" ilrPCBDoughDirectoryBrowser;
						button -edit -command ("fileBrowser \"ilrPCBSetDoughDirectoryCallback\" \"Set Directory\" \"\" 4") ilrPCBDoughDirectoryBrowser;
					setParent ..;
					
					textFieldGrp -label "Output File Name"
						-cc "ilrSetPointCloudBakeAttributes; ilrUpdatePointCloudBakeEditor;"
						ilrPCBDoughFileField;
						
					button -label "Create From Selected Shapes" -c ("ilrMeshToPointCloudButtonAction");

				setParent ..;
			setParent ..;

			frameLayout -label "Bake Point Cloud"
				-collapsable 1 ilrPCBakeFrameLayout;
				columnLayout -rowSpacing 4 -adjustableColumn true -columnAlign "center";
				
 					radioButtonGrp -numberOfRadioButtons 2 -label "Source"
						-cc "ilrUpdatePointCloudBakeEditor;"
 						-labelArray2 "Selected Shapes" "File"
 						-data1 0 -data2 1
 						ilrPCBakeSourceRadio;
					connectControl ilrPCBakeSourceRadio "TurtleUIOptions.pcbSource";

					rowLayout -numberOfColumns 2 -columnWidth2 377 40 -columnAttach 1 "left" 0 -columnAttach 2 "left" 5;
						textFieldGrp -label "Input Point Cloud"
							-cc "ilrSetPointCloudBakeAttributes; ilrUpdatePointCloudBakeEditor;"
							ilrPCBInputFileField;
						symbolButton -image "navButtonBrowse.xpm" ilrPCBInputFileNameBrowser;
						button -edit -command ("fileBrowser \"ilrPCBSetInputFileCallback\" \"Choose File\" \"\" 0") ilrPCBInputFileNameBrowser;
					setParent ..;

					separator;
					
					rowLayout -numberOfColumns 2 -columnWidth2 377 40 -columnAttach 1 "left" 0 -columnAttach 2 "left" 5;
						textFieldGrp -label "Lua Bake Script"
							-cc "ilrSetPointCloudBakeAttributes; ilrUpdatePointCloudBakeEditor;"
							ilrPCBLuaFileField;
						symbolButton -image "navButtonBrowse.xpm" ilrPCBLuaFileNameBrowser;
						button -edit -command ("fileBrowser \"ilrPCBSetLuaFileCallback\" \"Choose File\" \"\" 0") ilrPCBLuaFileNameBrowser;
					setParent ..;

					rowLayout -numberOfColumns 2 -columnWidth2 377 40 -columnAttach 1 "left" 0 -columnAttach 2 "left" 5;
						textFieldGrp -label "Output Directory"
							-cc "ilrSetPointCloudBakeAttributes; ilrUpdatePointCloudBakeEditor;"
							ilrPCBOutputDirectoryField;
						symbolButton -image "navButtonBrowse.xpm" ilrPCBOutputDirectoryBrowser;
						button -edit -command ("fileBrowser \"ilrPCBSetOutputDirectoryCallback\" \"Set Directory\" \"\" 4") ilrPCBOutputDirectoryBrowser;
					setParent ..;

					textFieldGrp -label "Output File Name"
						-cc "ilrSetPointCloudBakeAttributes; ilrUpdatePointCloudBakeEditor;"
						ilrPCBOutputFileField;

					button -label "Bake" -c ("ilrPointCloudBakeButtonAction");
					
				setParent ..;
			setParent ..;

		setParent ..;
	setParent ..;

	tabLayout -e -selectTab "editortab" $tablayout;
	
	ilrUpdatePointCloudBakeEditor;

	setUITemplate -popTemplate;

	showWindow $editor;
	
	setParent $oldParent;
}

global proc ilrClosePointCloudBakeEditor()
{
	if(`window -query -exists ilrPCBEMainWindow`) {
		deleteUI ilrPCBEMainWindow;
	}
}
