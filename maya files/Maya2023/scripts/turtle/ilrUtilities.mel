// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
// provided at the time of installation or download, or which otherwise accompanies 

//
// Various utility scripts
//

global proc ilrVisualizePointCloud(string $file, string $name) {
	string $shape = $name + "Shape";
	if (!`objExists $shape`) {
		string $trans = `createNode "transform" -shared -name $name`;
		$shape = `createNode "ilrPointCloudShape" -shared -parent $trans -name $shape`;
	}
	setAttr -type "string" ($shape + ".inputFile") $file;
	ilrPointCloudCmd -rebuild -inputShape $shape;
	select $shape;
}

// Procedure for toggling referenced bake layers on/off
// (renderable / non-renderable)
//
global proc ilrToggleReferencedBakeLayers(int $enable)
{
	string $layers[] = `ls -type ilrBakeLayer`;
	for ($l in $layers) 
	{
		if (`referenceQuery -isNodeReferenced $l`)
		{
			setAttr ($l + ".renderable") $enable;
		}
	};
}

// Procedure for deleting Turtle nodes. All nodes
// named "Turtle..." and "ilr..." will be deleted.
//
global proc ilrDeleteTurtleNodes()
{
	string $nodes[];
	$nodes = `ls "Turtle*"`;
	for ($n in $nodes) {
		if (`objExists $n`) {
			lockNode -lock 0 $n;
			delete $n;
		}
	}
	$nodes = `ls "ilr*"`;
	for ($n in $nodes) {
		if (`objExists $n`) {
			lockNode -lock 0 $n;
			delete $n;
		}
	}
}

// Procedure for rendering an animation sequence. The render command is specified through an argument flag,
// so both rendering, baking and surface transfer can be started with this procedure
//
global proc ilrRenderAnimationSequence(string $renderCmd, float $startFrame, float $endFrame, float $frameStep)
{
	float $frame = $startFrame;
	while ($frame <= $endFrame)
	{
		currentTime $frame;
		eval $renderCmd;		
		$frame += $frameStep;
	}
}

// Procedure for texture baking an animation sequence.
//
global proc ilrTextureBakeAnimationSequence(float $startFrame, float $endFrame, float $frameStep)
{
	string $cmd = "ilrTextureBakeBatchCallback(\"-layer defaultRenderLayer\")";
	ilrRenderAnimationSequence($cmd, $startFrame, $endFrame, $frameStep);
}

// Searches down the DAG for a non-transform object
//
global proc string ilrExtendToShape(string $node)
{
	if (`nodeType $node` == "transform") {
		string $children[] = `listRelatives -children -noIntermediate -path $node`;
		if(size($children) > 0) {
			string $extended = $node + "|" + $children[0];
			if (!`objExists $extended`) {  // Sometimes listRelatives includes the parent in the returned child path
				$extended = $children[0];  // so make sure to check for this here and adjust accordingly
			}
			$node = ilrExtendToShape($extended);
		}
	}
	// We have found a non-transform, so return it
	return $node;
}
