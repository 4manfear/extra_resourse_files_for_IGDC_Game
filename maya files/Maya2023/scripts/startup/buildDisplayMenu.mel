// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  1 April 1996
//
//
//  Description:
//      This implements the "Display" menu on the main menubar.
//

// helper procs. these are approxomately in the same order
// the items are in the Display menu
//
global proc gridMenuUpdate() {
//
// This is called when a "gridDisplayChanged" event is detected.
// Update the menu item, the option var and the gShowGrid variable.
//
	if( `menuItem -exists dispGridItem` ) {
		menuItem -e -cb `grid -q -tgl` dispGridItem;
	}
}

global proc originAxesMenuUpdate() {
//
// This is called when a "originAxesDisplayChanged" event is detected.
// Update the menu item, the option var and the gToggleOriginAxis variable.
//
	if( `menuItem -exists originAxesItem` ) {
		menuItem -e -cb `toggleAxis -q -o` originAxesItem;
	}
}

global proc paintEffectsMeshDisplayMenuUpdate() 
{
	if( `menuItem -exists paintEffectsMeshDisplayItem` ) {
		optionVar -init false -category "Paint Effects" -iv paintEffectsDisplayMesh 1;
		int $disp = `optionVar -query paintEffectsDisplayMesh`;
		paintEffectsDisplay -me $disp;
		menuItem -e -cb $disp paintEffectsMeshDisplayItem;
	}
}

global proc polyNormalSizeMenuUpdate()
{
	if( `menuItem -exists polyNormalSizeItem` ) {
		if(`floatSliderGrp -exists normalsSizeSlider`) {
			float $sizeNormalArray[] = `polyOptions -q -activeObjects -sizeNormal`;
			if(size($sizeNormalArray) > 0){
				int $index = size($sizeNormalArray)-1;
				floatSliderGrp -edit -value $sizeNormalArray[$index] normalsSizeSlider;
			}
		}		
	}
}

global proc TogglePaintEffectsMeshDisplay()
{
	int $disp = `paintEffectsDisplay -q -me`;
	$disp = !$disp;
	optionVar -intValue paintEffectsDisplayMesh $disp;
	paintEffectsDisplay -me $disp;
	refresh -f;
}

global proc showLastHidden () 
{
	global string $gLastHiddenSelection[];
	global string $gLastNonMayaHiddenSelection[];
	if ((size($gLastHiddenSelection) != 0) || (size($gLastNonMayaHiddenSelection) != 0))
	{
		string $lastHiddenObjects[] = `ls -tr -s $gLastHiddenSelection`;
		if ( size($lastHiddenObjects) != 0 )
		{
			int $numHiddenObjects = 0;
			for ($shape in $lastHiddenObjects) 
			{
				if ( getAttr($shape + ".visibility") == 0 )
					$numHiddenObjects++;
			}
			if ( $numHiddenObjects == 0 )
			{	
				// All the objects listed as previously hidden are visible. This happens when user executes show last hidden twice
				warning (uiRes("m_buildDisplayMenu.kNoPreviouslyHidden"));
				return;
			}
		}

		string $objectsToHide[] = stringArrayCatenate($gLastHiddenSelection, $gLastNonMayaHiddenSelection);

		// There is a bug in the MEL parser when you have multiple UFE path strings
		// in the string array passed to the command. See MAYA-107302
		// As a workaround until fixed add each item in the string array
		// as an individual string to the command.
		string $cmd = "showHidden -a ";
		string $object;
		for ($object in $objectsToHide)
		{
			$cmd += ("\"" + $object + "\" ");
		}
		eval($cmd);

		// Don't clear last hidden selection, because then showLastHidden won't work after undo. See MAYA-70621
		hide -clearLastHidden -testVisibility;	// the testVisibility flag is added so that the hide command skips changing the visibility of any selection
		return;
	}
	if ( `showHidden -lastHidden` == 0 )
		warning (uiRes("m_buildDisplayMenu.kNoPreviouslyHidden"));
}

global proc showAllComponents ()
{
	showHidden `ls -type mesh`;
}

global proc hideShowDeformingGeom( string $state )
//
//	Hides or shows deforming geometry in the system.
//	Takes a state, either hide or show, in order to
//	perform the appropriate action.
{
	//	Get a list of all deformers in the system, then
	//	hide their associated set
	//
	string $deformers[] = `ls -type cluster -type jointCluster
		-type jointLattice -type boneLattice -type ffd -type jointFfd
		-type wire -type sculpt -type blendShape
		-type geometryFilter -type weightGeometryFilter`;
	string $sortedDeformers[] = `sort $deformers`;
	string $lastDeformer = "";
	string $deformerSets[];
	string $result[];
	for( $deformer in $sortedDeformers ) {
		if ( $deformer != $lastDeformer )
		{
			$lastDeformer = $deformer;
			$deformerSets = `listConnections ( $deformer + ".message" )`;
			for( $set in $deformerSets ) {
				if ("objectSet" == nodeType($set))
					$result[size($result)]=$set;
			}
		}
	}

	// $result holds a list of sets. We want the members of the sets
	// so that we can get the parents
	int $count = 0;
	string $geometry[];
	string $members[];
	for( $set in $result ) {
		$members = `sets -q $set`;
		for( $member in $members ) {
			$geometry[ $count ] = $member;
			$count++;
		}
	}

	// get the parents (which may be shapes) of the geometry/components
	string $parents[] = `listRelatives -p $geometry`;

	// Get the parent transforms of the shapes
	string $shapes[] = `ls -type shape $parents`;
	string $parentTransforms[] = `listRelatives -p $shapes`;

	// extract the transforms and add then to the list of shapeTransforms
	string $transforms[] = `ls -type transform $parents`;
	if ( size($transforms) != 0 ) {
		int $count = size($parentTransforms);
		for( $xform in $transforms ) {
			$parentTransforms[ $count ] = $xform;
			$count++;
		}
	}

	if( $state == "hide" ) {
		if ( size($parentTransforms) != 0 ) {
			hideKeepSelection $parentTransforms 0;
        }
		else warning (uiRes("m_buildDisplayMenu.kNoDeformingGeometryToHide")) ;
	}
	else {
		if ( size($parentTransforms) != 0 ) {
			string $cmd="showHidden";
			for ($i in $parentTransforms) {
				if (`objExists $i`)
					$cmd=($cmd + " " + $i);
			}
			evalEcho $cmd;
		}
		else warning (uiRes("m_buildDisplayMenu.kNoDeformingGeometryToShow")) ;
	}
}

proc string[] listWireCurves()
//
// Returns a list of all the curves attached to wire nodes
// in the scene
{
	string $wires[];
	$wires = `ls -type wire`;

	string $connections[];
	string $ws[];
	int $wcount = 0;
	for ( $wire in $wires )
	{
		$connections = `listConnections ($wire + ".deformedWire")`;
		int $numConn = size($connections);
		for ($ii=0; $ii<$numConn; $ii++)
			$ws[$wcount++] = $connections[$ii];
	}
	return $ws;
}


proc string[] listWrapInfluences()
//
// Returns a list of all the influence objects
// attached to the wrap nodes in the scene
{
	string $wraps[];
	$wraps = `ls -type wrap`;

	string $connections[];
	string $infls[];
	int $inflCount = 0;
	for( $wrap in $wraps )
	{
		$connections = `listConnections ($wrap + ".driverPoints")`;
		int $numConn = size($connections);
		for($i=0;$i<$numConn;$i+=2)
			$infls[$inflCount++] = $connections[$i];
	}
	return $infls;
}

proc string[] listRelatedMeshes( string $transforms[] )
//
// Returns a list of all the associated output meshes
// for the given nodes
{
	string $meshes[];
	int $numMeshes = 0;

	int $numTransforms = size($transforms);
	int $transformIndex = 0;
	while( $transformIndex < $numTransforms ){
		string $transform = $transforms[$transformIndex];
		string $children[] = `listRelatives -type "nBase" $transform`;
		int $numChildren = size($children);
		int $childIndex = 0;
		while( $childIndex < $numChildren ){
			string $child = $children[$childIndex];
			$childIndex++;
			// Find mesh related to child
			//
			string $downstreamNodes[] = `listHistory -f 1 $child`;
			string $oMeshes[] = `ls -dag -type mesh $downstreamNodes`;
			string $iMeshes[] = `listConnections -sh true -type mesh ($child + ".inputMesh")`;
			string $oMesh;
			string $iMesh;
			if( size($oMeshes) > 0 ){
				$oMesh = $oMeshes[0];
			}
			if( size($iMeshes) > 0 ){
				$iMesh = $iMeshes[0];
			}
			// If the input mesh is an intermediate object, then we'll want to
			// hide the output mesh, if any. If the input mesh is not an
			// intermediate object, then we'll hide the input mesh.
			//
			if( ($iMesh != "") && !`getAttr ($iMesh + ".intermediateObject")`){
				$meshes[$numMeshes] = $iMesh;
			} else if( $oMesh != "" ){
				$meshes[$numMeshes] = $oMesh;
			} else if( $iMesh != "" ){
				$meshes[$numMeshes] = $iMesh;
			} else {
				$numMeshes--;
			}
			$numMeshes++;
		}
		$transformIndex++;
	}
	return $meshes;
}

proc string[] listSkinClusterInfluences()
//
// Returns a list of all the influence objects
// attached to the skinCluster nodes in the scene
{
	string $skinClusters[];
	$skinClusters = `ls -type skinCluster`;

	string $connections[];
	string $infls[];
	int $inflCount = 0;
	for( $skinCluster in $skinClusters )
	{
		$connections = `listConnections ($skinCluster + ".matrix")`;
		int $numConn = size($connections);
		for($i=0;$i<$numConn;$i++)
		{
			$transformType = `nodeType $connections[$i]`;
			if ($transformType != "joint")
				$infls[$inflCount++] = $connections[$i];
		}
	}
	return $infls;
}

proc appendToList( string $list1[], string $list2[])
//
// Appends the elements of list2 to the end of list1
{
	$count = size($list1);
	for( $elem in $list2 )
	{
		$list1[$count++] = $elem;
	}
}

	
global proc hideShow( string $type, string $state )
//
// Hides/shows objects in the scene.  Takes an object
// type and the state to set as arguments.  
{
	string $list[];
	string $meshes[];

	switch( $type ) {
		case "-controllers":
			$list = `controller -q -ac`;
			break;
		case "-cameras":
			$list = `listTransforms "-ap -cameras"`;
			break;
		case "-geometry":
			//
			// High level setting to turn off all
			// geometry types
			//
		  if (`isTrue "SubdivUIExists"`) 
			$list = `listTransforms
				"-type nurbsSurface -type nurbsCurve -type mesh -type subdiv"`;
		  else
			$list = `listTransforms
				"-type nurbsSurface -type nurbsCurve -type mesh"`;
			break;
		case "-nurbsSurfaces":
			$list = `listTransforms "-type nurbsSurface"`; 
			break;
		case "-nurbsCurves":
			$list = `listTransforms "-type nurbsCurve"`;
			break;
		case "-polySurfaces":
			$list = `listTransforms "-type mesh"`;
			break;
		case "-subdiv":
			$list = `listTransforms "-type subdiv"`;
			break;
		case "-planes":
			$list = `listTransforms "-type sketchPlane"`;
			break;
		case "-lights":
			$list = `listTransforms "-type light"`;
			break;
		case "-strokes":
			$list = `listTransforms "-type stroke"`;
			break;
		case "-strokeCurves":
			$list = listAllStrokeCurves(false);
			break;
		case "-strokeControlCurves":
			$list = listAllStrokeCurves(true);
			break;
		case "-place3dTexture":
			$list = `ls -type "place3dTexture"`;
			break;
		case "-kinematics":
		//
		// High level setting to turn off
		// all kinematics types
		//
			$list =
				`ls -type joint -type hikEffector -type hikIKEffector
					-type ikHandle`;
			break;
		case "-joints":
			$list = `ls -type joint`;
			break;
		case "-ikHandles":
			$list = `ls -type ikHandle -type hikEffector -type hikIKEffector`;
			break;
		case "-ikEff":
			$list = `ls -type ikEffector -type hikEffector -type hikIKEffector`;
			break;
		case "-deformers":
		//
		// High level setting to turn
		// off all deformer types
		//
			$list = `listTransforms
					"-type lattice -type implicitSphere -type clusterHandle -type deformBend -type deformFlare -type deformSine -type deformSquash -type deformTwist -type deformWave"`;
			$wraps = listWrapInfluences();
			$wires = listWireCurves();			
			$skinClusters = listSkinClusterInfluences();
			appendToList($list, $wraps);
			appendToList($list, $wires);			
			appendToList($list, $skinClusters);

			break;
		case "-lattices":
			$list = `listTransforms "-type lattice"`;
			break;
		case "-sculptObjects":
			$list = `listTransforms "-type implicitSphere"`;
			break;
		case "-clusters":
			$list = `listTransforms "-type clusterHandle"`;
			break;
		case "-nonlinears":
			$list = `listTransforms "-type deformBend -type deformFlare -type deformSine -type deformSquash -type deformTwist -type deformWave"`;
			break;
		case "-wraps":
			$list = listWrapInfluences();
			break;
		case "-skinClusters":
			$list = listSkinClusterInfluences();
			break;
		case "-posMarker":
			$list = `listTransforms "-type positionMarker"`;
			break;
		case "-fluids":
			$list = `listTransforms "-type fluidShape"`;
			break;
		case "-fur":
			$list = `listTransforms "-type FurFeedback"`;
			break;
		case "-hairSystems":
			$list = `listTransforms "-type hairSystem"`;
			break;
		case "-follicles":
			$list = `listTransforms "-type follicle"`;
			break;
		case "-nCloth":
			$list = `listTransforms "-type nCloth"`;
			$meshes = listRelatedMeshes( $list );
			appendToList( $list, $meshes );
			break;
		case "-nParticle":
			$list = `listTransforms "-type nParticle"`;
			break;
		case "-nRigid":
			$list = `listTransforms "-type nRigid"`;
			$meshes = listRelatedMeshes( $list );
			appendToList( $list, $meshes );
			break;
		case "-dynamicConstraint":
			$list = `listTransforms "-type dynamicConstraint"`;
			break;
		default:
			warning (uiRes("m_buildDisplayMenu.kNodeTypeNotKnown"));
			break;
	}

	// Do the actual hide/show, based on the
	// list that was built in the above case
	// statement
	//
	if( $state == "-hide" ) {
		if (size($list) > 0) {
			hideKeepSelection $list 0;
		}
		else warning (uiRes("m_buildDisplayMenu.kNoObjectsToHide"));
	}
	else {
		if (size($list) > 0) {
			string $cmd="showHidden -a";
			for ($i in $list) {
				if (`objExists $i`)
					$cmd=($cmd + " " + $i);
			}
			evalEcho $cmd;
		}
		else warning (uiRes("m_buildDisplayMenu.kNoObjectsToShow"));
	}
}

global proc adjustSmoothness ( string $selection ){

	switch ( $selection ){
		case "Rough":
			displaySmoothness -du 0 -dv 0 -pw 4 -ps 1;
			displaySmoothness -su 6 -sv 6 -pw 4 -ps 1;
			break;
		case "Medium":
			displaySmoothness -du 1 -dv 1 -pw 8 -ps 2;
			displaySmoothness -su 3 -sv 3 -pw 8 -ps 2;
			break;
		case "Fine":
			displaySmoothness -du 2 -dv 2 -pw 16 -ps 4;
			displaySmoothness -su 1 -sv 1 -pw 16 -ps 4;
			break;
		default:
			displaySmoothness -du 1 -dv 1 -pw 8 -ps 2;
			displaySmoothness -su 3 -sv 3 -pw 8 -ps 2;
			break;
	}
}

global proc setNormalsSize ( float $val ) 
{
	polyOptions -ao -dn true -sn $val;
		}

global proc doFastInteractionItem(int $isFast) 
{
	global int $gFastInteraction;

	displayLevelOfDetail -lod $isFast;
	$gFastInteraction = $isFast;

    if( `menuItem -exists dispLODItem` ) {
		menuItem -e -cb $isFast dispLODItem;
	}
}

global proc doFastViewportTextures( int $slider )
{
	int $resolution;
	switch ( $slider )
	{
		case 0:
			$resolution = 32;
			break;
		case 1:
			$resolution = 64;
			break;
		case 2:
			$resolution = 128;
			break;
		case 3:
			$resolution = 256;
			break;
		case 4:
			$resolution = 512;
			break;
		case 5:
			$resolution = 1024;
			break;
		case 6:
			$resolution = 2048;
			break;
		default:
			$resolution = 32;
			break;
	}
	optionVar -intValue defaultTextureResolution $resolution;
}

global proc toggleSurfaceBackfaceCulling() 
//
//  Toggle the backface culling on all selected surfaces
//
{
	global int $gSelectMeshesBit ;
	global int $gSelectNurbsSurfacesBit;

	// Toggle backface culling for all nurbs surfaces
	//
	string $nurbsSurfaces[] = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit`;
	for ( $surface in $nurbsSurfaces ) {
		displayCull -bfc (!`displayCull -q -bfc $surface`) $surface;
	}

	//  Toggle backface culling for all mesh surfaces
	//
	
	int $dispVertex = `optionVar -q polyDisplayVertexBackfaceCulling`;
	int $dispWire = `optionVar -q polyDisplayWireBackfaceCulling`;
	int $dispHardEdge = `optionVar -q polyDisplayHardEdgeBackfaceCulling`;
	
	string $meshSurfaces[] = `filterExpand -ex true -sm $gSelectMeshesBit`;
	
	int  $isNotCulled[] = `polyOptions -activeObjects -q -bc $meshSurfaces`;	
	int  $isKeepingWire[] = `polyOptions -activeObjects -q -wbc $meshSurfaces`;	
	int  $isKeepingHardEdge[] = `polyOptions -activeObjects -q -hb $meshSurfaces`;
	int  $isNotShowingVertex[] = `polyOptions -activeObjects -q -bcv $meshSurfaces`;
	
	string $vertexOption = "";
	
	string $cmd = "";
	
	int    $index = 0;
	for ( $surface in $meshSurfaces ) {
		$cmd += "polyOptions ";
		if ($dispVertex){
			$vertexOption = " -bcv false ";
		} else {
			$vertexOption = " -bcv true ";
		}
		$cmd += $vertexOption;
		if ( $isNotCulled[$index]) {
			//Turn the correct form of culling on
			if ($dispWire){
				$cmd += " -activeObjects -wbc ";
			} else 	if ($dispHardEdge){
				$cmd += " -activeObjects -hb ";
			} else {
				$cmd += " -activeObjects -fb ";
			}
		} else {
			//Don't always toggle off culling, because could be called by turning off one of the 
			//culling options
			if (!$dispWire && $isKeepingWire[$index] && $dispHardEdge){
				$cmd += " -activeObjects -hb ";
			} else if (!$dispHardEdge && $isKeepingHardEdge[$index] && $dispWire){
				$cmd += " -activeObjects -wbc ";
			} else if (!$isNotShowingVertex[$index] && !$dispVertex){
				if ($dispWire){
					$cmd += " -activeObjects -wbc ";
				} else if ($dispHardEdge){
					$cmd += " -activeObjects -hb ";
				} else {
					$cmd += " -activeObjects -fb ";
				}
			}else if ((!$dispHardEdge && $isKeepingHardEdge[$index]) || ($isKeepingWire[$index] && !$dispWire)){
				$cmd += " -activeObjects -fb ";
			} else if (!$isKeepingWire[$index] && $dispWire){
				$cmd += " -activeObjects -wbc ";
			} else if (!$isKeepingHardEdge[$index] && $dispHardEdge){
				$cmd += " -activeObjects -hb ";
			} else if ($isNotShowingVertex[$index] && $dispVertex){
				if ($dispWire){
					$cmd += " -activeObjects -wbc ";
				} else if ($dispHardEdge){
					$cmd += " -activeObjects -hb ";
				} else {
					$cmd += " -activeObjects -fb ";
				}
			} else {
				$cmd += " -activeObjects -bc ";
			}
		}
		$cmd += $surface;
		
		$cmd += "; ";

		eval($cmd);
		
		$index++;
	}
}

global proc toggleNormalDisplay( string $type )
//
//  Toggle face or vertex normals display
//	$type - "face" or "vertex"
//
{
	global int $gSelectMeshesBit ;
	
	string $meshSurfaces[] = `filterExpand -ex true -sm $gSelectMeshesBit`;
	int $displayNormalOn[] = `polyOptions -query -displayNormal $meshSurfaces`;
	int $faceNormalsOn[] = `polyOptions -query -facet $meshSurfaces`;
	int $vertexNormalsOn[] = `polyOptions -query -point $meshSurfaces`;
	int $bothOn[] = `polyOptions -query -pointFacet $meshSurfaces`;

	int $index = 0;
	for ( $surface in $meshSurfaces ) {
		
		// Figure out current state of display
		//
		int $displayFaceNormals = ( $displayNormalOn[$index] && ( $faceNormalsOn[$index] || $bothOn[$index]));
		int $displayVertexNormals = ( $displayNormalOn[$index] && ( $vertexNormalsOn[$index] || $bothOn[$index]));
		
		// Toggle face/vertex display accordingly
		//
		switch ($type) {
			case "face":
				$displayFaceNormals = !$displayFaceNormals;
				break;
			case "vertex":
				$displayVertexNormals = !$displayVertexNormals;
				break;
		}
		
		if( $displayFaceNormals && $displayVertexNormals ){
			polyOptions -displayNormal true -pointFacet $surface;
		} else if ( $displayFaceNormals ) {
			polyOptions -displayNormal true -facet $surface;
		} else if ( $displayVertexNormals ) {
			polyOptions -displayNormal true -point $surface;
		} else {
			polyOptions -displayNormal false $surface;
		}
		
		$index++;
	}
}

global proc toggleTangentDisplay()
//
//  Toggle tangent display
//
{
	global int $gSelectMeshesBit ;
	
	string $meshSurfaces[] = `filterExpand -ex true -sm $gSelectMeshesBit`;
	int $displayTangentsOn[] = `polyOptions -query -displayTangent $meshSurfaces`;

	int $index = 0;
	for ( $surface in $meshSurfaces ) 
	{
		polyOptions -displayTangent (!$displayTangentsOn[ $index]) $surface;
		$index++;
	}
}

global proc ignoreHardwareShader(int $val)
//
// For all nurbs and poly meshes. Set the surface to
// ignore or not ignore hardware shaders for dislay.
//
{
	global int $gSelectMeshesBit ;
	global int $gSelectNurbsSurfacesBit;

	// Set attribute on nurbs surfaces
	//
	string $nurbsSurfaces[] = `filterExpand -ex true -sm $gSelectNurbsSurfacesBit -fp 1`;
	for ( $surface  in $nurbsSurfaces ) 
	{
		setAttr ($surface + ".ignoreHwShader") $val;
	}

	//  Set attribute for all mesh surfaces
	//
	string $meshSurfaces[] = `filterExpand -ex true -sm $gSelectMeshesBit -fp 1`;
	for ( $surface in $meshSurfaces ) 
	{
		setAttr ($surface + ".ignoreHwShader") $val;
	}
}

global proc boundingBoxDisplayCtrl ( int $enabled, string $startNode )
//
// For all the shapes under the selected objects, either turn
// bounding box display on or off based on the value of enabled.
// 0=turn off display, non-zero=turn on display.
//
{
	string $selectedObjects[];
	string $object;

	if ( $startNode == "" ) {
		$selectedObjects = `ls -sl`;
	} else {
		$selectedObjects[0] = $startNode;
	}

	for ( $object in $selectedObjects ) {

		string $shapes[] = `listRelatives -path -shapes $object`;
		if ( size( $shapes ) == 0 ) {
			$shapes = `listRelatives -path -children $object`;
			for ( $transform in $shapes ) {
				if ( `nodeType $transform` == "transform" ) {
					// We encountered a group node.  Recur down until
					// we find the shape nodes in this group.
					boundingBoxDisplayCtrl $enabled $transform;
				}
			}
		}

		for ( $shape in $shapes ) {
			if ( $enabled ) {
				setAttr ( $shape + ".overrideEnabled") 1;
				setAttr ( $shape + ".overrideLevelOfDetail") 1;
			} else {
				// Don't reset the overrideEnabled attribute. It
				// is used for more than just bounding box display
				// and turning if off will mess things up of you
				// have temporarily enabled bounding box display 
				// of an object in a layer.
				setAttr ( $shape + ".overrideLevelOfDetail" ) 0;
			}

		}
	}
}

global proc refreshHeadsUpDisplayMenu ( string $parent ){
	
	setParent -menu $parent;
	menuItem -edit 
		-checkBox `optionVar -query inViewMessageEnable`
		inViewMessageToggle;

	menuItem -edit
		-checkBox `viewManip -q -v`
		viewCubeItem;

	menuItem -edit
		-checkBox `optionVar -query inViewEditorVisible`
		inViewEditorToggle;
		
	if(!`pluginInfo -q -loaded xgenToolkit` && `menuItem -q -exists xgenInfoItem`)
	{
		deleteUI -menuItem xgenInfoItem;
	}
	
	if ( `pluginInfo -q -loaded xgenToolkit` && !`menuItem -q -exists xgenInfoItem`)
	{
		menuItem -checkBox `optionVar -query xgenHUDVisibility`
			-parent $parent
			-insertAfter viewportRendererItem
			-version 2017
			-label (uiRes("m_buildDisplayMenu.kXGenInfo"))
			-command "ToggleXGenDisplayHUD"
			-annotation (uiRes("m_buildDisplayMenu.kXGenInfoAnnot"))
			xgenInfoItem;
	}
}

//
//	Build the "Heads Up Display" submenu of the Display menu.
//  If it already exists then it is deleted first. This allows rebuilding of
//  the submenu with different elements based on the current state information
//
//  This presumes the current parent is a menu item and restores it on returning.
//    cmd            = the runTimeCommand to execute when the HUD item is selected
//    optionVarName  = the name of the optionVar from which the current HUD item toggle value should be read
//		or
//    value          = the current HUD item toggle value
//    itemName       = the name given to the menuItem, for easy querying and editing
//    version        = the version in which this item was introduced (blank means no version)
//
proc hudItem(string $cmd, string $optionVarName, string $itemName, string $version)
{
	if( $version != "" ) {
		menuItem -checkBox `optionVar -query $optionVarName` -runTimeCommand $cmd -version $version $itemName;
	} else {
		menuItem -checkBox `optionVar -query $optionVarName` -runTimeCommand $cmd $itemName;
	}
}
proc hudItemFlag(string $cmd, int $value, string $itemName, string $version)
{
	if( $version != "" ) {
		menuItem -checkBox $value -runTimeCommand $cmd -version $version $itemName;
	} else {
		menuItem -checkBox $value -runTimeCommand $cmd $itemName;
	}
}

global proc buildDisplayMenu ( string $parent ) {
//
//	Build the Display menu.  Checks to see if it's already
//	been built, and returns if this is true.
//

	string $cmd;
	setParent -m $parent;

	global string $gHeadsUpDisplayMenu; // Main Display menuItem
	global int $gToggleOriginAxis;
	
	global int $gShowGrid;

	setParent -m $parent;
	if( `menu -q -ni $parent` == 0 ) {

		// Viewport
		menuItem -divider true -dividerLabel (uiRes("m_buildDisplayMenu.kDisplayViewport"));

        // first Items that affect a whole panel's state
		$cmd = "ToggleGrid";
		menuItem -cb $gShowGrid 
			-rtc $cmd
			dispGridItem;

			$cmd = "GridOptions";
			menuItem -ecr false -optionBox true 
				-annotation (getRunTimeCommandAnnotation($cmd))
				-c $cmd dispGridSpacingItem;

		//Note: HeadsUpDisplay Toggle methods (except origin axis) are located in initHUDScripts.mel
		//
		if (!`exists initHUDScripts`)
		{
			source initHUDScripts.mel;
		}

		 $gHeadsUpDisplayMenu = `menuItem -label (uiRes("m_buildDisplayMenu.kHeadsUpDisplay")) 
								-sm true
								-allowOptionBoxes true
								-tearOff true`;

		menuItem -edit
			-postMenuCommand ( "refreshHeadsUpDisplayMenu " + $gHeadsUpDisplayMenu )
			$gHeadsUpDisplayMenu;			

		hudItem( "ToggleAnimationDetails",                 "animationDetailsVisibility",       "animationDetailsItem",       "" );
		// Make sure the method parameter is the name of the menuItem above this one as it needs
		// it in order to properly delete and restore the item when the plug-in state changes.
		python( "from maya.plugin.evaluator.cache_ui import cache_ui_hud_menu_item_create" );
		python( "cache_ui_hud_menu_item_create('animationDetailsItem')" );
		hudItem( "ToggleCameraNames",                      "cameraNamesVisibility",            "cameraNamesItem",            "" );
		hudItem( "ToggleCapsLockDisplay",                  "capsLockVisibility",               "capsLockItem",               "2016" );
		hudItem( "ToggleCurrentContainerHud",              "currentContainerVisibility",       "currentContainerItem",       "" );
		hudItem( "ToggleCurrentFrame",                     "currentFrameVisibility",           "currentFrameItem",           "" );
		hudItem( "ToggleEvaluationManagerVisibility",      "evaluationVisibility",             "evaluationItem",             "2016" );
		hudItem( "ToggleFocalLength",                      "focalLengthVisibility",            "focalLengthItem",            "" );
		hudItem( "ToggleFrameRate",                        "frameRateVisibility",              "frameRateItem",              "" );
		hudItem( "ToggleHikDetails",                       "hikDetailsVisibility",             "hikDetailsItem",             "" );
		hudItem( "ToggleMaterialLoadingDetailsVisibility", "materialLoadingDetailsVisibility", "materialLoadingDetailsItem", "2016" );
		hudItem( "ToggleObjectDetails",                    "objectDetailsVisibility",          "objectDetailsItem",          "" );
		hudItemFlag( "ToggleOriginAxis",                   $gToggleOriginAxis,                 "originAxesItem",             "" );
		hudItem( "ToggleParticleCount",                    "particleCountVisibility",          "particleCountItem",          "" );
		hudItem( "TogglePolyCount",                        "polyCountVisibility",              "polyCountItem",              "" );

		menuItem -enableCommandRepeat false -optionBox true
				 -command "performPolyCountOptions 1"; 

		hudItem( "ToggleSceneTimecode",                    "sceneTimecodeVisibility",          "sceneTimecodeItem",          "" );
		hudItem( "ToggleSelectDetails",                    "selectDetailsVisibility",          "selectDetailsItem",          "" );
		if (`isTrue "SubdivUIExists"`) {
			hudItem( "ToggleSubdDetails",                  "subdDetailsVisibility",            "subdDetailsItem",            "" );
		}
		hudItem( "ToggleSymmetryDisplay",                  "symmetryVisibility",               "symmetryItem",               "2017" );
		hudItem( "ToggleViewAxis",                         "viewAxisVisibility",               "viewAxisItem",               "" );
		hudItemFlag( "ToggleViewCube", `viewManip -q -v`, "viewCubeItem", "" );
		hudItem( "ToggleViewportRenderer",                 "viewportRendererVisibility",       "viewportRendererItem",       "2015" );
		menuItem -divider true;
		hudItem( "ToggleInViewMessage",                    "inViewMessageEnable",              "inViewMessageToggle",        "" );
		hudItem( "ToggleInViewEditor",                     "inViewEditorVisible",              "inViewEditorToggle",         "2016" );;

		// NOTE:
		// Do not just add new things to the bottom of this menu.
		// Look at the loose groupings above and add new things
		// where they fit best. (modeling, animation, view...)

		setParent -m $parent;

		// Object
		menuItem -divider true -dividerLabel (uiRes("m_buildDisplayMenu.kDisplayObject"));

		// items that work on object's display in all panels
			
		$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kHide")) -subMenu 1 -tearOff 1`;
		global string $gDisplayHideSubmenu;
		$gDisplayHideSubmenu = $menuItem;
		menuItem -e -pmc ( "buildHideSubmenu " + $menuItem ) $menuItem;
		setParent -m ..;
		$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kShow")) -subMenu 1 -tearOff 1`;
		global string $gDisplayShowSubmenu;
		$gDisplayShowSubmenu = $menuItem;
		menuItem -e -pmc ( "buildShowSubmenu " + $menuItem ) $menuItem;
		setParent -m ..;

		$cmd = "ToggleVisibilityAndKeepSelection";
		menuItem 
			   -rtc $cmd
			   -version 2016;
			$cmd = "ToggleVisibilityAndKeepSelectionOptions";
			menuItem -ecr false -optionBox true 
				-annotation (getRunTimeCommandAnnotation($cmd))
				-c $cmd;
		
		$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kPerCameraVisibility")) -subMenu 1 -tearOff 1`;
		global string $gDisplayPerCameraVisibilitySubmenu;
		$gDisplayPerCameraVisibilitySubmenu = $menuItem;
		menuItem -e -pmc ( "buildPerCameraVisibilitySubmenu " + $menuItem ) $menuItem;
		setParent -m ..;

		menuItem -d true -ld false;

		menuItem 
			-rtc "SetWireframeColor"
			objectColorItem;

		menuItem -label (uiRes("m_buildDisplayMenu.kObjectDisplay")) -subMenu true -tearOff true;

			$cmd = "TemplateObject";
			menuItem -rtc $cmd templateOnItem;

			$cmd = "UntemplateObject";
			menuItem -rtc $cmd templateOffItem;

			menuItem -d true;
			$cmd = "ShowBoundingBox";
			menuItem 
				-rtc $cmd enableBoundingBoxDisplayItem;

			$cmd = "HideBoundingBox";
			menuItem 
				-rtc $cmd disableBoundingBoxDisplayItem;

			menuItem -d true;

			$cmd = "ShowObjectGeometry";
			menuItem 
				-rtc $cmd;

			$cmd = "HideObjectGeometry";
			menuItem 
				-rtc $cmd;
				
			menuItem -d true;
			
			menuItem -rtc "IgnoreHardwareShader";
			menuItem -rtc "UseHardwareShader";
			
			menuItem -d true;

			menuItem -cb `optionVar -q "fastInteraction"` 
				-rtc "ToggleFastInteraction" dispLODItem;				

		setParent -m ..;

		menuItem -label (uiRes("m_buildDisplayMenu.kTransformDisplay")) -subMenu true -tearOff true objectsCompItem;
			$cmd = "ToggleLocalRotationAxes";
			menuItem 
				-rtc $cmd toggleAxisItem;
			$cmd = "ToggleRotationPivots";
			menuItem 
				-rtc $cmd toggleRPItem;
			$cmd = "ToggleScalePivots";
			menuItem 
				-rtc $cmd toggleSPItem;
			$cmd = "ToggleSelectionHandles";
			menuItem 
				-rtc $cmd toggleSHItem;
			setParent -m ..;

		originAxesMenuUpdate;
		gridMenuUpdate;
	} else {
		//
		//  Update check items
		//
		menuItem -e -cb `displayLevelOfDetail -q -lod` dispLODItem;
	}
	menuItem  -divider true -ld false;

	$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kPolygons")) -subMenu 1 -tearOff 1 -allowOptionBoxes true`;
	global string $gDisplayPolygonsSubmenu;
	$gDisplayPolygonsSubmenu = $menuItem;
	menuItem -e -pmc ( "buildPolygonsSubmenu " + $menuItem ) $menuItem;
	setParent -m ..;	
	
	$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kNurbs")) -subMenu 1 -tearOff 1 -allowOptionBoxes true`;
	global string $gDisplayNurbsSubmenu;
	$gDisplayNurbsSubmenu = $menuItem;
	menuItem -e -pmc ( "buildNurbsSubmenu " + $menuItem ) $menuItem;
	setParent -m ..;
	
	if (`isTrue "SubdivUIExists"`) {
		$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kSubdivSurfaces")) -subMenu true  -tearOff true -allowOptionBoxes true`;
		global string $gDisplaySubdivSubmenu;
		$gDisplaySubdivSubmenu = $menuItem;
		menuItem -e -pmc ( "buildSubdivSurfaces " + $menuItem ) $menuItem;
		setParent -m ..;
	}
	
	$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kAnimation")) -subMenu true  -tearOff true -allowOptionBoxes true -version 2019`;
	global string $gDisplayAnimationSubmenu;
	$gDisplayAnimationSubmenu = $menuItem;
	menuItem -e -pmc ( "buildAnimationMenu " + $menuItem ) $menuItem;
	setParent -m ..;	
	
	$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kRendering")) -subMenu true  -tearOff true -allowOptionBoxes true`;

	global string $gDisplayRenderingSubmenu;
	$gDisplayRenderingSubmenu = $menuItem;
	menuItem -e -pmc ( "buildRenderingMenu " + $menuItem ) $menuItem;
	setParent -m ..;	
	
	menuItem -divider true -ld false;

	$cmd = "FrameAllInAllViews";
    menuItem -rtc $cmd;
	$cmd = "FrameSelectedWithoutChildrenInAllViews";
    menuItem 
		-version 2017
		-rtc $cmd;
	$cmd = "FrameSelectedInAllViews";
	menuItem 
		-version 2017
		-rtc $cmd;
	
}

////////////////////////////////////////////////////////
//
//	The following procedures build the contents of
//	the Display menu submenus - this speeds up the
//	initial display of the Display menu when the user
//	clicks on the menu
//
////////////////////////////////////////////////////////

global proc buildHideSubmenu( string $parent )
//
//	Build the Hide submenu contents
{
	string $cmd;
    int $dimWhenNoSelect = 0;
	
	setParent -m $parent;
		$cmd = "HideSelectedObjects";
		menuItem 
			-rtc $cmd hideItem;
    	if( $dimWhenNoSelect ) {
			dimWhen -f "SomethingSelected" ($parent+"|hideItem");
		}

		$cmd = "HideUnselectedObjects";
		menuItem 
			-rtc $cmd hideUnselectedItem;
    	if( $dimWhenNoSelect ) {
			dimWhen -f "SomethingSelected" ($parent+"|hideUnselectedItem");
		}

		$cmd = "HideUnselectedCVs";
		menuItem 
			-rtc $cmd hideUnselectedCVsItem;
    	if( $dimWhenNoSelect ) {
			dimWhen -f "SomethingSelected" ($parent+"|hideUnselectedCVsItem");
		}

		$cmd = "HideAll";
		menuItem 
			-rtc $cmd hideAllItems;

		menuItem -d true;
		$cmd = "HideControllers";
		menuItem 
				-version "2017"
				-rtc $cmd
				hideControllersItem;

		menuItem -label (uiRes("m_buildDisplayMenu.kHideGeometry")) -sm true -to true;
			$cmd = "HideGeometry";
			menuItem 
				-rtc $cmd hideGeometryItem;
			menuItem -d true;
			if( `isTrue "SurfaceUIExists"` ) {
				$cmd = "HideNURBSSurfaces";
				menuItem 
					-rtc $cmd
					hideNurbsSurfacesItem;
			}
			$cmd = "HideNURBSCurves";
			menuItem 
				-rtc $cmd
				hideNurbsCurvesItem;
			$cmd = "HidePolygonSurfaces";
			menuItem 
				-rtc $cmd
				hidePolySurfacesItem;
			$cmd = "HideDeformingGeometry";
			menuItem 
				-rtc $cmd;

			if (`isTrue "SubdivUIExists"`) {
			  $cmd = "HideSubdivSurfaces";
			  menuItem 
				-rtc $cmd
				subdivToggleHideGeometryItem;
			}
			if(`isTrue "MayaCreatorExists"`) {
				menuItem -d 1;
				$cmd = "HideStrokes";
				menuItem 
					-rtc $cmd hideStrokesItem;
				$cmd = "HideStrokePathCurves";
				menuItem  
					-rtc $cmd hideStrokeCurvesItems;
				$cmd = "HideStrokeControlCurves";
				menuItem 
					-rtc $cmd hideStrokeControlCurvesItems;
			}

		setParent -m ..;

		menuItem -label (uiRes("m_buildDisplayMenu.kHideKinematics")) -sm true -to true;
			$cmd = "HideKinematics";
			menuItem 
				-rtc $cmd hideKinItem;
			menuItem -d true;
			$cmd = "HideJoints";
			menuItem 
				-rtc $cmd hideJointsItem;
			$cmd = "HideIKHandles";
			menuItem 
				-rtc $cmd
				hideHandleItem;
		setParent -m ..;

		menuItem -label (uiRes("m_buildDisplayMenu.kHideDeformers")) -sm true -to true hideDeformersItem;
			$cmd = "HideDeformers";
			menuItem 
				-rtc $cmd hideDeformItem;
			menuItem -d true;
			$cmd = "HideLattices";
			menuItem 
				-rtc $cmd hideFFDItem;

			$cmd = "HideSculptObjects";
			menuItem 
				-rtc $cmd hideSculptItem;

			$cmd = "HideClusters";
			menuItem 
				-rtc $cmd
				hideClusterItem;

			$cmd = "HideNonlinears";
			menuItem 
				-rtc $cmd hideNonlinearItem;

			$cmd = "HideWrapInfluences";
			menuItem 
				-rtc $cmd hideWrapItem;

			$cmd = "HideSmoothSkinInfluences";
			menuItem 
				-rtc $cmd hideSkinClusterItem;

		setParent -m ..;


		$cmd = "HideLights";
		menuItem  
			-rtc $cmd hideLightsItem;
		$cmd = "HideCameras";
		menuItem  
			-rtc $cmd hideCamerasItem;
		$cmd = "HideTexturePlacements";
		menuItem 
			-rtc $cmd hidePlace3dTxItem;
		$cmd = "HidePlanes";
		menuItem  
			-rtc $cmd hidePlanesItem;

		$cmd = "HideFluids";
		menuItem  
			-rtc $cmd hideFluidsItem;

		$cmd = "HideHairSystems";
		menuItem  
			-rtc $cmd hideHairSystemsItem;

		$cmd = "HideFollicles";
		menuItem  
			-rtc $cmd hideFolliclesItem;

		if( `exists buildFurFiles` ) {
			global string $gHideFurItem;

			$cmd = "HideFur";
			$gHideFurItem = `menuItem  
								-rtc $cmd hideFurItem`;
		}

		$cmd = "HideNCloths";
		menuItem  
			-rtc $cmd hidNClothsItem;
		$cmd = "HideNParticles";
		menuItem  
			-rtc $cmd hideNParticleItem;
		$cmd = "HideNRigids";
		menuItem 
			-rtc $cmd hideNRigidsItem;
		$cmd = "HideDynamicConstraints";
		menuItem 
			-rtc $cmd hideDynamicConstraintsItem;

		menuItem -d true;

		$cmd = "HideMarkers";
		menuItem 
			-rtc $cmd hideMarkersItem;

		if (`isTrue "RenderingExists"`)	{ 
			$cmd = "HideLightManipulators";
			menuItem  
				-rtc $cmd
				hideLightManipItem;
			$cmd = "HideCameraManipulators";
			menuItem  
				-rtc $cmd
				hideCameraManipItem;
			}

	// Delete the -pmc now that the contents of the submenu are built
	//
	menuItem -e -pmc "" $parent;
}

global proc buildShowSubmenu( string $parent )
//
//	Build the Show submenu contents
{
	string $cmd;
    int $dimWhenNoSelect = 0;
	setParent -m $parent;

		$cmd = "ShowSelectedObjects";
		menuItem 
			-rtc $cmd showHiddenItem;
	    	if( $dimWhenNoSelect ) {
			dimWhen -f "SomethingSelected" ($parent+"|showHiddenItem");
		}
		$cmd = "ShowLastHidden";
		menuItem -ecr false
			-rtc $cmd showLastHiddenItem;
		$cmd = "ShowSurfaceCVs";
		menuItem -ecr false
			-rtc $cmd showAllSurfaceCVsItem;
		$cmd = "ShowAllPolyComponents";
		menuItem -ecr false -version 2016
			-rtc $cmd showAllComponentsItem;
		$cmd = "ShowAll";
		menuItem 
			-rtc $cmd visibilityShowAllItem2;

		menuItem -d true;

		$cmd = "ShowControllers";
		menuItem 
				-version "2017"
				-rtc $cmd
				showControllersItem;

		menuItem -label (uiRes("m_buildDisplayMenu.kShowGeometry")) -sm true -to true;
			$cmd = "ShowGeometry";
			menuItem 
				-rtc $cmd showGeometryItem;
			menuItem -d true;
			if( `isTrue "SurfaceUIExists"` ) {
				$cmd = "ShowNURBSSurfaces";
				menuItem 
					-rtc $cmd
					showNurbsSurfacesItem;
			}
			$cmd = "ShowNURBSCurves";
			menuItem 
				-rtc $cmd
				showNurbsCurvesItem;
			$cmd = "ShowPolygonSurfaces";
			menuItem 
				-rtc $cmd
				showPolySurfacesItem;
			$cmd = "ShowDeformingGeometry";
			menuItem 
				-rtc $cmd;

			if (`isTrue "SubdivUIExists"`) {
			  $cmd = "ShowSubdivSurfaces";
			  menuItem 
				-rtc $cmd
			    subdivToggleShowGeometryItem;
			}
			if(`isTrue "MayaCreatorExists"`) {
				menuItem -d 1;
				$cmd = "ShowStrokes";
				menuItem 
					-rtc $cmd showStrokesItem;
				$cmd = "ShowStrokePathCurves";
				menuItem 
					-rtc $cmd showStrokeCurvesItem;
				$cmd = "ShowStrokeControlCurves";
				menuItem 
					-rtc $cmd showStrokeControlCurvesItem;
			}

		setParent -m ..;

		menuItem -label (uiRes("m_buildDisplayMenu.kShowKinematics")) -sm true -to true;
			$cmd = "ShowKinematics";
			menuItem 
				-rtc $cmd showKinItem;
			menuItem -d true;
			$cmd = "ShowJoints";
			menuItem 
				-rtc $cmd showJointsItem;
			$cmd = "ShowIKHandles";
			menuItem 
				-rtc $cmd showHandleItem;
		setParent -m ..;

		menuItem -label (uiRes("m_buildDisplayMenu.kShowDeformers")) -sm true -to true showDeformersItem;
			$cmd = "ShowDeformers";
			menuItem 
				-rtc $cmd showDeformItem;
			menuItem -d true;
			$cmd = "ShowLattices";
			menuItem 
				-rtc $cmd showFFDItem;

			$cmd = "ShowSculptObjects";
			menuItem 
				-rtc $cmd showSculptItem;

			$cmd = "ShowClusters";
			menuItem 
				-rtc $cmd showClusterItem;

			$cmd = "ShowNonlinears";
			menuItem 
				-rtc $cmd showNonlinearItem;

			$cmd = "ShowWrapInfluences";
			menuItem 
				-rtc $cmd showWrapItem;

			$cmd = "ShowSmoothSkinInfluences";
			menuItem 
				-rtc $cmd showSkinClusterItem;

		setParent -m ..;
		

		$cmd = "ShowLights";
		menuItem 
			-rtc $cmd showLightsItem;
		$cmd = "ShowCameras";
		menuItem 
			-rtc $cmd showCamerasItem;
		$cmd = "ShowTexturePlacements";
		menuItem 
			-rtc $cmd showPlace3dTxItem;
		$cmd = "ShowPlanes";
		menuItem 
			-rtc $cmd showPlanesItem;

		$cmd = "ShowFluids";
		menuItem 
			-rtc $cmd showFluidsItem;

		$cmd = "ShowHairSystems";
		menuItem 
			-rtc $cmd showHairSystemsItem;
		$cmd = "ShowFollicles";
		menuItem 
			-rtc $cmd showFolliclesItem;

		if( `exists buildFurFiles` ) {
			global string $gShowFurItem;

			$cmd = "ShowFur";
			$gShowFurItem = `menuItem 
							-rtc $cmd showFurItem`;
		}

		$cmd = "ShowNCloths";
		menuItem 
			-rtc $cmd showNClothsItem;
		$cmd = "ShowNParticles";
		menuItem 
			-rtc $cmd showNParticlesItem;
		$cmd = "ShowNRigids";
		menuItem 
			-rtc $cmd showNRigidsItem;
		$cmd = "ShowDynamicConstraints";
		menuItem 
			-rtc $cmd showDynamicConstraintsItem;

		menuItem -d true;

		$cmd = "ShowMarkers";
		menuItem  
			-rtc $cmd showMarkersItem;

		if (`isTrue "RenderingExists"`)	{ 
			$cmd = "ShowLightManipulators";
			menuItem 
				-rtc $cmd	
				showLightManipItem;
 	   		if( $dimWhenNoSelect ) {
				dimWhen -f "SomethingSelected"
				($parent+"|showLightManipItem");
			}
			$cmd = "ShowCameraManipulators";
			menuItem 
				-rtc $cmd
				showCameraManipItem;
    		if( $dimWhenNoSelect ) {
				dimWhen -f "SomethingSelected"
					($parent+"|showCameraManipItem");
			}
		}

	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;
}

global proc doPerCameraVisibility( int $action )
{
	if ( $action == 5 )
	{
		evalEcho( "perCameraVisibility -removeAll" );
		return;
	}
	
	string $items;
	string $cameras[];
	string $selected[] = `ls -sl`;
	
	for ( $item in $selected )
	{
		if ( catchQuiet( `camera -q -aspectRatio $item` ) )
			$items += " " + $item;
		else
			$cameras[ size( $cameras ) ] = $item;
	}

	if ( size($cameras) == 0 )
	{
		source "sequenceEditorPanel.mel";
		string $cam = getSequencerViewCamera();
		$cameras[0] = $cam;
	}

	for ( $camera in $cameras )
	{
		string $cmd = "perCameraVisibility -c " + $camera + " ";
		switch ( $action )
		{
			case 0:
				$cmd += "-exclusive" + $items;
				break;
			case 1:
				$cmd += "-hide" + $items;
				break;
			case 2:
				$cmd += "-exclusive -remove" + $items;
				break;
			case 3:
				$cmd += "-hide -remove" + $items;
				break;
			case 4:
				$cmd += "-removeCamera";
				break;
		}
		evalEcho( $cmd );
	}
}

global proc buildPerCameraVisibilitySubmenu( string $parent )
//
//	Build the PerCameraVisibility submenu contents
{
	setParent -m $parent;

		menuItem -rtc "SetExclusiveToCamera" exclusiveToCameraItem;
		menuItem -rtc "SetHiddenFromCamera" hiddenFromCameraItem;
		menuItem -d true;
		menuItem -rtc "CameraRemoveFromExclusive" removeFromExclusiveItem;
		menuItem -rtc "CameraRemoveFromHidden" removeFromHiddenItem;
		menuItem -rtc "CameraRemoveAll" removeAllForCameraItem;
		menuItem -d true;
		menuItem -rtc "CameraRemoveAllForAll" removeAllItem;

	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;
}

global proc polyNonPlanarFaceDisplay()
{
	string $cmd = "polyOptions -activeObjects -dw ";
	int $val[] = `polyOptions -q -dw`;
	if($val[0])
		$cmd = $cmd + "0";
	else
		$cmd = $cmd + "1";

	eval($cmd);
}


//
//  Procedure Name:
//      resetMetadataMenuOptions
//
//  Description:
//		Reset metadata menu options,
//		such as the checkbox of visual status
//		
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc resetMetadataMenuOptions()
{
	// reset current stream to get the stream 
	// in the new scene
	optionVar -sv metadataVisualCurrentStreamMember "";
	
	updateMetadataVisualMenu();
}

//
//  Procedure Name:
//      updateMetadataVisualMenu
//
//  Description:
//		Update the checkbox on the menu according
//		to the current activated metadata stream
//		This callback method is called when the command
//		"showMetadata" change the current activated metadata
//		
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc updateMetadataVisualMenu() {
	global string $gMetadataVisualCheckBox;
	
	if(!`exists getCurrentStreamMember`)
		source performVisualizeMetadataOptions.mel;
		
	string $currentStreamMember = getCurrentStreamMember();
	string $tokens[] = stringToStringArray($currentStreamMember, ".");
	int $isActivated = `showMetadata -query -isActivated -stream $tokens[0] -member $tokens[1] -dataType $tokens[2]`;
		
	menuItem -e -checkBox $isActivated $gMetadataVisualCheckBox;
}

//
//  Procedure Name:
//      updateMetadataUI
//
//  Description:
//		Update all metadata UI to reflects
//		the current metadata status.
//		The metadata windows work rely on each other.
//		They are sharing the option vars to handle 
//		the visualization of metadata, that means it is
//		possible that a setting in one window break another
//		window. To control the update order, we refresh 
//		the independent UI together by one event message. 
//		
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc updateMetadataUI()
{
	// update menu
	updateMetadataVisualMenu();

	// update option box
	if (!`exists updateMetadataOptionBox`)
		source performVisualizeMetadataOptions.mel;
	updateMetadataOptionBox();
		
	// update edit window
	if (!`exists updateEditMetadataWindow`)
		source editMetadataWindow.mel;
	updateEditMetadataWindow();
}

//
//  Procedure Name:
//      resetMetadataUI
//
//  Description:
//		Set all metadata UI to default settings.
//		The metadata windows work rely on each other.
//		They are sharing the option vars to handle 
//		the visualization of metadata, that means it is
//		possible that a setting in one window break another
//		window. To control the update order, we refresh 
//		the independent UI together by one event message. 
//		
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//
global proc resetMetadataUI()
{
	// reset menu
	resetMetadataMenuOptions();

	// reset option box
	if (!`exists resetMetadataOptionBox`)
		source performVisualizeMetadataOptions.mel;
	resetMetadataOptionBox();
		
	// reset edit window
	if (!`exists resetEditMetadataWindow`)
		source editMetadataWindow.mel;
	resetEditMetadataWindow();
}

//
//  Procedure Name:
//      toggleMetadata
//
//  Description:
//		Show or hide the current stream.
//		This method is called when user modify the status
//		of the checkbox on the menu.
//
//  Input Arguments:
//      menuItemPath		the path of the menu item widget
//
//  Return Value:
//      None.
//
global proc toggleMetadata()
{
	global string $gMetadataVisualCheckBox;
	int $checkStatus = `menuItem -q -checkBox $gMetadataVisualCheckBox`;
	
	if(!`exists getCurrentStreamMember`)
		source performVisualizeMetadataOptions.mel;
		
	string $currentStreamMember = getCurrentStreamMember();
	string $tokens[] = stringToStringArray($currentStreamMember, ".");
	if($checkStatus)
		showMetadata -stream $tokens[0] -member $tokens[1] -dataType $tokens[2] `ls -shapes`;
	else
		showMetadata -stream $tokens[0] -member $tokens[1] -dataType $tokens[2] -off `ls -shapes`;
}

global proc buildPolygonsSubmenu( string $parent )
//
//	Build the Polygons submenu contents
{
	setParent -m $parent;
		
	string $cmd = "ToggleBackfaceGeometry";
	menuItem 
		-rtc $cmd
		polyBackfaceCullingItem
		;
	
	$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kCullingOptions")) -subMenu 1 -tearOff 1`;
		$cmd = "ToggleKeepWireCulling";
		menuItem 
			-checkBox `optionVar -q polyDisplayWireBackfaceCulling`
			-rtc $cmd toggleKeepWireBackCullingItem;
		$cmd = "ToggleKeepHardEdgeCulling";
		menuItem 
			-checkBox `optionVar -q polyDisplayHardEdgeBackfaceCulling`
			-rtc $cmd toggleKeepHardEdgesCullingItem;
		$cmd = "ToggleCullingVertices";
		menuItem
			-checkBox `optionVar -q polyDisplayVertexBackfaceCulling`
			 -rtc $cmd toggleCullingVerticesItem;			 
	setParent -m ..;	
		
	menuItem -divider true;

	$cmd = "ToggleVertices";
	menuItem 
			-rtc $cmd togglePolyvItem;
			 
	$cmd = "ChangeVertexSize";
	menuItem -rtc $cmd polyVertexSizeItem;
	
	$cmd = "ToggleCreaseVertices";
	menuItem -rtc $cmd showCreaseVertex;			 

	$cmd = "ToggleUVs";
	menuItem -rtc $cmd ;	

	$cmd = "ToggleUnsharedUVs";
	menuItem -rtc $cmd;
			 
	$cmd = "ChangeUVSize";
	menuItem -rtc  $cmd polyUVSizeItem;
	
	$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kCoponentIDs")) -subMenu 1 -tearOff 1`;
		$cmd = "ToggleVertIDs";
		menuItem 
			-rtc $cmd togglePolyVItemNum;
		$cmd = "ToggleEdgeIDs";
		menuItem
			-rtc $cmd togglePolyEItemNum;
		$cmd = "ToggleFaceIDs";
		menuItem
			 -rtc $cmd togglePolyFItemNum;			 
		$cmd = "ToggleCompIDs";
		menuItem 
			-rtc $cmd;	
	setParent -m ..;				 
	
	menuItem -divider true;
	
	$cmd = "ToggleFaceNormalDisplay";
	menuItem 
			 -rtc $cmd showFaceNormal;			 
	
	$cmd = "ToggleVertexNormalDisplay";
	menuItem 
			 -rtc $cmd showVertexNormal;			 			 

	$cmd = "ToggleTangentDisplay";
	menuItem 
			 -rtc $cmd showTangents;			 			 

	$cmd = "ChangeNormalSize";
	menuItem 
			 -rtc ($cmd) polyNormalSizeItem;

	menuItem -divider true;
	
	$cmd = "TogglePolyDisplayEdges";
	menuItem 
			 -rtc $cmd showEdge;			 
    
	$cmd = "TogglePolyDisplaySoftEdges";
    menuItem 
			-rtc $cmd togglePolySoftEdgesItem;
			 
	$cmd = "TogglePolyDisplayHardEdgesColor";
	menuItem 
			-version 2016
			 -rtc $cmd showHardEdgeColor;	

	$cmd = "TogglePolyDisplayHardEdges";
	menuItem
			-version 2016
			 -rtc $cmd showHardEdge;				 


	menuItem -divider true;

	$cmd = "ToggleBorderEdges";
	menuItem 
			-rtc $cmd togglePolyBEItem;
	
	$cmd = "ToggleCreaseEdges";
	menuItem 
			 -rtc $cmd showCreaseEdge;			 

	$cmd = "ToggleTextureBorderEdges";
	menuItem 
			 -rtc $cmd showPolyTextureBorderEdge;			 
				 
	$cmd = "ChangeEdgeWidth";
	menuItem 
			 -rtc  $cmd polyEdgeSizeItem;
	
	menuItem -divider true;
	
	$cmd = "TogglePolygonFaceCenters";
	menuItem
			-rtc $cmd;
			 			 
	menuItem -rtc "TogglePolygonFaceTrianglesDisplay" showPolyFaceTriangle;			 			 			 

	$cmd = "TogglePolyNonPlanarFaceDisplay";
	menuItem 
			 -rtc $cmd showPolyNonplanarFace;
				
	$cmd = "ToggleHoleFaces";
	menuItem 
			 -rtc $cmd showSubdivHoleFaces;
	
	menuItem -divider true;	
	
	// Metadata menu
	$menuItem = `menuItem -version 2016 -label (uiRes("m_buildDisplayMenu.kMetadataMenu")) -subMenu 1 -tearOff 1`;
		
    string $visibleStream[] = `showMetadata -query -listVisibleStreams`;
    int $visibleStreamNum = size($visibleStream);
    int $isActivated = 0;
    if($visibleStreamNum>0)
    {
        $isActivated = 1 ;
    }
    else
    {
        $isActivated = 0 ;
    }
    
    global string $gMetadataVisualCheckBox;
    $gMetadataVisualCheckBox = `menuItem -cb $isActivated 
                                -rtc "ToggleMetadata"
                                showMetadataItem`;
                                        
        $cmd = "VisualizeMetadataOptions";
        menuItem -ecr false -optionBox true 
            -annotation (getRunTimeCommandAnnotation($cmd))
            -c $cmd showMetadataOptionBoxItem;
	setParent -m ..;
			
	menuItem -divider true;
	
	menuItem
		-rtc "ResetDisplay"
		-enableCommandRepeat 1
		-echoCommand 0
		;
		
	$cmd = "TogglePolyDisplayLimitToSelected";
	menuItem
		-checkBox `optionVar -q polyDisplayLimitedToSelectedOV`
		-rtc $cmd
		PolyDisplayLimitedToSelectedMI
		;
		
	$cmd = "CustomPolygonDisplay";
	menuItem
		-rtc $cmd
		PolyDisplayItem;

		$cmd = "CustomPolygonDisplayOptions";
		menuItem -optionBox true
			-rtc $cmd
			PolyDisplayOptionBox;
				
	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;			 
}

global proc buildNurbsSubmenu( string $parent )
{
	setParent -m $parent;
	
	string $cmd = "ToggleCVs";
	menuItem 
		-rtc $cmd toggleCVItem;
	$cmd = "ToggleEditPoints";
	menuItem 
		-rtc $cmd toggleEPItem;
	$cmd = "ToggleHulls";
	menuItem 
		-rtc $cmd  toggleHullItem;
	if( `isTrue SurfaceUIExists` ) {
		menuItem 
			-imageOverlayLabel (uiRes("m_buildDisplayMenu.kNormalsOverlayLabel"))
			-rtc "ToggleNormals"  toggleNormalItem;
	}
	menuItem 
		-rtc "ToggleSurfaceFaceCenters" toggleSurfaceFaceItem;
	menuItem 
		-rtc "ToggleSurfaceOrigin" toggleOriginItem;
	menuItem 
		-dmc "performDisplayControl 2"
		-rtc "ToggleCustomNURBSComponents" dispSmthnessCustomItem;
		menuItem -ecr false -optionBox true 
			-annotation (uiRes("m_buildDisplayMenu.kCustomNURBSAnnot"))
			-c "CustomNURBSComponentsOptions" dispSmthnessCustomOBItem;
	
	menuItem -divider true;
	
	menuItem 
		-dmc "performDisplaySmoothnessHull 2"
		-rtc "NURBSSmoothnessHull"
		dispSmthnessHullItem;
		menuItem -ecr false -optionBox true 
			-annotation (uiRes("m_buildDisplayMenu.kHullOptionAnnot"))
			-c "NURBSSmoothnessHullOptions"
			dispSmthnessHullOptionItem;

	menuItem 
		-dmc "performDisplaySmoothnessRough 2"
		-rtc "NURBSSmoothnessRough"
		dispSmthnessRoughItem;
		menuItem -ecr false -optionBox true 
			-annotation (uiRes("m_buildDisplayMenu.kRoughOptionAnnot"))
			-c "NURBSSmoothnessRoughOptions"
			dispSmthnessRoughOptionItem;

	menuItem 
		-dmc "performDisplaySmoothnessMedium 2"
		-rtc "NURBSSmoothnessMedium"
		dispSmthnessMediumItem;
		menuItem -ecr false -optionBox true 
			-annotation (uiRes("m_buildDisplayMenu.kDisplayMediumOptionAnnot"))
			-c "NURBSSmoothnessMediumOptions"
			dispSmthnessMediumOptionItem;

	menuItem 
		-dmc "performDisplaySmoothnessFine 2"
		-rtc "NURBSSmoothnessFine"
		dispSmthnessFineItem;
		menuItem -ecr false -optionBox true 
			-annotation (uiRes("m_buildDisplayMenu.kFineOptionAnnot"))
			-c "NURBSSmoothnessFineOptions"
			dispSmthnessFineOptionItem;

	menuItem 
		-dmc "performDisplaySmoothnessCustom 2"
		-rtc "CustomNURBSSmoothness"
		dispNurbsSmthnessCustomItem;
		menuItem -ecr false -optionBox true 
			-annotation (uiRes("m_buildDisplayMenu.kDisplayCustomOptionAnnot"))
			-c "CustomNURBSSmoothnessOptions"
			dispNurbsSmthnessCustomOptionItem;
	
	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;
}

global proc buildSubdivSurfaces(string $parent)
{
	setParent -m $parent;

	menuItem 
		-rtc "ToggleMeshPoints" subdivToggleMeshPointItem;
	menuItem 
		-rtc "ToggleMeshEdges" subdivToggleMeshEdgeItem;
	menuItem 
		-rtc "ToggleMeshFaces" subdivToggleMeshFaceItem;
	menuItem
		-rtc "ToggleMeshMaps" subdivToggleMeshMapItem;

	string $cmd = "ToggleNormals";
	menuItem 
		-imageOverlayLabel (uiRes("m_buildDisplayMenu.kNormalsOverlayLabel2")) 
		-rtc $cmd  toggleNormalSubdivItem;

	$cmd = "ToggleMeshUVBorders";
	menuItem 
		-rtc $cmd subdivToggleMeshCreasesItem;
	
	menuItem -d true;
	
	$cmd = "SubdivSmoothnessHull";
	menuItem 
		-dmc "performSubdivDisplaySmoothnessHull 2"
		-rtc $cmd
		dispSmthnessHullItem;

		$cmd = "SubdivSmoothnessHullOptions";
		menuItem -ecr false -optionBox true 
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c $cmd
			subdivSetHullOptionItem;

	$cmd = "SubdivSmoothnessRough";
	menuItem 
  		-dmc "performSubdivDisplaySmoothnessRough 2"
  		-rtc $cmd
		subdivSetRoughItem;

		$cmd = "SubdivSmoothnessRoughOptions";
		menuItem -ecr false -optionBox true 
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c $cmd
			subdivSetRoughOptionItem;

	$cmd = "SubdivSmoothnessMedium";
	menuItem 
  		-dmc "performSubdivDisplaySmoothnessMedium 2"
  		-rtc $cmd
		subdivSetMediumItem;

		$cmd = "SubdivSmoothnessMediumOptions";
		menuItem -ecr false -optionBox true 
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c $cmd
			subdivSetMediumOptionItem;

	$cmd = "SubdivSmoothnessFine";
	menuItem 
  		-dmc "performSubdivDisplaySmoothnessFine 2"
  		-rtc $cmd
		subdivSetFineItem;

		$cmd = "SubdivSmoothnessFineOptions";
		menuItem -ecr false -optionBox true 
			-annotation (getRunTimeCommandAnnotation($cmd))
			-c $cmd
			subdivSetFineOptionItem;

	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;
}
global proc buildAnimationMenu(string $parent)
{
	setParent -m $parent;
	
	string $cmd = "ToggleLatticePoints";
	menuItem 
		-rtc $cmd toggleLatticePtItem;
	$cmd = "ToggleLatticeShape";
	menuItem 
		-rtc $cmd toggleLatticeShapeItem;
	
	menuItem -d true;		
	
	menuItem -rtc "JdsWin" jdsItem5;
	menuItem -rtc "IkfkjdsWin" ikfkjdsItem5;
	menuItem -rtc "IkHdsWin" ikHdsItem5;

	menuItem -d true;		
	
	menuItem -rtc "ToggleJointLabels" toggleJointLabelsItem;
		
	menuItem -d true;	
		
	menuItem -label (uiRes("m_buildDisplayMenu.kHighlightAffected"))
			 -version 2019
			 -checkBox `displayPref -q -displayAffected` 
			 -command "displayPref -displayAffected #1;"
			 highlightAffectedMenuItem;
	
	// add a script job on highlightAffectedMenuItem 
	//
	// This is need to keep the checkbox sync if the menu is detatched (floating window)
	//
	scriptJob -permanent -parent $parent -event "DisplayPreferenceChanged"
	"menuItem -e -checkBox `displayPref -q -displayAffected` highlightAffectedMenuItem";
   
	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;	
}
global proc buildRenderingMenu(string $parent)
{
	setParent -m $parent;
	// This menu cannot be tear-off-able since it is dynamically built
	string $menu = `menuItem -label (uiRes("m_buildDisplayMenu.kCameraLightManipulator")) -sm true`;
	menuItem -e -pmc ("buildRenderManipMenu "+ $menu) $menu;
	setParent -m ..;

	if (`isTrue "MayaCreatorExists"`)
	{
		menuItem -d 1;
		menuItem -cb 0 
			-rtc "ToggleEffectsMeshDisplay"
			paintEffectsMeshDisplayItem;

		$menuItem = `menuItem -label (uiRes("m_buildDisplayMenu.kStrokeDisplayQuality"))	
						-subMenu true -tearOff true`;
		menuItem -e -pmc ( "buildStrokeDisplayQualitySubmenu "
						+ $menuItem ) $menuItem;
		setParent -m ..;
		paintEffectsMeshDisplayMenuUpdate;
	}

	// Delete the -pmc now that the submenu contents are built
	//
	menuItem -e -pmc "" $parent;
}
//The following two methods displays a window for Normals Size and Edge Width.
global proc winReset(string $op)
{
	if($op == "VertSz"){
		floatSliderGrp -edit -value 3.0 vertexSizeSlider;
		polyOptions -sizeVertex `floatSliderGrp -query -value vertexSizeSlider`;
	}
	else if($op == "UVSz"){
		floatSliderGrp -edit -value 4.0 uvSizeSlider;
		polyOptions -sizeUV `floatSliderGrp -query -value uvSizeSlider`;
	}
	else if($op == "NormSz"){
		floatSliderGrp -edit -value 0.4 normalsSizeSlider;
		polyOptions -sizeNormal `floatSliderGrp -query -value normalsSizeSlider`;
	}
	else if($op == "EdgeSz"){
		floatSliderGrp -edit -value 2.0 edgeSizeSlider;
		polyOptions -sizeBorder `floatSliderGrp -query -value edgeSizeSlider`;
	}
}

global proc dispWindow(string $op)
{
	string $wndName = ($op+"wnd");
	string $wndTitle = "";
	if($op == "VertSz"){
		$wndTitle = (uiRes("m_buildDisplayMenu.kVertexSizeWindow"));
	}
	else if($op == "UVSz"){
		$wndTitle = (uiRes("m_buildDisplayMenu.kUVSizeWindow"));
	}
	else if($op == "NormSz"){
		$wndTitle = (uiRes("m_buildDisplayMenu.kNormalSizeWindow"));
	}
	else if($op == "EdgeSz"){
		$wndTitle = (uiRes("m_buildDisplayMenu.kEdgeWidthWindow"));
	}
		
	string $resetMenu = ($op+"ResetMenu");
	string $resetMenuItem = ($op+"ResetToItem");
	
    if ( `window -exists $wndName`) 
	{
    	showWindow $wndName;
	}
	else 
	{
		window 
			-resizeToFitChildren 1
			-title $wndTitle 
			-iconName $op 
			-menuBar 1 
			-height 75
			-width 250
			-sizeable 0 
			$wndName;
		
		menu -parent $wndName 
			-label (uiRes("m_buildDisplayMenu.kResetMenu")) 
			-enable 1 
			-familyImage "menuIconReset.png" 
			$resetMenu;
			
		menuItem -parent $resetMenu 
			-label (uiRes("m_buildDisplayMenu.kResetSettings"))
			-command ("winReset "+$op) 
			$resetMenuItem; 			
			
		setParent $wndName;
		
		string $formLayout = `formLayout`;
		string $control;

		if($op == "VertSz"){
			$control = `floatSliderGrp -field 1 
				-minValue 0.02 
				-maxValue 10 
				-precision 2 
				-value 3.0
				-changeCommand ("setVertexSize()") 
				vertexSizeSlider`;
		}
		else if($op == "UVSz"){
			$control = `floatSliderGrp -field 1 
				-minValue 0.02 
				-maxValue 10 
				-precision 2 
				-value 4.0
				-changeCommand ("setUVSize()") 
				uvSizeSlider`;
		}
		else if($op == "NormSz"){
			$control = `floatSliderGrp -field 1 
				-minValue 0.02 
				-maxValue 10 
				-fieldMaxValue 10000
				-precision 2 
				-value 0.4
				-changeCommand ("setNormalSize()") 
				normalsSizeSlider`;
		}
		else if($op == "EdgeSz"){
			$control = `floatSliderGrp -field 1 
				-minValue 0.02 
				-maxValue 10 
				-precision 2 
				-value 2.0
				-changeCommand ("setEdgeWidth()") 
				edgeSizeSlider`;
		}
      	
      	formLayout -edit
      		-attachForm $control top 3 
      		-attachForm $control left 3 
      		-attachForm $control right 3
      		-attachForm $control bottom 3 
      		$formLayout;
   	}
   	
    showWindow $wndName;
}
