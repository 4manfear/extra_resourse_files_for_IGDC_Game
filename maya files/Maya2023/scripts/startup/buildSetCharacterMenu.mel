// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//	Creation Date:  23 November 1998
//
//  Procedure Name:
//      buildSetCharacterMenu
//
//  Description:
//      build the menu used for quickly selecting the current character
//
//  Input Arguments:
//      Name of the parent menu
//
//  Return Value:
//      None.
//
proc int
createCharacterMenuItem(string $character,
						string $currentCharacter,
						int $submenu)
{
	int $characterRadioOn = false;
	int $radioState = ( $character == $currentCharacter );
	if ( $radioState ) {
		$characterRadioOn = true;
	}
	string $cmd = ( "setCurrentCharacters( { \"" + $character + "\" } )" );
	string $charSetAnnotationFormat = (uiRes("m_buildSetCharacterMenu.kCharSetAnnotFormat"));
	$annotation = `format -stringArg $character $charSetAnnotationFormat `;

	
	string $chmem[] = `character -q $character`;
	string $subcharacters[] = `ls -type character $chmem`;
	$submenu = (size($subcharacters) > 0);
	menuItem -label $character -command $cmd -annotation $annotation  -subMenu $submenu
		-radioButton $radioState;		
	if ($submenu) {
		menuItem -label $character -command $cmd -annotation $annotation
			-radioButton $radioState;
		menuItem -divider true;		
		for ($sub in $subcharacters) {
			if (createCharacterMenuItem($sub,
										$currentCharacter,1)) {
				$characterRadioOn = true;
			}
		}
		setParent -m ..;
	}
	return $characterRadioOn;
}

global proc buildSetCharacterMenu( string $menu ) 
{
	menu -edit -dai $menu;
	setParent -m $menu;
	int $characterRadioOn = false;

	// Get the list of top-level characters from the character partition
	//
	string $characters[] = `partition -query characterPartition`;
	string $currentCharacters[] = currentCharacters();

	// Determine if there is a single current character
	//
	string $currentCharacter = "";
	if ( size( $currentCharacters ) == 1 ) {
		$currentCharacter = $currentCharacters[0];
	}

	// Put in the "None" menu item
	//
	radioMenuItemCollection;
	int $radioState; 
	$radioState = ( size( $currentCharacters ) == 0 );
	string $cmd = "setCurrentCharacters( {} )";
	menuItem -label (uiRes("m_buildSetCharacterMenu.kNone")) -command "ClearCurrentCharacterList" 
		-annotation (uiRes("m_buildSetCharacterMenu.kNoneAnnot"))
		-radioButton $radioState;

	// Put in another divider, but only if there are characters
	// to list in the top-level character section of the menu
	//
	if ( size( $characters ) > 0 ) {
		menuItem -divider true;
	}

	// Put in the radio buttons for all of the top-level characters
	// in the scene
	//
	string $annotation;
	for ( $character in $characters ) {
		if (createCharacterMenuItem($character,
									$currentCharacter, 0)) {
			$characterRadioOn = true;
		}
	}

	menuItem -divider true;

	// Put in the special case item for multiple or sub characters selected
	//
	$radioState = ( ( size( $currentCharacters ) > 0 ) && !$characterRadioOn );
	string $label;
	if ( $radioState ) {
		if ( size( $currentCharacters ) > 1 ) {
			// There are multiple characters selected
			//
			$label = (uiRes("m_buildSetCharacterMenu.kMultiple"));
			$annotation = (uiRes("m_buildSetCharacterMenu.kMultipleAnnot"));
		} else {
			// There is only one character selected, so it must be
			// a sub character
			//
			$label = (uiRes("m_buildSetCharacterMenu.kSubCharacter"));
			$annotation = (uiRes("m_buildSetCharacterMenu.kSubCharacterAnnot"));
		}
		menuItem -label $label -radioButton true -annotation $annotation;
	}
	menuItem -label (uiRes("m_buildSetCharacterMenu.kCharacterSets"))
	 	 -command "characterEditor( true )"
		 -annotation (uiRes("m_buildSetCharacterMenu.kCharacterSetsAnnot"));

}
