// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Description:
//      This file creates the window menu
//

// This string points to the relationship editor pulldown menu in the
// main window.  If plugins add new tasks, they can add their popup menu
// items to this menu.
global string $gRelationshipEditorPulldownMenu = "";

// These strings point to procedures for adding and removing tasks to the
// relationship editor.  They are managed by the relationshipEditorRegisterTask
// global procedure that plugin writers can call.
global string $gRelationshipEditorRegisterCB[] = {};
global string $gRelationshipEditorUnregisterCB[] = {};

global proc string[] getRelationshipEdPopups()
//
// Description:
//	This procedure finds and returns the popup task menu for all relationship
//  editors.  This list is used to allow plugins to register their own tasks.
//
{
	string $popups[];
    string $controls[] = `lsUI -long -controls`;
	
	// Look for controls whose leaf name is "taskPopup".
	for ($c in $controls) {
		string $tokens[];
		int $numTokens = `tokenize $c "|" $tokens`;
		if ($tokens[$numTokens-1] == "taskPopup")
		    $popups[size($popups)] = $c;
	}
	
	return $popups;
}

global proc int relationshipEditorRegisterTask(
		string $registerCB,
		string $unregisterCB)
//
// Description:
//	This procedure saves the two callbacks for registering and unregistering
//  a task for the relationship editor.  The callbacks are used to add and
//  remove the popup UI which makes the tasks visible to the user.  An id
//  number is returned to the caller to use when unregistering the task.
//
{
	global string $gRelationshipEditorPulldownMenu;
	global string $gRelationshipEditorRegisterCB[];
	global string $gRelationshipEditorUnregisterCB[];
	
	// Use the next available index as the id.
    int $id = size($gRelationshipEditorRegisterCB);
	
	// Store the callback procedures.
	$gRelationshipEditorRegisterCB[$id] = $registerCB;
	$gRelationshipEditorUnregisterCB[$id] = $unregisterCB;
	
	// If the main menu pulldown or the relationship editor popup 
	// have already been created, call the registerCB.
	if ($gRelationshipEditorPulldownMenu != "") {
	
	    // Call the register CB at least once for the main menu pulldown.
	    eval($registerCB + " foo");
		
		// Get the relationship editor task popups and register the plugin
		// UI for each one.
	    string $taskPopups[] = getRelationshipEdPopups();
		for ($popup in $taskPopups)
	        eval($registerCB + " " + $popup);
	}
	
	return $id;
}

global proc relationshipEditorUnregisterTask(int $taskId)
//
// Description:
//	This procedure unregisters that task specified by the given id.
//
{
	global string $gRelationshipEditorPulldownMenu;
	global string $gRelationshipEditorRegisterCB[];
	global string $gRelationshipEditorUnregisterCB[];
	
    // If the task id is not valid, just return.
	if (($taskId < 0) || ($taskId >= size($gRelationshipEditorRegisterCB)))
	    return;
		
	// If the relationship editor or the main window pulldown have been created,
	// call the unregisterCB for each relationship editor.
	if ($gRelationshipEditorPulldownMenu != "") {
	
	    // Call the unregister CB at least once for the main menu pulldown.
	    eval($gRelationshipEditorUnregisterCB[$taskId] + " foo");
		
		// Get the relationship editor task popups and unregister the plugin
		// UI for each one.
	    string $taskPopups[] = getRelationshipEdPopups();
		for ($popup in $taskPopups)
	        eval($gRelationshipEditorUnregisterCB[$taskId] + " " + $popup);
    }
		
	// Clear the callback procedures.
	$gRelationshipEditorRegisterCB[$taskId] = "";
	$gRelationshipEditorUnregisterCB[$taskId] = "";
}

global proc addRelationshipEdPluginItems(string $popup)
//
// Description:
//	This procedure is called when the relationship editor is built.  It
//  creates the UI for any tasks registered by plugins.
//
{
	global string $gRelationshipEditorRegisterCB[];
	
    // Call the register callback for each registered plugin.
    for ($cb in $gRelationshipEditorRegisterCB) {
	    if ($cb != "")
	    	eval($cb + " " + $popup);
	}
}

global proc buildObjectEdMenu( string $parent )
{

	global string $gCommandWindow;

	setParent -menu $parent;
	string $cmd;

	if (!(`menuItem -query -exists wmAttributeEditor`))
	{
		$cmd = "AttributeEditor";
		menuItem -ecr false 
			-rtc $cmd wmAttributeEditor;
	}

	
	if(!`optionVar -q channelsLayersSeparate`) {
		// delete individual menu items if exist.
		if(`menuItem -query -exists wmChannels`)
		{
			deleteUI -menuItem wmChannels;
		}
		if(`menuItem -query -exists wmLayers`)
		{
			deleteUI -menuItem wmLayers;
		}
		if (!(`menuItem -query -exists wmChannelsLayers`))
		{
			menuItem -ecr false
				-rtc "OpenChannelsLayers"
				-insertAfter wmAttributeEditor
				wmChannelsLayers;
		}
	}
	else {
		// delete combined menuitem if exist.
		if(`menuItem -query -exists wmChannelsLayers`) {
			 deleteUI -menuItem wmChannelsLayers;
		}
		if (!(`menuItem -query -exists wmChannels`))
		{
			menuItem -ecr false
				-rtc "OpenChannelBox"
				-insertAfter wmAttributeEditor wmChannels;
		}
	
		if (!(`menuItem -query -exists wmLayers`))
		{
			menuItem -ecr false
				-rtc "OpenLayerEditor"
				-insertAfter wmChannels wmLayers;
		}
	}

	if (!(`menuItem -query -exists wmToolSettings`))
	{
		$cmd = "ToolSettingsWindow";
	    menuItem  -ecr false 
			-rtc $cmd wmToolSettings;	
	}

	string $hyperOverlay = (uiRes("m_WindowMenu.kHypergraphOverlayLabel"));

	if (!(`menuItem -query -exists wmHGHierarchy`))
	{
		$cmd = "HypergraphHierarchyWindow";
		menuItem -ecr false  
			-imageOverlayLabel $hyperOverlay
			-rtc $cmd wmHGHierarchy;
	}


	if (!(`menuItem -query -exists wmHGHierarchyOptions`))
	{
	    menuItem -optionBox true 
	        -annotation (uiRes("m_WindowMenu.kHyperGraphOptionsAnnot"))
	        -command "hyperGraphOptions DAG" wmHGHierarchyOptions;
	}

    if (!(`menuItem -query -exists wmHGConnections`))
    {
		$cmd = "HypergraphDGWindow";
    	menuItem -ecr false
			-imageOverlayLabel $hyperOverlay
			-rtc $cmd wmHGConnections;
    }


	if (!(`menuItem -query -exists wmHGConnectionsOptions`))
	{
	    menuItem -optionBox true 
	        -annotation (uiRes( "m_WindowMenu.kHyperGraphOptionsAnnot"))
	        -command "hyperGraphOptions DG" wmHGConnectionsOptions;
	}
	if (!(`menuItem -query -exists wmViewPort`))
	{
		menuItem -ecr false
			-version "2017"
			-rtc "DisplayViewport" wmViewPort;
	}

	if (!(`menuItem -query -exists wmGEDivider1`))
	{
		menuItem -divider true -ld false wmGEDivider1;
	}

	if (!(`menuItem -query -exists wmAdobeAfterEffectsLiveLink`))
	{
		menuItem -ecr false 
			-rtc "OpenAELiveLink"
			-version "2017"
			wmAdobeAfterEffectsLiveLink;
	}
	if (!(`menuItem -query -exists wmAssetEditor`))
	{
		menuItem -ecr false 
			-rtc "AssetEditor" wmAssetEditor;
	}

	if (!(`menuItem -query -exists wmSpreadsheetEditor`))
	{
		$cmd = "SpreadSheetEditor";
		menuItem -ecr false 
			-imageOverlayLabel (uiRes("m_WindowMenu.kAttrSpreadOverlayLabel")) 
			-rtc $cmd wmSpreadsheetEditor;
	}

	if (!(`menuItem -query -exists wmComponentEditor`))
	{
		$cmd = "ComponentEditor";
		menuItem -ecr false 
			-imageOverlayLabel (uiRes("m_WindowMenu.kClipEdOverlayLabel")) 
			-rtc $cmd wmComponentEditor;
	}

	if (!(`menuItem -query -exists wmConnectionEditor`))
	{
		$cmd = "ConnectionEditor";
		menuItem -ecr false 
			-rtc $cmd wmConnectionEditor;
	}

	if (!(`menuItem -query -exists wmChannelControlEditor`))
	{
		$cmd = "ChannelControlEditor";
		menuItem -ecr false 
			-rtc $cmd wmChannelControlEditor;
	}

	if (!(`menuItem -query -exists wmDisplayLayerEditorWindow`))
	{
		$cmd = "DisplayLayerEditorWindow";
		menuItem -ecr false 
			-rtc $cmd wmDisplayLayerEditorWindow;
	}

	if (!(`menuItem -query -exists wmFilePathEditor`))
	{
		menuItem -ecr false
			-rtc "FilePathEditor" wmFilePathEditor;
	}

	if (!(`menuItem -query -exists wmNamespaceEditor`))
	{
		menuItem -ecr false
			-rtc "NamespaceEditor" wmNamespaceEditor;
	}

	// menuItem -label "Panel Camera Attributes..." -c "showPanelCameraEditor \"\"";
	if (!(`menuItem -query -exists wmGEDivider2`))
	{
		menuItem -divider true -ld false wmGEDivider2;
	}

	if (!(`menuItem -query -exists wmScriptEditor`))
	{
		$cmd = "ScriptEditor";
		menuItem -ecr false
			-rtc $cmd wmScriptEditor;
	}
	if (!(`menuItem -query -exists wmCommandShell`))
	{
		$cmd = "CommandShell";
		menuItem -ecr false
			-rtc $cmd wmCommandShell;
	}

	int $profilerPluginLoaded = `pluginInfo -q -loaded "dgProfiler"`;
	if ($profilerPluginLoaded)
	{
		if (!(`menuItem -query -exists wmDGProfiler`))
		{
			menuItem -ecr false -rtc "OpenDGProfiler" wmDGProfiler;
		}
	}
	else
	{
		catchQuiet(`deleteUI -menuItem wmDGProfiler`);
	}
	if (!(`menuItem -query -exists wmProfiler`))
	{
		$cmd = "ProfilerTool";
		menuItem -ecr false 
			-ver "2016"
			-rtc $cmd wmProfiler;
	}

	if (!(`menuItem -query -exists wmEvaluationToolkit`))
	{
		$cmd = "EvaluationToolkit";
		menuItem  -ecr false
			-rtc $cmd
			-version "2017"
			wmEvaluationToolkit;
	}
}

global proc buildModelingEdMenu( string $parent )
{
	setParent -menu $parent;
	string $cmd;
	global string $gMiInteractionEditorMenuParent;
	global string $gMiInteractionEditorMenuAfter;

	$gMiInteractionEditorMenuParent = $parent;

	int $modelingToolkitPluginLoaded = `pluginInfo -q -loaded "modelingToolkit"`;
	if ($modelingToolkitPluginLoaded)
	{
		if (!(`menuItem -query -exists wmModelingToolkit`))
		{
			menuItem -ecr false -rtc "OpenModelingToolkit"
				wmModelingToolkit;
		}
	}
	else
	{
		catchQuiet(`deleteUI -menuItem wmModelingToolkit`);
	}


	if (!(`menuItem -query -exists wmPaintEffects`))
	{
		// License check for annotation moved over to runTimeCommand
		menuItem -ecr false -rtc "PaintEffectsWindow" wmPaintEffects;
	}
		
	
	if (!(`menuItem -query -exists wmUVEditor`))
	{
		$cmd = "TextureViewWindow";
		$gMiInteractionEditorMenuAfter = `menuItem -ecr false 
			-rtc $cmd wmUVEditor`;
	}

	int $xgenToolkitPluginLoaded = `pluginInfo -q -loaded "xgenToolkit"`;
	if ($xgenToolkitPluginLoaded)
	{
		if (!(`menuItem -query -exists wmXGenEditor`))
		{
			menuItem -ecr false
				-rtc "OpenXGenEditor" wmXGenEditor;
		}
	}
	else
	{
		catchQuiet(`deleteUI -menuItem wmXGenEditor`);	
	}


	if (!(`menuItem -query -exists wmCreaseSets`))
	{
		menuItem
			-rtc "OpenCreaseEditor"
			-enableCommandRepeat 1
			-version "2014"
			wmCreaseSets;
	}


}

global proc buildRenderingEdMenu( string $parent )
{

	popupMenu -e -deleteAllItems $parent;
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	string $cmd;

	string $command = "RenderViewWindow";
	menuItem -ecr false 
		-rtc $command;
	
	// Create a render globals menu item for each available renderer
	//
	string $renderers[] = `renderer -query -namesOfAvailableRenderers`;
	string $rendererUIName = "";
	
	$command = "RenderGlobalsWindow";
	menuItem 
		-enableCommandRepeat false 
		-rtc $command;

	$command = "HypershadeWindow";
	$annotation = getRunTimeCommandAnnotation($command);
	menuItem -ecr false 
		-imageOverlayLabel (uiRes("m_WindowMenu.kHyperShadeOverlayLabel")) 
		-rtc $command
		-version 2016;

	// Create renderer specific submenus for any additional renderers installed
	for ($i = 0; $i < size($renderers); $i += 1)
	{
		$command = `renderer -q -renderingEditorsSubMenuProcedure $renderers[$i]`;

		if($command != "")
		{
            $rendererUIName = `renderer -query -rendererUIName $renderers[$i]`;

		   	menuItem
		   		-tearOff				true
				-subMenu				true
				-label $rendererUIName 
 				-annotation 
                (uiRes("m_WindowMenu.kRendererSpecificOptionsAnnot"))
				("rendererOptionsItem" + $renderers[$i]);

			menuItem
				-edit
				-postMenuCommand
					("eval " + $command +
					 " rendererOptionsItem" + $renderers[$i])
				("rendererOptionsItem" + $renderers[$i]);

			setParent -menu ..;
		}
	}
	if( !mayaHasRenderSetup() ) {
		$cmd = "RenderLayerEditorWindow";
		menuItem -ecr false 
			-rtc $cmd;
	}
	else
	{
        $command = "RenderSetupWindow";
		menuItem -ecr false 
			-version "2017"
			-rtc $command;

		menuItem -ecr false
			-version "2017"
			-rtc "OpenLightEditor";
	}

	menuItem -rtc "OpenStereoRigManager";

	menuItem -divider true;

	$cmd = "RenderFlagsWindow";
	menuItem -ecr false 
		-rtc $cmd;

	$cmd = "ShadingGroupAttributeEditor";
	menuItem -ecr false
		-rtc $cmd;


	if (isLegacyViewportEnabled())
	{
		menuItem -divider true;

		$cmd = "HardwareRenderBuffer";
		menuItem -ecr false
			-rtc $cmd
            hardwareRenderBufferItem;

		string $vp2Engine = getPreferredRenderingEngine();
		if ($vp2Engine == "OpenGLCoreProfile") {
			menuItem -e -enable false hardwareRenderBufferItem;
		}
	}
}

global proc buildAnimationEdMenu( string $parent )
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	string $cmd = "GraphEditor";
	menuItem -ecr false
		-version "2017"
		-rtc $cmd;

	$cmd = "TimeEditorWindow";
	menuItem -ecr false 
		-version "2017"
		-rtc $cmd;


	$cmd = "CharacterAnimationEditor";
	menuItem  -ecr false
		-rtc $cmd;

	$cmd = "SequenceEditor";
	menuItem  -ecr false
		-rtc $cmd;

	$cmd = "DopeSheetEditor";
	menuItem  -ecr false
		-rtc $cmd;

	python( "from maya.app.ghosting.GhostingMenus import create_window_ghosting_menu_item" );
	python( "create_window_ghosting_menu_item()" );

	$cmd = "QuickRigEditor";
	menuItem  -ecr false 
		-rtc $cmd
		-version "2017";

	$cmd = "HIKCharacterControlsTool";
	menuItem
		-to true
		-rtc $cmd
		hikWindowItem;

	$cmd = "ShapeEditor";
	menuItem  -ecr false
		-imageOverlayLabel (uiRes("m_WindowMenu.kShapeEditorOverlayLabel")) 
		-rtc $cmd
		-version "2017";

	$cmd = "PoseEditor";
	menuItem  -ecr false 
		-imageOverlayLabel (uiRes("m_WindowMenu.kPoseEditorOverlayLabel")) 
		-rtc $cmd
		-version "2017";

	menuItem -divider true;
	$cmd = "ExpressionEditor";
	menuItem -ecr false 
		-rtc $cmd expressionItem;
}

global proc buildLightLinkingEdMenu( string $parent )
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	string $cmd = "LightCentricLightLinkingEditor";
	menuItem -ecr false 
	  -rtc $cmd;
	$cmd = "ObjectCentricLightLinkingEditor";
	menuItem -ecr false 
		-rtc $cmd;
}

global proc buildUvLinkingEdMenu( string $parent )
{
	global string $gUvMainLinkMenu;
	global string $gFurUVLinkMenuItem;
	$gUvMainLinkMenu = $parent;

	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	string $cmd = "TextureCentricUVLinkingEditor";
	menuItem 
		-ecr false
		-rtc $cmd;
	$cmd = "UVCentricUVLinkingEditor";
	menuItem 
		-ecr false 
		-rtc $cmd;

	//Paint Effects/UV Linking Menu
	{
		$cmd = "PFXUVSetLinkingEditor";
		menuItem -ecr false 
		-rtc $cmd;
	}

	//Hair/UV Linking Menu
	{
		$cmd = "HairUVSetLinkingEditor";
		menuItem -ecr false 
		-rtc $cmd;
	}

	//Maya Fur Plugin Fur/UV Linking Menu
	if (`pluginInfo -q -l Fur`) {
			$gFurUVLinkMenuItem = `menuItem -ecr false 
			-rtc "FurUVSetLinkingEditor"`;
	}
}

global proc buildRelationshipEdMenu( string $parent )
{	
	// Make the parent menu available to plugins who want to add their own
	// relationships.  This variable is defined in relationshipEditor.mel.
    global string $gRelationshipEditorPulldownMenu;
	$gRelationshipEditorPulldownMenu = $parent;
	
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}
	string $cmd;

	$cmd = "AnimLayerRelationshipEditor";
	menuItem -ecr false 
	  -rtc $cmd;	  

	$cmd = "CameraSetEditor";
	menuItem -ecr false
		-rtc $cmd;

	$cmd = "CharacterSetEditor";
	menuItem -ecr false 
	  -rtc $cmd;

	$cmd = "DeformerSetEditor";
	menuItem -ecr false 
		-rtc $cmd;
	
	$cmd = "LayerRelationshipEditor";
	menuItem -ecr false 
		-rtc $cmd;

	$cmd = "DynamicRelationshipEditor";
	menuItem  -ecr false
		-rtc $cmd;

	if (`pluginInfo -q -l Fur`)
	{
		global string $gHairFurLinkMenuItem;
		$gHairFurLinkMenuItem = `menuItem -ecr false 
		-rtc "HairFurRelationshipEditor"`;
		setParent -menu $parent;
	}

	$menu = `menuItem 
          -label (uiRes("m_WindowMenu.kLightLinkingEdLabel"))  
          -sm true -to true`;
		menu -e -pmc ( "buildLightLinkingEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$cmd = "PartitionEditor";
	menuItem -ecr false
	  -rtc $cmd;

	if( !mayaHasRenderSetup() ) {
		$cmd = "RenderLayerRelationshipEditor";
		menuItem -ecr false
		  -rtc $cmd;
	}
	$cmd = "RenderPassSetEditor";
	menuItem -ecr false
		-rtc $cmd;

	$cmd = "SetEditor";
	menuItem -ecr false
	  -rtc $cmd;
	$menu = `menuItem 
          -label (uiRes("m_WindowMenu.kUVLinkingEdLabel")) 
          -sm true -to true`;
		menu -e -pmc ( "buildUvLinkingEdMenu " + $menu ) $menu;
	setParent -menu $parent;
	
	// Add any items from plugins.
	addRelationshipEdPluginItems("foo");
}

global proc buildSettingsMenu( string $parent ) 
{
	setParent -menu $parent;

	if( `menu -q -ni $parent` != 0 ) {
		//
		//	Menu is already built - just return
		//
		return;
	}

	string $cmd = "PreferencesWindow";
	menuItem -ecr false
		-rtc $cmd;

	if (isLegacyViewportEnabled())
	{
		$cmd = "PerformanceSettingsWindow";
		menuItem -ecr false 
			-rtc $cmd;
	}

    menuItem -divider true;

	$cmd = "HotkeyPreferencesWindow";
	menuItem -ecr false
		-rtc $cmd
		-version "2016";

	$cmd = "ColorPreferencesWindow";
	menuItem -ecr false
		-rtc $cmd;

	$cmd = "MarkingMenuPreferencesWindow";
	menuItem  -ecr false
		-rtc $cmd;

	$cmd = "ShelfPreferencesWindow";
	menuItem  -ecr false 
		-rtc $cmd shelfOptionsItem;

	$cmd = "PanelPreferencesWindow";
	menuItem  -ecr false
		-rtc $cmd;

	menuItem -divider true;

	$cmd = "PluginManager";
    menuItem -ecr false
		-rtc $cmd;
}

global proc openAEWindow( )
//
//	Description:
//		Opens an AE window, IF the attribute editor isn't
//		in the main Maya window pane already.
//
{
	editSelected;
}

global proc WindowMenu( string $parent )
{
	setParent -menu $parent;
	string $cmd;
	
	menuItem -divider true -dividerLabel (uiRes("m_WindowMenu.kEditors"));

	string $menu = `menuItem 
           -label (uiRes("m_WindowMenu.kGeneralEditorsLabel"))  
           -sm true -to true`;
		menu -e -pmc ( "buildObjectEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem
		  -label (uiRes("m_WindowMenu.kModelingEditorsLabel"))
		  -sm true -to true`;
		menu -e -pmc ( "buildModelingEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem 
          -label (uiRes("m_WindowMenu.kAnimEditorsLabel"))
          -sm true -to true`;
		menu -e -pmc ( "buildAnimationEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem -label 
    		(uiRes("m_WindowMenu.kRenderingEditorsLabel")) 
    		-sm true -to true`;
		menu -e -pmc ( "buildRenderingEdMenu " + $menu ) $menu;
	setParent -menu $parent;

	$menu = `menuItem 
            -label (uiRes("m_WindowMenu.kRelationEditorsLabel"))
            -sm true -to true`;
		menu -e -pmc ( "buildRelationshipEdMenu " + $menu ) $menu;
	setParent -menu $parent;

    global string $gMainOptionsMenu;
    menuItem -label (uiRes("m_WindowMenu.kUIElements"))
        -subMenu true -tearOff true
        -familyImage "menuIconOptions.png"
        -pmc ( "buildPreferenceMenu " + $gMainOptionsMenu )
        $gMainOptionsMenu;

	setParent -menu $parent;

	$menu = `menuItem -label 
          (uiRes("m_WindowMenu.kSettingsPrefsLabel"))
          -sm true -to true`;
		menu -e -pmc ( "buildSettingsMenu " + $menu ) $menu;

	setParent -menu $parent;

	menuItem -divider true -ld false;
	if (!(`menuItem -query -exists wmOutliner`))
	{
		menuItem -ecr false 
			-rtc "OutlinerWindow" wmOutliner;
	}

	if (!(`menuItem -query -exists wmNodeEditor`))
	{
		menuItem -ecr false 
			-rtc "NodeEditorWindow" wmNodeEditor;
	}


	if (!(`menuItem -query -exists wmContentBrowser`))
	{
	    menuItem -ecr false 
			-image "contentBrowserGeneric"
	    	-rtc "OpenContentBrowser"
			wmContentBrowser;
	}

	if( `isTrue AnimationExists` ) {
		$cmd = "PlayblastWindow";
		menuItem 
			-rtc $cmd playblastItem;
			
			$cmd = "PlayblastOptions";
			menuItem -optionBox true 
				-annotation (getRunTimeCommandAnnotation($cmd))
	            -c $cmd playblastDialogItem;
	} 

}
