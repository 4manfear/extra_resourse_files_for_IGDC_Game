// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  22 Aug 2000
//

// New functions added to support Toolbars and Dock Widgets
// New code added to support Workspaces

global proc string createUIComponentToolBar(string $name, string $label, string $uiScript, string $area, int $tabbed)
{
	global string $gUIComponentToolBarArray[];
	global int $gNameIndex;
	global int $gControlIndex;
	
	// create toolbar
	string $controlNameArray[] = stringToStringArray($name, " /");
	string $controlName = stringArrayToString($controlNameArray, "");

	string $createCmd = ("workspaceControl -uiScript \"") + $uiScript 
							+ ("\" -loadImmediately true -label \"") + $label 
							+ ("\" -dockToMainWindow ") + $area + " " + $tabbed
							+ " " + $controlName;

	string $toolbar = `eval($createCmd)`;

	// add entry to array
	int $count = size($gUIComponentToolBarArray);
	$gUIComponentToolBarArray[$count + $gNameIndex] = $name;
	$gUIComponentToolBarArray[$count + $gControlIndex] = $toolbar;

	return $toolbar;
}


global proc string getUIComponentToolBar(string $name, int $reportError)
//
//	Description:
//		Return the tool bar corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid tool bar. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the component tool bar.
//
{
	global string $gUIComponentToolBarArray[];

	global int    $gNameIndex;
	global int    $gControlIndex;
	global int    $gToolBarElementSize;

	string $component = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $component;
	}

	//	Search the tool bar array.
	//
	$count = size($gUIComponentToolBarArray);
	for ($index = 0; $index < $count; $index += $gToolBarElementSize) {
		if ($name == $gUIComponentToolBarArray[$index + $gNameIndex]) {
			$component = $gUIComponentToolBarArray[$index + $gControlIndex];

			if (!`workspaceControl -exists $component`){
				$component = "";
			}

			break;
		}
	}

	if ("" == $component && $reportError) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $component;
}

global proc string createUIComponentDockControl(string $name, string $label, string $uiScript, string $area, int $tabbed)
{
	global string $gUIComponentDockControlArray[];
	global int $gNameIndex;
	global int $gControlIndex;
	
	// create dock control
	string $controlNameArray[] = stringToStringArray($name, " /");
	string $controlName = stringArrayToString($controlNameArray, "");

	string $createCmd = ("workspaceControl -uiScript \"") + $uiScript
							+ ("\" -loadImmediately true -label \"") + $label 
							+ ("\" -dockToMainWindow ") + $area + " " + $tabbed
							+ (" -visibleChangeCommand \"evalDeferred(\\\"updateEditorToggleCheckboxes()\\\")\" ")
							+ $controlName;

	string $dockControl = `eval($createCmd)`;

	// add entry to array
	int $count = size($gUIComponentDockControlArray);
	$gUIComponentDockControlArray[$count + $gNameIndex] = $name;
	$gUIComponentDockControlArray[$count + $gControlIndex] = $dockControl;

	return $dockControl;
}

global proc string getUIComponentDockControl(string $name, int $reportError)
//
//	Description:
//		Return the dock control corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid dock control. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the component dock control.
//
{
	global string $gUIComponentDockControlArray[];

	global int    $gNameIndex;
	global int    $gControlIndex;
	global int    $gDockControlElementSize;

	string $component = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $component;
	}

	//	Search the tool bar array.
	//
	$count = size($gUIComponentDockControlArray);
	for ($index = 0; $index < $count; $index += $gDockControlElementSize) {
		if ($name == $gUIComponentDockControlArray[$index + $gNameIndex]) {
			$component = $gUIComponentDockControlArray[$index + $gControlIndex];

			if (!`workspaceControl -exists $component`){
				$component = "";
			}

			break;
		}
	}

	if ("" == $component && $reportError) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $component;
}

//  Description:
//      This script provides support for UI components. A UI component is a
//		group of controls appearing in a window which may be hidden or
//		shown. The main purpose for this is the main application window that
//		has various tool bars and user interface elements that the user may
//		show or hide depending on their preference. Note however that this
//		functionality is structured such that UI components may be placed
//		in any window.
//
//		There 2 types of UI Components, horizontal and vertical.
//
//		Each horizontal UI Component can be hidden and shown individually.
//		When visible, a horizontal UI Component has a close box along its
//		left edge.
//
//		Vertical UI Components may appear along the left or right edge of
//		the window. Only one vertical UI Component may be visible on a 
//		particular side. Each vertical UI Component has a close box along its
//		top edge.
//
//		You have access to the close button control for each component. You
//		may want to attach a popup menu to each close box for quick access
//		to the visibility of all the components.
//
//		Consider the following ASCII art diagram. There are 3 horizontal
//		components, 2 at the top of the window and 1 along the bottom. There
//		are also 3 vertical components, 1 on the left and 2 on the right.
//		All components below are currently visible. Note that you can only
//		see one of the two right vertical components at any given time.
//
//		The X's indicate the close boxes for hiding the components.
//
//		+--------------------------------------------------+
//		|X                                                 |
//		+--------------------------------------------------+
//
//		+--------------------------------------------------+
//		|X                                                 |
//		+--------------------------------------------------+
//
//		+----+  +-------------------------------+  +-------+
//		|X   |  |                               |  |      X|
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |          Work Area            |  |       |
//		|    |  |          eg. Panels           |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		|    |  |                               |  |       |
//		+----+  +-------------------------------+  +-------+
//
//		+--------------------------------------------------+
//		|X                                                 |
//		+--------------------------------------------------+
//
//		To take advantage of UI Components you must structure the layout
//		of your window in a specific way. This is best described by way
//		of a complete example found in the script UICompenentsExample.mel.
//
//
//----------------------------------------------------------------------
//
//	Public interface.
//
//
// global proc createUIComponentBar(
// 	string $name, 
// 	string $position)
// 
// global proc removeUIComponentBar(string $name)
// 
// global proc string createUIComponent(
// 	string $barName, 
// 	string $name, 
// 	string $parent)
// 
// global proc string getUIComponent(string $name)
// 
// global proc setUIComponentStateCallback(
// 	string $componentName,
// 	string $callback)
// 
// global proc setUIComponentWorkArea(
// 	string $name,
// 	string $workArea)
// 
// global proc int toggleUIComponentVisibility(string $name)
// 
// global proc int isUIComponentVisible(string $name)
// 
// global proc string getUIComponentCloseButton(string $name)
//
// global proc int UIComponentExists(string $name)
// 
// global proc printUIComponentBarInfo()
// 
//----------------------------------------------------------------------
//
//	Global variables. Not intended to be accessed outside of this file.
//

//	Contains the name of the component bar, the layout control, the
//	number of components associated with the bar, and the work area layout.
//
// global string $gUIComponentBarArray[];
 
//	Contains the component name and layout control.
//
// global string $gUIComponentBarComponentArray[];
 
//	Indecies and constants that help provide pseudo-structures in MEL.
//
//	Component UI information is stored in one dimensional string arrays.
//	The indecies are used to access individual values within the array.
//
// global int $gNameIndex;
// global int $gParentIndex;
// global int $gComponentCountIndex;
// global int $gCallbackIndex;
// global int $gLayoutIndex;
// global int $gPositionIndex;
// global int $gCurrentIndex;
 
//	Size of the elements in the information arrays.
//
// global int $gComponentBarElementSize;
// global int $gComponentElementSize;

//----------------------------------------------------------------------
//
//	Local procedures. Even though some of these procedures may be 
//	declared global they are still intended to be used within this
//	file only.
//

// proc string getUIComponentBarFromComponent(string $name)
// 
// proc string [] getUIComponentArray(string $name)
// 
// proc string getCallback(string $componentName)
// 
// proc string getWorkArea(string $name)
// 
// proc string getUIComponentBarPosition(string $name)
// 
// proc setCurrentUIComponent(string $componentBar, string $component)
// 
// proc string getCurrentUIComponent(string $componentBar)
// 
// proc string getUIComponentContentLayout(string $componentLayout)
// 
// global proc showCurrentComponent(string $componentBarName)
// 

proc string getUIComponentBarFromComponent(string $name)
//
//	Description:
//		Return the name of the component bar that contains the specified
//		component.
//
//		May return an empty string if the argument component name does not 
//		refer to a valid component. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of component bar that contains the argument component.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gComponentCountIndex;
	global int    $gComponentBarElementSize;
	global int    $gComponentElementSize;

	string $component, $componentBar = "";
	int    $index, $count, $componentIndex = -1;
	int    $numberOfComponents, $componentSum;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $componentBar;
	}

	//	Search the component array...
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $gNameIndex]) {
			$componentIndex = $index / $gComponentElementSize;
			break;
		}
	}

	if ($componentIndex >= 0) {

		//	Search the component bar array.
		//
		$componentSum = 0;
		$count = size($gUIComponentBarArray);

		//	For each component bar test the number of components it has.
		//
		for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {

			//	Test if the component bar has 0 components.
			//
			$numberOfComponents = $gUIComponentBarArray[$index + $gComponentCountIndex];
			if (0 < $numberOfComponents) {

				//	Keep a running sum of the total number of components
				//	in order to compare with the component index determined
				//	above.
				//
				$componentSum += $numberOfComponents;

				if ($componentIndex < $componentSum) {
					//
					//	Retrieve the component bar name.
					//
					$componentBar = $gUIComponentBarArray[$index + $gNameIndex];
					break;
				}
			}
		}

	} else {
		string $error = (uiRes("m_UIComponents.kComponentError"));
		error -showLineNumber true (`format -s $name $error`);
	}

	return $componentBar;
}

proc string [] getUIComponentArray(string $name)
//
//	Description:
//		Return an array containing the names of all the components
//		contained in the specified component bar.
//
//		May return an empty string array if the argument component bar
//		name does not refer to a valid component bar. In this case this 
//		procedure will generate an error.
//
//	Arguments:
//		name - The component bar name.
//
//	Returns:
//		A string array containing all the names of all the components
//		contained in the specified component bar.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gComponentCountIndex;
	global int    $gComponentBarElementSize;
	global int    $gComponentElementSize;
	
	string $componentArray[];
	int    $index, $count, $componentIndex, $componentCount = -1;
	int    $end, $start;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $componentArray;
	}

	//	Search the component bar array.
	//
	//	Note that this array records the number of components in each bar.
	//	By summing the component counts we can determine the start and
	//	end indecies of the corresponding components in the component
	//	array.
	//
	$start = 0;
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			$componentCount = $gUIComponentBarArray[$index + $gComponentCountIndex];
			break;
		}
		$start += $gUIComponentBarArray[$index + $gComponentCountIndex];
	}

	if ($componentCount >= 0) {
		$end = $start + $componentCount;
		$componentIndex = 0;
		for ($index = $start; $index < $end; $index ++) {
			$componentArray[$componentIndex++]
				= $gUIComponentBarComponentArray[$index * $gComponentElementSize];
		}

	} else {
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $componentArray;
}

proc string getCallback(string $componentName)
//
//	Description:
//		Return the callback for a component.
//
//	Arguments:
//		componentName - The UI component name.
//
//	Returns:
//		The name of the callback. May be an empty string.
//
{
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gCallbackIndex;
	global int    $gComponentElementSize;

	string $callback = "";
	int    $index, $count;
	
	if ("" == $componentName) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgEmptyError"));
		return $callback;
	}

	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		if ($componentName == $gUIComponentBarComponentArray[$index + $gNameIndex]) {
			$callback = $gUIComponentBarComponentArray[$index + $gCallbackIndex];
			break;
		}
	}

	return $callback;
}

proc string getWorkArea(string $name)
//
//	Description:
//		Return the name of the work area layout associated with the given
//		component bar name.
//
//	Arguments:
//		name - The UI component bar name.
//
//	Returns:
//		The name of the work area layout.
//
{
	global string $gUIComponentBarArray[];

	global int    $gNameIndex;
	global int    $gLayoutIndex;
	global int    $gComponentBarElementSize;

	string $workArea = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgEmptyError"));
		return $workArea;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			$workArea = $gUIComponentBarArray[$index + $gLayoutIndex];
			break;
		}
	}

	return $workArea;
}

proc string getUIComponentBarPosition(string $name)
//
//	Description:
//		Return the position of the component bar.
//
//	Arguments:
//		name - The UI component bar name.
//
//	Returns:
//		The position of the component bar.
//
{
	global string $gUIComponentBarArray[];

	global int    $gNameIndex;
	global int    $gPositionIndex;
	global int    $gComponentBarElementSize;

	string $position = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgEmptyError"));
		return $position;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			$position = $gUIComponentBarArray[$index + $gPositionIndex];
			break;
		}
	}

	return $position;
}

proc setCurrentUIComponent(
	string $componentBar,
	string $component)
//
//	Description:
//		Set the current component for a UI component bar.
//
//	Arguments:
//		componentBar - The component bar name.
//
//		name - The component name.
//
{
	global string $gUIComponentBarArray[];

	global int    $gNameIndex;
	global int    $gCurrentIndex;
	global int    $gComponentBarElementSize;

	int    $index, $count, $componentBarIndex = -1;

	if ("" == $componentBar) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($componentBar == $gUIComponentBarArray[$index + $gNameIndex]) {
			$componentBarIndex = $index;
			break;
		}
	}

	if ($componentBarIndex >= 0) {
		$gUIComponentBarArray[$componentBarIndex + $gCurrentIndex] = $component;

	} else {
		//	Component bar not found. Return.
		//
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $componentBar $error`);
		return;
	}
}

proc string getCurrentUIComponent(string $name)
//
//	Description:
//		Return the name of the current component for a UI component bar.
//
//	Arguments:
//		$name - The component bar name.
//
//	Returns:
//		The name of the current UI component.
//
{
	global string $gUIComponentBarArray[];

	global int    $gNameIndex;
	global int    $gCurrentIndex;
	global int    $gComponentBarElementSize;

	string $current = "";
	int    $index, $count, $componentBarIndex = -1;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $current;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			$current = $gUIComponentBarArray[$index + $gCurrentIndex];
			break;
		}
	}

	return $current;
}

proc string getUIComponentContentLayout(string $componentLayout)
//
//	Description:
//		Return the parent layout for component content.
//
//	Arguments:
//		componentLayout - The layout containing the component.
//
{
	string $contentLayout, $childArray[];

	$childArray = `layout -query -childArray $componentLayout`;
	$contentLayout = $childArray[1];

	return ($componentLayout + "|" + $contentLayout);
}

global proc showCurrentComponent(string $componentBarName)
//
//	Description:
//		This procedure is called whenever a side component bar is opened.
//
//		Determine the component that should be shown (ie. that last one
//		that was shown before the component was hidden) and make it
//		visible again.
//
//	Arguments:
//		componentBarName - The name of the component bar.
//
{
	string $currentComponentName = getCurrentUIComponent($componentBarName);

	toggleUIComponentVisibility($currentComponentName);
}

global proc createUIComponentBar(
	string $name, 
	string $position)
//
//	Description:
//		Create a UI component bar.
//
//		A UI component bar consists of buttons that correspond to UI 
//		components created with the createUIComponent() procedure.
//
//		Whenever a UI component is hidden (or collapsed) a button appears
//		on the component bar that will show the component when pressed.
//
//	Arguments:
//		name     - The component bar name
//
//		position - The position of the bar. Valid values are "top",
//		           "left", "bottom", and "right".
//
{
	global string $gUIComponentBarArray[];
	global int    $gNameIndex;
	global int    $gComponentCountIndex;
	global int    $gLayoutIndex;
	global int    $gPositionIndex;
	global int    $gCurrentIndex;
	global int    $gComponentBarElementSize;

	string $componentBarLayout, $openButton, $image;
	int    $count, $index;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Check if a component bar with the argument name already exists.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			string $uniqueName = (uiRes("m_UIComponents.kArgumentUniqueError"));
			error -showLineNumber true (`format -s $name $uniqueName`);
			return;
		}
	}

	//	Validate the position argument.
	//
	if ("top" != $position && "bottom" != $position
		&& "left" != $position && "right" != $position) {
		string $invalidArgument = (uiRes("m_UIComponents.kInvalidArgument"));
		error -showLineNumber true (`format -s $position $invalidArgument`);
		return;
	}

	$gUIComponentBarArray[$count + $gNameIndex]           = $name;
	$gUIComponentBarArray[$count + $gComponentCountIndex] = 0;
	$gUIComponentBarArray[$count + $gLayoutIndex]         = "";
	$gUIComponentBarArray[$count + $gPositionIndex]       = $position;
	$gUIComponentBarArray[$count + $gCurrentIndex]        = "";
}

global proc removeUIComponentBar(string $name)
//
//	Description:
//		Remove all references to a UI component bar and its components.
//
//		Note that this procedure doesn't actually delete any controls or
//		layouts.
//
//	Arguments:
//		name - The component bar name.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gParentIndex;
	global int    $gCallbackIndex;
	global int    $gComponentCountIndex;
	global int    $gLayoutIndex;
	global int    $gPositionIndex;
	global int    $gCurrentIndex;

	global int    $gComponentBarElementSize;
	global int    $gComponentElementSize;

	string $newComponentBarArray[], $newComponentArray[];
	int    $index, $newIndex, $start, $end, $count, $componentCount = -1;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Remove the components.
	//
	$start = 0;
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			$componentCount = $gUIComponentBarArray[$index + $gComponentCountIndex];
			break;
		}
		$start += $gUIComponentBarArray[$index + $gComponentCountIndex];
	}

	if ($componentCount >= 0) {
		$end = $start + $componentCount;

		$newIndex = 0;
		$count = size($gUIComponentBarComponentArray);
		for ($index = 0; $index < $count; $index += $gComponentElementSize) {
			if ($index < ($start * $gComponentElementSize) 
				|| $index > ($end * $gComponentElementSize + 1)) {
				$newComponentArray[$newIndex + $gNameIndex] 
					= $gUIComponentBarComponentArray[$index + $gNameIndex];
				$newComponentArray[$newIndex + $gParentIndex] 
					= $gUIComponentBarComponentArray[$index + $gParentIndex];
				$newComponentArray[$newIndex + $gCallbackIndex] 
					= $gUIComponentBarComponentArray[$index + $gCallbackIndex];
				$newIndex += $gComponentElementSize;
			}
		}

		clear($gUIComponentBarComponentArray);
		$gUIComponentBarComponentArray = $newComponentArray;

	} else {
		string $warn = (uiRes("m_UIComponents.kComponentWarn"));
		warning -showLineNumber true (`format -s $name $warn`);
	}

	//	Remove the component bar.
	//
	$newIndex = 0;
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name != $gUIComponentBarArray[$index + $gNameIndex]) {
			$newComponentBarArray[$newIndex + $gNameIndex]
				= $gUIComponentBarArray[$index + $gNameIndex];
			$newComponentBarArray[$newIndex + $gComponentCountIndex]
				= $gUIComponentBarArray[$index + $gComponentCountIndex];
			$newComponentBarArray[$newIndex + $gLayoutIndex]
				= $gUIComponentBarArray[$index + $gLayoutIndex];
			$newComponentBarArray[$newIndex + $gPositionIndex]
				= $gUIComponentBarArray[$index + $gPositionIndex];
			$newComponentBarArray[$newIndex + $gCurrentIndex]
				= $gUIComponentBarArray[$index + $gCurrentIndex];
			$newIndex += $gComponentBarElementSize;
		}
	}

	clear($gUIComponentBarArray);
	$gUIComponentBarArray = $newComponentBarArray;
}

global proc string createUIComponent(
	string $barName, 
	string $name, 
	string $parent)
//
//	Description:
//		Create a UI component.
//
//		A UI component consists of a control layout containing a button
//		for hiding (or collapsing) the entire component.
//
//		Whenever a UI component is hidden (or collapsed) a button appears
//		on the component bar that will show the component when pressed.
//
//	Arguments:
//		barName - The component bar name.
//
//		name - The component name.
//
//		parent - The parent layout for the UI component. Assumed to
//		         be a form layout.
//
//	Returns:
//		The name of the form layout for you to use as the parent of your
//		specific component UI.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gParentIndex;
	global int    $gCallbackIndex;
	global int    $gComponentCountIndex;
	global int    $gPositionIndex;
	global int    $gCurrentIndex;
	global int    $gCloseButtonIndex;
	global int    $gComponentBarElementSize;

	string $result = "", $image, $layout, $layoutArray[];
	string $componentBar, $buttonArray[];
	string $hideButton, $showButton, $previousShowButton, $position;
	string $component, $componentArray[];

	int    $index, $count, $componentCount, $buttonCount;
	int    $componentBarIndex = -1;

	if ("" == $barName) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $result;
	}

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $result;
	}

	string $requiredType = "formLayout";
	if ($requiredType != `objectTypeUI $parent`) {
		string $type = (uiRes("m_UIComponents.kArgumentError"));
		error -showLineNumber true (`format -s $requiredType $type`);
		return $result;
	}

 	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($barName == $gUIComponentBarArray[$index + $gNameIndex]) {
			$componentBarIndex = $index;
			break;
		}
	}

	//	Component bar not found. Return empty string.
	//
	if ($componentBarIndex < 0 ) {
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $barName $error`);
		return $result;
	}

	//	Increment the number of components that the component bar
	//	now contains.
	//
	$componentCount = $gUIComponentBarArray[$componentBarIndex + $gComponentCountIndex];
	$componentCount ++;
	$gUIComponentBarArray[$componentBarIndex + $gComponentCountIndex] = $componentCount;

	$layout = `formLayout -parent $parent -manage false`;

	$position = $gUIComponentBarArray[$componentBarIndex + $gPositionIndex];

	string $hideAnnot = (uiRes("m_UIComponents.kHideAnnot"));
	string $displayName = localizedUIComponentLabel($name);
	
	if ("top" == $position || "bottom" == $position) {

		// ------------------------------------------------------------
		//
		//	 Vertical component bar.
		//
		// ------------------------------------------------------------

		//	Create the hide button.
		//
		string $hideAnnot1 = `format -s $displayName $hideAnnot`;
		$hideButton = `iconTextButton
			-image1 "verticalCloseBar.xpm" 
			-width  9
			-height 16
			-annotation ($hideAnnot1)
			-command ("toggleUIComponentVisibility \"" + $name + "\"")`;

		//	Create a layout for the specific UI to be added to the 
		//	component.
		//
		$result = `formLayout`;

		formLayout -edit
			-attachForm    $hideButton   "top"    0
			-attachForm    $hideButton   "left"   0
			-attachNone    $hideButton   "bottom"
			-attachNone    $hideButton   "right"

			-attachForm    $result       "top"    0
			-attachControl $result       "left"   0 $hideButton
			-attachForm    $result       "bottom" 0
			-attachForm    $result       "right"  0
			$layout;

	} else {

		// ------------------------------------------------------------
		//
		//	Horizontal component bar.
		//
		// ------------------------------------------------------------

		//	Create the hide button.
		//
		string $hideAnnot2 = `format -s $displayName $hideAnnot`;
		$hideButton = `iconTextButton
			-image1 "horizontalCloseBar.xpm" 
			-width  16
			-height 9
			-annotation ($hideAnnot2)
			-command ("toggleUIComponentVisibility \"" + $name + "\"")`;

		//	Create a layout for the specific UI to be added to the 
		//	component.
		//
		$result = `formLayout`;

		if ("left" == $position) {
			formLayout -edit
				-attachForm    $hideButton   "top"    0
				-attachForm    $hideButton   "left"   0
				-attachNone    $hideButton   "bottom"
				-attachNone    $hideButton   "right"
				$layout;

		} else {
				if(`about -mac`)
				{
					// force the iconTextButton for a left attachment with the formLayout
					formLayout -edit
					-attachForm    $hideButton   "top"    	0
					-attachForm    $hideButton   "left" 	2
					-attachNone    $hideButton   "bottom"
					-attachForm    $hideButton   "right"  	0
					$layout;
				}
				else
				{
					formLayout -edit
						-attachForm    $hideButton   "top"    0
						-attachNone    $hideButton   "left"
						-attachNone    $hideButton   "bottom"
						-attachForm    $hideButton   "right"  0
						$layout;
				}
		}

		formLayout -edit
			-attachControl $result       "top"    0 $hideButton
			-attachForm    $result       "left"   0
			-attachForm    $result       "bottom" 0
			-attachForm    $result       "right"  0
			$layout;

		if (1 == $componentCount) {
			//
			//	Make the first component the current one.
			//
			$gUIComponentBarArray[$componentBarIndex + $gCurrentIndex] = $name;

		} else {
			formLayout -edit -manage false $layout;
		}
	}

	formLayout -edit
		-attachForm    $layout       "top"    0
		-attachForm    $layout       "left"   0
		-attachForm    $layout       "bottom" 0
		-attachForm    $layout       "right"  0
		$parent;

	//	Add the new component to the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	$gUIComponentBarComponentArray[$count + $gNameIndex] = $name;
	$gUIComponentBarComponentArray[$count + $gParentIndex] = $layout;
	$gUIComponentBarComponentArray[$count + $gCloseButtonIndex] = $hideButton;
	$gUIComponentBarComponentArray[$count + $gCallbackIndex] = "";

	return $result;
}

global proc string getUIComponent(string $name)
//
//	Description:
//		Return the layout corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid component. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the component layout.
//
{
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gParentIndex;
	global int    $gComponentElementSize;

	string $component = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $component;
	}

	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $gNameIndex]) {
			$component = $gUIComponentBarComponentArray[$index + $gParentIndex];
			break;
		}
	}

	if ("" == $component) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $component;
}

global proc setUIComponentStateCallback(
	string $componentName,
	string $callback)
//
//	Description:
//		Specify the callback procedure for a component. This procedure will 
//		be called whenever the corresponding component is hidden or about
//		to be shown.
//
//		The callback procedure must have the following form:
//
//			global proc int procedureName(int $newState, string $layout) { ... }
//
//			Where the paramenters are:
//
//				newState - The new visible state of the component.
//
//				layout - The parent layout for the component content.
//
//			And the return value is:
//
//				true - If you want to allow the new state to take affect.
//
//				false - If you want to reject the new state.
//
//	Arguments:
//		componentName - The component bar name.
//
//		workArea - The layout corresponding to the work area.
//
{
	global string $gUIComponentToolBarArray[];
	global string $gUIComponentDockControlArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gCallbackIndex;
	global int    $gComponentElementSize;

	int    $index, $count, $componentIndex = -1;

	if ("" == $componentName) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($componentName, false);
	if(size($component)) {
		string $cmd = $callback + "(`workspaceControl -q -visible " + $component + "`, \"\")";
		workspaceControl -e -visibleChangeCommand $cmd $component;
		return;
	}
	
	// Try dock control now, don't report error
	$component = getUIComponentDockControl($componentName, false);
	if(size($component)) {
		string $cmd = $callback + "(`workspaceControl -q -visible " + $component + "`, \"\")";
		workspaceControl -e -visibleChangeCommand $cmd $component;
		return;
	}
	
	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		if ($componentName == $gUIComponentBarComponentArray[$index + $gNameIndex]) {
			$componentIndex = $index;
			break;
		}
	}
		
	if ($componentIndex >= 0) {
		$gUIComponentBarComponentArray[$componentIndex + $gCallbackIndex] = $callback;

	} else {
		//	Component not found. Return.
		//
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $componentName $error`);
		return;
	}
}

global proc setUIComponentWorkArea(
	string $name,
	string $workArea)
//
//	Description:
//		Specify the work area layout corresponding to a UI component bar layout.
//
//		To use UI components you must set up your window layout in a very 
//		specific way, ie. using form layouts. The work area refers to that
//		part of your window layout that is not allowed to be hidden.
//
//	Arguments:
//		name - The component bar name.
//
//		workArea - The layout corresponding to the work area.
//
{
	global string $gUIComponentBarArray[];

	global int    $gNameIndex;
	global int    $gLayoutIndex;
	global int    $gComponentBarElementSize;

	int    $index, $count, $componentBarIndex = -1;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return;
	}

	//	Search the component bar array.
	//
	$count = size($gUIComponentBarArray);
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		if ($name == $gUIComponentBarArray[$index + $gNameIndex]) {
			$componentBarIndex = $index;
			break;
		}
	}

	if ($componentBarIndex >= 0) {
		$gUIComponentBarArray[$componentBarIndex + $gLayoutIndex] = $workArea;

	} else {
		//	Component bar not found. Return.
		//
		string $error = uiRes("m_UIComponents.kComponentWarn");
		error -showLineNumber true (`format -s $name $error`);
		return;
	}
}

global proc setUIComponentVisibility(string $name, int $visible)
{
	if(`workspaceControl -q -vis $name`) {
		if($visible){
			workspaceControl -e -restore $name;
		}else{
			workspaceControl -e -vis false $name;
		}
	} else {
		if($visible){
			workspaceControl -e -restore $name;
		}
	}
	return;
}

global proc int toggleUIComponentVisibility(string $name)
//
//	Description:
//		Toggle the visibility of the specified UI component.
//
//	Arguments:
//		name - The UI component name.
//
//	Returns:
//		True if the UI component is visible as a result of calling
//		this procedure. False otherwise.
//
{
	global string $gUIComponentToolBarArray[];
	global string $gUIComponentDockControlArray[];
	global string $gUIComponentBarArray[];

	string $component, $c, $componentArray[], $componentBar, $position;
	string $workArea = "", $children[], $callback, $contentLayout;
	int    $visible = false, $count, $numberOfVisibleComponents = 0;
	int    $proceed = true;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $visible;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($name, false);
	if(size($component)) {
		if(isUIComponentVisible($name)) {
			//
			// Hide
			//
			workspaceControl -edit -visible false $component;
			$visible = false;
		} else {
			//
			// Show
			//
			workspaceControl -edit -visible true $component;
			$visible = true;
		}
		
		return $visible;
	}
	
	// If we are trying to toggle a Channel Box/Layer Editor-related dock
	// widget that should not be accessed due to the current preference,
	// switch the preference and then toggle the intended dock widget.
	//
	// Try dock control now, don't report error
	$component = getUIComponentDockControl($name, false);
	if(size($component)) {
		if(isUIComponentVisible($name)) {
			// If the component is visible, it can be collapsed or not be the current tab of its parent widget.
			// In those cases, we need to expand them or set them as current widget.
			if(`workspaceControl -q -collapse $component`) {
				//
				// Show
				//
				workspaceControl -e -restore $component;
				$visible = true;
			}
			else {
				if(isUIComponentRaised($name)){
					//
					// Hide
					//
					workspaceControl -edit -visible false $component;
					$visible = false;
				}else{
					//
					// Show
					//
					// The UI element is visible, but it is not raised.
					workspaceControl -edit -restore $component;
					$visible = true;
				}
			}
		} else {
			//
			// Show
			//
			//
			// The "Channel Box / Layer Editor" dock widget should never 
			// coexist with the "Channel Box" and/or "Layer Editor" dock
			// widgets at the same time. If that is about to happen then
			// we should hide the offending editors before showing the 
			// new one.
			//
			string $conflictingEditors[] = {"Channel Box / Layer Editor",
				                            "Channel Box",
				                            "Layer Editor"};
			$conflictingEditors = stringArrayRemove({$name},
				                                    $conflictingEditors);

			for ($ed in $conflictingEditors) {
				// hide $ed if it is visible
				if (isUIComponentVisible($ed)) {
					string $edUI = getUIComponentDockControl($ed, false);
					if (size($edUI)) {
						if (startsWith($name, $ed) || startsWith($ed, $name)
							|| endsWith($name, $ed) || endsWith($ed, $name))
						{
							workspaceControl -edit -visible false $edUI;
						}
					}
				}
			}

			workspaceControl -edit -restore $component;
			$visible = true;
		}

		return $visible;
	}

	// Is the input UI component a workspace control?
	if (`workspaceControl -exists $name`)
	{
		$visible = !isUIComponentRaised($name) || `workspaceControl -q -collapse $name`;
		setUIComponentVisibility($name, $visible);
		return $visible;
	}

	return $visible;
}

global proc int isUIComponentRaised(string $name)
{
	int $visible = false;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $visible;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($name, false);
	if(size($component) > 0) {
		$visible = `workspaceControl -q -raise $component`;
		return $visible;
	}
	
	// Try dock control now, don't report error
	$component = getUIComponentDockControl($name, false);
	if(size($component) > 0) {
		$visible = `workspaceControl -q -raise $component`;
		return $visible;
	}
	
	// Is the input UI component a workspace control?
	if (`workspaceControl -exists $name`)
	{
		$visible = `workspaceControl -q -raise $name`;
		return $visible;
	}
	
	return $visible;
}

global proc int isUIComponentVisible(string $name)
//
//	Description:
//		Return true if the specified UI component is visible.
//
//	Arguments:
//		name - The UI component name.
//
//	Returns:
//		True if the UI component is visible, false otherwise.
//
{
	int    $visible = false;

	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $visible;
	}

	// Try tool bar first, don't report error
	$component = getUIComponentToolBar($name, false);
	if(size($component) > 0) {
		$visible = `workspaceControl -q -visible $component`;
		return $visible;
	}
	
	// Try dock control now, don't report error
	$component = getUIComponentDockControl($name, false);
	if(size($component) > 0) {
		$visible = `workspaceControl -q -visible $component`;
		return $visible;
	}

	// Is the input UI component a workspace control?
	if (`workspaceControl -exists $name`)
	{
		$visible = `workspaceControl -q -visible $name`;
		return $visible;
	}

	return $visible;
}

global proc string getUIComponentCloseButton(string $name)
//
//	Description:
//		Return the close button corresponding to the given component name.
//
//		May return an empty string if the argument name does not refer
//		to a valid component. In this case this procedure will
//		generate an error.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		The name of the close button.
//
{
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gCloseButtonIndex;
	global int    $gComponentElementSize;

	string $closeButton = "";
	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return $closeButton;
	}

	//	Search the component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $gNameIndex]) {
			$closeButton = $gUIComponentBarComponentArray[$index + $gCloseButtonIndex];
			break;
		}
	}

	if ("" == $closeButton) {
		string $error = uiRes("m_UIComponents.kComponentError");
		error -showLineNumber true (`format -s $name $error`);
	}

	return $closeButton;
}

global proc int UIComponentExists(string $name)
//
//	Description:
//		Return true if the specified component exists.
//
//	Arguments:
//		name - The component name.
//
//	Returns:
//		True if the component exists, false otherwise.
//
{
	global string $gUIComponentToolBarArray[];
	global string $gUIComponentDockControlArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gToolBarElementSize;
	global int    $gDockControlElementSize;
	global int    $gComponentElementSize;

	int    $index, $count;
	
	if ("" == $name) {
		error -showLineNumber true (uiRes("m_UIComponents.kArgError"));
		return false;
	}

	// Search the toolbar array.
	//
	$count = size($gUIComponentToolBarArray);
	for ($index = 0; $index < $count; $index += $gToolBarElementSize) {
		if ($name == $gUIComponentToolBarArray[$index + $gNameIndex]) {
			return `workspaceControl -query -exists $name`;
		}
	}
	
	// Search the dock control array.
	//
	$count = size($gUIComponentDockControlArray);
	for ($index = 0; $index < $count; $index += $gDockControlElementSize) {
		if ($name == $gUIComponentDockControlArray[$index + $gNameIndex]) {
			return `workspaceControl -query -exists $name`;
		}
	}
	
	//	Search the old-style component array.
	//
	$count = size($gUIComponentBarComponentArray);
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		if ($name == $gUIComponentBarComponentArray[$index + $gNameIndex]) {
			return true;
		}
	}

	// Is the input UI component a workspace control?
	if (`workspaceControl -exists $name`)
	{
		return true;
	}

	// If we got here, component was not found
	return false;
}

//	Note that the following script block is not a procedure and will be
//	executed when this script file is sourced.
//
{
	//	Define the array indecies.
	//
	global int    $gNameIndex                = 0;
	global int    $gControlIndex             = 1;
	global int    $gComponentCountIndex      = 2;
	global int    $gCallbackIndex			 = 2;
	global int    $gLayoutIndex              = 3;
	global int    $gCloseButtonIndex         = 3;
	global int    $gParentIndex              = 1;
	global int    $gPositionIndex            = 4;
	global int    $gCurrentIndex             = 5;

	//	Define the array element sizes.
	//
	global int    $gToolBarElementSize       = 2; // tool bars
	global int    $gDockControlElementSize   = 2; // dock controls 
	global int    $gComponentBarElementSize  = 6; // old-style component bars
	global int    $gComponentElementSize     = 4; // old-style components
}

global proc printUIComponentBarInfo()
//
//	Description:
//		Helpful debugging procedure. Print out the contents of the component
//		arrays.
//
{
	global string $gUIComponentBarArray[];
	global string $gUIComponentBarComponentArray[];

	global int    $gNameIndex;
	global int    $gParentIndex;
	global int    $gCallbackIndex;
	global int    $gComponentCountIndex;
	global int    $gLayoutIndex;
	global int    $gPositionIndex;
	global int    $gCurrentIndex;
	global int    $gCloseButtonIndex;

	global int    $gComponentBarElementSize;
	global int    $gComponentElementSize;

	int $index, $count;

	$count = size($gUIComponentBarArray);
	print  ("DEBUG: Number of component bars = " + $count / $gComponentBarElementSize + "\n");
	for ($index = 0; $index < $count; $index += $gComponentBarElementSize) {
		print  ("DEBUG: Name:       " + $gUIComponentBarArray[$index + $gNameIndex] + "\n");
		print  ("DEBUG: Components: " + $gUIComponentBarArray[$index + $gComponentCountIndex] + "\n");
		print  ("DEBUG: Work Area:  " + $gUIComponentBarArray[$index + $gLayoutIndex] + "\n");
		print  ("DEBUG: Position:   " + $gUIComponentBarArray[$index + $gPositionIndex] + "\n");
		print  ("DEBUG: Current:    " + $gUIComponentBarArray[$index + $gCurrentIndex] + "\n\n");
	}

	$count = size($gUIComponentBarComponentArray);
	print  ("DEBUG: Number of components = " + $count / $gComponentElementSize + "\n");
	for ($index = 0; $index < $count; $index += $gComponentElementSize) {
		print  ("DEBUG: " + $gUIComponentBarComponentArray[$index + $gNameIndex] + "\t\t"
			+ $gUIComponentBarComponentArray[$index + $gCallbackIndex] + "\t\t("
			+ $gUIComponentBarComponentArray[$index + $gParentIndex] + "\t\t("
			+ $gUIComponentBarComponentArray[$index + $gCloseButtonIndex] + ")\n");

	}
}


proc updateToolIconState(string $iconName, string $workspaceControlName)
{	
	string $component = getUIComponentDockControl($workspaceControlName, false);
	if(!`size($component)`) {
		$component = getUIComponentToolBar($workspaceControlName, false);
		if(!`size($component)`)
			return;
	}
	iconTextCheckBox -e 
		-value (isUIComponentRaised($workspaceControlName) && 
				!`workspaceControl -q -collapse $component`)
		$iconName;
}


global proc updateEditorToggleCheckboxes()
{
	global string $gAttributeEditorButton;
	global string $gToolSettingsButton;
	global string $gChannelsOrChannelsLayersButton;
	global string $gLayerEditorButton;
	global int    $gAEDeferredUpdate;
	global string $gOutlinerToggleButton;
	if(`iconTextCheckBox -exists $gOutlinerToggleButton`){
		updateToolIconState($gOutlinerToggleButton, "Outliner");
	}	

	if(`iconTextCheckBox -exists $gAttributeEditorButton`) {
		int $atEdVisible = `isUIComponentRaised("Attribute Editor")`;
		updateToolIconState($gAttributeEditorButton, "Attribute Editor");
		if( $atEdVisible && $gAEDeferredUpdate ){
			// Update the Attribute Editor with the deferred node
			// See bug #346864 and note in autoUpdateAttrEd (in showEditor.mel)
			// See bug #384393 AE doesn't refresh object name properly
			//
			string $selectedNode ="";
			string $nodes[] = `ls -sl -l -o -ufe`;
			int $count = size($nodes);
			if($count > 0){
				$selectedNode = $nodes[$count -1];
			}
			updateAE( $selectedNode );
			$gAEDeferredUpdate = false;
		}
		updateToolIconState($gToolSettingsButton, "Tool Settings");

		if(`optionVar -q channelsLayersSeparate`) {
			updateToolIconState($gChannelsOrChannelsLayersButton, "Channel Box");
			updateToolIconState($gLayerEditorButton, "Layer Editor");
		} else {
			updateToolIconState($gChannelsOrChannelsLayersButton, "Channel Box / Layer Editor");
		}
	}
}
