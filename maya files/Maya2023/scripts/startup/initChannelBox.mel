// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  19 June 1997
//
//  Description:
//      This script initializes the Channel box.  Initialization involves
//		determining the initial Channel box preferences, creating the UI
//		and setting the initial visibility.
//

global proc showChannelBox(int $show)
//
//	Description:
//
//		*** Obsolete ***
//
//		*** Use runTimeCommand ToggleChannels instead ***
//	
//	Arguments:
//		show - True if the Channel Box should be shown, false if the Channel
//		       Box should become hidden.
//
{
	warning -showLineNumber true
		(uiRes("m_initChannelBox.kShowChannelBox")) ;
}

global proc int channelBoxVisibilityStateChange(
	int    $newState,
	string $layout)
//
//	Description:
//		This procedure is called whenever the visibility state of the 
//		Channel Box is changed.
//
//	Arguments:
//		newState - The new visibile state of the Channel Box.
//
//		layout - The parent layout for the Channel Box.
//
//	Returns:
//		true - If the change of state is to be allowed.
//
//		false - If the state change is rejected.
//
{
	int $result = true;

	//	Defer these commands because this proc is called when the visibility
	//	state is about to change. This proc must return true to accept 
	//	the state change. After this proc returns restore the panel focus.
	//
	evalDeferred("restoreLastPanelWithFocus();");
	return $result;
}

global int $gChannelFcurveEdSyncCallback = -1;

//
// If something is selected in the channel box, sync the fcurve editor display
// to those channels.
//
global proc syncChannelBoxFcurveEd()
{
	global string	$gChannelBoxName;

	string $selAttrs[] = `selectedChannelBoxPlugs`;
	selectionConnection -e -clear graphEditor1FromOutliner;
	if (size($selAttrs) > 0) {
		for ($attr in $selAttrs) {
			selectionConnection -e -select $attr graphEditor1FromOutliner;
		}
	} else if (size($selAttrs) == 0) {
		// So we are aligned with the timeline behaviour, we select all active objects 
		// when we no longer have any channels selected 
		string $objects[] = `channelBoxObjects`;
		for ($obj in $objects) {
			selectionConnection -e -select $obj graphEditor1FromOutliner;
		}
	}
}

//  Procedure Name:
//	checkSpeedButton
//
//  Description Name;
//	Sets the button which visualizes the current speed which is
//	used for channel box sliders
//
//  Input Value:
//	which speed is currently set 
//
//  Output Value:
//	None
// 
global proc checkSpeedButton ( string $speed, int $useManips )
{
	switch ($speed){
		case "slowest":
			channelBox -e -speed 0.01 mainChannelBox;
			symbolButton -e 
				-i "channelBoxSlowest.png"
			 	-c ("channelBoxSettings slow " + $useManips )
				cbSpeedButton;
			break;
		case "slow":
			channelBox -e -speed 0.1 mainChannelBox;
			symbolButton -e 
				-i "channelBoxSlow.png"
			 	-c ("channelBoxSettings medium " + $useManips )
				cbSpeedButton;
			break;
		case "medium":
			channelBox -e -speed 1 mainChannelBox;
			symbolButton -e 
				-i "channelBoxMedium.png"
			 	-c ("channelBoxSettings fast " + $useManips )
				cbSpeedButton;
			break;
		case "fast":
			channelBox -e -speed 10 mainChannelBox;
			symbolButton -e 
				-i "channelBoxFast.png"
			 	-c ("channelBoxSettings slowest " + $useManips )
				cbSpeedButton;
			break;
		default:
		    symbolButton -e 
				-i "channelBoxUnknownSpeed.png"
			 	-c ("channelBoxSettings medium " + $useManips )
				cbSpeedButton;
			break;
			
	}
}


//  Procedure Name:
//	checkManipButton
//
//  Description Name;
//	Sets the button which visualize which manipType is
//	used in the channel box.
//
//  Input Value:
//	which manipType is currently used 
//
//  Output Value:
//	None
// 



global proc checkManipButton ( int $state )
{
	switch ($state){
		case 0:
			symbolButton -e -i "channelBoxNoManips.png"
			 	-c "channelBoxSettings useManips 1"
				cbManipsButton;
			break;
		case 1:
			symbolButton -e -i "channelBoxInvisibleManips.png"
			 	-c "channelBoxSettings useManips 2"
				cbManipsButton;
			break;
		case 2:
			symbolButton -e -i "channelBoxUseManips.png"
			 	-c "channelBoxSettings useManips 0"
				cbManipsButton;
			break;
	}
}

//
//  Procedure Name:
//      setChannelLongName
//
//  Description:
//		Sets the Channel box long/short name flag and also changes the
//		width of the Channel box and sets the optionVar for this setting.
//
//  Input Arguments:
//      state - 0 = short, 1 = nice, 2 = long
//
//  Return Value:
//      None.
//
global proc setChannelLongName( int $state )
{
	global string	$gChannelBoxName;
	global int    	$gChannelsWidth;

	int $width;

	//	Query the current "name" state of the Channel box.
	//
	int $longNames = `channelBox -query -longNames $gChannelBoxName`;
	int $niceNames = `channelBox -query -niceNames $gChannelBoxName`;

	//	Check for a change.
	//
	if ($niceNames && $state == 1) return;
	if (!$niceNames && $longNames && $state == 2) return;
	if (!$niceNames && !$longNames && $state == 0) return;

	if( $state == 2 ) {
		$width = 180;
		channelBox -e -ln true -nn false $gChannelBoxName;
		optionVar -iv channelsLongName 2;

	} else if( $state == 1 ) {
		$width = 180;
		channelBox -e -ln true -nn true $gChannelBoxName;
		optionVar -iv channelsLongName 1;

	} else {
		$width = 140;
		channelBox -e -ln false -nn false $gChannelBoxName;
		optionVar -iv channelsLongName 0;
	}

	setChannelsWidth($width);
}

global proc initChannelBoxButtons()
//
//	Handle initializing the icons at the top of the channel box
//
{
	//	Get the current channel box settings to set
	//	the buttons at the top of the channelbox to
	//	the appropriate values
	//
	string $manipType = `channelBox -q -useManips mainChannelBox`;
	int $useManips;
	switch ($manipType){
	  case "none":
		$useManips = 0;
		break;
	  case "invisible":
		$useManips = 1;
		break;
	  default:
		$useManips = 2;
		break;
	}
	float $speed = `channelBox -q -speed mainChannelBox`;
	string $speedMode;
	if ($speed == 0.01) {
		$speedMode = "slowest";
	} else if ($speed == 0.1) {
		$speedMode = "slow";
	} else if ($speed == 1.0) {
		$speedMode = "medium";
	} else if ($speed == 10.0) {
		$speedMode = "fast";
	} else {
		$speedMode = "unknown";
	}
		
	int $hyperbolic = `channelBox -q -hyperbolic mainChannelBox`;

	//	Update the buttons
	//
	symbolButton -edit
		-enable true
		cbManipsButton;
	checkManipButton ($useManips);

	symbolButton -edit
		-enable ( $useManips > 0 )
		cbSpeedButton;
	checkSpeedButton $speedMode $useManips;

	symbolCheckBox -edit
		-v $hyperbolic
		-enable ( $useManips > 0 )
		cbHyperbolicButton;
}

global proc channelBoxSettings( string $cmd, int $state )
//
//	Handle updating the icons at the top of the channel
//	box when menu entries are selected in the popup menu
{
	switch( $cmd ) {
		case "slowest":
			checkSpeedButton "slowest" $state;
			break;
		case "slow":
			checkSpeedButton "slow" $state;
			break;
		case "medium":
			checkSpeedButton "medium" $state;
			break;
		case "fast":
			checkSpeedButton "fast" $state;
			break;
		case "hyperbolic":
			channelBox -e -hyperbolic $state mainChannelBox;
			symbolCheckBox -e -v $state cbHyperbolicButton;
			break;
		case "showNamespace":
			channelBox -e -showNamespace $state mainChannelBox;
			break;
		case "useManips":
			checkManipButton ($state);

			if ( $state == 0 ) {
				//
				//	Manips are off - disable the speed settings
				//
				symbolButton -e -enable false cbSpeedButton;
				symbolCheckBox -e -enable false cbHyperbolicButton;
				channelBox -e -useManips "none" mainChannelBox;

			} else if( $state == 1 ) {
				//
				//	Manips are invisible only - enable the speed settings
				//
				symbolButton -e -enable true cbSpeedButton;
				symbolCheckBox -e -enable true cbHyperbolicButton;
				channelBox -e -useManips "invisible" mainChannelBox;

			} else {
				//
				//	Manips are standard - disable the speed settings
				//
				symbolButton -e -enable true cbSpeedButton;
				symbolCheckBox -e -enable true cbHyperbolicButton;
				channelBox -e -useManips "standard" mainChannelBox;
			}
			break;
	}
}

// Simple helper proc used by buildChannelObjectMenu to add a menu item.
proc addChannelBoxObjectToMenu(string $obj)
{
	// The input obj can be either a Maya node or a UFE path string.
	// When it is a UFE path string, we get the node name from it to use as menu label.
	string $lbl = $obj;
	int $nonMaya = python("import maya.internal.ufeSupport.utils as ufeUtils; ufeUtils.isPathStringValidNonMayaObject('" + $obj + "')");
	if ($nonMaya) {
		$lbl = `python("import maya.internal.ufeSupport.utils as ufeUtils; ufeUtils.getNodeNameFromPathString('" + $obj + "')")`;
	}

	menuItem -label $lbl -command ("select -add \"" + $obj + "\"");
	menuItem -optionBox true -command ("select -add \"" + $obj + "\"; editSelected");
}

global proc buildChannelObjectMenu( string $parent ) {
//
//	Builds a menu with the last 10 items on the selection
//	list, and allows the user to switch which objects
//	values are being shown.  In effect, it switches
//	the lead object, by "adding" it to the selection
//	list, which places it last in the selection list
//
	setParent -m $parent;
	menu -e -dai $parent;

	// The channel box now handles UFE items.
	string $sel[] = `ls -sl -ufe -tail 10`;
	int $size = `size( $sel )`;
	if ($size > 0) {
		addChannelBoxObjectToMenu($sel[$size-1]);
		if ($size > 1) {
			menuItem -divider true;
		}

		for($i = $size-2; $i >= 0; $i--) {
			addChannelBoxObjectToMenu($sel[$i]);
		}
	} else {
		menuItem -label (uiRes("m_initChannelBox.kNothingSelected"));
	}
}

global proc CBselectionChanged()
//
//	Handle updating the UI layout based on object selection
//
{
	if( `isTrue SomethingSelected` ) {
		CBsetDisplayActive();
	} else {
		int $haveNonMaya = `python("import maya.internal.ufeSupport.utils as ufeUtils; ufeUtils.hasNonMayaSelectedItems()")`;
		if ($haveNonMaya) {
			CBsetDisplayActive();
		} else {
			CBsetDisplayEmpty();
		}
	}
}

global proc CBsetDisplayEmpty() {
//
//	Nothing is selected so switch to the empty layout.
//
	global string $gCBStackLayout;
	global string $gCBEmptyLayout;

	tabLayout -e -m false $gCBStackLayout;
	formLayout -e -m true $gCBEmptyLayout;
}

global proc CBsetDisplayActive() {
//
//	Switch to the regular layout to show channel information 
//	for the selected object(s).
//
	global string $gCBStackLayout;
	global string $gCBEmptyLayout;

	tabLayout -e -m true $gCBStackLayout;
	formLayout -e -m false $gCBEmptyLayout;
}

// Now, the main script to be executed.  Not that this is NOT a proc.
//
{
	//   Declare referenced or returned globals.
	//
	global string $gChannelBoxName;
	global string $gChannelBoxForm;
	global string $gCBEmptyLayout;
	global string $gCBStackLayout;

	//  Determine values of option variables
	//
	int $channelsLongName = `optionVar -query channelsLongName`;
	int $precision = `optionVar -q channelsPrecision`;
	int $numWidth = `optionVar -q channelsFieldWidth`;

	//	Create a menu bar layout for the Channel box.
	//
	string $menuBarLayout = `menuBarLayout`;

	string $columnName;
	int $nSections;

	// Add a menu to the menuBarLayout at the top of the
	// channel box.  NOTE: can't make this menu a tearoff,
	// as it dynamically updates based on channels selected
	// in the channel box.
	//
	string $menu = `menu -label (uiRes("m_initChannelBox.kChannels"))
				-familyImage "menuIconChannels.png"`;
		menu -edit -pmc ("generateChannelMenu " + $menu + " 0" ) $menu;
    setParent -m ..;

	$menu = `menu -label (uiRes("m_initChannelBox.kEdit")) -allowOptionBoxes 1`;
		menu -edit -pmc ("generateCBEditMenu " + $menu + " 0" ) $menu;
    setParent -m ..;

    $menu = `menu -label (uiRes("m_initChannelBox.kObject")) 
		-aob true
		-familyImage "menuIconObject.png"`;
        menu -e -pmc ( "buildChannelObjectMenu " + $menu ) $menu;
    setParent -m ..;

    $menu = `menu -label (uiRes("m_initChannelBox.kShow")) 
		-aob true cbShowMenu`;
        menu -e -pmc ( "generateChannelShowMenu " + $menu ) $menu;
    setParent -m ..;

	//  Build the Channel box, with a frame layout around it.
	//
	string $boxName = `frameLayout 
		-labelVisible  false
		-collapsable   false
		-collapse      false
		-marginHeight  1
		-marginWidth   1`;

	//	Create the layout for when no objects are selected.
	//
	$gCBEmptyLayout = "CBEmptyLayout";
	formLayout -nd 100 $gCBEmptyLayout;
		text -font boldLabelFont -ww on
			-label (uiRes("m_initChannelBox.kMakeSelection"))
			CBnothingSelectedText;
		formLayout -e
			-af CBnothingSelectedText left 30
			-af CBnothingSelectedText right 30
			-ap CBnothingSelectedText top 0 30
			-ap CBnothingSelectedText bottom 0 70
			$gCBEmptyLayout;
	setParent ..;

	// Make a tab layout, with invisible tabs, that will flip
	// between "Nothing selected" and the tab layout that holds
	// channel information for the selected node(s).
	$gCBStackLayout = "CBStackLayout";
	tabLayout -tabsVisible false -borderStyle "none" $gCBStackLayout;

	//	Register a callback to handle switching the layout based on selection.
	//
	global int $gCBSelectionChangedCallback;
	if ($gCBSelectionChangedCallback <= 0) {
		$gCBSelectionChangedCallback = `scriptJob -event "UFESelectionChanged" CBselectionChanged`;
	}

	//	Create the Channel box.
	//
	$gChannelBoxName = "mainChannelBox";
	channelBox -st true
		-longNames ($channelsLongName==2)
		-niceNames ($channelsLongName==1)
		-precision $precision
		-fieldWidth $numWidth
		$gChannelBoxName;

	if (`optionVar -exists cbContainerAtTop`) {
		int $atTop = `optionVar -q cbContainerAtTop`;
		channelBox -edit -containerAtTop $atTop $gChannelBoxName;
	}


	
	// Add the Channels menu as an RMB popup for the whole channel box.
	//
	eval ("source generateChannelMenu");
	$menu = `popupMenu -parent $gChannelBoxName`;
	menu -edit -postMenuCommand ( "generateChannelMenu " + $menu + " 1" ) $menu;
	// Add the Edit menu as a Ctrl+RMB popup for the whole channel box.
	//
	$menu = `popupMenu -ctrlModifier 1 -allowOptionBoxes 1
		-parent $gChannelBoxName`;
	menu -edit -postMenuCommand ( "generateCBEditMenu " + $menu + " 1" ) $menu;

	setParent ..;

	//	Layout the separator, Channel box and the buttons.
	//
	formLayout -edit
		-attachForm    $menuBarLayout "top"    0
		-attachForm    $menuBarLayout "left"   0
		-attachForm	   $menuBarLayout "bottom" 0 
		-attachForm    $menuBarLayout "right"  0
		$gChannelBoxForm;
	
	initChannelBoxButtons();

	// If the fcurve editor is to be sync'd with the channel box, set up a
	// scriptJob to do the updates.
	//
	global int $gChannelFcurveEdSyncCallback;
	if (`optionVar -q setKeyframeWhich` == 1) {
		if ($gChannelFcurveEdSyncCallback < 0) {
			// The same code exists in toggleChannelBoxGraphEdSync()
			$gChannelFcurveEdSyncCallback = `scriptJob -event "ChannelBoxLabelSelected" syncChannelBoxFcurveEd`;
		}
	}
}

