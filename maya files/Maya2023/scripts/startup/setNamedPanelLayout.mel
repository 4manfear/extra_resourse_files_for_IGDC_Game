// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================

global proc setNamedPanelLayout( string $whichNamedLayout ) {
	global string $gMainPane;

	string $configName = `getPanel -cwl $whichNamedLayout`;
	int	   $fixed[];
	string $labels[];
	string $types[];
	string $create[];
	string $edit[];
	string $panelType;
	string $panelName;
	string $visPanels[4];
	string $panelsToReplace[4];
	int    $exists = false;
	int	   $i,$numberOfPanels;

	if ( ($whichNamedLayout == localizedPanelLabel( "Stereo Persp" ) )||
	     ($whichNamedLayout == localizedPanelLabel( "Stereo Persp/Outliner" ) )
	   )		
	{
	   //ensure plugin stereoCamera be loaded
           python("from maya.app.stereo import stereoCameraUtil");
           python("stereoCameraUtil.loadPlugin()");
	}


	if ($configName == "") {
		string $msg = (uiRes("m_setNamedPanelLayout.kArrangeNotFound"));
		warning `format -s $whichNamedLayout $msg`;
	} else {
		if (`panelHistory -exists "mainPanelHistory"`) {
			panelHistory -e -suspend true "mainPanelHistory";
		}

		if (`paneLayout -exists $gMainPane`) {
			//  
			//  get state arrays.
			//
			$fixed = `panelConfiguration -q -isFixedState $configName`;
			$labels = `panelConfiguration -q -labelStrings $configName`;
			$types = `panelConfiguration -q -typeStrings $configName`;
			$create = `panelConfiguration -q -createStrings $configName`;
			$edit = `panelConfiguration -q -editStrings $configName`;

			//  build an array of visible panels and make sure that 
			//  they are parented to the main pane.
			//
			$numberOfPanels = `panelConfiguration -query -numberOfPanels $configName`;
			for ($i = 0; $i < $numberOfPanels; $i++) {
				$panelName = `getPanel -withLabel $labels[$i]`;
				if ($panelName != "") {
					$panelType = `getPanel -typeOf $panelName`;
					if ("" == `panel -q -control $panelName`) {
						eval ($panelType + " -e -p $gMainPane " + $panelName);
					}

					// Keep track of panels that are already torn off out of the main pane or docked as a
					// workspace control, as they can't be used in the panel config and need to be replaced
					global string $gViewportWorkspaceControl;
					if ((`panel -q -to $panelName` && !startsWith(`panel -q -control $panelName`, $gViewportWorkspaceControl)) || `workspaceControl -q -exists ($panelName+"Window")`) {
						$panelsToReplace[$i] = $panelName;
					} else {
						$visPanels[$i] = $panelName;
					}

					// Only reset state on panels that won't be replaced, or panels that will be replaced but
					// are not model panels, as they will be replaced with a model panel, not a panel of its type
					if ($fixed[$i] && (($visPanels[$i] != "") || ($panelType != "modelPanel"))) {
						//
						// Reset state.
						//
						string $editStr = ("{ int $menusOkayInPanels = `optionVar -q allowMenusInPanels`; string $editorName; string $panelName = \"" +
                                           $panelName + "\"; " + $edit[$i] + "; }");
						eval ($editStr);
					}
				} else {
					//  Make a new panel
					//
					string $makeStr = ("{ int $menusOkayInPanels = `optionVar -q allowMenusInPanels`; string $editorName; string $panelName;"+$create[$i] + "; }");
					eval ($makeStr);
					$panelName = `getPanel -wl $labels[$i]`;

					if ("" == $panelName) {
						string $msg = (uiRes("m_setNamedPanelLayout.kProblem"));
						warning `format -s $whichNamedLayout $msg`;
					} else {
						//  Parent it to main pane.
						//
						$panelType = `getPanel -typeOf $panelName`;
						eval ($panelType + " -e -p $gMainPane " + $panelName);
						$visPanels[$i] = $panelName;

						//  update the config.
						//
						panelConfiguration -e 
							-replacePanel ($i+1)
							$fixed[$i]
							`panel -q -label $panelName` 
							$types[$i] $create[$i] $edit[$i] $configName;
					}
				}
			}

			//
			// Replace panels as necessary with a model panel
			//

			// Make the initial list of existing model panels we can use to replace panels with
			string $fullModelPanelArray[] = `getPanel -type "modelPanel"`;
			string $availModelPanelArray[];
			int $availModelPanelCount = 0;
			string $modelPanel;
			for($modelPanel in $fullModelPanelArray) {
				// We don't want any model panel that is already going to be in the new panel config, or is already torn off or docked as a workspace control
				if(!(stringArrayContains($modelPanel, $visPanels) || `panel -q -to $modelPanel` || `workspaceControl -q -exists ($modelPanel+"Window")`)) {
					$availModelPanelArray[$availModelPanelCount] = $modelPanel;
					$availModelPanelCount++;
				}
			}

			// Find an appropriate model panel replacement for each panel we need to replace
			for ($i = 0; $i < $numberOfPanels; $i++) {
				string $panelToReplace = $panelsToReplace[$i];
				if($panelToReplace != "") {
					string $replacedPanelType = `getPanel -typeOf $panelToReplace`;
					string $replacedPanelLabel = `panel -q -label $panelToReplace`; 
					string $modelPanelReplacement = "";

					// Try to find a suitable model panel among those available
					for($modelPanel in $availModelPanelArray) {
						if($replacedPanelType == "modelPanel") {
							// If we're replacing a model panel, we only want to use an existing model panel if it is the same view
							if(`panel -q -label $modelPanel` == $replacedPanelLabel) {
								$modelPanelReplacement = $modelPanel;
								break;
							}
						} else {
							// If we're not replacing a model panel, any model panel that is not currently or going to be used is good enough
							$modelPanelReplacement = $modelPanel;
							break;
						}
					}

					if($modelPanelReplacement != "") {
						// If we found a suitable model panel to use, remove it from the available model panel list
						string $modelPanelArray[] = { $modelPanelReplacement };
						$availModelPanelArray = stringArrayRemove($modelPanelArray, $availModelPanelArray);
					} else {
						// If we can't find a suitable model panel, create a copy to use
						if($replacedPanelType == "modelPanel") {
							// If we're replacing a model panel, make a copy of that panel
							$modelPanelReplacement = `modelPanel -unParent -copy $panelToReplace -label $replacedPanelLabel`;
						} else {
							// If we're not replacing a model panel, make a copy of the first model panel that is not going to be in the new panel config
							for($modelPanel in $fullModelPanelArray) {
								if(!stringArrayContains($modelPanel, $visPanels)) {
									string $copiedModelPanelLabel = `panel -q -label $modelPanel`;
									$modelPanelReplacement = `modelPanel -unParent -copy $modelPanel -label $copiedModelPanelLabel`;
									break;
								}
							}
						}
					}

					if($modelPanelReplacement != "") {
						// If we have a model panel replacement, parent it to the main pane.
						eval ("modelPanel -e -p $gMainPane " + $modelPanelReplacement);
					}

					// If we're not replacing a model panel, throw a warning that the panel can't be used
					// (not necessary if we are replacing a model panel, since it will still have the same view)
					if($modelPanelReplacement == "" || $replacedPanelType != "modelPanel") {
						string $msg = (uiRes("m_setNamedPanelLayout.kCantUsePanel"));
						warning `format -s $replacedPanelLabel $msg`;
					} else if($fixed[$i]) {
						// If we're replacing a model panel with fixed state, set the replacement model panel to its saved state
						// (not necessary if we're not replacing a model panel, since we now have a model panel in its place)
						string $editStr = ("{ int $menusOkayInPanels = `optionVar -q allowMenusInPanels`; string $editorName; string $panelName = \"" +
                                           $modelPanelReplacement + "\"; "+ $edit[$i] + "; }");
						eval ($editStr);
					}

					$visPanels[$i] = $modelPanelReplacement;
				}
			}

			int $configurationChange = true;
			int $previousNumberOfPanels = `paneLayout -query -numberOfVisiblePanes $gMainPane`;
			string $currPane;

			if ($numberOfPanels == $previousNumberOfPanels) {
				$configurationChange = false;
				for ($i = 0; $i < $numberOfPanels; $i++) {
					if (0 == $i)      $currPane = `paneLayout -query -pane1 $gMainPane`;
					else if (1 == $i) $currPane = `paneLayout -query -pane2 $gMainPane`;
					else if (2 == $i) $currPane = `paneLayout -query -pane3 $gMainPane`;
					else if (3 == $i) $currPane = `paneLayout -query -pane4 $gMainPane`;
					
					if ($visPanels[$i] != $currPane) {
						$configurationChange = true;
						break;
					}
				}
			}

			//  reconfigure the main pane.
			//
			if ($configurationChange) {
				paneLayout -e -manage false $gMainPane;
				for ($i = 0; $i < $numberOfPanels; $i++) {
					if ("" != $visPanels[$i]) {
						paneLayout -e -setPane $visPanels[$i] ($i+1) $gMainPane;
					}
				}
				eval `panelConfiguration -q -cfs $configName`;
				paneLayout -e -manage true $gMainPane;
				setFocus `paneLayout -q -p1 $gMainPane`;
			} else {
				// No change in panels
				//
				paneLayout -e -manage false $gMainPane;
				eval `panelConfiguration -q -cfs $configName`;
				paneLayout -e -manage true $gMainPane;
			}
		}

		if (`panelHistory -exists "mainPanelHistory"`) {
			panelHistory -e -suspend false "mainPanelHistory";
		}
		
		// MAYA-48298: Always take out property editor panel from Hypershade 
		// for the "Hypershade/Persp" layout.
		global string $gLookdevPropertyPanel;
		if ($whichNamedLayout == localizedPanelLabel("Hypershade/Persp")) {
			hideHypershadeWindow($gLookdevPropertyPanel);	
		}
	}
	
	updateToolbox();
}
