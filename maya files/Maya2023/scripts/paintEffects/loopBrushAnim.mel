// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date: 99 
//
//
//  Description:
//		This command makes selected brushstrokes seamlessly
// 		loop brush turbulence and flowing gap animation
//


global proc loopBrushAnim( int $loopFrames, int $turbMult, int $flowMult )
{
	string $brushes[];
	string $timeUnit;
	int	   $i, $fps, $textured, $turbType;
	float $gapSpace, $gapSize, $repeatU, $flowSpeed, $turbSpeed;

	$timeUnit = `currentUnit -q -time`;	
	if( $timeUnit == "game" )
	{
		$fps = 15;
	}
	else if( $timeUnit == "film" )
	{
		$fps = 24;
	}
	else if( $timeUnit == "pal" )
	{
		$fps = 25;
	}
	else if( $timeUnit == "ntsc" )
	{
		$fps = 30;
	}
	else if( $timeUnit == "show" )
	{
		$fps = 48;
	}
	else if( $timeUnit == "palf" )
	{
		$fps = 50;
	}
	else if( $timeUnit == "ntscf" )
	{
		$fps = 60;
	}
	else
	{
		$fps = 1;
	}

	$turbSpeed = (float)($turbMult * 2.0 * $fps) / (float)$loopFrames;
	$brushes = getSelectedBrushes();
	for( $i = 0; $i < size( $brushes ); $i++ )
	{
		setAttr ($brushes[$i] + ".turbulenceSpeed") $turbSpeed;
		$gapSpace = `getAttr ($brushes[$i] + ".gapSpacing")`;
		$textured = ( `getAttr ($brushes[$i] + ".mapColor")`
		  			|| `getAttr ($brushes[$i] + ".mapOpacity")` );
		$gapSize = `getAttr ($brushes[$i] + ".gapSize")`;
		$repeatU = `getAttr ($brushes[$i] + ".repeatU")`;
		if( $textured && $repeatU != 0 )
		{
			if( $gapSize == 0 )
			{
				// no gaps, so base loop on texture coords
				$gapSpace = 1.0/$repeatU;
			}
			else
			{
				$tR = 1.0/$gapSize;
				if( $repeatU < $tR )
				{
					// texture repeat must be zero or the minimum gap size
					$repeatU = $tR;
				}
				else
				{
					// snap texture scale to the nearest multiple of the gap
					$repeatU = $tR * (float)((int)(0.5 + $repeatU/$tR));
				}
				setAttr ($brushes[$i] + ".repeatU") $repeatU;
			}
		}
		$flowSpeed = (float)$flowMult * (float)$fps * $gapSpace/(float)$loopFrames;
		setAttr ( $brushes[$i] + ".flowSpeed" ) $flowSpeed;
		setAttr ( $brushes[$i] + ".strokeTime" ) 0;
		setAttr ( $brushes[$i] + ".timeClip" ) 0;
		$turbType = `getAttr ($brushes[$i] + ".turbulenceType")`;
		if( $turbType == 6 && `getAttr ($brushes[$i] + ".branches")` )
		{
			warning( (uiRes("m_loopBrushAnim.kTreeIncorrectLoop")));
		}
		
	}
}

