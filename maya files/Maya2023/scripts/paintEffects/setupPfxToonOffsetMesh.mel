// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  2005
//
// Description: create toon offset mesh objects and connect them 
//	

proc string getObjShader( string $obj ){
	return "";
}

global proc setupPfxToonOffsetMesh( string $pfxToon)
{
	string $nType = nodeType($pfxToon);
	string $tform = $pfxToon;
	string $warningStr = (uiRes("m_setupPfxToonOffsetMesh.kNotPfxToon"));
	if($nType == "transform"){
		string $leaf[] = `ls -leaf -dag $pfxToon`;
		$pfxToon = $leaf[0];
		if( nodeType( $pfxToon ) != "pfxToon" ){
			warning( `format -s $pfxToon $warningStr` );
			return;
		}
	} else if( $nType == "pfxToon" ){
		string $tforms[] = listTransforms( $pfxToon );
		$tform = $tforms[0];
	} else {
		warning( `format -s $pfxToon $warningStr` );
		return;
	}

	string $cons[] = `listAttr -m ($pfxToon + ".inputSurface")`;
	if( size( $cons ) < 1 ){
		return;
	}
	string $sel[] = `ls -sl`;
	int $selChanged = false;
	string $profileMeshGroup = ($tform + "ProfileMeshes");
	if( !objExists( $profileMeshGroup ) ){
		$profileMeshGroup = `group -em -name $profileMeshGroup`;
		$selChanged = true;
	}
	string $material = ($tform + "ProfileShader");
	string $sg = ($material + "SG");
	int $createShader = true;
	if( objExists( $sg ) ){
		$createShader = false;
	}

	string $con;	
	for( $con in $cons ){
		string $buffer[];
		int $numTokens = `tokenize $con "[]" $buffer`;
		if( $numTokens == 3 ){
			if( $buffer[2] == ".surface" ){ // ignore matrix connections
				int $index = (int)$buffer[1];
				string $outputConnection = 
					($pfxToon + ".outProfileMesh["+$index+"]");
				string $outCons[] = `listConnections $outputConnection`;
				if( size($outCons) > 0 ){
/*
					if( $createShader ){
						string $mat	= getObjShader( $outCon[0] );
						if( objExists( $mat ) ){
							$createShader = false;
							$material = $mat;
						}
					}
*/
				} else {
					$selChanged = true;
					if( $createShader ){
						$material = `shadingNode -asShader -name $material "surfaceShader"`;
						// create shading group
						$sg = `sets -renderable true 
								-noSurfaceShader true -empty -name ($material + "SG")`;
						defaultNavigation
							-connectToExisting
							-source $material
							-destination $sg;
						connectAttr ($pfxToon + ".outColor") ($material + ".outColor");
						$createShader = false;
					}
					string $mesh = `createNode "mesh"`;
					setAttr ($mesh +".overrideEnabled") 1;
					setAttr ($mesh +".overrideDisplayType") 2;
					setAttr ($mesh +".doubleSided") 0;
					setAttr ($mesh +".castsShadows") 0;
					setAttr ($mesh +".receiveShadows") 0;

					if( attributeExists( "miFinalGatherCast", $mesh ) ){
						// these do not exist if mental ray is not loaded
						setAttr ($mesh +".miFinalGatherCast") 0;
						setAttr ($mesh +".miFinalGatherReceive") 0;
					}
					setAttr ($mesh +".opposite") 1;

					string $tforms[] = `listTransforms $mesh`;
					string $meshDag = $tforms[0];
					connectAttr $outputConnection ($mesh + ".inMesh");
					// select -r $mesh;
					hyperShade -assign $sg;
					parent -relative $meshDag $profileMeshGroup;

				}
			}
		}
	}
	if( $selChanged ){
		select -r $sel;
	}
}
