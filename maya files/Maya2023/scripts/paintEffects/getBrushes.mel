// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date: Jan 99
//
//
//  Description:
//      This finds all brushes in the selection list,
//        0 - only return brushes which are picked directly
//        1 - return brushes which are picked directly, or
//            indirectly though their strokes
//        2 - return brushes which are picked directly,
//            indirectly though their strokes, or indirectly
//            through their curves
//        3 - return brushes which are picked directly,
//            indirectly though their strokes, or indirectly
//            through their curves, or indirectly through
//            surfaces with COS's.
//
//  Returns:
//        $string[] - a list of all brushes selected.
//        If a brush is selected more than once it will
//        only appear once in the list.
//
global proc string[] getBrushes( int $filter )
{
	string $brushes[];
	int    $idx = 0;

	if ($filter > 0) {
		int $val = $filter - 1;
		string $strokes[] = getStrokes( $val );
		string $pfxStrokes[] = `ls -sl -dag -type pfxHair`;
		$strokes = stringArrayCatenate( $strokes, $pfxStrokes );
		$pfxStrokes = `ls -sl -dag -type pfxToon`;
		$strokes = stringArrayCatenate( $strokes, $pfxStrokes );
		// Walk through all strokes returned and add their associated brushes to our list.
		string $stroke;
		for ($stroke in $strokes) {
			if ($stroke != "") {
				string $attr = $stroke + ".brush";
				string $result = `connectionInfo -sfd $attr`;
				string $buffer[];
				int $num = `tokenize $result "." $buffer`;
				$brushes[ $idx ] = $buffer[0];
				++$idx;
			}
		}
	}

	// Now add any brushes which are on the pick list directly.
	string $selectionList[] = `ls -sl -l`;
	string $selection;
	for ($selection in $selectionList) {
		if (`nodeType $selection` == "brush") {
				$brushes[$idx] = $selection;
				++$idx;
		}
	}

	// Now filter any duplicates out of the brush list.
	string $returnBrushes[];
	int    $brushesSize = size( $brushes );
	if ( $brushesSize != 0) {
		string $sortedBrushes[] = `sort $brushes`;
		int $i;
		int $idx = 0;
		$returnBrushes[ $idx ] = $sortedBrushes[ 0 ];
		for ($i = 1; $i < $brushesSize; ++$i) {
			if ($sortedBrushes[ $i ] != $returnBrushes[ $idx ]) {
				// It is a unique entry.
				++$idx;
				$returnBrushes[ $idx ] = $sortedBrushes[ $i ];
			}
		}
		if ( $sortedBrushes[0] != $brushes[0] ) {
			// We have changed the lead brush
			for ($i = 1; $i < $brushesSize; ++$i) {
				// Find the lead brush in the unique array.
				if ( $sortedBrushes[ $i ] == $brushes[0] ) {
					// Found it.
					$brushes[0]          = $sortedBrushes[ 0 ];
					$sortedBrushes[ 0 ]  = $sortedBrushes[ $i ];
					$sortedBrushes[ $i ] = $brushes[0];
					$i = $brushesSize; // break out of the loop
				}
			}
		}
	}
		
	return ( $returnBrushes );
}
