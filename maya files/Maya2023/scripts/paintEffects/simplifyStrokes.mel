// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date: Dec 1998
//
// Description:
//    Simplify the curves based on percentage of current cvs 
//

global proc simplifyStrokes( float $skip )
{
	int $i, $j, $k, $l;
	
	string $curves[] =  `ls -dag -sl -typ nurbsCurve`;
	string $strokes[] = `getStrokes 2`;
	string $allCurves[];
	int    $aCIdx = 0;

	// For each stroke on the pick list, find it's associated curve.
	for ($i = 0; $i < size( $strokes ); $i++) {
		string $curveList[] = `listConnections ($strokes[$i] + ".pathCurve")`;
		for ($j = 0; $j < size( $curveList ); $j++) {
			if (`nodeType $curveList[$j]` == "curveFromSurfaceCoS") {
				// Need to find the nurbsCurve(s) from the curve on surface.
				string $transforms[] = `listConnections ($curveList[$j] + ".curveOnSurface")`;
				for ($l = 0; $l < size( $transforms ); $l++) {
					string $moreChildren[] = `listRelatives -c -s -f $transforms[$l]`;
					for ($k = 0; $k < size( $moreChildren ); $k++) {
						$allCurves[ $aCIdx ] = $moreChildren[ $k ];
						$aCIdx++;
					}
				}
			}
			else if (`nodeType $curveList[$j]` == "curveFromMeshCoM") {
				// Need to find the nurbsCurve(s) from the curve on surface.
				string $transforms[] = `listConnections ($curveList[$j] + ".curveOnMesh")`;
				for ($l = 0; $l < size( $transforms ); $l++) {
					string $moreChildren[] = `listRelatives -c -s -f $transforms[$l]`;
					for ($k = 0; $k < size( $moreChildren ); $k++) {
						$allCurves[ $aCIdx ] = $moreChildren[ $k ];
						$aCIdx++;
					}
				}
			} else {
				if (`nodeType $curveList[$j]` == "transform") {
					string $moreChildren[] = `listRelatives -c -s -f $curveList[$j]`;
					for ($l = 0; $l < size( $moreChildren ); $l++) {
						if (`nodeType $moreChildren[$l]` == "nurbsCurve") {
							$allCurves[ $aCIdx ] = $moreChildren[ $l ];
							$aCIdx++;
						}
					}
				}
				else if (`nodeType $curveList[$j]` == "nurbsCurve") {
					$allCurves[ $aCIdx ] = $curveList[ $j ];
					$aCIdx++;
				}
			}
		}
	}
	// Now add the selected curves to $allCurves.
	for ( $i = 0; $i < size( $curves ); $i++ ) {
		$allCurves[ $aCIdx ] = $curves[ $i ];
		$aCIdx++;
	}

	// Finally, remove any duplicate curves from this list.
	string $uniqueCurves[];
	int    $curveSize = size( $allCurves );
	int    $idx;
	if ( $curveSize != 0) {
		// Now filter out any duplicates.
		string $sortedCurves[] = `sort $allCurves`;
		int $i;
		int $idx = 0;
		$uniqueCurves[ $idx ] = $sortedCurves[ 0 ];
		for ($i = 1; $i < $curveSize; ++$i) {
			if ($sortedCurves[ $i ] != $uniqueCurves[ $idx ]) {
				// It is a unique entry.
				++$idx;
				$uniqueCurves[ $idx ] = $sortedCurves[ $i ];
			}
		}
	}

	for( $i = 0; $i < size( $uniqueCurves ); $i++ )
	{
		int $spans = `getAttr ($uniqueCurves[$i] + ".spans")`;
		$spans = (float)$spans/(float)$skip;
		rebuildCurve -ch 1 -rpo 1 -rt 0 -kr 0 -kcp 0 
					-kep 1 -kt 0 -s $spans -d 3 -tol 1.0 $uniqueCurves[$i];
	}
}

