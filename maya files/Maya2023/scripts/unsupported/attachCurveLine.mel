// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Jan 12, 1998
//
//  Description:
//      The attachCurveLine() procedure takes the selected two curves and 
//		creates a one span straight curve between them, using the end of curve1
//      and the start of curve2. The result will always be at least a degree
//      3 curve. If you don't want to attach the curves then call this proc
//      with $doAttach = 0.
//
//  Input Arguments:
//      $doAttach - if 1 attach results otherwise just create new curve
//
//  Return Value:
//      String.
//

global proc string attachCurveLine( int $doAttach )
{
	global int $gSelectNurbsCurvesBit;
	string $curvesList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;

	int $numCurves = size($curvesList);
	if ( $numCurves < 2 )
	{
		error((uiRes("m_attachCurveLine.kErrorSelectTwoCurves")) );
		return "";
	}

    // get the last cv on the first curve and the first cv on the second curve
    //
	int $degree = eval("getAttr " + $curvesList[0] + ".degree");
	int $numSpans = eval("getAttr " + $curvesList[0] + ".spans");
    int $numCVs = $degree + $numSpans;

    int $lastCV = $numCVs - 1;
    float $cvCurve1[] = `getAttr ($curvesList[0] + ".cp[" + $lastCV + "]")`;
    float $cvCurve2[] = `getAttr ($curvesList[1] + ".cp[0]")`;

    // this is the vector between the two cvs
    //
    float $vector[3];
    $vector[0] = $cvCurve2[0] - $cvCurve1[0];
    $vector[1] = $cvCurve2[1] - $cvCurve1[1];
    $vector[2] = $cvCurve2[2] - $cvCurve1[2];

    // calculate two other cvs on the line between the end cvs
    //
    float $cvNew1[3];
    $cvNew1[0] = $cvCurve1[0] + ($vector[0] * 0.333);
    $cvNew1[1] = $cvCurve1[1] + ($vector[1] * 0.333);
    $cvNew1[2] = $cvCurve1[2] + ($vector[2] * 0.333);
    float $cvNew2[3];
    $cvNew2[0] = $cvCurve1[0] + ($vector[0] * 0.666);
    $cvNew2[1] = $cvCurve1[1] + ($vector[1] * 0.666);
    $cvNew2[2] = $cvCurve1[2] + ($vector[2] * 0.666);

    // create the degree 3 curve
    //
    string $resultCurve = eval("curve -p " + $cvCurve1[0] + " " + $cvCurve1[1] + " " + $cvCurve1[2] + " -p " + $cvNew1[0] + " " + $cvNew1[1] + " " + $cvNew1[2] + " -p " + $cvNew2[0] + " " + $cvNew2[1] + " " + $cvNew2[2] + " -p " + $cvCurve2[0] + " " + $cvCurve2[1] + " " + $cvCurve2[2] + " -k 0 -k 0 -k 0 -k 1 -k 1 -k 1");

    // attach all 3 curves if required
    //
    if ( $doAttach == 1 )
    {
        // attach curve1 to the new curve
        //
        string $attachedCurve[] = eval("attachCurve -ch 0 -rpo 0 -kmk 1 " + $curvesList[0] + " " + $resultCurve);

        // the straight curve is no longer needed
        //
        delete $resultCurve;

        // attach curve2 to the previously attached curves
        //
        $attachedCurve = eval("attachCurve -ch 0 -rpo 1 -kmk 1 " + $attachedCurve[0] + " " + $curvesList[1]);
        $resultCurve = $attachedCurve[0];
    }

    select -r $resultCurve;
    return $resultCurve;
}
