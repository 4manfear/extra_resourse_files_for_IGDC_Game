// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:  Oct 23, 1997
//
//  Description:
//      The attachBlendCurve() procedure takes the selected curve and 
//		closes it. The selected curve must be open. The result is a periodic
// 		curve with the same number of cvs as the original curve.
//
//  Input Arguments:
//      None.
//
//  Return Value:
//      String.
//

global proc string attachBlendCurve()
{
	global int $gSelectNurbsCurvesBit;
	string $curvesList[] = `filterExpand -ex true -sm $gSelectNurbsCurvesBit`;

	int $numCurves = size($curvesList);
	if ( $numCurves == 0 )
	{
		error((uiRes("m_attachBlendCurve.kErrorSelectCurve")) );
		return "";
	}

	if ( $numCurves > 1 )
	{
		warning((uiRes("m_attachBlendCurve.kWarningTooManyCurves")) );
	}

	string $curve = $curvesList[$numCurves-1];
	
	// check that we have the required # of spans on the curve in order to
	// do the attach blend
	//
	int $degree = eval("getAttr " + $curve + ".degree");
	int $numSpans = eval("getAttr " + $curve + ".spans");
	int $minSpans;
	if ( $degree == 1 ) $minSpans = 3;
	else if ( $degree == 2 ) $minSpans = 4;
	else $minSpans = 2 * ($degree - 1);
	if ( $numSpans < $minSpans ) 
	{
		string $degreeStr = "" + $degree;
		string $minSpansStr = "" + $minSpans;
		warning(`format -s $degreeStr -s $minSpansStr (uiRes("m_attachBlendCurve.kWarningTooFewSpans"))` );
		return "";
	}

	// close the curve with preserve shape off and keep original on
	//
	string $results[] = `closeCurve -ch 0 -rpo 0 -ps 0 $curve`;

	int $resultCount = size($results);
	if ( $resultCount == 0 ) 
	{
		error((uiRes("m_attachBlendCurve.kErrorClosingCurveFailed")) );
		return "";
	}

	// rebuild the closed curve result to have the #spans as the original curve
	//
	$results = `rebuildCurve -ch 0 -rpo 1 -rt 0 -kr 0 -kcp 0 -kep 1 -kt 0 -s $numSpans -d $degree -tol 0.05 $results[0]`;

	$resultCount = size($results);
	if ( $resultCount == 0 ) 
	{
		error((uiRes("m_attachBlendCurve.kErrorRebuildingCurveFailed")) );
		return "";
	}

	// set interior cvs on new periodic curve to match cvs from original curve
	//
	float $origCvs[];
	int $i, $j;
	for ( $i = 1, $j = $i+1; $i < $numSpans; $i++, $j++ )
	{
		$origCvs = eval("getAttr " + $curve + ".controlPoints[" + $j + "]");
		eval("setAttr " + $results[0] + ".controlPoints[" + $i + "] -type double3 " + $origCvs[0] + " " + $origCvs[1] + " " + $origCvs[2]);
	}

	// set start cv on new periodic curve to be at the midpoint between the
	// start and end of original curve
	//
	$origCvs = eval("getAttr " + $curve + ".controlPoints[0]");
	float $origCvsEnd[];
	int $numCvsOrig = $numSpans + $degree - 1;
	$origCvsEnd = eval("getAttr " + $curve + ".controlPoints[" + $numCvsOrig + "]");
	for ( $i = 0; $i < 3; $i++ )
	{
		$origCvs[$i] = ($origCvs[$i] + $origCvsEnd[$i]) * 0.5;
	}
	eval("setAttr " + $results[0] + ".controlPoints[0] -type double3 " + $origCvs[0] + " " + $origCvs[1] + " " + $origCvs[2]);

	eval("select -r " + $results[0]);

	// return the final result curve
	return $results[0];
}
