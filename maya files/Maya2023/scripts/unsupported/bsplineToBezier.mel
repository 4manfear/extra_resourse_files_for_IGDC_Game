// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
// Description : A script to convert Bspline curve of arbitrary degree
// in to Bezier segments. The Bezier segments are 1 span B-spline segments.
// So, one would get as many shapes as the number of spans in the
// B-spline curve.
//

proc string[] makeOneSpanSegments( 
	string $crvName )
//
//	Description :
//
{

	int $i ;
	string $crvs[] ;

	// 1. Extract the knots out.
	//
	select -r $crvName ;	
	float $knots[] = nurbsCurveKnots() ;
	if( size($knots) == 0 ) return $crvs ;

	// get # of spans.
	//
	string $spansAttr = $crvName + ".spans" ;
	int $ns = `getAttr $spansAttr` ;

	string $degAttr = $crvName + ".degree" ;
	int $d = `getAttr $degAttr` ;

	string $subCurveNode ;
	if( catch( $subCurveNode = `createNode subCurve` ) ) {
		warning((uiRes("m_bsplineToBezier.kWarningSubCurveCreationFailed")) );
		return $crvs ;
	}

	string $txfrmGeoNode ;
	if( catch( $txfrmGeoNode = `createNode transformGeometry` ) ) {
		warning((uiRes("m_bsplineToBezier.kWarningTransGeomCreationFailed")) );
		delete $subCurveNode ;
		return $crvs ;
	}

	string $tAttr = $crvName + ".l" ;	 // local curve.
	string $ingAttr = $txfrmGeoNode + ".ig" ;
	connectAttr $tAttr $ingAttr ;
	$tAttr = $crvName + ".wm[0]" ;
	$ingAttr = $txfrmGeoNode + ".transform" ;
	connectAttr $tAttr $ingAttr ;
		
	int $oi = $d - 1 ;

	string $inAttr1 = $txfrmGeoNode + ".og" ;
	string $outAttr1 = $subCurveNode + ".ic" ;	
	string $minAttr = $subCurveNode + ".minValue" ;	
	string $maxAttr = $subCurveNode + ".maxValue" ;	
	string $inAttr2 = $subCurveNode + ".oc" ;	
	connectAttr $inAttr1  $outAttr1 ;
	for( $i = 0 ; $i < $ns ; $i++ ) {

		string $spanCrv ;
		if( catch( $spanCrv = `createNode nurbsCurve` ) ) {
			continue ;
		}
		setAttr $minAttr $knots[$i+$oi] ;
		setAttr $maxAttr $knots[$i+$oi+1] ;
		string $outAttr2 = $spanCrv + ".cr" ;
		connectAttr  $inAttr2 $outAttr2 ;
		string $dummy = $spanCrv + ".spans" ;
		getAttr $dummy ;
		disconnectAttr  $inAttr2 $outAttr2 ;
		$crvs[$i] = $spanCrv ;
	} // for.

	delete $txfrmGeoNode ;
	//delete $subCurveNode ;
	return $crvs ;
}

global proc string[] bsplineToBezier( ) 
{
	string $crvs[] ;

	// 0. Grab the select list.
    //
    string $selList[] ;
    $selList = `ls -sl` ;

	// 1. set filter to select only the nurbs curves out.
	//
	global int $gSelectNurbsCurvesBit ;

	string $crvList[] ;
    $crvList = `filterExpand -ex true -sm $gSelectNurbsCurvesBit $selList` ;

	if( size($crvList) == 0 ) {
		warning (uiRes("m_bsplineToBezier.kWarningSelectCurve"));
		return $crvs;
	}

	// 2. we have NURBS curve selected.
	//
	int $len = size($crvList) ;
    string $lastCrv = $crvList[$len-1] ;
    if( $len != 1 ) {
        string $w = (uiRes("m_bsplineToBezier.kWarningUsingLastCurve")) ;
        warning `format -s $lastCrv $w` ;
    }

	// 3. Call local proc.   
	//
	$crvs =  makeOneSpanSegments( $lastCrv ) ;

	if( size($crvs) > 0  ) {
		select -r $crvs ;
	} else {
		warning (uiRes("m_bsplineToBezier.kWarningBsplineToBezierFailed"));
	}
	return $crvs ;
}


