// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//  AEaudioTemplate
//
//  Description Name;
//  Creates the attribute editor controls for the audio Node
//
//  Input Value:
//  nodeName 
//
//  Output Value:
//  None
//


//
//  Procedure Name:
//  AEassignAudioCB - sets the attr and retains the cwd
//
global proc int AEassignAudioCB( string $fileAttribute,
                                 string $filename,
                                 string $fileType )
{
    setAttr $fileAttribute -type "string" $filename;

    string $currentDir = `workspace -q -dir`;
    retainWorkingDirectory ($currentDir);

    return true;
}


//
//  Procedure Name:
//  AEaudioFileBrowser - start the filebrowser out in the proper dir.
//
global proc AEaudioFileBrowser( string $cmd )
{
    string  $workspace = `workspace -q -fn`;
    setWorkingDirectory $workspace "audio" "audio";

    fileBrowser ($cmd, (uiRes("m_AEaudioTemplate.kOpen")), "audio", 0);
}


global proc AEchangeSoundfile ( string $filename )
{
    string $nodeName[];
    tokenize ($filename, ".", $nodeName);

    string $newValue = `textField -q -fileName audioNameField`;

    sound -e -f  $newValue  $nodeName[0];
}


global proc int AEsoundUpdateFilename ( string $filename, 
                string $file, string $fileType )
{
    string $oldFileName = `textField -q -fileName audioNameField`;
    textField -edit -text $file audioNameField;
    if ( catch( `AEchangeSoundfile $filename` ) ) {
        // Setting the sound failed, go back to the old file name
        //
        textField -edit -text $oldFileName audioNameField;
        return false;
    }
    return true;
}


global proc AEaudioFilenameNew ( string $fileAttribute )
{
    string $nodeName[];
    tokenize ($fileAttribute, ".", $nodeName);

    setUITemplate -pst attributeEditorTemplate;
        columnLayout -adj true;
            string $conFilename = `sound -q -file $nodeName[0]`;
            rowLayout -nc 3;
                text -label (uiRes("m_AEaudioTemplate.kFilename"))  filenameName;
                textField  -fileName $conFilename audioNameField;
                symbolButton -image "navButtonBrowse.png" browseSoundfiles;
                setParent ..;
        setParent ..;

    setUITemplate -ppt;

    AEaudioFilenameReplace( $fileAttribute );
}


global proc int AEaudioFilenameReplace ( string $fileAttribute )
{
    connectControl -fileName audioNameField $fileAttribute;

    string $nodeName[];
    tokenize ($fileAttribute, ".", $nodeName);

    string $conFilename;
    if ( catch( $conFilename = `sound -q -file $nodeName[0]` ) ) {
        string $warnMsg = (uiRes("m_AEaudioTemplate.kCouldNotGetFilename"));
        $warnMsg = `format -s $nodeName[0] $warnMsg`;
        warning ( $warnMsg );
        return false;
    } 
    string $command = "AEassignAudioCB "+" "+$fileAttribute;
    textField -e -cc ("AEchangeSoundfile " + $fileAttribute) audioNameField;
    button -e -c ("AEaudioFileBrowser \"" + $command + "\"") browseSoundfiles;
    return true;
}

// EndFrame fields override
// The following function allows to change the displayed values for the endFields
// by subtracting 1 from the real value. This is needed because in the editing world the last 
// frame of a shot is usually inclusive

global proc AEaudioEndFrameEdited( string $control, string $attrib )
{
    float $value = `timeFieldGrp -q -value1 $control`;
    $value += 1;

    setAttr $attrib $value;
}

global proc AEaudioEndFrameValueChanged( string $control, string $endFrameAttr )
{
    float $newValue =  `getAttr $endFrameAttr`;
    $newValue -= 1;

    timeFieldGrp -e -value1 $newValue $control;
}

global proc AEaudioEndFrameReplace( string $endFrameAttr )
{
    string $endFrameControl = (`setParent -query` + "|endFrameField_"+`attributeName -short $endFrameAttr`);

    float $newValue =  `getAttr $endFrameAttr`;
    $newValue -= 1;

    timeFieldGrp -e -changeCommand ("AEaudioEndFrameEdited( \""+$endFrameControl+"\" , \""+$endFrameAttr+"\" )") $endFrameControl;
    timeFieldGrp -e -value1 $newValue $endFrameControl;
    timeFieldGrp -e -enable (`gmatch $endFrameAttr "*.sourceEnd"`) $endFrameControl;

    string $callBack = "AEaudioEndFrameValueChanged( \""+$endFrameControl + "\" , \"" + $endFrameAttr + "\" )";

    scriptJob -p $endFrameControl -rp -attributeChange $endFrameAttr $callBack ;
}

global proc AEaudioEndFrameInit( string $endFrameAttr )
{
    string $controlName = "endFrameField_"+`attributeName -short $endFrameAttr`;
    string $label       = `attributeName -nice $endFrameAttr`;

    setUITemplate -pst attributeEditorTemplate;

    timeFieldGrp -label $label $controlName;

    setUITemplate -ppt;
    
    AEaudioEndFrameReplace( $endFrameAttr );
}

global proc AEaudioTemplate ( string $nodeName )
{
    editorTemplate -suppress "track";
    editorTemplate -suppress "trackState";
    editorTemplate -suppress "order";
    editorTemplate -suppress "endFrame"; // Replaced by a custom control
    editorTemplate -suppress "sourceEnd"; // Replaced by a custom control
    

    editorTemplate -beginScrollLayout;
        editorTemplate -beginLayout (uiRes("m_AEaudioTemplate.kAudioAttributes"))  -collapse 0;
            editorTemplate -addControl "offset";
            editorTemplate -callCustom "AEaudioFilenameNew"
                    "AEaudioFilenameReplace"
                    "filename";
            editorTemplate -addControl "frameCount";
            editorTemplate -addControl "channels";
            editorTemplate -addControl "sampleRate";
            editorTemplate -addControl "duration";
            editorTemplate -addControl "mute";
        editorTemplate -endLayout;

        editorTemplate -beginLayout (uiRes("m_AEaudioTemplate.kSequencerAttributes"))  -collapse 0;
            editorTemplate -addControl "silence";
            editorTemplate -callCustom "AEaudioEndFrameInit" "AEaudioEndFrameReplace" "endFrame";
            editorTemplate -addControl "sourceStart";
            editorTemplate -callCustom "AEaudioEndFrameInit" "AEaudioEndFrameReplace" "sourceEnd";
            
        editorTemplate -endLayout;

        // include/call base class/node attributes
        AEdependNodeTemplate $nodeName;

    editorTemplate -addExtraControls;
    editorTemplate -endScrollLayout;
}
