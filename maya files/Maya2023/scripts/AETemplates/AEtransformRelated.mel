// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
// FILE: AEtransformRelated.mel
// INPUT: string (node name)
// RETURN:	string[] (list of related nodes, with the node whose
//			tab you want to be opened duplicated at the
//			end of the array)
//


global proc int AEisLastNodeDuplicated(string $inputArray[])
{
	int		 $inputArraySizeMinusOne = size($inputArray)-1;
	if ($inputArraySizeMinusOne < 1) return false;
	string $searchString = $inputArray[$inputArraySizeMinusOne];
	string $tmp[] = `ls -l $searchString`;
	$searchString = $tmp[0];
	for ($i = 0; $i < $inputArraySizeMinusOne; $i++) {
		if ($inputArray[$i] == "") continue; // do not call "ls -l" without a node name.
		clear $tmp;
		$tmp = `ls -l $inputArray[$i]`;
		if ( $searchString == $tmp[0]) return true;
	}
	return false;
}


global proc string[] AEtransformRelated (string $nodeName)
{
	string $retval[];
	string $preferredNode = "";
	int $isNucleus = false;

	// get all shapes immediately below the transform first
	//
	string $leaves[] = `listRelatives -fullPath -shapes $nodeName`;
	for ($leaf in $leaves) {
		$retval[size($retval)] = $leaf;
	}

	// now get the connections for the transform
	// to deal with things like expressions, motionPaths, etc.
	//
	string $tmp[];
	$tmp = `defaultNavigation -ren -d $nodeName`;
	for ($node in $tmp) {
		if( `objectType -isa "reference" $node` ){
			// If we've added the reference node associated with this
			// transform, and if this reference has precisely one container
			// node, we'll add that container node's tab to the AE, and make it
			// the preferred node.
			//
			string $refNodes[] = `referenceQuery -dagPath -nodes $node`;
			string $containers[] = `ls -type container $refNodes`;
			if( size($containers) == 1 ){
				$retval[size($retval)] = $containers[0];
				$preferredNode = $containers[0];
			}
		}
		$retval[size($retval)] = $node;
	}

    // See if there is a specified number of tabs for the AE
	// If there is and we've got more nodes than tabs, don't
    // bother searching the leaves for even MORE nodes.
	if ( `optionVar -exists AEmaxRelatedTabs` ) {
		int $AEmaxRelatedTabs = `optionVar -q AEmaxRelatedTabs`;
		// If optionVar exists and is less than 10, use 10
		if ( $AEmaxRelatedTabs < 10 ) {
			$AEmaxRelatedTabs = 10;
		}

        if (size($retval) > $AEmaxRelatedTabs) {
            return $retval;
        }
    }

	// loop through each of the leaves looking for
	// appropriate AE<leafType>Related.mel scripts
	//
	for ($leaf in $leaves) {

		clear $tmp;
		// get the leaf's nodeType
		string $leafType = `nodeType $leaf`;
		if( $leafType == "nCloth" || $leafType == "nRigid" ){
			$isNucleus = true;
		}

		// build the related script's name
		string $relatedScript = "AE"+$leafType+"Related";

		if (`exists $relatedScript`) {

			// if an AE*Related script exists for the shape leaf
			// node, run it 
			//
			$tmp = eval($relatedScript+" \""+$leaf+"\"");

			// Check if the last item is duplicated.
			// AEisLastNodeDuplicated is a Mel script which will
			// search the input string array for a duplicate
			// occurrence of the last element in that array.
			// AEisLastNodeDuplicated returns 1 if true, 0 if false.
			// (this script is shown below)
			//
			// Note that any node that has been designated "internal"
			// is not a candidate for preferred status.
			//
			if (AEisLastNodeDuplicated($tmp) == true) {
				string $pNode = $tmp[size($tmp)-1];
				string $pType = `nodeType $pNode`;
				if ( !`attributeQuery -ex -node $pNode intermediateObject` ||
					 !`getAttr ($pNode+".intermediateObject")` ||
					 $pType == "nCloth" || $pType == "nRigid" ){
					$preferredNode = $pNode;
				}
			}

		} else {

			$tmp = `defaultNavigation -ren -d $leaf`;
			string $tmpPreferredNode = `defaultNavigation -dwn -d $leaf`;
			string $tmpPreferredFullPathName[] = `ls -l $tmpPreferredNode`;
			if ( $tmpPreferredFullPathName[0] != $leaf 
				|| $preferredNode == "" )
			{
				$preferredNode = $tmpPreferredNode;
				$tmp[size($tmp)] = $preferredNode;
			}

		}

		// catenate the result to the return string array ($retval)
		for ($i = 0; $i < size($tmp); $i++) {
			$retval[size($retval)] = $tmp[$i];
		}

	}

	// Note that if you have multiple leaves and each specifies
	// a preferredNode, only the last one is remembered.
	// If no preferredNode was specified, the transform itself
	// is used.
	//
	if ($preferredNode == "") {
		$preferredNode = $nodeName;
	}
	$retval[size($retval)] = $preferredNode;
	// For nucleus type nodes, always use the preferred node, so make sure
	// $gAETabMarker won't override it by clearing the "transform" entry.
	// See bug #254719.
	//
	string $prefNodeType = `nodeType $preferredNode`;
	if( $prefNodeType == "nCloth" || $prefNodeType == "nRigid" ||
		$prefNodeType == "dynamicConstraint" ){
		if( !`exists setTabMarker` ){
			eval("source \"showEditor.mel\"");
		}
		setTabMarker( "transform", "" );
	}
	
	return $retval;
}

