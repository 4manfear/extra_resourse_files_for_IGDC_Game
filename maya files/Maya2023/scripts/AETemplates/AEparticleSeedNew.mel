// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//
//  Creation Date:	october 5, 1998
//
//  Procedure Name:
//	AEparticleSeedNew
//
//  Description Name;
//	Creates the controls for the multiAttr "seed" of the particle object
//
//  Input Value:
//	nodeName.attrName 
//
//  Output Value:
//	None
// 
//====================  getParticleSeedAttributes   ====================
//
//	Description
//		Get all the "seed" attribute names of the particle.
//
//	Arguments
//		$nodeAttr   <particleShapeName>.seed
//
//	Return
//		The list of seed attribute names.
//
global proc string[] getParticleSeedAttributes(string $nodeAttr)
{
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);

	string $seedAttrs[];

	// Get the list of connections, both ways, of the particle shape.
	//
	string $connections[] = `listConnections -c true $buffer[0]`;

	// Find all the seed connections and save and return them.
	//
	int $i, $numSeedAttrs = 0;
	for ($i = 0; $i < size($connections); $i++)
	{
		// Match <particleShapeName>.seed with the seed connections, which
		// will be of the type <particleShapeName>.seed[n].  Match will
		// return from <particleShapeName>.seed[n] the substring
		// <particleShapeName>.seed.
		//
		string $seedAttr = match($nodeAttr, $connections[$i]); 

		if ($seedAttr == $nodeAttr)
		{
			$seedAttrs[$numSeedAttrs] = $connections[$i];
			$numSeedAttrs++;
		}
	}
	return $seedAttrs;
}


//====================  getParticleSeedEmitters   ====================
//
//	Description
//		Get the list of emitters that are connected to the particle
//		seed attributes.  The array it returns will be a parallel array
//		to seedAttrs.
//
//	Arguments
//		$nodeName   name of the particle shape
//		$seedAttrs  the names of all the particle's seed attributes that are
//					connected to an emitter (well, to something).
//
//	Return
//		The list of emitters connected to the seed attributes.
//
global proc	string[] getParticleSeedEmitters(string $nodeName, 
												string $seedAttrs[])
{
	string $emitters[];

	// Get all the connections of the particle shape.
	//
	string $connections[] = `listConnections -c true $nodeName`;

	// Get the seed attribute name.
	//
	string  $attrName = $nodeName + ".seed";

	int $i, $j, $numEmitters = 0;

	// For each seed attribute, find the emitter it is connected to in
	// the connections list, and add it to the emitter array to be returned.
	// Note that the listConnections command at least now guarantees that
	// the connection listed after the particle seed attribute will be the
	// object it is connected to.
	//
	for ($i = 0; $i < size($seedAttrs); $i++)
	{
		for ($j = 0; $j < size($connections) - 1; $j++)
		{
			if ($seedAttrs[$i] == $connections[$j])
			{
				$emitters[$i] = $connections[$j + 1];
				break;
			}
		}
	}
	return $emitters;
}


global proc AEparticleSeedNew ( string $nodeAttr )
{
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];

	setUITemplate -pst attributeEditorTemplate;

	columnLayout ($attrName+"Column");

	setParent ..;
	setUITemplate -ppt;

	AEparticleSeedReplace $nodeAttr;
}


global proc AEparticleSeedReplace ( string $nodeAttr )
{

	// The layout will contain a attrFieldSliderGrp control for each seed
	// attribute of the particle shape that is connected to an object.  The
	// label of each seed attrFieldSliderGrp will be the name of the emitter
	// the seed attribute is connected to.
	//
	string $buffer[];
	tokenize($nodeAttr, ".", $buffer);
	string $nodeName = $buffer[0];
	string $attrName = $buffer[1];

	int $i;

	// First, get the names of the seed attributes and the emitters they
	// are connected to, in parallel arrays.
	// Unfortunately, we can't have two arrays returned from one proc, and
	// no arrays can be returned in the arg list, so we are going to have
	// to do this in two steps.
	//
	string $seedAttrs[] = getParticleSeedAttributes($nodeAttr);
	string $emitters[] = getParticleSeedEmitters($nodeName, $seedAttrs);

	// Get the seed values for each of the attributes.
	//
	int $seeds[];
	for ($i = 0; $i < size($seedAttrs); $i++)
	{
		$seeds[$i] = `getAttr $seedAttrs[$i]`;
	}

	// Now set up the layout for the seed controls.
	//
	string $columnName = $attrName + "Column";
	setUITemplate -pst attributeEditorTemplate;
	if (!`columnLayout -ex $columnName`)
	{
		setUITemplate -pst attributeEditorTemplate;
		columnLayout $columnName;
		setUITemplate -ppt;
	}
	setParent $columnName;
	$layoutName=`setParent -q`;

	// Get the count of current seed controls.  We will re-use what exists,
	// and delete any existing controls that are not needed.
	//
	int $oldCount=`columnLayout -q -nch $layoutName`;

	// Make the seed attrFieldSliderGrps if not existing, or update them if
	// they are.
	//
	for ($i = 0; $i < size($seeds); $i++)
	{		
		$sliderLabel = $emitters[$i];

		$sliderName = "seed" + $i;

		if (`attrFieldSliderGrp -ex $sliderName`)
		{
			attrFieldSliderGrp -e 
				-l $sliderLabel
				-min 0  -max 100 -s 1 -pre 0
				-at $seedAttrs[$i]
				$sliderName;
		}
		else
		{
			setUITemplate -pst attributeEditorTemplate;
			attrFieldSliderGrp 
				-l $sliderLabel
				-min 0  -max 100 -s 1 
				-at $seedAttrs[$i]
			$sliderName;

			setUITemplate -ppt;
		}
	}

	// Remove any unused controls.
	//
	for ($i = size($seeds); $i < $oldCount; $i++)
	{
		$sliderName = "seed" + $i;

		if (`attrFieldSliderGrp -ex $sliderName` )
			deleteUI $sliderName;
	}

	setParent ..;
	setUITemplate -ppt;
}

