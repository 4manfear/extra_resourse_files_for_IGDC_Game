// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//      AEcharacterTemplate
//
//  Description Name;
//      Creates the attribute editor controls for the character node
//
//  Input Value:
//      nodeName
//
//  Output Value:
//      None
//


//
//  Procedure Name:
//      characterSetMembersNew
//
//  Description:
//      Create the attributes section for the character for the first time
//
//  Input Arguments:
//      $attrName - the name of the attribute passed in (eg node.dnSetMembers)
//
//  Return Value:
//      None.
//
global proc characterSetMembersNew( string $attrName )
{
	frameLayout -borderVisible false -collapsable true -labelVisible false -collapse false characterMemberFrameLayout;
		columnLayout characterMemberLayout;
		setParent ..;
	setParent ..;
	characterSetMembersReplace( $attrName );
}

//
//  Procedure Name:
//      characterSetMembersReplace
//
//  Description:
//      Replace the contents of the character attributes section
//
//  Input Arguments:
//      $attrName - the name of the attribute passed in (eg node.dnSetMembers)
//
//  Return Value:
//      None.
//
global proc characterSetMembersReplace( string $attrName )
{
	setParent characterMemberLayout;

	// Delete the controls that are there now
	//
	string $children[] = `columnLayout -query 
		-childArray characterMemberLayout`;

	string $cmd = "deleteUI ";
	for ( $child in $children ) 
	{
		$cmd += $child;
		$cmd += " ";
	}
	// If there are no children don't call "deleteUI"
	if ( `size $children` > 0 )
	{
		// Only call evalDeferred once so the attrFieldSliderGrps don't get
		// deleted one by one.
		evalDeferred( $cmd );
	}

	// Get a list of the plugs that belong to the character
	//
	string $attrs[] = `listConnections -plugs true $attrName`;

	// Convert attrs to use short attr names
	//
	setParent characterMemberLayout;

	string $node, $shortAttrs[];
	string $tokens[];
	int $count;
	int $last = size( $attrs );
	for ( $i = 0; $i < $last; $i++ ) {
		$count = `tokenize $attrs[$i] "." $tokens`;
		if ( $count > 0 ) {
			$node = $tokens[0];
			$shortAttrs = `listAttr -shortNames $attrs[$i]`;
			if ( size( $shortAttrs ) > 0 ) {
				$attrs[$i] = ( $node + "." + $shortAttrs[0] );
			}
		}
	}

	// Add the controls for each attribute
	//
	string $attrType;
	for ( $attr in $attrs ) {

		// Set slider min and max for each attribute
		// Each attribute defaults to a range of [-25, 25]
		float $min = -25.0;
		float $max = 25.0;

		if ( "character" == `nodeType $attr` ) continue;

		if ( "" != `match "\\.t[xyz]$" $attr` )
		{
			// Translate attributes (.tx, .ty, .tz) should have a range of 
			// [-100, 100]
			$min = -100.0;
			$max = 100.0;
		}
		else if ( "" != `match "\\.r[xyz]$" $attr` )
		{
			// Rotate attributes (.rx, .ry, .rz) should have a range of 
			// [-360, 360]
			$min = -360.0;
			$max = 360.0;
		}
		else if ( "" != `match "\\.s[xyz]$" $attr` )
		{
			// Scale attributes (.sx, .sy, .sz) should have a range of
			// [-10, 10]
			$min = -10.0;
			$max = 10.0;
		}

		string $attrType = `getAttr -type $attr`;
		switch ( $attrType ) {
		case "double":
		case "float":
		case "doubleAngle":
		case "doubleLinear":
		case "time":
			// attrFieldSliderGrp sliders won't show up unless a min and max
			// for the control is specified.  Use `maxfloat` and `minfloat` to 
            // ensure the user is not limited manually entering a value into the 
			// field.
			attrFieldSliderGrp 
				-enable 1 
				-min `minfloat`
				-max `maxfloat`
				-sliderMinValue $min
				-sliderMaxValue $max
				-label $attr 
				-attribute $attr;
			break;
		case "bool":
			$checkBox = `checkBoxGrp -label $attr -l1 ""`;
			connectControl -index 2 $checkBox $attr;
			break;
		case "enum":
			attrEnumOptionMenuGrp -label $attr -attribute $attr;
			break;
		}
	}
}


global proc AEcharacterTemplate( string $nodeName )
{
	// Put our attributes into a scrolled layout field

	editorTemplate -beginScrollLayout;

	// Build a custom section where the plugs for elements in the
	// character will be displayed
	//
	editorTemplate -beginLayout (uiRes("m_AEcharacterTemplate.kCharacterSetAttributes"))  -collapse true;
	   editorTemplate -callCustom "characterSetMembersNew"
					  "characterSetMembersReplace"
					  "dnSetMembers";
	editorTemplate -endLayout;

	// Call the base node template to get the node state controls
	AEdependNodeTemplate $nodeName;

	// Create an "Extras" section and also add controls for any
	// attributes we have not explicitly mentioned.
	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;

	// Tell the attribute editor not to display the attributes
	// that are not appropriate for user-interaction
	//
	editorTemplate -suppress "dagSetMembers";
	editorTemplate -suppress "linearValues";
	editorTemplate -suppress "angularValues";
	editorTemplate -suppress "unitlessValues";
	editorTemplate -suppress "timeValues";
	editorTemplate -suppress "memberWireframeColor";
	editorTemplate -suppress "isLayer";
	editorTemplate -suppress "edgesOnlySet";
	editorTemplate -suppress "verticesOnlySet";
	editorTemplate -suppress "facetsOnlySet";
	editorTemplate -suppress "editPointsOnlySet";
	editorTemplate -suppress "renderableOnlySet";
	editorTemplate -suppress "annotation";
	editorTemplate -suppress "partition";
	editorTemplate -suppress "timeClipValues";
	editorTemplate -suppress "angularClipValues";
	editorTemplate -suppress "linearClipValues";
	editorTemplate -suppress "unitlessClipValues";
	editorTemplate -suppress "clipEvaluate";
	editorTemplate -suppress "activeClipConnected";
	editorTemplate -suppress "clipIndexMap";
	editorTemplate -suppress "timelineClipStart";
	editorTemplate -suppress "timelineClipEnd";
	editorTemplate -suppress "evalCharacterKeys";

	AEcontainerNodeSuppress $nodeName;
}

