// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//	AEdisplayLayerNoScroll
//
//  Description Name;
//	Creates the attribute editor controls for the displayLayer Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
// 

global proc int getCurrentColor( string $layerColorAttr )
{
	int $color = `getAttr $layerColorAttr`;
	if ( $color < 1 ) {
		$color = 0;	// If out of range select the invisible color
	} else if ( $color > 31 ) {
		$color = 31;
	}
	return $color + 1;
}

global proc changeObjColor ( string $layerColorAttr, string $colorCtrl )
{

	int $color = `colorIndexSliderGrp -q -v $colorCtrl` - 1;

	if( catch(`setAttr $layerColorAttr $color`) )
	{
		int $oldColor = getCurrentColor( $layerColorAttr );
		colorIndexSliderGrp -e -v $oldColor $colorCtrl;
	}
}

global proc updateLayerColor (string $layerColorAttr, string $colorCtrl)
{
	// check to set the correct initial settings
	int $color = getCurrentColor( $layerColorAttr );
	colorIndexSliderGrp -e -v $color $colorCtrl;
}

//
//	drawInfoObjColorReplace
//
global proc drawInfoObjColorReplace (string $layerColorAttr)
{
	// There are more then one instance of this slider so to
	// be safe get its full name.
	string $colorCtrl = (`setParent -query` + "|objIndexColorSlider");
	
	colorIndexSliderGrp -e  
			-cc ("changeObjColor " + $layerColorAttr + " "+ $colorCtrl )
			objIndexColorSlider;

	updateLayerColor $layerColorAttr $colorCtrl;
	
	scriptJob -p objIndexColorSlider -rp 
		-attributeChange $layerColorAttr 
		("updateLayerColor " + $layerColorAttr + " " + $colorCtrl);

}

//
//	drawInfoObjColorNew
//
global proc drawInfoObjColorNew ( string $layerColorAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	colorIndexSliderGrp  -label ""  
			-invisible 1
			-v 1			// Color index 1 is taken as the invisible one
			-min 1 -max 32	// Enable the entire (dormant) colour palette
			objIndexColorSlider;
	setUITemplate -ppt;
	colorIndexSliderGrp -e -el "" objIndexColorSlider;
	
	drawInfoObjColorReplace  $layerColorAttr;
}

//
//  RGB color functions
//

global proc float[] getCurrentRGBColor( string $layerColorAttr )
{
	return `getAttr $layerColorAttr`;
}

global proc float getCurrentRGBAlpha( string $alphaAttr )
{
	return `getAttr $alphaAttr`;
}

global proc changeObjRGBColor ( string $layerColorAttr, string $colorCtrl )
{

	float $color[] = `colorSliderGrp -q -rgb $colorCtrl`;

	if( catch(`setAttr $layerColorAttr $color[0] $color[1] $color[2]`) )
	{
		float $oldColor[] = getCurrentRGBColor( $layerColorAttr );
		colorSliderGrp -e -rgb $oldColor $colorCtrl;
	}
}

global proc updateLayerRGBColor (string $layerColorAttr, string $colorCtrl)
{
	// check to set the correct initial settings
	float $color[] = getCurrentRGBColor( $layerColorAttr );
	colorSliderGrp -e -rgb $color[0] $color[1] $color[2] $colorCtrl;
}

global proc changeObjRGBAlpha ( string $alphaAttr, string $alphaCtrl )
{
	float $alpha = `floatSliderGrp -q -value $alphaCtrl`;

	if( catch(`setAttr $alphaAttr $alpha`) )
	{
		float $oldAlpha = getCurrentRGBAlpha( $alphaAttr );
		floatSliderGrp -e -value $oldAlpha $alphaCtrl;
	}
}

global proc updateLayerRGBAlpha (string $alphaAttr, string $alphaCtrl)
{
	// check to set the correct initial settings
	float $alpha = getCurrentRGBAlpha( $alphaAttr );
	floatSliderGrp -e -value $alpha $alphaCtrl;
}

global proc updateObjColorsVisibility(string $layerColorAttr)
{
	int $colorType = `getAttr $layerColorAttr`;
	colorIndexSliderGrp -e -visible ($colorType == 0) objIndexColorSlider;
	colorSliderGrp -e -visible ($colorType == 1) objRGBColorSlider;
	floatSliderGrp -e -visible ($colorType == 1)  objRGBAlphaSlider;
}

global proc changeObjLayerColorType ( string $layerColorAttr, string $colorCtrl )
{
	int $useRgb = `optionMenuGrp -q -select $colorCtrl` == 2;

	if( catch(`setAttr $layerColorAttr $useRgb`) )
	{
		int $oldColorType = `getAttr $layerColorAttr`;
		optionMenuGrp -e -select ($oldColorType == 0 ? 1 : 2) $colorCtrl;
	}
	
	updateObjColorsVisibility($layerColorAttr);
}

global proc updateObjLayerColorType (string $layerColorAttr, string $colorCtrl)
{
	// check to set the correct initial settings
	int $colorType = `getAttr $layerColorAttr`;
	optionMenuGrp -e -select ($colorType == 0 ? 1 : 2) $colorCtrl;
}

//
//	drawInfoObjRGBColorReplace
//
global proc drawInfoObjRGBColorReplace (string $layerColorAttr)
{
	// There are more then one instance of this slider so to
	// be safe get its full name.
	string $colorCtrl = (`setParent -query` + "|objRGBColorSlider");
	
	colorSliderGrp -e  
			-cc ("changeObjRGBColor " + $layerColorAttr + " "+ $colorCtrl )
			objRGBColorSlider;

	updateLayerRGBColor $layerColorAttr $colorCtrl;
	
	scriptJob -p objRGBColorSlider -rp 
		-attributeChange $layerColorAttr 
		("updateLayerRGBColor " + $layerColorAttr + " " + $colorCtrl);
}

//
//	drawInfoObjRGBAlphaReplace
//
global proc drawInfoObjRGBAlphaReplace (string $alphaAttr)
{
	// There are more then one instance of this slider so to
	// be safe get its full name.
	string $alphaCtrl = (`setParent -query` + "|objRGBAlphaSlider");
	
	floatSliderGrp -e  
			-cc ("changeObjRGBAlpha " + $alphaAttr + " "+ $alphaCtrl )
			objRGBAlphaSlider;

	updateLayerRGBAlpha $alphaAttr $alphaCtrl;
	
	scriptJob -p objRGBAlphaSlider -rp 
		-attributeChange $alphaAttr 
		("updateLayerRGBAlpha " + $alphaAttr + " " + $alphaCtrl);
}

//
//	drawInfoObjRGBColorNew
//
global proc drawInfoObjRGBColorNew ( string $layerColorAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	colorSliderGrp  -label "" objRGBColorSlider;
	setUITemplate -ppt;

	drawInfoObjRGBColorReplace  $layerColorAttr;
}

//
//	drawInfoObjRGBAlphaNew
//
global proc drawInfoObjRGBAlphaNew ( string $alphaAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	string $opacityAnn = (uiRes("m_AEdrawInfo.kOpacityAnn"));
	floatSliderGrp -label (uiRes("m_AEdrawInfo.kAlphaLabel")) -annotation $opacityAnn objRGBAlphaSlider;
	setUITemplate -ppt;

	drawInfoObjRGBAlphaReplace  $alphaAttr;
}

//
//	drawInfoObjColorTypeReplace
//
global proc drawInfoObjColorTypeReplace (string $layerColorAttr)
{
	// There are more then one instance of this widget so to
	// be safe get its full name.
	string $colorCtrl = (`setParent -query` + "|objOverrideColorType");
	
	optionMenuGrp -e  
			-cc ("changeObjLayerColorType " + $layerColorAttr + " "+ $colorCtrl )
			objOverrideColorType;

	updateObjLayerColorType $layerColorAttr $colorCtrl;
	
	scriptJob -p objOverrideColorType -rp 
		-attributeChange $layerColorAttr 
		("updateObjLayerColorType " + $layerColorAttr + " " + $colorCtrl);

}

//
//	drawInfoObjColorTypeNew
//
global proc drawInfoObjColorTypeNew ( string $layerColorAttr )
{
	setUITemplate -pst attributeEditorTemplate;
	optionMenuGrp -label (uiRes("m_AEdrawInfo.kColorType")) objOverrideColorType;
	menuItem -label (uiRes("m_AEdrawInfo.kIndexed"));
	menuItem -label (uiRes("m_AEdrawInfo.kRGB"));
	
	setUITemplate -ppt;

	drawInfoObjColorTypeReplace  $layerColorAttr;
}
// On incoming connections from the layers to the objects turning off
// the "enabled" flag should gray out the other controls as they will be
// ignored from then on.  The outgoing connections can still modify the
// values although they will not have immediate effect.
//
global proc checkDrawEnabled(
	string	$enabledName,
	string	$displayTypeName,
	string	$levelOfDetailName,
	string	$shadingName,
	string	$texturingName,
	string	$playbackName,
	string	$visibleName,
	string  $useRGBName,
	string  $colourName,
	string	$rgbColourName,
	string $rgbAlphaName,
	string	$nodeName )
{
	string $long[] = `ls -long $nodeName`;
    if( size($long) == 0 ) {
        // If the node was deleted before this nothing needs updating
        return;
    }
	string $nodeAttr = $long[0] + "." + $enabledName;
	int $value = 1 - `getAttr $nodeAttr`;

	// Disable everything for the default layer.  It has no effect
	// on its members anyway so no sense in misleading the user.
	//
	string $mgr[] = `ls -type displayLayerManager`;
	if( size($mgr) > 0 )
	{
		string $def[] = `listConnections ($mgr[0] + ".displayLayerId[0]")`;
		if( (size($def) > 0)
		&&  ($def[0] == $nodeName) )
		{
			$value = 1;
		}
	}

	editorTemplate -dimControl $nodeName $displayTypeName ($value);
	editorTemplate -dimControl $nodeName $levelOfDetailName ($value);
	editorTemplate -dimControl $nodeName $shadingName ($value);
	editorTemplate -dimControl $nodeName $texturingName ($value);
	editorTemplate -dimControl $nodeName $playbackName ($value);
	editorTemplate -dimControl $nodeName $visibleName ($value);
	editorTemplate -dimControl $nodeName $useRGBName ($value);
	editorTemplate -dimControl $nodeName $rgbColourName ($value);
	editorTemplate -dimControl $nodeName $rgbAlphaName ($value);

	if (`colorIndexSliderGrp -exists objIndexColorSlider`) {
		// replaced slider control with dimControls
		editorTemplate -dimControl $nodeName $colourName ($value);	
	}
}

//	AEdrawInfo
//
global proc AEdrawInfo (
	string $displayTypeName
,	string $levelOfDetailName
,	string $shadingName
,	string $texturingName
,	string $playbackName
,	string $enabledName
,	string $visibleName
,	string $useRGBName
,	string $colourName
,	string $rgbColourName
,	string $rgbAlphaName
)
{
	editorTemplate -beginNoOptimize;

	// Make a callback for the incoming end of the enabled flag so that
	// disabling it shuts off the ability to change the other (ignored)
	// values.
	//
	editorTemplate -label (uiRes("m_AEdrawInfo.kEnableOverrides"))  -addControl $enabledName
					("checkDrawEnabled "   + $enabledName + " " +
					$displayTypeName + " " + $levelOfDetailName + " " +
					$shadingName	 + " " + $texturingName + " " +
					$playbackName	 + " " + $visibleName + " " +
					$useRGBName		 + " " + $colourName + " " +
					$rgbColourName  + " " +  $rgbAlphaName);

	editorTemplate -label (uiRes("m_AEdrawInfo.kDisplayType"))  -addControl $displayTypeName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kLevelofDetail"))  -addControl $levelOfDetailName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kShading"))  -addControl $shadingName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kTexturing"))  -addControl $texturingName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kPlayback"))  -addControl $playbackName;
	editorTemplate -label (uiRes("m_AEdrawInfo.kVisible"))  -addControl $visibleName;
	editorTemplate -endNoOptimize;
	editorTemplate -callCustom "drawInfoObjColorTypeNew" "drawInfoObjColorTypeReplace"
				$useRGBName;
	editorTemplate -callCustom "drawInfoObjColorNew" "drawInfoObjColorReplace"
				$colourName;
	editorTemplate -callCustom "drawInfoObjRGBColorNew" "drawInfoObjRGBColorReplace"
				$rgbColourName;
	editorTemplate -callCustom "drawInfoObjRGBAlphaNew" "drawInfoObjRGBAlphaReplace"
				$rgbAlphaName;
	editorTemplate -callCustom "updateObjColorsVisibility" "updateObjColorsVisibility"
				$useRGBName;
}
