// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//	Procedure Name:
//	AEmeshTemplate
//
//	Description Name;
//	Creates the attribute editor controls for the mesh node
//
//	Input Value:
//	nodeName
//
//	Output Value:
//	None
//

global proc checkMeshDisplayBorder ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayBorders";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "borderWidth" false;
	} else {
		editorTemplate -dimControl $nodeName "borderWidth" true;
	}
}

global proc checkMeshUseMaxSubd ( string $nodeName )
{
  string $nodeAttr = $nodeName + ".useMaxSubdivisions";
  int $value = `getAttr $nodeAttr`;

	if ( $value ) {
	  editorTemplate -dimControl $nodeName "maxSubd" false;
	} else {
	  editorTemplate -dimControl $nodeName "maxSubd" true;
	}
}

global proc checkMeshUseMinScreen ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMinScreen";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "minScreen" false;
	} else {
		editorTemplate -dimControl $nodeName "minScreen" true;
	}
}

global proc checkMeshUseMaxEdgeLength ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMaxEdgeLength";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "maxEdgeLength" false;
	} else {
		editorTemplate -dimControl $nodeName "maxEdgeLength" true;
	}
}

global proc checkMeshUseMaxUv ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMaxUV";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "maxUv" false;
	} else {
		editorTemplate -dimControl $nodeName "maxUv" true;
	}
}



global proc checkMeshUseMinEdgeLength ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".useMinEdgeLength";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "minEdgeLength" false;
	} else {
		editorTemplate -dimControl $nodeName "minEdgeLength" true;
	}
}

global proc checkMeshDisplayNormals ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayNormal";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "normalSize" false;
		editorTemplate -dimControl $nodeName "normalType" false;
	} else {
		$nodeAttr = $nodeName + ".displayTangent";
		$value = `getAttr $nodeAttr`;
		if( $value )
		{
			editorTemplate -dimControl $nodeName "normalSize" false;
		}
		else
		{
			editorTemplate -dimControl $nodeName "normalSize" true;
		}
		editorTemplate -dimControl $nodeName "normalType" true;
	}
}

global proc checkMeshDisplayVertices ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayVertices";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "vertexBackfaceCulling" false;
		editorTemplate -dimControl $nodeName "vertexSize" false;
	} else {
		editorTemplate -dimControl $nodeName "vertexBackfaceCulling" true;
		editorTemplate -dimControl $nodeName "vertexSize" true;
	}
}

global proc checkMeshDisplayUVs ( string $nodeName )
{
	string $nodeAttr = $nodeName + ".displayUVs";
	int $value = `getAttr $nodeAttr`;

	if ( $value ) {
		editorTemplate -dimControl $nodeName "uvSize" false;
	} else {
		editorTemplate -dimControl $nodeName "uvSize" true;
	}
}

global proc checkMeshAllowTopologyMod( string $nodeName )
{
	int $isLocked[] = `lockNode -q $nodeName`;
	editorTemplate -dimControl $nodeName "allowTopologyMod" $isLocked[0];
}

proc setDisplayColorChannelOptionMenu( string $attrName )
{
	string $channel = `getAttr $attrName`;
	int $option = 4; // Diffuse
	if ( $channel == "color" || $channel == "Diffuse" ) $option = 4;
	else if ( $channel == "None" ) $option = 1;
	else if ( $channel == "Ambient" ) $option = 2;
	else if ( $channel == "Ambient+Diffuse" ) $option = 3;
	else if ( $channel == "Specular" ) $option = 5;
	else if ( $channel == "Emission" ) $option = 6;

	if ( `optionMenuGrp -q -exists displayColorChannelOptionMenu` )
	{
		optionMenuGrp -e
			-select $option
			displayColorChannelOptionMenu;
	}
}

global proc setDisplayColorChannelAttribute( string $attrName )
{
	string $channel = "Diffuse";
	int $option = `optionMenuGrp -q -select displayColorChannelOptionMenu`;

	if ( $option == 4 ) $channel = "Diffuse";
	else if ( $option == 1 ) $channel = "None";
	else if ( $option == 2 ) $channel = "Ambient";
	else if ( $option == 3 ) $channel = "Ambient+Diffuse";
	else if ( $option == 5 ) $channel = "Specular";
	else if ( $option == 6 ) $channel = "Emission";
	
	setAttr -type "string" $attrName $channel;
}

global proc AEdisplayColorChannelNew ( string $attrName )
{
	setUITemplate -pushTemplate attributeEditorTemplate;
	string $parent = `setParent -q`;

	optionMenuGrp 
		-label (uiRes("m_AEmeshTemplate.kDisplayColorChannel"))
		displayColorChannelOptionMenu;
	menuItem -label (uiRes("m_AEmeshTemplate.kNone")) ;
	menuItem -label (uiRes("m_AEmeshTemplate.kAmbient"));
	menuItem -label (uiRes("m_AEmeshTemplate.kAmbientPlusDiffuse"));
	menuItem -label (uiRes("m_AEmeshTemplate.kDiffuse"));
	menuItem -label (uiRes("m_AEmeshTemplate.kSpecular"));
	menuItem -label (uiRes("m_AEmeshTemplate.kEmission"));
	setDisplayColorChannelOptionMenu( $attrName );

	optionMenuGrp -e
		-changeCommand ( "setDisplayColorChannelAttribute " + $attrName )
		displayColorChannelOptionMenu;

	setUITemplate -popTemplate;
}

global proc AEdisplayColorChannelReplace( string $attrName )
{
	optionMenuGrp -e
		-changeCommand ""
		displayColorChannelOptionMenu;

	setDisplayColorChannelOptionMenu( $attrName );

	optionMenuGrp -e
		-changeCommand ( "setDisplayColorChannelAttribute " + $attrName )
		displayColorChannelOptionMenu;
}

global proc SMPCustomControlsNew( string $attr1Name, string $attr2Name )
{
	setUITemplate -pushTemplate attributeEditorTemplate;

	string $nodeName = plugNode($attr1Name);

	checkBoxGrp -label (uiRes("m_AEmeshTemplate.kSMPDisplay")) 
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreview_CBG;

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPDisplayLabel"))
			-numberOfRadioButtons 1
			-label1 (uiRes("m_AEmeshTemplate.kSMPDisplayBoth"))
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType1_RBG;

		if (isLegacyViewportEnabled())  // show only in vp1
		{
			radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPEditLabel"))
			-columnWidth 1 175
			-numberOfRadioButtons 3
			-vertical
			-label1 (uiRes("m_AEmeshTemplate.kSMPEditCage"))
			-label2 (uiRes("m_AEmeshTemplate.kSMPEditSmoth"))
			-label3 (uiRes("m_AEmeshTemplate.kSMPEditBoth"))
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
			SMPreviewSelectType_RBG;
		}

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPEmpty")) 
			-shareCollection SMPreviewType1_RBG
			-numberOfRadioButtons 1
			-label1 (uiRes("m_AEmeshTemplate.kSMPDisplaySmooth"))
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType2_RBG;

	SMPCustomControlsUIFromAttrs($nodeName);

	setUITemplate -popTemplate;

	global int $SMPDisplayModeScriptJobId;
	global int $SMPSelectionTypeScriptJobId;

	string $cmd = ("SMPCustomControlsUIFromAttrs \"" + $nodeName + "\"");
	$SMPDisplayModeScriptJobId = `scriptJob -parent SMPreview_CBG 
									-replacePrevious
									-attributeChange $attr1Name 
									$cmd`;

	$SMPSelectionTypeScriptJobId = `scriptJob -parent SMPreviewType1_RBG 
										-replacePrevious
										-attributeChange $attr2Name 
										$cmd`;
}

global proc DPCustomControlsNew( string $showDisplacements )
{
	string $nodeName = plugNode($showDisplacements);

	// Define the command responding the UI change of "Displacement Preview".
	setUITemplate -pushTemplate attributeEditorTemplate;
	checkBoxGrp -label (uiRes("m_AEmeshTemplate.kDPDisplay")) 
			-changeCommand ("DPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		DPreview_CBG;
	setUITemplate -popTemplate;

	// Update UI from attributes.
	DPCustomControlsUIFromAttrs($nodeName);

	// Create scriptJob to monitor the attributes that affect the "Displacement Preview" UI.
	string $cmd = ("DPCustomControlsUIFromAttrs \"" + $nodeName + "\"");
	
	global int $DPSMPScriptJobId;
	global int $DPUseGlobalScriptJobId;
	global int $DPDrawMethodScriptJobId;
	global int $DPShowScriptJobId;	
	
	string $displaySmoothMesh = $nodeName + ".displaySmoothMesh";
	$DPSMPScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $displaySmoothMesh
							$cmd`;	
	string $useGlobalSmoothDrawType = $nodeName + ".useGlobalSmoothDrawType";
	$DPUseGlobalScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $useGlobalSmoothDrawType
							$cmd`;	
	string $smoothDrawType = $nodeName + ".smoothDrawType";
	$DPDrawMethodScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $smoothDrawType
							$cmd`;	
	$DPShowScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $showDisplacements
							$cmd`;
}

global proc SMPMapBordersNew( string $attr1Name, string $attr2Name, string $attr3Name )
{
	setUITemplate -pushTemplate attributeEditorTemplate;

	string $nodeName = plugNode($attr1Name);

	radioButtonGrp -label (uiRes("m_AEmeshTemplate.kSMPMapBordersLabel"))
			-vertical
			-numberOfRadioButtons 3
			-label1 (uiRes("m_AEmeshTemplate.kSMPDoNotSmooth"))
			-label2 (uiRes("m_AEmeshTemplate.kSMPSmoothInternal"))
			-label3 (uiRes("m_AEmeshTemplate.kSMPSmoothAll"))
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMMapBorders_RBG;
	
	checkBoxGrp -label (uiRes("m_AEmeshTemplate.kSMPPreserve"))
			-vertical
			-numberOfCheckBoxes 2
			-label1 (uiRes("m_AEmeshTemplate.kSMPGeometryBorders"))
			-label2 (uiRes("m_AEmeshTemplate.kSMPHardEdges"))
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMPreserver_CBG;

	SMPMapBordersUIFromAttrs($nodeName);

	setUITemplate -popTemplate;

	string $cmd = ("SMPMapBordersUIFromAttrs \"" + $nodeName + "\"");
	scriptJob -parent SMMapBorders_RBG 
			  -replacePrevious
			  -attributeChange $attr1Name 
			  $cmd;
}


proc string SMPGlobalSmoothDrawTypeMsg( string $useGlobalSmoothDrawType)
{
	string $pre = (uiRes("m_AEmeshTemplate.kActiveSubdivisionMethod"));

	string $result;
	int $subdivisionVal;

	int $attrVal = `getAttr $useGlobalSmoothDrawType`;

	int $polyOpts[] = `polyOptions -q -smoothDrawType`;

	// This gives us the combobox values off of the pref dialog, match them with
	// the TpolySmoothGeomOptions enums.
	if ($polyOpts[0] == 1)
		$subdivisionVal = 2;
	if ($polyOpts[0] == 2)
		$subdivisionVal = 3;

	if ($subdivisionVal == 0)
		$result = $pre + (uiRes("m_AEmeshTemplate.kActiveSubdivisionMayaCC")) +")";
	else if ($subdivisionVal == 2)
		$result = $pre + (uiRes("m_AEmeshTemplate.kActiveSubdivisionOSDCC")) +")";
	else if ($subdivisionVal == 3)
		$result = $pre + (uiRes("m_AEmeshTemplate.kActiveSubdivisionOSDCCA")) +")";
	else if ($subdivisionVal == 4)
		$result = $pre + (uiRes("m_AEmeshTemplate.kActiveSubdivisionOSDLoop")) +")";
	else
		$result = $pre + (uiRes("m_AEmeshTemplate.kActiveSubdivisionUndefined")) + ")";

	return $result;
}

//
// 	Callback called when Subdivision Method checkbox (SMPUseGlobal_CBG) state changed
//
// 	Update the useGlobalSmoothDrawType attribute if needed 
//	and enable / disable the smoothDrawType dropdown list
//
global proc SMPUseGlobalCustomControlsUI(string $useGlobalSmoothDrawType)
{
	int $attrVal = `getAttr $useGlobalSmoothDrawType`;
	int $uiVal = `checkBoxGrp -query -value1 SMPUseGlobal_CBG`;

	if ($attrVal != $uiVal)
		setAttr $useGlobalSmoothDrawType $uiVal;

	string $nodeName = plugNode($useGlobalSmoothDrawType);
	editorTemplate -dimControl $nodeName "smoothDrawType" $uiVal;
}

global proc SMPGobalCheckBoxNew(string $useGlobalSmoothDrawType)
{
	int $attrVal = `getAttr $useGlobalSmoothDrawType`;

	string $strVal = SMPGlobalSmoothDrawTypeMsg($useGlobalSmoothDrawType);

	checkBoxGrp -label (uiRes("m_AEmeshTemplate.kSMPSubdivisionMethod"))
			-numberOfCheckBoxes 1
			-label1 $strVal
			-value1 $attrVal
			-changeCommand ("SMPUseGlobalCustomControlsUI \"" + $useGlobalSmoothDrawType + "\"")
		SMPUseGlobal_CBG;

	string $nodeName = plugNode($useGlobalSmoothDrawType);
	editorTemplate -dimControl $nodeName "smoothDrawType" $attrVal;
}

global proc SMPGlobalCheckBoxReplace(string $useGlobalSmoothDrawType) 
{
	int $attrVal = `getAttr $useGlobalSmoothDrawType`;
	checkBoxGrp -edit -value1 $attrVal SMPUseGlobal_CBG; 

	string $nodeName = plugNode($useGlobalSmoothDrawType);
	editorTemplate -dimControl $nodeName "smoothDrawType" $attrVal;
		
	string $strVal = SMPGlobalSmoothDrawTypeMsg($useGlobalSmoothDrawType);

	checkBoxGrp -edit -label1 $strVal -changeCommand ("SMPUseGlobalCustomControlsUI \"" + $useGlobalSmoothDrawType + "\"") SMPUseGlobal_CBG;
}

proc string[] SMPSmoothDrawTypeWarningMsg(string $errorAttr)
{
	string $result[] = { "", "" };
	int $error = `getAttr $errorAttr`;
	if ($error != 0) {
		$result = {
			(uiRes("m_AEmeshTemplate.kSmoothDrawWarningMsg")),
			(uiRes("m_AEmeshTemplate.kSmoothDrawWarningAnn"))
		};
	}
	return $result;
}

global proc SMPSmoothDrawTypeWarningNew(string $errorAttr)
{
	string $msg[] = SMPSmoothDrawTypeWarningMsg($errorAttr);
	text -label $msg[0] -ann $msg[1] smoothDrawTypeWarning;
}

global proc SMPSmoothDrawTypeWarningReplace(string $errorAttr)
{
	string $msg[] = SMPSmoothDrawTypeWarningMsg($errorAttr);
	text -edit -label $msg[0] -ann $msg[1] smoothDrawTypeWarning;
}

global proc SMPCustomControlsReplace( string $attr1Name, string $attr2Name )
{
	string $nodeName = plugNode($attr1Name);

	checkBoxGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreview_CBG;

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType1_RBG;

	if (isLegacyViewportEnabled())  // show only in vp1
	{
		radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewSelectType_RBG;
	}

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		SMPreviewType2_RBG;

	global int $SMPDisplayModeScriptJobId;
	global int $SMPSelectionTypeScriptJobId;

	scriptJob -kill $SMPDisplayModeScriptJobId;
	scriptJob -kill $SMPSelectionTypeScriptJobId;

	string $cmd = ("SMPCustomControlsUIFromAttrs \"" + $nodeName + "\"");
	$SMPDisplayModeScriptJobId = `scriptJob -parent SMPreview_CBG 
									-replacePrevious
									-attributeChange $attr1Name 
									$cmd`;

	$SMPSelectionTypeScriptJobId = `scriptJob -parent SMPreviewType1_RBG 
										-replacePrevious
										-attributeChange $attr2Name 
										$cmd`;

	SMPCustomControlsUIFromAttrs($nodeName);
}

global proc DPCustomControlsReplace( string $showDisplacements )
{
	string $nodeName = plugNode($showDisplacements);

	// Define the command responding the UI change of "Displacement Preview".
	checkBoxGrp -edit
			-changeCommand ("DPAttrsFromCustomControlsUI \"" + $nodeName + "\"")
		DPreview_CBG;

	// Update UI from attributes.
	DPCustomControlsUIFromAttrs($nodeName);
	
	// Create scriptJob to minitor the attributes that affect the "Displacement Preview" UI.
	string $cmd = ("DPCustomControlsUIFromAttrs \"" + $nodeName + "\"");
		
	global int $DPSMPScriptJobId;
	global int $DPUseGlobalScriptJobId;
	global int $DPDrawMethodScriptJobId;
	global int $DPShowScriptJobId;

	scriptJob -kill $DPSMPScriptJobId;
	scriptJob -kill $DPUseGlobalScriptJobId;
	scriptJob -kill $DPDrawMethodScriptJobId;
	scriptJob -kill $DPShowScriptJobId;
	
	string $displaySmoothMesh = $nodeName + ".displaySmoothMesh";
	$DPSMPScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $displaySmoothMesh
							$cmd`;
	string $useGlobalSmoothDrawType = $nodeName + ".useGlobalSmoothDrawType";
	$DPUseGlobalScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $useGlobalSmoothDrawType
							$cmd`;
	string $smoothDrawType = $nodeName + ".smoothDrawType";
	$DPDrawMethodScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $smoothDrawType
							$cmd`;
	$DPShowScriptJobId = `scriptJob -parent DPreview_CBG							
							-attributeChange $showDisplacements
							$cmd`;	
}

global proc SMPMapBordersReplace( string $attr1Name, string $attr2Name, string $attr3Name )
{
	string $nodeName = plugNode($attr1Name);

	radioButtonGrp -edit
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMMapBorders_RBG;

	checkBoxGrp -edit
			-changeCommand ("SMPAttrsFromMapBordersUI \"" + $nodeName + "\"")
		SMPreserver_CBG;

	SMPMapBordersUIFromAttrs($nodeName);
}

global proc SMPCustomControlsUIFromAttrs(string $nodeName)
{
	int $smpMode = `getAttr ($nodeName + ".displaySmoothMesh")`;
	int $smpSelMode = `getAttr ($nodeName + ".smoothMeshSelectionMode")`;

	checkBoxGrp -edit -value1 (0 != $smpMode) SMPreview_CBG;

	if (1 == $smpMode)
		radioButtonGrp -edit -select 1 SMPreviewType1_RBG;
	else if (2 == $smpMode)
		radioButtonGrp -edit -select 1 SMPreviewType2_RBG;

	if (isLegacyViewportEnabled())  // show only in vp1
	{
		radioButtonGrp -edit -select ($smpSelMode + 1) SMPreviewSelectType_RBG;
	}

	SMPSetCustomControlsEnableState($nodeName);
}

global proc int DisplacementEnabled(string $nodeName)
{
	int $drawSmooth = `getAttr ($nodeName + ".displaySmoothMesh")`;
	
	int $subdivisionVal = GetSmoothDrawType($nodeName);

	int $showDisp = `getAttr ($nodeName + ".showDisplacements")`;

	int $enableDisp = ($drawSmooth != 0 && $subdivisionVal == 3 && $showDisp == 1);
	return $enableDisp;
}

global proc DPCustomControlsUIFromAttrs(string $nodeName)
{
	int $enableDisp = DisplacementEnabled($nodeName);
	checkBoxGrp -edit -value1 $enableDisp DPreview_CBG;	// update the displacement preview checkbox

	DPSetCustomControlsEnableState($nodeName);
}

global proc SMPMapBordersUIFromAttrs(string $nodeName)
{
	int $smpMapBorders = `getAttr ($nodeName + ".keepMapBorders")`;

	if (0 == $smpMapBorders)
		radioButtonGrp -edit -select 3 SMMapBorders_RBG;
	else if (2 == $smpMapBorders)
		radioButtonGrp -edit -select 1 SMMapBorders_RBG;
	else
		radioButtonGrp -edit -select 2 SMMapBorders_RBG;

	int $keepBorder = `getAttr ($nodeName + ".keepBorder")`;
	checkBoxGrp -edit -value1 $keepBorder SMPreserver_CBG;

	int $keepHardEdge = `getAttr ($nodeName + ".keepHardEdge")`;
	checkBoxGrp -edit -value2 $keepHardEdge SMPreserver_CBG;

	SMPSetMapBordersEnableState();
}

global proc SMPAttrsFromCustomControlsUI(string $nodeName)
{
	int $display = `checkBoxGrp -query -value1 SMPreview_CBG`;
	if (0 == $display)
	{
		setAttr ($nodeName + ".displaySmoothMesh") 0;
	}
	else if (1 == `radioButtonGrp -query -select SMPreviewType1_RBG`)
	{
		setAttr ($nodeName + ".displaySmoothMesh") 1;
	}
	else
	{
		setAttr ($nodeName + ".displaySmoothMesh") 2;
	}

    if (isLegacyViewportEnabled())
	{
		int $selMode = `radioButtonGrp -query -select SMPreviewSelectType_RBG`;
		$selMode = $selMode - 1;
		if (0 <= $selMode && $selMode <= 2 )
			setAttr ($nodeName + ".smoothMeshSelectionMode") $selMode;
	}

	SMPSetCustomControlsEnableState($nodeName);
}

global proc int GetSmoothDrawType(string $nodeName)
{
	int $subdivisionVal = 0;	// MayaCC
	int $useGlobal = `getAttr ($nodeName + ".useGlobalSmoothDrawType")`;
	if ($useGlobal == 1)
	{
		int $polyOpts[] = `polyOptions -q -smoothDrawType`;
		if ($polyOpts[0] == 1)
			$subdivisionVal = 2;	// Osd-Uniform
		else if ($polyOpts[0] == 2)
			$subdivisionVal = 3;	// Osd-Adaptive			
	}
	else
	{
		$subdivisionVal = `getAttr ($nodeName + ".smoothDrawType")`;
	}

	return $subdivisionVal;
}

//
// Displacement Preview checkbox (DPreview_CBG) callback called when the checkbox state changed
//
global proc DPAttrsFromCustomControlsUI(string $nodeName)
{
	int $display = `checkBoxGrp -query -value1 DPreview_CBG`;
	if (0 == $display)
	{
		setAttr ($nodeName + ".showDisplacements") 0;
		
		editorTemplate -dimControl $nodeName "smoothDrawType" 0;
	}
	else
	{
		// Show smooth mesh.
		int $drawSmooth = `getAttr ($nodeName + ".displaySmoothMesh")`;
		if (0 == $drawSmooth)
			setAttr ($nodeName + ".displaySmoothMesh") 2;

		// Use OpenSubdiv-Adaptive.
		int $subdivisionVal = GetSmoothDrawType($nodeName);
		if ($subdivisionVal != 3)
		{
			setAttr ($nodeName + ".useGlobalSmoothDrawType") 0;
			setAttr ($nodeName + ".smoothDrawType") 3;
		}

		// Show displacements.
		setAttr ($nodeName + ".showDisplacements") 1;
	}
}

global proc SMPAttrsFromMapBordersUI(string $nodeName)
{
	int $mapBorders = `radioButtonGrp -query -select SMMapBorders_RBG`;
	if (1 == $mapBorders)
		setAttr ($nodeName + ".keepMapBorders") 2;
	else if (3 == $mapBorders)
		setAttr ($nodeName + ".keepMapBorders") 0;
	else
		setAttr ($nodeName + ".keepMapBorders") 1;

	int $keepBorder = `checkBoxGrp -query -value1 SMPreserver_CBG`;
	setAttr ($nodeName + ".keepBorder") $keepBorder;

	int $keepHardEdge = `checkBoxGrp -query -value2 SMPreserver_CBG`;
	setAttr ($nodeName + ".keepHardEdge") $keepHardEdge;

	SMPSetMapBordersEnableState();
}

global proc SMPSetCustomControlsEnableState(string $nodeName)
{
	int $disableDisplayType = (0 == `checkBoxGrp -q -value1 SMPreview_CBG`);
	
	if ($disableDisplayType)
	{
		radioButtonGrp -edit -enable false SMPreviewType1_RBG;
		if (isLegacyViewportEnabled()) radioButtonGrp -edit -enable false SMPreviewSelectType_RBG;
		radioButtonGrp -edit -enable false SMPreviewType2_RBG;
	}
	else
	{
		radioButtonGrp -edit -enable true SMPreviewType1_RBG;
		radioButtonGrp -edit -enable true SMPreviewType2_RBG;

		if (isLegacyViewportEnabled())
		{
			int $enableSelectType = (1 == `radioButtonGrp -q -select SMPreviewType1_RBG`);
			radioButtonGrp -edit -enable $enableSelectType SMPreviewSelectType_RBG;
		}
	}

	editorTemplate -dimControl $nodeName "smoothLevel" $disableDisplayType;
	editorTemplate -dimControl $nodeName "displaySubdComps" $disableDisplayType;
	editorTemplate -dimControl $nodeName "continuity" $disableDisplayType;
	editorTemplate -dimControl $nodeName "smoothUVs" $disableDisplayType;
	editorTemplate -dimControl $nodeName "keepBorder" $disableDisplayType;
	editorTemplate -dimControl $nodeName "keepHardEdge" $disableDisplayType;
	editorTemplate -dimControl $nodeName "propagateEdgeHardness" $disableDisplayType;
	editorTemplate -dimControl $nodeName "smoothOffset" $disableDisplayType;
	editorTemplate -dimControl $nodeName "useSmoothPreviewForRender" $disableDisplayType;

	SMPcheckUsePreviewForRender($nodeName);
	SMPSetMapBordersEnableState();
}

global proc DPSetCustomControlsEnableState(string $nodeName)
{
	int $enableDisp = (1 == `checkBoxGrp -q -value1 DPreview_CBG`);
	
	string $nodeAttr = $nodeName + ".useGlobalSmoothDrawType";
	int $attrVal = `getAttr $nodeAttr`;
	checkBoxGrp -edit -value1 $attrVal SMPUseGlobal_CBG; 
	
	if ($enableDisp)
	{
		checkBoxGrp -edit -enable false SMPreview_CBG;

		checkBoxGrp -edit -enable false SMPUseGlobal_CBG;

		editorTemplate -dimControl $nodeName "smoothDrawType" 1;
	}
	else
	{
		checkBoxGrp -edit -enable true SMPreview_CBG;

		checkBoxGrp -edit -enable true SMPUseGlobal_CBG;
	}
}

global proc SMPSetMapBordersEnableState()
{
	int $enableMapBorders = (0 != `checkBoxGrp -q -value1 SMPreview_CBG`);

	if (`radioButtonGrp -query -exists SMMapBorders_RBG`)
	{
		radioButtonGrp -edit -enable $enableMapBorders SMMapBorders_RBG;
	}

	if (`checkBoxGrp -query -exists SMPreserver_CBG`)
	{
		checkBoxGrp -edit -enable $enableMapBorders SMPreserver_CBG;
	}
}

global proc SMPcheckUsePreviewForRender(string $nodeName)
{
	int $disableDisplayType = true;
	if (`checkBoxGrp -exists SMPreview_CBG`) {
		$disableDisplayType = (0 == `checkBoxGrp -q -value1 SMPreview_CBG`);
	}
	string $nodeAttr = $nodeName + ".useSmoothPreviewForRender";
	int $value = `getAttr $nodeAttr`;
	int $dim = ($disableDisplayType || $value);

	editorTemplate -dimControl $nodeName "renderSmoothLevel" $dim;
}

global proc SMPuseGlobalSmoothDrawType(string $nodeName)
{
	string $nodeAttr = $nodeName + ".useGlobalSmoothDrawType";
	int $value = `getAttr $nodeAttr`;
	editorTemplate -dimControl $nodeName "smoothDrawType" $value;
}

global proc SmoothDrawTypeCallback( string $nodeName )
{
	int $result = 0;
	
	int $useGlobalVal = `getAttr ($nodeName + ".useGlobalSmoothDrawType")`;
	
	if ($useGlobalVal)
		$result = 1;
	else if (DisplacementEnabled($nodeName))
		// When displacement is enabled, smoothDrawType is forced to OpenSubdiv-Adaptive, and shouldn't change.
		$result = 1;

	editorTemplate -dimControl $nodeName "smoothDrawType" $result;	
}

global proc AEbuildSmoothControls(string $nodeName)
{
	editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kSmoothMeshControls"));

		editorTemplate -callCustom 
			"SMPCustomControlsNew"
			"SMPCustomControlsReplace"
			"displaySmoothMesh"
			"smoothMeshSelectionMode";

		editorTemplate -callCustom
			"SMPGobalCheckBoxNew"
			"SMPGlobalCheckBoxReplace"
			"useGlobalSmoothDrawType";
		editorTemplate -l " "
			-addControl "smoothDrawType" "SmoothDrawTypeCallback";
		
		editorTemplate -callCustom 
			"DPCustomControlsNew"
			"DPCustomControlsReplace"
			"showDisplacements";

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kDisplaySmoothControls")) -collapse false;
			editorTemplate -label (uiRes("m_AEmeshTemplate.kDispSubdCompsAttr"))
				-addControl "displaySubdComps";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothLevelAttr"))
				-addControl "smoothLevel";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kUsePreviewLevel"))
				-addControl "useSmoothPreviewForRender" "SMPcheckUsePreviewForRender";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kRenderSmoothLevel"))
				-addControl "renderSmoothLevel";

										
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kSmoothMeshOpenSubdivControls")) -collapse true;
		editorTemplate -beginNoOptimize;

		// For OSD Boundary Conditions
		//editorTemplate -addControl "useOsdBoundaryMethods"; // Hidden
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdVertBoundary_label")) -addControl "osdVertBoundary" ;
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdFvarBoundary_label"))     -addControl "osdFvarBoundary" ;

		// Additional OSD Parameters
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdFvarPropagateCorners_label")) -addControl "osdFvarPropagateCorners";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdSmoothTriangles_label"))     -addControl "osdSmoothTriangles";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_osdCreaseMethod_label"))        -addControl "osdCreaseMethod";
		editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_enableOpenCL_label")) -addControl "enableOpenCL";
		{
			editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_smoothTessLevel_label")) -addControl "smoothTessLevel";
			//editorTemplate -label _L10N(kSmoothMesh_smoothOsdColorizePatches_label, "Adaptive Colorized Patches") -addControl "smoothOsdColorizePatches" ;
			// Hide colorize for time being
			editorTemplate -suppress "smoothOsdColorizePatches";
		}

		// Displacement attributes
		editorTemplate -addSeparator;
		if (isLegacyViewportEnabled())
		{
			editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_loadTiledTextures_label")) -addControl "loadTiledTextures";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kSmoothMesh_Displacement_label"))  -addControl "displacementType";
		}

		editorTemplate -endNoOptimize;
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kSmoothMeshMayaControls")) -collapse true;
			editorTemplate -beginNoOptimize;

			editorTemplate -label (uiRes("m_AEmeshTemplate.kBoundaryRule"))
				-addControl "boundaryRule"; 
			editorTemplate -addControl "continuity";
			editorTemplate -addControl "smoothUVs";
			editorTemplate -addControl "propagateEdgeHardness";
			editorTemplate -endNoOptimize;
			editorTemplate -callCustom 
				"SMPMapBordersNew"
				"SMPMapBordersReplace"
				"keepMapBorders"
				"keepHardEdge"
				"keepBorder";
		editorTemplate -endLayout;

	editorTemplate -endLayout;

	editorTemplate -suppress "smoothOffset";
}
global proc checkMeshReuseTrianglesAE( string $nodeName )
{
	int $val = `getAttr ($nodeName+".reuseTriangles")`;	
	polyOptions -reuseTriangles $val $nodeName;
}

global proc AEmeshTangentSpaceChange( string $tangentSpaceMenu, string $windingOrderMenu, string $attr)
{
	int $space = `radioButtonGrp -query -select $tangentSpaceMenu` - 1;
	int $windingOrder = `radioButtonGrp -query -select $windingOrderMenu` - 1;
	if( $windingOrder >= 0 && $space >= 0)
		setAttr $attr ($space * 2 + $windingOrder);
}

global proc AEmeshTangentSpaceNew( string $attributeUIName, string $attr)
{
	string $tangentSpaceMenu = "AEmeshTangentSpace" + $attributeUIName;
	string $windingOrderMenu = "AEmeshWindingOrder" + $attributeUIName;

	radioButtonGrp 
		-numberOfRadioButtons 2 
		-label (uiRes("m_AEmeshTemplate.kTangentSpaceCoordinateSystem")) 
		-labelArray2 	(uiRes("m_AEmeshTemplate.kRightHandedTangents")) 
						(uiRes("m_AEmeshTemplate.kLeftHandedTangents")) 
		$tangentSpaceMenu;

	radioButtonGrp 
		-numberOfRadioButtons 2 
		-label (uiRes("m_AEmeshTemplate.kTangentSpaceUVWindingOrder")) 
		-labelArray2 	(uiRes("m_AEmeshTemplate.kDetectUVWindingOrder")) 
						(uiRes("m_AEmeshTemplate.kIgnoreUVWindingOrder")) 
		$windingOrderMenu;

	AEmeshTangentSpaceReplace($attributeUIName, $attr);
}

global proc AEmeshTangentSpaceReplace( string $attributeUIName, string $attr )
{
	string $tangentSpaceMenu = "AEmeshTangentSpace" + $attributeUIName;
	string $windingOrderMenu = "AEmeshWindingOrder" + $attributeUIName;

	int $value = `getAttr $attr`;
	int $space = $value / 2;
	int $windingOrder = $value - $space * 2;
	
	radioButtonGrp -e -select ($space + 1) $tangentSpaceMenu;
	radioButtonGrp -edit -changeCommand
		("AEmeshTangentSpaceChange " + $tangentSpaceMenu + " " + $windingOrderMenu + " " + $attr)
		$tangentSpaceMenu;
	radioButtonGrp -edit -enable true $tangentSpaceMenu;

	radioButtonGrp -edit -select ($windingOrder + 1) $windingOrderMenu;
	radioButtonGrp -edit -changeCommand
		("AEmeshTangentSpaceChange " + $tangentSpaceMenu + " " + $windingOrderMenu + " " + $attr)
		$windingOrderMenu;
	radioButtonGrp -edit -enable true $windingOrderMenu;

}


global proc AEmeshTemplate( string $nodeName )
{
	editorTemplate -beginScrollLayout;


		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kTessellationAttributes"));

			editorTemplate -addControl "maxTriangles";

			editorTemplate -addControl "useMaxSubdivisions" 
						"checkMeshUseMaxSubd";
			editorTemplate -addControl "maxSubd";

			editorTemplate -addControl "useMinScreen"
						"checkMeshUseMinScreen";
			editorTemplate -addControl "minScreen";

			editorTemplate -addControl "useMaxUV"
						"checkMeshUseMaxUv";
			editorTemplate -addControl "maxUv";

			editorTemplate -addControl "useMinEdgeLength"
						"checkMeshUseMinEdgeLength";
			editorTemplate -addControl "minEdgeLength";

			editorTemplate -addControl "useMaxEdgeLength"
						"checkMeshUseMaxEdgeLength";
			editorTemplate -addControl "maxEdgeLength";

		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kMeshComponentDisplay"));
			editorTemplate -beginNoOptimize;
			editorTemplate -addControl "displayImmediate";
			editorTemplate -addControl "displayVertices"
				"checkMeshDisplayVertices";
			editorTemplate -addControl "vertexSize";
			editorTemplate -addControl "vertexBackfaceCulling";
			editorTemplate -addControl "backfaceCulling";

			editorTemplate -endNoOptimize;
	
			editorTemplate -addSeparator;
			editorTemplate -addControl "displayEdges";	
			editorTemplate -addControl "displayBorders" 
				"checkMeshDisplayBorder";
			editorTemplate -addControl "borderWidth";
	
			editorTemplate -addSeparator;
			editorTemplate -beginNoOptimize;
			editorTemplate -suppress "displayItemNumbers";			
			editorTemplate -addControl "displayCenter";
			editorTemplate -addControl "displayTriangles";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kDisplayUVs")) -addControl "displayUVs" 
				"checkMeshDisplayUVs";
			editorTemplate -addControl "uvSize";
			editorTemplate -addControl "displayNonPlanar";
			editorTemplate -label (uiRes("m_AEmeshTemplate.kDisplayInvisibleFaces")) -addControl "displayInvisibleFaces";
			
			editorTemplate -addSeparator;
					
			editorTemplate -addControl "displayColors";
			editorTemplate -callCustom 
				"AEdisplayColorChannelNew"
				"AEdisplayColorChannelReplace"
				"displayColorChannel";
				
			editorTemplate -addControl "materialBlend";				
			
			editorTemplate -addSeparator;
			editorTemplate -addControl "displayNormal" 
						"checkMeshDisplayNormals";
			editorTemplate -addControl "displayTangent" 
						"checkMeshDisplayNormals";
			editorTemplate -addControl "normalSize"
						"checkMeshDisplayNormals";
			editorTemplate -addControl "normalType";

			editorTemplate -endNoOptimize;
	
		editorTemplate -endLayout;

		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kMeshControls"));
			AEpythonDefinedTemplate "vertexcolors" $nodeName;
			editorTemplate -addControl "allowTopologyMod" "checkMeshAllowTopologyMod";
			editorTemplate -addControl "quadSplit";
			editorTemplate -addControl "vertexNormalMethod";
			editorTemplate -addSeparator;
			editorTemplate -addControl "displayAlphaAsGreyScale";
			editorTemplate -addSeparator;
			if (isLegacyViewportEnabled())
				editorTemplate -addControl "reuseTriangles" "checkMeshReuseTrianglesAE";
		editorTemplate -endLayout;
		
		editorTemplate -beginLayout (uiRes("m_AEmeshTemplate.kTangentSpace"));
			editorTemplate -callCustom  "AEmeshTangentSpaceNew     \"Mesh\"" 
										"AEmeshTangentSpaceReplace \"Mesh\"" 
										"tangentSpace";
			editorTemplate -addControl "tangentSmoothingAngle";
			editorTemplate -addControl "tangentNormalThreshold";
		editorTemplate -endLayout;
		
		AEbuildSmoothControls($nodeName);
		
		// include/call base class/node attributes
		AEsurfaceShapeTemplate $nodeName;

		// supressed attributes
		editorTemplate -suppress "inMesh";
		editorTemplate -suppress "outMesh";
		editorTemplate -suppress "outSmoothMesh";
		editorTemplate -suppress "cachedInMesh";
		editorTemplate -suppress "useNumTriangles";
		editorTemplate -suppress "numTriangles";
		editorTemplate -suppress "pnts";
		editorTemplate -suppress "colors";
		editorTemplate -suppress "colorPerVertex";
		editorTemplate -suppress "normalPerVertex";
		editorTemplate -suppress "uvSet";
		editorTemplate -suppress "normals";
		editorTemplate -suppress "displayFacesWithGroupId";
		editorTemplate -suppress "userTrg";
		editorTemplate -suppress "collisionOffsetVelocityIncrement";
		editorTemplate -suppress "collisionDepthVelocityIncrement";
		editorTemplate -suppress "perInstanceIndex";
		editorTemplate -suppress "perInstanceTag";
		editorTemplate -suppress "useMeshSculptCache";
		editorTemplate -suppress "computeFromSculptCache";
		editorTemplate -suppress "useMeshTexSculptCache";
		editorTemplate -suppress "freeze";

	editorTemplate -addExtraControls;

	editorTemplate -addDynamicControl "collisionEnable";
	editorTemplate -addDynamicControl "collisionOffset";
	editorTemplate -addDynamicControl "collisionDepth";
	editorTemplate -addDynamicControl "collisionPriority";
	editorTemplate -addDynamicControl "depthMapEnable";
	editorTemplate -addDynamicControl "depthMapWeight";
	editorTemplate -addDynamicControl "displayCollision";
	AEaddDynRampClothCollision "collisionOffsetVelocityMultiplier";
	AEaddDynRampClothCollision "collisionDepthVelocityMultiplier";

	editorTemplate -endScrollLayout;

}
