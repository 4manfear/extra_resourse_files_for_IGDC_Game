// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//	AEavgNurbsSurfacePointsTemplate
//
//  Description Name;
//	Creates the attribute editor controls for the 
//	avgNurbsSurfacePoints Node
//
//  Input Value:
//	nodeName 
//
//  Output Value:
//	None
//
 
global proc AEavgNurbsSurfacePointsTemplate ( string $nodeName )
{
	editorTemplate -beginScrollLayout;

	editorTemplate -beginLayout (uiRes("m_AEavgNurbsSurfacePointsTemplate.kAverageNURBSSurfacePoints")) -collapse false;
		editorTemplate -callCustom
				"AEsurfacePointNew"
				"AEsurfacePointReplace"
				"surfacePoint";
	editorTemplate -endLayout;

	// suppressed attributes
	editorTemplate -suppress "inputSurface";

	// include/call base class/node attributes
	AEdependNodeTemplate $nodeName;

	editorTemplate -addExtraControls;
	editorTemplate -endScrollLayout;
}


proc AEconnectSurfacePointControls( string $plug, string $srfPt )
{

	string $number[];
	tokenize($srfPt, "[]", $number);
	string $name = ($number[0] + $number[1]);

	// get the index
	//
	string $buffer[];
	tokenize($srfPt,"[]",$buffer);
	string $index = $buffer[1];

	// get the nodeName
	//
	clear $buffer;
	tokenize($plug,".",$buffer);
	string $nodeName = $buffer[0];

	// build the plug name
	//
	string $plugName = $nodeName+"."+$srfPt;

	// get the input node
	//
	string $inputAttr = ($plugName+".inputSurface");
	string $inputNode[] = `listConnections -d false -sh true $inputAttr`;

	string $fmt = (uiRes("m_AEavgNurbsSurfacePointsTemplate.kSurfacePointLabel"));
	text -e -label (`format -s $index $fmt`) srfPtLabel;
	textField -e -tx $inputNode[0] srfPtInput;
	connectControl ($name + "Weight") ($plugName+".weight");
	connectControl ($name + "Floats") -index 2 ($plugName+".parameterU");
	connectControl ($name + "Floats") -index 3 ($plugName+".parameterV");
	connectControl ($name + "Ints") -index 2 ($plugName+".cvIthIndex");
	connectControl ($name + "Ints") -index 3 ($plugName+".cvJthIndex");
}


proc AEcreateNewSurfacePointControls( string $nodeName, string $srfPt )
{
	string $number[];
	tokenize($srfPt, "[]", $number);
	string $name = ($number[0] + $number[1]);

	string $inputAttr = ($nodeName+"."+$srfPt+".inputSurface");
	string $connections[] = `listConnections -p true $inputAttr`;
	string $conInput[];
	tokenize($connections[0], ".", $conInput);

	setUITemplate -pst attributeEditorTemplate;
	columnLayout -adj true;
		separator ($name + "Sep");
		rowLayout -nc 4;
			text srfPtLabel;
			textField -ed false srfPtInput;
			if ($conInput[0] == ""){
				symbolButton -i "inArrow.png" -en 0 
					goToConnectedInput;
			} else {
				symbolButton -i "inArrow.png" 
					-c ("AEgoToConnected " + $conInput[0] )
					goToConnectedInput;
			}
		setParent ..;
		floatSliderGrp -f 1 -min 0 -max 1 -label (uiRes("m_AEavgNurbsSurfacePointsTemplate.kWeight")) ($name + "Weight");
		floatFieldGrp -nf 2 -label (uiRes("m_AEavgNurbsSurfacePointsTemplate.kParametersUV")) ( $name + "Floats");
		intFieldGrp -nf 2 -label (uiRes("m_AEavgNurbsSurfacePointsTemplate.kIndexIJ")) ($name + "Ints");
	setParent ..;

	AEconnectSurfacePointControls( $nodeName, $srfPt );
	setUITemplate -ppt;
}


global proc AEsurfacePointNew( string $plug )
{

	// get the nodeName
	//
	string $buffer[];
	tokenize($plug,".",$buffer);
	string $nodeName = $buffer[0];

	// get all of the elements of the array
	//
	string $tmpPoints[] = `listAttr -m $plug`;
	string $surfacePoints[];
	for ($tmp in $tmpPoints) {
		string $tmpBuffer[];
		tokenize($tmp,".",$tmpBuffer);
		if (size($tmpBuffer) == 1) {
			$surfacePoints[size($surfacePoints)] = $tmp;
		}
	}
	int $numSurfacePoints = size($surfacePoints);

	setUITemplate -pst attributeEditorTemplate;
	columnLayout AEsurfacePointLayout;
	for ( $srfPt in $surfacePoints ) {
		AEcreateNewSurfacePointControls($nodeName, $srfPt);
	}
	setParent ..;
	setUITemplate -ppt;

}


global proc AEsurfacePointReplace( string $plug )
{
	// get the nodeName
	//
	string $buffer[];
	tokenize($plug,".",$buffer);
	string $nodeName = $buffer[0];

	string $tmpPoints[] = `listAttr -m $plug`;
	string $newSurfacePoints[];
	for ($tmp in $tmpPoints) {
		string $tmpBuffer[];
		tokenize($tmp,".",$tmpBuffer);
		if (size($tmpBuffer) == 1) {
			$newSurfacePoints[size($newSurfacePoints)] = $tmp;
		}
	}
	int $newNumSurfacePoints = size ($newSurfacePoints);
	string $oldSurfacePointLayouts[] = `columnLayout -q -ca AEsurfacePointLayout`;
	int $oldNumSurfacePoints = size ($oldSurfacePointLayouts);

	setParent AEsurfacePointLayout;

	if ( $newNumSurfacePoints >= $oldNumSurfacePoints ) {

		// replace what we can
		//
		for ( $i = 0; $i < $oldNumSurfacePoints; $i++ ) {
			setParent $oldSurfacePointLayouts[$i];
			AEconnectSurfacePointControls($nodeName, $newSurfacePoints[$i]);
		}

		// and build what we need
		//
		setParent AEsurfacePointLayout;
		for ( $i = $oldNumSurfacePoints; $i < $newNumSurfacePoints; $i++ ) {
			AEcreateNewSurfacePointControls($nodeName, $newSurfacePoints[$i]);
		}


	} else {

		// replace what we need
		//
		for ( $i = 0; $i < $newNumSurfacePoints; $i++ ) {
			setParent $oldSurfacePointLayouts[$i];
			AEconnectSurfacePointControls($nodeName, $newSurfacePoints[$i]);
		}

		// delete old columnLayouts
		//
		setParent AEsurfacePointLayout;
		for ( $i = $newNumSurfacePoints; $i < $oldNumSurfacePoints; $i++ ) {
			deleteUI -layout $oldSurfacePointLayouts[$i];
		}

	}
}
