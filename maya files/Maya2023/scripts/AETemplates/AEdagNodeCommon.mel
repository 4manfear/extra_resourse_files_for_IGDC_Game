// ===========================================================================
// Copyright 2022 Autodesk, Inc. All rights reserved.
//
// Use of this software is subject to the terms of the Autodesk license
// agreement provided at the time of installation or download, or which
// otherwise accompanies this software in either electronic or hard copy form.
// ===========================================================================
//
//  Procedure Name:
//	AEdagNodeCommon
//
//  Description:
//	Creates the attribute editor controls for the dagObjectNode
//
//  Input Value:
//	nodeName
//
//  Output Value:
//	None
//
global proc AEreplaceBbox( string $minBox, string $maxBox )
{
	attrFieldGrp -edit
		-label (uiRes("m_AEdagNodeCommon.kBoundingBoxMin")) 
		-attribute $minBox
		bboxMin;

	attrFieldGrp -edit
		-label (uiRes("m_AEdagNodeCommon.kBoundingBoxMax")) 
		-attribute $maxBox
		bboxMax;
	
	string $parent = `setParent -q`;
	string $tokens[];
	tokenize( $minBox,".", $tokens);
	string $node = $tokens[0];
		
	scriptJob -runOnce true
		-ac ($node+".matrix")
		("setParent "+$parent+";AEreplaceBbox(\""+$minBox+"\",\""+$maxBox+"\")");
}	
	
	
global proc AEnewBbox( string $minBox, string $maxBox )
{
	// Create custom UI for the bounding box attributes.
	// This needs to be done because they don't send
	// attribute changed messages, and must instead rely
	// on another attribute to update them.
	//
	attrFieldGrp bboxMin;
	attrFieldGrp bboxMax;
	
	AEreplaceBbox( $minBox, $maxBox );
}

global proc AEdagNodeCommonRefreshOutliners()
{
	string $eds[] = `lsUI -editors`;
	for ( $ed in $eds )
	{
		if ( `outlinerEditor -exists $ed` )
			outlinerEditor -e -refresh $ed;
	}
}

proc string getOutlinerColorGrp(string $plug)
{
	// Assign name based on the type of object
	return "outliner" + `objectType $plug` + "ColorGrp";
}

global proc AEhiddenInOutlinerNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
	checkBoxGrp -label1 (uiRes("m_AEdagNodeCommon.kHiddenInOutliner")) hiddenInOutlinerCheck;
	AEhiddenInOutlinerReplace($plug);
	setUITemplate -ppt;
}

global proc AEhiddenInOutlinerReplace(string $plug)
{
	int $v = `getAttr $plug`;
	checkBoxGrp -e -value1 $v hiddenInOutlinerCheck;
	checkBoxGrp -e -cc ("setAttr " + $plug + " #1;AEdagNodeCommonRefreshOutliners();") hiddenInOutlinerCheck;
}

global proc AEuseOutlinerColorNew(string $plug)
{
	setUITemplate -pst attributeEditorTemplate;
	checkBoxGrp -label1 (uiRes("m_AEdagNodeCommon.kUseOutlinerColor")) useOutlinerColorCheck;
	AEuseOutlinerColorReplace($plug);
	setUITemplate -ppt;
}

global proc AEuseOutlinerColorReplace(string $plug)
{
	int $v = `getAttr $plug`;
	checkBoxGrp -e -value1 $v useOutlinerColorCheck;
	checkBoxGrp -e -cc ("setAttr " + $plug + " #1;AEdagNodeCommonRefreshOutliners();") useOutlinerColorCheck;
}

global proc AEoutlinerColorNew(string $plug)
{
	string $colorGrp = getOutlinerColorGrp($plug);
	setUITemplate -pst attributeEditorTemplate;
	colorSliderGrp -label (uiRes("m_AEdagNodeCommon.kOutlinerColor")) $colorGrp;
	AEoutlinerColorReplace($plug);
	setUITemplate -ppt;
}

global proc AEoutlinerColorSet( string $plug )
{
	string $colorGrp = getOutlinerColorGrp($plug);
	float $rgb[] = `colorSliderGrp -q -rgbValue $colorGrp`;
	setAttr $plug -type float3 $rgb[0] $rgb[1] $rgb[2];
	AEdagNodeCommonRefreshOutliners();
}

global proc AEoutlinerColorReplace(string $plug)
{
	string $colorGrp = getOutlinerColorGrp($plug);
	float $v[] = `getAttr $plug`;
	colorSliderGrp -e -rgbValue $v[0] $v[1] $v[2] $colorGrp;
	colorSliderGrp -e -cc ( "AEoutlinerColorSet " + $plug ) -dc ( "AEoutlinerColorSet " + $plug ) $colorGrp;
}

global proc AEdagNodeCommon ( string $nodeName ) 
{
	editorTemplate -label (uiRes("m_AEdagNodeCommon.kVisibility")) -addControl "visibility";
	editorTemplate -label (uiRes("m_AEdagNodeCommon.kTemplate")) -addControl "template";
	editorTemplate -label (uiRes("m_AEdagNodeCommon.kLODVisibility"))  -addControl "lodVisibility";

	string $nodeType = `objectType $nodeName`;
	
	if ($nodeType == "nurbsCurve") {
		editorTemplate -addControl "alwaysDrawOnTop";
	}

	editorTemplate -beginNoOptimize;
	if (`attributeExists "displayHWEnvironment" $nodeName` && isLegacyViewportEnabled() )
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kEnvironmentMapTexture"))  
			-addControl "displayHWEnvironment";			

	if ($nodeType == "nurbsSurface" ||
		// $nodeType == "subdiv" || -- not currently supported in hw renderer
		$nodeType == "mesh")
	{
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kIgnoreHardwareShader"))  
				-addControl "ignoreHwShader";
	}
	else
		editorTemplate -suppress "ignoreHwShader";			
	editorTemplate -endNoOptimize;

	// Make sure we test for all derived camera types
	if ($nodeType == "spotLight" ||
		$nodeType == "directionalLight" ||
		$nodeType == "areaLight" ||
		$nodeType == "volumeLight" ||
		`objectType -isa "camera" $nodeName`) { 
		// Note: ambient and point light shapes are drawn as icons, i.e. they
		// have a fixed size.  Therefore scaling these shapes does not apply.
		//
		editorTemplate -addControl "locatorScale"; 
	}

	if ($nodeType == "imagePlane" ) { 
		editorTemplate -addControl "frameVisibility"; 
	}

	editorTemplate -label (uiRes("m_AEdagNodeCommon.kHideOnPlayback"))  -addControl "hideOnPlayback";
	
	if ($nodeType == "lattice" ||
		$nodeType == "baseLattice" ||
		$nodeType == "nurbsSurface" ||
		$nodeType == "subdiv" ||
		$nodeType == "nurbsCurve" ||
		$nodeType == "fluidShape" ||
		$nodeType == "particle" ||
		$nodeType == "nParticle" ||
		$nodeType == "nCloth" ||
		$nodeType == "nRigid" ||
		$nodeType == "mesh"){
		editorTemplate -addControl "intermediateObject";
	} else {
		editorTemplate -suppress "intermediateObject";
	}

	editorTemplate -interruptOptimize;
	editorTemplate -callCustom "AEhiddenInOutlinerNew" "AEhiddenInOutlinerReplace" "hiddenInOutliner";
	editorTemplate -callCustom "AEuseOutlinerColorNew" "AEuseOutlinerColorReplace" "useOutlinerColor";
	editorTemplate -callCustom "AEoutlinerColorNew" "AEoutlinerColorReplace" "outlinerColor";
	
	if ($nodeType == "nurbsSurface" ||
		$nodeType == "mesh" ||
		$nodeType == "particle" ||
		$nodeType == "nParticle")
	{				
		editorTemplate -label (uiRes("m_AEdagNodeCommon.kHardwareFogMultiplier")) 
				-addControl "hardwareFogMultiplier";
	}
	else {
		editorTemplate -suppress "hardwareFogMultiplier";		
	}	

	python( "from maya.app.ghosting.GhostingMenus import layout_ghosting_attributes" );
	python( "layout_ghosting_attributes('" + $nodeName + "')" );

    if($nodeType != "motionTrailShape") {
	    editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kBoundingBoxInformation")) ;
		    editorTemplate -suppress "boundingBox";
		    editorTemplate -callCustom AEnewBbox AEreplaceBbox "boundingBoxMin" "boundingBoxMax";
	    editorTemplate -endLayout;

	    editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kDrawingOverrides"))  -collapse 1;
		    AEdrawInfo	"overrideDisplayType"
					    "overrideLevelOfDetail"
					    "overrideShading"
					    "overrideTexturing"
					    "overridePlayback"
					    "overrideEnabled"
					    "overrideVisibility"
					    "overrideRGBColors"
					    "overrideColor"
					    "overrideColorRGB"
						"overrideColorA";
	    editorTemplate -endLayout;
	
	    editorTemplate -beginLayout (uiRes("m_AEdagNodeCommon.kSelection")) -collapse 1;
		    editorTemplate -addControl "selectionChildHighlighting";
	    editorTemplate -endLayout;
    }

	// suppressed Attributes
	editorTemplate -suppress "drawOverride";
	editorTemplate -suppress "useObjectColor";
	editorTemplate -suppress "objectColor";
	editorTemplate -suppress "objectColorRGB";
	editorTemplate -suppress "center";
	editorTemplate -suppress "matrix";
	editorTemplate -suppress "inverseMatrix";
	editorTemplate -suppress "worldMatrix";
	editorTemplate -suppress "worldInverseMatrix";
	editorTemplate -suppress "parentMatrix";
	editorTemplate -suppress "parentInverseMatrix";
	editorTemplate -suppress "instObjGroups";
    editorTemplate -suppress "containerEdits";
	editorTemplate -suppress "wireColorRGB";
	AEcontainerNodeSuppress $nodeName;
}

